// GENERATED CODE - DO NOT EDIT!
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package outer

import (
	"runtime"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sourcegraph/srclib/unit"
	"sourcegraph.com/sqs/pbtypes"
	"src.sourcegraph.com/sourcegraph/gitserver/gitpb"
	"src.sourcegraph.com/sourcegraph/go-sourcegraph/sourcegraph"
	"src.sourcegraph.com/sourcegraph/pkg/inventory"
	"src.sourcegraph.com/sourcegraph/pkg/vcs"
	"src.sourcegraph.com/sourcegraph/svc"
)

// Services returns a full set of services with an implementation of each service method that lets you customize the initial context.Context and map Go errors to gRPC error codes. It is similar to HTTP handler middleware, but for gRPC servers.
func Services(ctxFunc ContextFunc, services svc.Services) svc.Services {
	s := svc.Services{
		GitTransport:      wrappedGitTransport{ctxFunc, services},
		MultiRepoImporter: wrappedMultiRepoImporter{ctxFunc, services},
		Accounts:          wrappedAccounts{ctxFunc, services},
		Annotations:       wrappedAnnotations{ctxFunc, services},
		Auth:              wrappedAuth{ctxFunc, services},
		Builds:            wrappedBuilds{ctxFunc, services},
		Defs:              wrappedDefs{ctxFunc, services},
		Deltas:            wrappedDeltas{ctxFunc, services},
		GraphUplink:       wrappedGraphUplink{ctxFunc, services},
		Meta:              wrappedMeta{ctxFunc, services},
		MirrorRepos:       wrappedMirrorRepos{ctxFunc, services},
		Notify:            wrappedNotify{ctxFunc, services},
		Orgs:              wrappedOrgs{ctxFunc, services},
		People:            wrappedPeople{ctxFunc, services},
		RegisteredClients: wrappedRegisteredClients{ctxFunc, services},
		RepoBadges:        wrappedRepoBadges{ctxFunc, services},
		RepoStatuses:      wrappedRepoStatuses{ctxFunc, services},
		RepoTree:          wrappedRepoTree{ctxFunc, services},
		Repos:             wrappedRepos{ctxFunc, services},
		Search:            wrappedSearch{ctxFunc, services},
		Storage:           wrappedStorage{ctxFunc, services},
		Units:             wrappedUnits{ctxFunc, services},
		UserKeys:          wrappedUserKeys{ctxFunc, services},
		Users:             wrappedUsers{ctxFunc, services},
	}
	return s
}

type wrappedGitTransport struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedGitTransport) InfoRefs(ctx context.Context, v1 *gitpb.InfoRefsOp) (returnedResult *gitpb.Packet, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in GitTransport.InfoRefs: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.GitTransportOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "GitTransport")
	}

	rv, err := innerSvc.InfoRefs(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedGitTransport) ReceivePack(ctx context.Context, v1 *gitpb.ReceivePackOp) (returnedResult *gitpb.Packet, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in GitTransport.ReceivePack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.GitTransportOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "GitTransport")
	}

	rv, err := innerSvc.ReceivePack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedGitTransport) UploadPack(ctx context.Context, v1 *gitpb.UploadPackOp) (returnedResult *gitpb.Packet, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in GitTransport.UploadPack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.GitTransportOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "GitTransport")
	}

	rv, err := innerSvc.UploadPack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMultiRepoImporter struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMultiRepoImporter) Import(ctx context.Context, v1 *pb.ImportOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Import: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Import(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMultiRepoImporter) Index(ctx context.Context, v1 *pb.IndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Index: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Index(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAccounts struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAccounts) Create(ctx context.Context, v1 *sourcegraph.NewAccount) (returnedResult *sourcegraph.UserSpec, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) RequestPasswordReset(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *sourcegraph.PendingPasswordReset, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.RequestPasswordReset: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.RequestPasswordReset(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) ResetPassword(ctx context.Context, v1 *sourcegraph.NewPassword) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.ResetPassword: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.ResetPassword(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Update(ctx context.Context, v1 *sourcegraph.User) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Invite(ctx context.Context, v1 *sourcegraph.AccountInvite) (returnedResult *sourcegraph.PendingInvite, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Invite: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Invite(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) AcceptInvite(ctx context.Context, v1 *sourcegraph.AcceptedInvite) (returnedResult *sourcegraph.UserSpec, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.AcceptInvite: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.AcceptInvite(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) ListInvites(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.AccountInviteList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.ListInvites: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.ListInvites(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) DeleteInvite(ctx context.Context, v1 *sourcegraph.InviteSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.DeleteInvite: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.DeleteInvite(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Delete(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAnnotations struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAnnotations) List(ctx context.Context, v1 *sourcegraph.AnnotationsListOptions) (returnedResult *sourcegraph.AnnotationList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Annotations.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AnnotationsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Annotations")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAuth struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAuth) GetAuthorizationCode(ctx context.Context, v1 *sourcegraph.AuthorizationCodeRequest) (returnedResult *sourcegraph.AuthorizationCode, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetAuthorizationCode: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetAuthorizationCode(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) GetAccessToken(ctx context.Context, v1 *sourcegraph.AccessTokenRequest) (returnedResult *sourcegraph.AccessTokenResponse, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetAccessToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetAccessToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) Identify(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.AuthInfo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.Identify: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.Identify(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) GetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalTokenRequest) (returnedResult *sourcegraph.ExternalToken, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) SetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalToken) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.SetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.SetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedBuilds struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedBuilds) Get(ctx context.Context, v1 *sourcegraph.BuildSpec) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) GetRepoBuild(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.GetRepoBuild: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.GetRepoBuild(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) List(ctx context.Context, v1 *sourcegraph.BuildListOptions) (returnedResult *sourcegraph.BuildList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) Create(ctx context.Context, v1 *sourcegraph.BuildsCreateOp) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) Update(ctx context.Context, v1 *sourcegraph.BuildsUpdateOp) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) ListBuildTasks(ctx context.Context, v1 *sourcegraph.BuildsListBuildTasksOp) (returnedResult *sourcegraph.BuildTaskList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.ListBuildTasks: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.ListBuildTasks(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) CreateTasks(ctx context.Context, v1 *sourcegraph.BuildsCreateTasksOp) (returnedResult *sourcegraph.BuildTaskList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.CreateTasks: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.CreateTasks(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) UpdateTask(ctx context.Context, v1 *sourcegraph.BuildsUpdateTaskOp) (returnedResult *sourcegraph.BuildTask, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.UpdateTask: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.UpdateTask(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) GetTaskLog(ctx context.Context, v1 *sourcegraph.BuildsGetTaskLogOp) (returnedResult *sourcegraph.LogEntries, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.GetTaskLog: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.GetTaskLog(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) DequeueNext(ctx context.Context, v1 *sourcegraph.BuildsDequeueNextOp) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.DequeueNext: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.DequeueNext(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedDefs struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedDefs) Get(ctx context.Context, v1 *sourcegraph.DefsGetOp) (returnedResult *sourcegraph.Def, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) List(ctx context.Context, v1 *sourcegraph.DefListOptions) (returnedResult *sourcegraph.DefList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListRefs(ctx context.Context, v1 *sourcegraph.DefsListRefsOp) (returnedResult *sourcegraph.RefList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListRefs: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListRefs(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListExamples(ctx context.Context, v1 *sourcegraph.DefsListExamplesOp) (returnedResult *sourcegraph.ExampleList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListExamples: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListExamples(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListAuthors(ctx context.Context, v1 *sourcegraph.DefsListAuthorsOp) (returnedResult *sourcegraph.DefAuthorList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListAuthors: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListAuthors(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListClients(ctx context.Context, v1 *sourcegraph.DefsListClientsOp) (returnedResult *sourcegraph.DefClientList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListClients: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListClients(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedDeltas struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedDeltas) Get(ctx context.Context, v1 *sourcegraph.DeltaSpec) (returnedResult *sourcegraph.Delta, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListUnits(ctx context.Context, v1 *sourcegraph.DeltasListUnitsOp) (returnedResult *sourcegraph.UnitDeltaList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListUnits: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListUnits(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListDefs(ctx context.Context, v1 *sourcegraph.DeltasListDefsOp) (returnedResult *sourcegraph.DeltaDefs, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListDefs: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListDefs(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListFiles(ctx context.Context, v1 *sourcegraph.DeltasListFilesOp) (returnedResult *sourcegraph.DeltaFiles, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListFiles: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListFiles(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListAffectedAuthors(ctx context.Context, v1 *sourcegraph.DeltasListAffectedAuthorsOp) (returnedResult *sourcegraph.DeltaAffectedPersonList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListAffectedAuthors: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListAffectedAuthors(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListAffectedClients(ctx context.Context, v1 *sourcegraph.DeltasListAffectedClientsOp) (returnedResult *sourcegraph.DeltaAffectedPersonList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListAffectedClients: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListAffectedClients(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedGraphUplink struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedGraphUplink) Push(ctx context.Context, v1 *sourcegraph.MetricsSnapshot) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in GraphUplink.Push: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.GraphUplinkOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "GraphUplink")
	}

	rv, err := innerSvc.Push(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedGraphUplink) PushEvents(ctx context.Context, v1 *sourcegraph.UserEventList) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in GraphUplink.PushEvents: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.GraphUplinkOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "GraphUplink")
	}

	rv, err := innerSvc.PushEvents(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMeta struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMeta) Status(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.ServerStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Meta.Status: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MetaOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Meta")
	}

	rv, err := innerSvc.Status(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMeta) Config(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.ServerConfig, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Meta.Config: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MetaOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Meta")
	}

	rv, err := innerSvc.Config(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMirrorRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMirrorRepos) RefreshVCS(ctx context.Context, v1 *sourcegraph.MirrorReposRefreshVCSOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MirrorRepos.RefreshVCS: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MirrorReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MirrorRepos")
	}

	rv, err := innerSvc.RefreshVCS(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMirrorRepos) GetUserData(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.UserMirrorData, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MirrorRepos.GetUserData: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MirrorReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MirrorRepos")
	}

	rv, err := innerSvc.GetUserData(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMirrorRepos) AddToWaitlist(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.WaitlistState, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MirrorRepos.AddToWaitlist: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MirrorReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MirrorRepos")
	}

	rv, err := innerSvc.AddToWaitlist(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedNotify struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedNotify) GenericEvent(ctx context.Context, v1 *sourcegraph.NotifyGenericEvent) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Notify.GenericEvent: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.NotifyOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Notify")
	}

	rv, err := innerSvc.GenericEvent(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedOrgs struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedOrgs) Get(ctx context.Context, v1 *sourcegraph.OrgSpec) (returnedResult *sourcegraph.Org, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedOrgs) List(ctx context.Context, v1 *sourcegraph.OrgsListOp) (returnedResult *sourcegraph.OrgList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedOrgs) ListMembers(ctx context.Context, v1 *sourcegraph.OrgsListMembersOp) (returnedResult *sourcegraph.UserList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.ListMembers: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.ListMembers(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedPeople struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedPeople) Get(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *sourcegraph.Person, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in People.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.PeopleOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "People")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRegisteredClients struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRegisteredClients) Get(ctx context.Context, v1 *sourcegraph.RegisteredClientSpec) (returnedResult *sourcegraph.RegisteredClient, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRegisteredClients) GetCurrent(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.RegisteredClient, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.GetCurrent: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.GetCurrent(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRegisteredClients) Create(ctx context.Context, v1 *sourcegraph.RegisteredClient) (returnedResult *sourcegraph.RegisteredClient, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRegisteredClients) Update(ctx context.Context, v1 *sourcegraph.RegisteredClient) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRegisteredClients) Delete(ctx context.Context, v1 *sourcegraph.RegisteredClientSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRegisteredClients) List(ctx context.Context, v1 *sourcegraph.RegisteredClientListOptions) (returnedResult *sourcegraph.RegisteredClientList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RegisteredClients.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RegisteredClientsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RegisteredClients")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoBadges struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoBadges) ListBadges(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.BadgeList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoBadges.ListBadges: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoBadgesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoBadges")
	}

	rv, err := innerSvc.ListBadges(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoBadges) ListCounters(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.CounterList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoBadges.ListCounters: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoBadgesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoBadges")
	}

	rv, err := innerSvc.ListCounters(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoBadges) RecordHit(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoBadges.RecordHit: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoBadgesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoBadges")
	}

	rv, err := innerSvc.RecordHit(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoBadges) CountHits(ctx context.Context, v1 *sourcegraph.RepoBadgesCountHitsOp) (returnedResult *sourcegraph.RepoBadgesCountHitsResult, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoBadges.CountHits: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoBadgesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoBadges")
	}

	rv, err := innerSvc.CountHits(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoStatuses struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoStatuses) GetCombined(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *sourcegraph.CombinedStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.GetCombined: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.GetCombined(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoStatuses) Create(ctx context.Context, v1 *sourcegraph.RepoStatusesCreateOp) (returnedResult *sourcegraph.RepoStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoTree struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoTree) Get(ctx context.Context, v1 *sourcegraph.RepoTreeGetOp) (returnedResult *sourcegraph.TreeEntry, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) Search(ctx context.Context, v1 *sourcegraph.RepoTreeSearchOp) (returnedResult *sourcegraph.VCSSearchResultList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Search: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Search(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) List(ctx context.Context, v1 *sourcegraph.RepoTreeListOp) (returnedResult *sourcegraph.RepoTreeListResult, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepos) Get(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) List(ctx context.Context, v1 *sourcegraph.RepoListOptions) (returnedResult *sourcegraph.RepoList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Create(ctx context.Context, v1 *sourcegraph.ReposCreateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Update(ctx context.Context, v1 *sourcegraph.ReposUpdateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Delete(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetReadme(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *sourcegraph.Readme, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetReadme: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetReadme(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetConfig(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.RepoConfig, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetConfig: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetConfig(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetCommit(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *vcs.Commit, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetCommit: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetCommit(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommits(ctx context.Context, v1 *sourcegraph.ReposListCommitsOp) (returnedResult *sourcegraph.CommitList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommits: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommits(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListBranches(ctx context.Context, v1 *sourcegraph.ReposListBranchesOp) (returnedResult *sourcegraph.BranchList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListBranches: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListBranches(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListTags(ctx context.Context, v1 *sourcegraph.ReposListTagsOp) (returnedResult *sourcegraph.TagList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListTags: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListTags(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommitters(ctx context.Context, v1 *sourcegraph.ReposListCommittersOp) (returnedResult *sourcegraph.CommitterList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommitters: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommitters(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetSrclibDataVersionForPath(ctx context.Context, v1 *sourcegraph.TreeEntrySpec) (returnedResult *sourcegraph.SrclibDataVersion, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetSrclibDataVersionForPath: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetSrclibDataVersionForPath(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ConfigureApp(ctx context.Context, v1 *sourcegraph.RepoConfigureAppOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ConfigureApp: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ConfigureApp(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetInventory(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *inventory.Inventory, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetInventory: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetInventory(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedSearch struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedSearch) SearchTokens(ctx context.Context, v1 *sourcegraph.TokenSearchOptions) (returnedResult *sourcegraph.DefList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.SearchTokens: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.SearchTokens(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedSearch) SearchText(ctx context.Context, v1 *sourcegraph.TextSearchOptions) (returnedResult *sourcegraph.VCSSearchResultList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.SearchText: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.SearchText(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedStorage struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedStorage) Get(ctx context.Context, v1 *sourcegraph.StorageKey) (returnedResult *sourcegraph.StorageValue, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedStorage) Put(ctx context.Context, v1 *sourcegraph.StoragePutOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.Put: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.Put(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedStorage) PutNoOverwrite(ctx context.Context, v1 *sourcegraph.StoragePutOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.PutNoOverwrite: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.PutNoOverwrite(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedStorage) Delete(ctx context.Context, v1 *sourcegraph.StorageKey) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedStorage) Exists(ctx context.Context, v1 *sourcegraph.StorageKey) (returnedResult *sourcegraph.StorageExists, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.Exists: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.Exists(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedStorage) List(ctx context.Context, v1 *sourcegraph.StorageKey) (returnedResult *sourcegraph.StorageList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Storage.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.StorageOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Storage")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedUnits struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedUnits) Get(ctx context.Context, v1 *sourcegraph.UnitSpec) (returnedResult *unit.RepoSourceUnit, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Units.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UnitsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Units")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUnits) List(ctx context.Context, v1 *sourcegraph.UnitListOptions) (returnedResult *sourcegraph.RepoSourceUnitList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Units.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UnitsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Units")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedUserKeys struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedUserKeys) AddKey(ctx context.Context, v1 *sourcegraph.SSHPublicKey) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in UserKeys.AddKey: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UserKeysOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "UserKeys")
	}

	rv, err := innerSvc.AddKey(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUserKeys) LookupUser(ctx context.Context, v1 *sourcegraph.SSHPublicKey) (returnedResult *sourcegraph.UserSpec, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in UserKeys.LookupUser: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UserKeysOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "UserKeys")
	}

	rv, err := innerSvc.LookupUser(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUserKeys) DeleteKey(ctx context.Context, v1 *sourcegraph.SSHPublicKey) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in UserKeys.DeleteKey: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UserKeysOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "UserKeys")
	}

	rv, err := innerSvc.DeleteKey(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUserKeys) ListKeys(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.SSHKeyList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in UserKeys.ListKeys: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UserKeysOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "UserKeys")
	}

	rv, err := innerSvc.ListKeys(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUserKeys) DeleteAllKeys(ctx context.Context, v1 *pbtypes.Void) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in UserKeys.DeleteAllKeys: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UserKeysOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "UserKeys")
	}

	rv, err := innerSvc.DeleteAllKeys(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedUsers struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedUsers) Get(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.User, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) GetWithEmail(ctx context.Context, v1 *sourcegraph.EmailAddr) (returnedResult *sourcegraph.User, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.GetWithEmail: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.GetWithEmail(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) ListEmails(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.EmailAddrList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.ListEmails: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.ListEmails(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) List(ctx context.Context, v1 *sourcegraph.UsersListOptions) (returnedResult *sourcegraph.UserList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) ListTeammates(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.Teammates, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.ListTeammates: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.ListTeammates(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) Count(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.UserCount, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.Count: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.Count(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}
