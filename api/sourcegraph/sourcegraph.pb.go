// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
	Package sourcegraph is a generated protocol buffer package.

	It is generated from these files:
		sourcegraph.proto

	It has these top-level messages:
		Origin
		CombinedStatus
		ListOptions
		ListResponse
		StreamResponse
		RepoConfig
		Repo
		RepoPermissions
		RepoListOptions
		RepoWebhookOptions
		RepoRevSpec
		RepoSpec
		RepoStatus
		RepoStatusList
		RepoStatusesCreateOp
		RepoList
		ReposResolveRevOp
		ResolvedRev
		ReceivePackOp
		UploadPackOp
		URIList
		Packet
		RepoResolveOp
		RepoResolution
		SrclibDataVersion
		ReposCreateOp
		ReposUpdateOp
		ReposListCommitsOp
		RepoListCommitsOptions
		CommitList
		ReposListBranchesOp
		RepoListBranchesOptions
		BranchList
		ReposListTagsOp
		ReposListCommittersOp
		RepoListCommittersOptions
		CommitterList
		RepoListTagsOptions
		TagList
		MirrorReposRefreshVCSOp
		RemoteRepo
		EmailAddr
		UserList
		User
		UserSpec
		EmailAddrList
		UpdateEmailsOp
		BetaRegistration
		BetaResponse
		AuthInfo
		ExternalToken
		Def
		DefGetOptions
		DefListOptions
		DefListRefsOptions
		DefSpec
		DefsGetOp
		DefList
		DefsListRefsOp
		RefList
		DefListRefLocationsOptions
		DefsListRefLocationsOp
		DefsListExamplesOp
		RefLocationsList
		DefRepoRef
		DefFileRef
		RepoTreeGetOptions
		GetFileOptions
		RepoTreeSearchOptions
		RepoTreeSearchResult
		RepoTreeGetOp
		RepoTreeSearchOp
		RepoTreeListOp
		RepoTreeListResult
		VCSSearchResultList
		TreeEntry
		BasicTreeEntry
		TreeEntrySpec
		FileRange
		DefsRefreshIndexOp
		AsyncRefreshIndexesOp
		AuthorshipInfo
		DefAuthor
		DefAuthorship
		DefListAuthorsOptions
		DefsListAuthorsOp
		DefAuthorList
		ServerConfig
		UserEvent
		Event
		EventList
		Annotation
		AnnotationList
		AnnotationsListOptions
		AnnotationsGetDefAtPosOptions
		SearchOptions
		SearchOp
		RepoSearchResult
		SearchReposOp
		SearchReposResultList
		DefSearchResult
		SearchResultsList
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import vcs "sourcegraph.com/sourcegraph/sourcegraph/pkg/vcs"
import graph "sourcegraph.com/sourcegraph/srclib/graph"
import graph1 "sourcegraph.com/sourcegraph/srclib/graph"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import pbtypes2 "sourcegraph.com/sqs/pbtypes"
import inventory "sourcegraph.com/sourcegraph/sourcegraph/pkg/inventory"

import (
	context "context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type TreeEntryType int32

const (
	FileEntry      TreeEntryType = 0
	DirEntry       TreeEntryType = 1
	SymlinkEntry   TreeEntryType = 2
	SubmoduleEntry TreeEntryType = 3
)

var TreeEntryType_name = map[int32]string{
	0: "FileEntry",
	1: "DirEntry",
	2: "SymlinkEntry",
	3: "SubmoduleEntry",
}
var TreeEntryType_value = map[string]int32{
	"FileEntry":      0,
	"DirEntry":       1,
	"SymlinkEntry":   2,
	"SubmoduleEntry": 3,
}

func (x TreeEntryType) String() string {
	return proto.EnumName(TreeEntryType_name, int32(x))
}
func (TreeEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{0} }

// ServiceType indicates which service is running on an origin. A
// repo whose origin service is GitHub, for example, should be
// accessed using a GitHub API client.
//
// If there are multiple API versions for a service, separate
// entries may be added per API version. In that case, the
// APIBaseURL may need to differ as well. The API client code is
// responsible for handling these cases.
type Origin_ServiceType int32

const (
	// GitHub indicates that the origin is GitHub.com or a GitHub
	// Enterprise server. If the latter, the origin base URL indicates
	// the URL to the GitHub Enterprise server's API.
	Origin_GitHub Origin_ServiceType = 0
)

var Origin_ServiceType_name = map[int32]string{
	0: "GitHub",
}
var Origin_ServiceType_value = map[string]int32{
	"GitHub": 0,
}

func (x Origin_ServiceType) String() string {
	return proto.EnumName(Origin_ServiceType_name, int32(x))
}
func (Origin_ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{0, 0}
}

type ReposUpdateOp_BoolType int32

const (
	ReposUpdateOp_NONE  ReposUpdateOp_BoolType = 0
	ReposUpdateOp_TRUE  ReposUpdateOp_BoolType = 1
	ReposUpdateOp_FALSE ReposUpdateOp_BoolType = 2
)

var ReposUpdateOp_BoolType_name = map[int32]string{
	0: "NONE",
	1: "TRUE",
	2: "FALSE",
}
var ReposUpdateOp_BoolType_value = map[string]int32{
	"NONE":  0,
	"TRUE":  1,
	"FALSE": 2,
}

func (x ReposUpdateOp_BoolType) String() string {
	return proto.EnumName(ReposUpdateOp_BoolType_name, int32(x))
}
func (ReposUpdateOp_BoolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{26, 0}
}

// Origin represents the origin of a resource that canonically lives
// on an external service (e.g., a repo hosted on GitHub).
type Origin struct {
	// ID is an identifier for the resource on its origin
	// service. Although numeric IDs are used on many services (GitHub
	// and Bitbucket, for example), this field is a string so that it
	// supports non-numeric IDs (which are used on Google Cloud
	// Platform and probably other services that Sourcegraph might
	// support in the future).
	//
	// If the ID is numeric, this string is the base-10 string
	// representation of the numeric ID (e.g., "1234"), with no
	// leading 0s.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Service is the type service that the resource canonically lives
	// on. It is used to determine which API client should be used to
	// access it on the origin service (e.g., GitHub vs. Bitbucket).
	Service Origin_ServiceType `protobuf:"varint,2,opt,name=Service,proto3,enum=sourcegraph.Origin_ServiceType" json:""`
	// APIBaseURL is the base URL to the API of the origin service for
	// the resource. (E.g., "https://api.github.com" for
	// GitHub.com-hosted repos.)
	APIBaseURL string `protobuf:"bytes,3,opt,name=APIBaseURL,proto3" json:"APIBaseURL,omitempty"`
}

func (m *Origin) Reset()                    { *m = Origin{} }
func (m *Origin) String() string            { return proto.CompactTextString(m) }
func (*Origin) ProtoMessage()               {}
func (*Origin) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{0} }

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	Rev string `protobuf:"bytes,4,opt,name=Rev,proto3" json:"Rev,omitempty"`
	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	CommitID string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=State,proto3" json:"State,omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=Statuses" json:"Statuses,omitempty"`
}

func (m *CombinedStatus) Reset()                    { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string            { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()               {}
func (*CombinedStatus) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{1} }

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=PerPage,proto3" json:"PerPage,omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=Page,proto3" json:"Page,omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()                    { *m = ListOptions{} }
func (m *ListOptions) String() string            { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()               {}
func (*ListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{2} }

// ListResponse specifies a general paginated response when fetching a list of results.
type ListResponse struct {
	// Total is the total number of results in the list.
	Total int32 `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty" url:",omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{3} }

// StreamResponse specifies a paginated response where the total number of results
// that can be returned is too expensive to compute, unbounded, or unknown.
type StreamResponse struct {
	// HasMore is true if there are more results available after the returned page.
	HasMore bool `protobuf:"varint,1,opt,name=HasMore,proto3" json:"HasMore,omitempty" url:",omitempty"`
}

func (m *StreamResponse) Reset()                    { *m = StreamResponse{} }
func (m *StreamResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()               {}
func (*StreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{4} }

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
type RepoConfig struct {
}

func (m *RepoConfig) Reset()                    { *m = RepoConfig{} }
func (m *RepoConfig) String() string            { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()               {}
func (*RepoConfig) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{5} }

// Repo represents a source code repository.
type Repo struct {
	// ID is the unique numeric ID for this repository.
	ID int32 `protobuf:"varint,18,opt,name=ID,proto3" json:"ID,omitempty"`
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// Owner is the repository owner (user or organizatin) of the repository. (For
	// example, for "github.com/user/repo", the owner is "user".)
	Owner string `protobuf:"bytes,2,opt,name=Owner,proto3" json:"Owner,omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=HTTPCloneURL,proto3" json:"HTTPCloneURL,omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=SSHCloneURL,proto3" json:"SSHCloneURL,omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=HomepageURL,proto3" json:"HomepageURL,omitempty"`
	// DefaultBranch is the default git branch used (typically "master").
	DefaultBranch string `protobuf:"bytes,8,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=Language,proto3" json:"Language,omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=Blocked,proto3" json:"Blocked,omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=Deprecated,proto3" json:"Deprecated,omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=Fork,proto3" json:"Fork,omitempty"`
	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream. If this repo
	// canonically lives on a repo hosting that can supply additional
	// metadata (such as GitHub), the Origin field should be set.
	Mirror bool `protobuf:"varint,13,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Private is whether this repository is private. Note: this field
	// is currently only used when the repository is hosted on GitHub.
	// All locally hosted repositories should be public. If Private is
	// true for a locally hosted repository, the repository might never
	// be returned.
	Private bool `protobuf:"varint,14,opt,name=Private,proto3" json:"Private,omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,15,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,16,opt,name=UpdatedAt" json:"UpdatedAt,omitempty"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,17,opt,name=PushedAt" json:"PushedAt,omitempty"`
	// VCSSyncedAt is when this repository's VCS data was last synced
	// with the upstream. This field is only populated for mirror
	// repositories.
	VCSSyncedAt *pbtypes.Timestamp `protobuf:"bytes,20,opt,name=VCSSyncedAt" json:"VCSSyncedAt,omitempty"`
	// Origin describes the repo's canonical location. It is only
	// populated for mirror repos; for non-mirror repos, it is null.
	Origin *Origin `protobuf:"bytes,19,opt,name=Origin" json:"Origin,omitempty"`
	// Permissions describes the actions that the current user (who
	// retrieved this repository from the API) may perform on the
	// repository. For public repositories retrieved by
	// non-contributors, the Permissions field may be null and the
	// Pull permission is implied (because it's a public repository).
	//
	// TODO(sqs): Currently these map directly to the user's GitHub
	// permissions for GitHub repositories; all other repositories
	// report that all users have the Pull permission only.
	Permissions *RepoPermissions `protobuf:"bytes,21,opt,name=Permissions" json:"Permissions,omitempty"`
}

func (m *Repo) Reset()                    { *m = Repo{} }
func (m *Repo) String() string            { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()               {}
func (*Repo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{6} }

// RepoPermissions describes the actions that a user may perform on a
// repo. Currently, the definition of these permissions directly maps
// to GitHub permissions, except for "Pull", which means read access.
type RepoPermissions struct {
	Pull  bool `protobuf:"varint,1,opt,name=Pull,proto3" json:"Pull,omitempty"`
	Push  bool `protobuf:"varint,2,opt,name=Push,proto3" json:"Push,omitempty"`
	Admin bool `protobuf:"varint,3,opt,name=Admin,proto3" json:"Admin,omitempty"`
}

func (m *RepoPermissions) Reset()                    { *m = RepoPermissions{} }
func (m *RepoPermissions) String() string            { return proto.CompactTextString(m) }
func (*RepoPermissions) ProtoMessage()               {}
func (*RepoPermissions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{7} }

type RepoListOptions struct {
	// Name filters the repository list by name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty" url:",omitempty"`
	// Query specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query string `protobuf:"bytes,2,opt,name=Query,proto3" json:"Query,omitempty" url:",omitempty"`
	// URIs specifies a set of repository URIs to list.
	URIs []string `protobuf:"bytes,3,rep,name=URIs" json:"URIs,omitempty" url:",comma,omitempty"`
	// Sort determines how the returned list of repositories is sorted.
	Sort string `protobuf:"bytes,5,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	// Direction determines the sort direction.
	Direction string `protobuf:"bytes,6,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	// NoFork excludes forks from the list of returned repositories.
	NoFork bool `protobuf:"varint,7,opt,name=NoFork,proto3" json:"NoFork,omitempty" url:",omitempty"`
	// Type of repositories to list. Possible values are currently
	// ones supported by the GitHub API, including: all, owner,
	// public, private, member. Default is "all".
	Type string `protobuf:"bytes,8,opt,name=Type,proto3" json:"Type,omitempty" url:",omitempty"`
	// Owner filters the list of repositories to those with the
	// specified owner.
	Owner string `protobuf:"bytes,10,opt,name=Owner,proto3" json:"Owner,omitempty" url:",omitempty"`
	// RemoteOnly makes the endpoint return repositories hosted on
	// GitHub that the currently authenticated user has access to.
	//
	// When RemoteOnly is true, the only other option field that is
	// obeyed is Type (pagination is ignored, too), and returned
	// repositories do not have valid IDs. If you want to get the ID of
	// a repository, fetch it individually.
	RemoteOnly bool `protobuf:"varint,12,opt,name=RemoteOnly,proto3" json:"RemoteOnly,omitempty" url:",omitempty"`
	// ListOptions controls pagination.
	ListOptions `protobuf:"bytes,13,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListOptions) Reset()                    { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()               {}
func (*RepoListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{8} }

// RepoWebhookOptions is used for enable repository webhook.
type RepoWebhookOptions struct {
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
}

func (m *RepoWebhookOptions) Reset()                    { *m = RepoWebhookOptions{} }
func (m *RepoWebhookOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoWebhookOptions) ProtoMessage()               {}
func (*RepoWebhookOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{9} }

// RepoRevSpec specifies a repository at a specific commit.
type RepoRevSpec struct {
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// CommitID is the 40-character SHA-1 of the Git commit ID.
	//
	// Revision specifiers are not allowed here. To resolve a revision
	// specifier (such as a branch name or "master~7"), call
	// Repos.GetCommit.
	CommitID string `protobuf:"bytes,2,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *RepoRevSpec) Reset()                    { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string            { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()               {}
func (*RepoRevSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{10} }

// RepoSpec specifies a repository.
type RepoSpec struct {
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *RepoSpec) Reset()                    { *m = RepoSpec{} }
func (m *RepoSpec) String() string            { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()               {}
func (*RepoSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{11} }

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=State,proto3" json:"State,omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=TargetURL,proto3" json:"TargetURL,omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=Context,proto3" json:"Context,omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=CreatedAt" json:"CreatedAt"`
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=UpdatedAt" json:"UpdatedAt"`
}

func (m *RepoStatus) Reset()                    { *m = RepoStatus{} }
func (m *RepoStatus) String() string            { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()               {}
func (*RepoStatus) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{12} }

type RepoStatusList struct {
	RepoStatuses []*RepoStatus `protobuf:"bytes,1,rep,name=RepoStatuses" json:"RepoStatuses,omitempty"`
}

func (m *RepoStatusList) Reset()                    { *m = RepoStatusList{} }
func (m *RepoStatusList) String() string            { return proto.CompactTextString(m) }
func (*RepoStatusList) ProtoMessage()               {}
func (*RepoStatusList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{13} }

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=Repo" json:"Repo"`
	Status RepoStatus  `protobuf:"bytes,2,opt,name=Status" json:"Status"`
}

func (m *RepoStatusesCreateOp) Reset()                    { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string            { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()               {}
func (*RepoStatusesCreateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{14} }

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *RepoList) Reset()                    { *m = RepoList{} }
func (m *RepoList) String() string            { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()               {}
func (*RepoList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{15} }

// ReposResolveRevOp specifies a Repos.ResolveRev operation.
type ReposResolveRevOp struct {
	Repo int32 `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// Rev is a VCS revision specifier, such as a branch or
	// "master~7".
	Rev string `protobuf:"bytes,2,opt,name=rev,proto3" json:"rev,omitempty"`
}

func (m *ReposResolveRevOp) Reset()                    { *m = ReposResolveRevOp{} }
func (m *ReposResolveRevOp) String() string            { return proto.CompactTextString(m) }
func (*ReposResolveRevOp) ProtoMessage()               {}
func (*ReposResolveRevOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{16} }

// ResolvedRev is the result of resolving a VCS revision specifier to
// an absolute commit ID.
type ResolvedRev struct {
	// CommitID is the 40-character absolute SHA-1 hex digest of the
	// commit's Git oid.
	CommitID string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *ResolvedRev) Reset()                    { *m = ResolvedRev{} }
func (m *ResolvedRev) String() string            { return proto.CompactTextString(m) }
func (*ResolvedRev) ProtoMessage()               {}
func (*ResolvedRev) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{17} }

type ReceivePackOp struct {
	Repo          int32  `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	AdvertiseRefs bool   `protobuf:"varint,4,opt,name=advertiseRefs,proto3" json:"advertiseRefs,omitempty"`
}

func (m *ReceivePackOp) Reset()                    { *m = ReceivePackOp{} }
func (m *ReceivePackOp) String() string            { return proto.CompactTextString(m) }
func (*ReceivePackOp) ProtoMessage()               {}
func (*ReceivePackOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{18} }

type UploadPackOp struct {
	Repo          int32  `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	AdvertiseRefs bool   `protobuf:"varint,4,opt,name=advertiseRefs,proto3" json:"advertiseRefs,omitempty"`
}

func (m *UploadPackOp) Reset()                    { *m = UploadPackOp{} }
func (m *UploadPackOp) String() string            { return proto.CompactTextString(m) }
func (*UploadPackOp) ProtoMessage()               {}
func (*UploadPackOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{19} }

type URIList struct {
	URIs []string `protobuf:"bytes,1,rep,name=URIs" json:"URIs,omitempty"`
}

func (m *URIList) Reset()                    { *m = URIList{} }
func (m *URIList) String() string            { return proto.CompactTextString(m) }
func (*URIList) ProtoMessage()               {}
func (*URIList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{20} }

type Packet struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Packet) Reset()                    { *m = Packet{} }
func (m *Packet) String() string            { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()               {}
func (*Packet) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{21} }

type RepoResolveOp struct {
	// Path is some repo path, such as "github.com/user/repo".
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Remote controls the behavior when Resolve locates a remote
	// repository that is not (yet) associated with an existing local
	// repository. If Remote is false (the default), then a NotFound
	// error is returned in that case. If Remote is true, then no
	// error is returned; the RepoResolution's Repo field will be
	// empty, but some metadata about the remote repository may be
	// provided.
	Remote bool `protobuf:"varint,2,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *RepoResolveOp) Reset()                    { *m = RepoResolveOp{} }
func (m *RepoResolveOp) String() string            { return proto.CompactTextString(m) }
func (*RepoResolveOp) ProtoMessage()               {}
func (*RepoResolveOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{22} }

// RepoResolution is the result of resolving a repo using
// Repos.Resolve.
type RepoResolution struct {
	// ID is the ID of the local repo (either a locally hosted repo,
	// or a locally added mirror).
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// CanonicalPath is the canonical repo path of the local repo
	// (with the canonical casing, etc.). Clients should generally
	// redirect the user to the canonical repo path if users access a
	// repo by a non-canonical path.
	CanonicalPath string `protobuf:"bytes,3,opt,name=CanonicalPath,proto3" json:"CanonicalPath,omitempty"`
	// RemoteRepo holds metadata about the repo that exists on a
	// remote service (such as GitHub).
	RemoteRepo *Repo `protobuf:"bytes,2,opt,name=RemoteRepo" json:"RemoteRepo,omitempty"`
}

func (m *RepoResolution) Reset()                    { *m = RepoResolution{} }
func (m *RepoResolution) String() string            { return proto.CompactTextString(m) }
func (*RepoResolution) ProtoMessage()               {}
func (*RepoResolution) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{23} }

// SrclibDataVersion specifies a srclib store version.
type SrclibDataVersion struct {
	CommitID      string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	CommitsBehind int32  `protobuf:"varint,2,opt,name=CommitsBehind,proto3" json:"CommitsBehind,omitempty"`
}

func (m *SrclibDataVersion) Reset()                    { *m = SrclibDataVersion{} }
func (m *SrclibDataVersion) String() string            { return proto.CompactTextString(m) }
func (*SrclibDataVersion) ProtoMessage()               {}
func (*SrclibDataVersion) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{24} }

type ReposCreateOp struct {
	// Types that are valid to be assigned to Op:
	//	*ReposCreateOp_New
	//	*ReposCreateOp_FromGitHubID
	//	*ReposCreateOp_Origin
	Op isReposCreateOp_Op `protobuf_oneof:"Op"`
}

func (m *ReposCreateOp) Reset()                    { *m = ReposCreateOp{} }
func (m *ReposCreateOp) String() string            { return proto.CompactTextString(m) }
func (*ReposCreateOp) ProtoMessage()               {}
func (*ReposCreateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{25} }

type isReposCreateOp_Op interface {
	isReposCreateOp_Op()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReposCreateOp_New struct {
	New *ReposCreateOp_NewRepo `protobuf:"bytes,1,opt,name=New,oneof"`
}
type ReposCreateOp_FromGitHubID struct {
	FromGitHubID int32 `protobuf:"varint,2,opt,name=FromGitHubID,proto3,oneof"`
}
type ReposCreateOp_Origin struct {
	Origin *Origin `protobuf:"bytes,3,opt,name=Origin,oneof"`
}

func (*ReposCreateOp_New) isReposCreateOp_Op()          {}
func (*ReposCreateOp_FromGitHubID) isReposCreateOp_Op() {}
func (*ReposCreateOp_Origin) isReposCreateOp_Op()       {}

func (m *ReposCreateOp) GetOp() isReposCreateOp_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *ReposCreateOp) GetNew() *ReposCreateOp_NewRepo {
	if x, ok := m.GetOp().(*ReposCreateOp_New); ok {
		return x.New
	}
	return nil
}

func (m *ReposCreateOp) GetFromGitHubID() int32 {
	if x, ok := m.GetOp().(*ReposCreateOp_FromGitHubID); ok {
		return x.FromGitHubID
	}
	return 0
}

func (m *ReposCreateOp) GetOrigin() *Origin {
	if x, ok := m.GetOp().(*ReposCreateOp_Origin); ok {
		return x.Origin
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReposCreateOp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReposCreateOp_OneofMarshaler, _ReposCreateOp_OneofUnmarshaler, _ReposCreateOp_OneofSizer, []interface{}{
		(*ReposCreateOp_New)(nil),
		(*ReposCreateOp_FromGitHubID)(nil),
		(*ReposCreateOp_Origin)(nil),
	}
}

func _ReposCreateOp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReposCreateOp)
	// Op
	switch x := m.Op.(type) {
	case *ReposCreateOp_New:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.New); err != nil {
			return err
		}
	case *ReposCreateOp_FromGitHubID:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.FromGitHubID))
	case *ReposCreateOp_Origin:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Origin); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReposCreateOp.Op has unexpected type %T", x)
	}
	return nil
}

func _ReposCreateOp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReposCreateOp)
	switch tag {
	case 1: // Op.New
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReposCreateOp_NewRepo)
		err := b.DecodeMessage(msg)
		m.Op = &ReposCreateOp_New{msg}
		return true, err
	case 2: // Op.FromGitHubID
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Op = &ReposCreateOp_FromGitHubID{int32(x)}
		return true, err
	case 3: // Op.Origin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Origin)
		err := b.DecodeMessage(msg)
		m.Op = &ReposCreateOp_Origin{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReposCreateOp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReposCreateOp)
	// Op
	switch x := m.Op.(type) {
	case *ReposCreateOp_New:
		s := proto.Size(x.New)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReposCreateOp_FromGitHubID:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FromGitHubID))
	case *ReposCreateOp_Origin:
		s := proto.Size(x.Origin)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReposCreateOp_NewRepo struct {
	// URI is the desired URI of the new repository.
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	CloneURL string `protobuf:"bytes,3,opt,name=CloneURL,proto3" json:"CloneURL,omitempty"`
	// DefaultBranch is the repository's default Git branch.
	DefaultBranch string `protobuf:"bytes,4,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	Mirror bool `protobuf:"varint,5,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Description is the description of the repository.
	Description string `protobuf:"bytes,6,opt,name=Description,proto3" json:"Description,omitempty"`
	// Language is the primary programming language of the repository.
	Language string `protobuf:"bytes,7,opt,name=Language,proto3" json:"Language,omitempty"`
}

func (m *ReposCreateOp_NewRepo) Reset()         { *m = ReposCreateOp_NewRepo{} }
func (m *ReposCreateOp_NewRepo) String() string { return proto.CompactTextString(m) }
func (*ReposCreateOp_NewRepo) ProtoMessage()    {}
func (*ReposCreateOp_NewRepo) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{25, 0}
}

// ReposUpdateOp is an operation to update a repository's metadata.
type ReposUpdateOp struct {
	// Repo is the repository to update.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// URI, if non-empty, is the updated value of the URI
	URI string `protobuf:"bytes,2,opt,name=URI,proto3" json:"URI,omitempty"`
	// Owner, if non-empty, is the updated value of the owner.
	Owner string `protobuf:"bytes,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
	// Name, if non-empty, is the updated value of the name.
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// Description, if non-empty, is the updated value of the description.
	Description string `protobuf:"bytes,5,opt,name=Description,proto3" json:"Description,omitempty"`
	// HTTPCloneURL, if non-empty, is the updated value of the HTTP clone URL.
	HTTPCloneURL string `protobuf:"bytes,6,opt,name=HTTPCloneURL,proto3" json:"HTTPCloneURL,omitempty"`
	// SSHCloneURL, if non-empty, is the updated value of the SSH clone URL.
	SSHCloneURL string `protobuf:"bytes,7,opt,name=SSHCloneURL,proto3" json:"SSHCloneURL,omitempty"`
	// HomepageURL, if non-empty, is the updated value of the homepage URL.
	HomepageURL string `protobuf:"bytes,8,opt,name=HomepageURL,proto3" json:"HomepageURL,omitempty"`
	// DefaultBranch, if non-empty, is the updated value of the default branch.
	DefaultBranch string `protobuf:"bytes,10,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Language, if non-empty, is the updated value of the language.
	Language string `protobuf:"bytes,11,opt,name=Language,proto3" json:"Language,omitempty"`
	// Origin is data about the repository origin (e.g., GitHub).
	Origin *Origin `protobuf:"bytes,19,opt,name=Origin" json:"Origin,omitempty"`
	// Blocked, if non-empty, updates whether this repository is blocked.
	Blocked ReposUpdateOp_BoolType `protobuf:"varint,12,opt,name=Blocked,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Blocked,omitempty"`
	// Deprecated, if non-empty, updates whether this repository is deprecated.
	Deprecated ReposUpdateOp_BoolType `protobuf:"varint,13,opt,name=Deprecated,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Deprecated,omitempty"`
	// Fork, if non-empty, updates whether this repository is a fork.
	Fork ReposUpdateOp_BoolType `protobuf:"varint,14,opt,name=Fork,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Fork,omitempty"`
	// Mirror, if non-empty, updates whether this repository is a mirror.
	Mirror ReposUpdateOp_BoolType `protobuf:"varint,15,opt,name=Mirror,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Mirror,omitempty"`
	// Private, if non-empty, updates whether this repository is private.
	Private ReposUpdateOp_BoolType `protobuf:"varint,16,opt,name=Private,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Private,omitempty"`
}

func (m *ReposUpdateOp) Reset()                    { *m = ReposUpdateOp{} }
func (m *ReposUpdateOp) String() string            { return proto.CompactTextString(m) }
func (*ReposUpdateOp) ProtoMessage()               {}
func (*ReposUpdateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{26} }

type ReposListCommitsOp struct {
	Repo int32                   `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListCommitsOp) Reset()                    { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()               {}
func (*ReposListCommitsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{27} }

type RepoListCommitsOptions struct {
	Head        string `protobuf:"bytes,1,opt,name=Head,proto3" json:"Head,omitempty" url:",omitempty"`
	Base        string `protobuf:"bytes,2,opt,name=Base,proto3" json:"Base,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
	Path        string `protobuf:"bytes,4,opt,name=Path,proto3" json:"Path,omitempty" url:",omitempty"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}
func (*RepoListCommitsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{28}
}

type CommitList struct {
	Commits        []*vcs.Commit `protobuf:"bytes,1,rep,name=Commits" json:"Commits,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *CommitList) Reset()                    { *m = CommitList{} }
func (m *CommitList) String() string            { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()               {}
func (*CommitList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{29} }

type ReposListBranchesOp struct {
	Repo int32                    `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListBranchesOp) Reset()                    { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()               {}
func (*ReposListBranchesOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{30} }

type RepoListBranchesOptions struct {
	IncludeCommit     bool   `protobuf:"varint,4,opt,name=IncludeCommit,proto3" json:"IncludeCommit,omitempty"`
	BehindAheadBranch string `protobuf:"bytes,5,opt,name=BehindAheadBranch,proto3" json:"BehindAheadBranch,omitempty"`
	ContainsCommit    string `protobuf:"bytes,6,opt,name=ContainsCommit,proto3" json:"ContainsCommit,omitempty"`
	ListOptions       `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}
func (*RepoListBranchesOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{31}
}

type BranchList struct {
	Branches       []*vcs.Branch `protobuf:"bytes,1,rep,name=Branches" json:"Branches,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *BranchList) Reset()                    { *m = BranchList{} }
func (m *BranchList) String() string            { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()               {}
func (*BranchList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{32} }

type ReposListTagsOp struct {
	Repo int32                `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListTagsOp) Reset()                    { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()               {}
func (*ReposListTagsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{33} }

type ReposListCommittersOp struct {
	Repo int32                      `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListCommittersOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListCommittersOp) Reset()         { *m = ReposListCommittersOp{} }
func (m *ReposListCommittersOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommittersOp) ProtoMessage()    {}
func (*ReposListCommittersOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{34}
}

type RepoListCommittersOptions struct {
	Rev         string `protobuf:"bytes,1,opt,name=Rev,proto3" json:"Rev,omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListCommittersOptions) Reset()         { *m = RepoListCommittersOptions{} }
func (m *RepoListCommittersOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommittersOptions) ProtoMessage()    {}
func (*RepoListCommittersOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{35}
}

type CommitterList struct {
	Committers     []*vcs.Committer `protobuf:"bytes,1,rep,name=Committers" json:"Committers,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *CommitterList) Reset()                    { *m = CommitterList{} }
func (m *CommitterList) String() string            { return proto.CompactTextString(m) }
func (*CommitterList) ProtoMessage()               {}
func (*CommitterList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{36} }

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListTagsOptions) Reset()                    { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()               {}
func (*RepoListTagsOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{37} }

type TagList struct {
	Tags           []*vcs.Tag `protobuf:"bytes,1,rep,name=Tags" json:"Tags,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *TagList) Reset()                    { *m = TagList{} }
func (m *TagList) String() string            { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()               {}
func (*TagList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{38} }

type MirrorReposRefreshVCSOp struct {
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// AsUser is the user whose auth token will be used for refreshing this
	// mirror repo. This can be used when refreshing a private repo mirror.
	AsUser *UserSpec `protobuf:"bytes,3,opt,name=AsUser" json:"AsUser,omitempty"`
}

func (m *MirrorReposRefreshVCSOp) Reset()         { *m = MirrorReposRefreshVCSOp{} }
func (m *MirrorReposRefreshVCSOp) String() string { return proto.CompactTextString(m) }
func (*MirrorReposRefreshVCSOp) ProtoMessage()    {}
func (*MirrorReposRefreshVCSOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{39}
}

// RemoteRepo is a repo canonically stored on an external host, and
// possibly mirrored on the local instance.
type RemoteRepo struct {
	// GitHubID is the repo's GitHub repository ID.
	GitHubID int32 `protobuf:"varint,1,opt,name=GitHubID,proto3" json:"GitHubID,omitempty"`
	// Owner is the login or org name of the repo's owner ("foo" in
	// github.com/foo/bar).
	Owner string `protobuf:"bytes,2,opt,name=Owner,proto3" json:"Owner,omitempty"`
	// OwnerIsOrg is true if the repo's owner is an org (not a user).
	OwnerIsOrg bool `protobuf:"varint,15,opt,name=OwnerIsOrg,proto3" json:"OwnerIsOrg,omitempty"`
	// Name is the repo's name ("bar" in github.com/foo/bar).
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	// VCS is "git".
	VCS string `protobuf:"bytes,4,opt,name=VCS,proto3" json:"VCS,omitempty"`
	// HTTPCloneURL is the repo's HTTP (preferably HTTPS) clone URL.
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=HTTPCloneURL,proto3" json:"HTTPCloneURL,omitempty"`
	// DefaultBranch is the default Git branch for the repo.
	DefaultBranch string `protobuf:"bytes,6,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Description is the repo's description from GitHub.
	Description string `protobuf:"bytes,7,opt,name=Description,proto3" json:"Description,omitempty"`
	// Language is the repo's primary programming language, as
	// reported by GitHub.
	Language string `protobuf:"bytes,8,opt,name=Language,proto3" json:"Language,omitempty"`
	// UpdatedAt is the date of the most recent update (push or
	// metadata edit) to the repo on GitHub.
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,9,opt,name=UpdatedAt" json:"UpdatedAt,omitempty"`
	// PushedAt is the date of the most recent git push to the repo.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,14,opt,name=PushedAt" json:"PushedAt,omitempty"`
	// Private is true for private repos.
	Private bool `protobuf:"varint,10,opt,name=Private,proto3" json:"Private,omitempty"`
	// Fork is true for repos that were forked from another repo using
	// GitHub's "fork" operation.
	Fork bool `protobuf:"varint,11,opt,name=Fork,proto3" json:"Fork,omitempty"`
	// Mirror is true for mirror repos (e.g., Apache Foundation
	// open-source repo mirrors on GitHub.com).
	Mirror bool `protobuf:"varint,12,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Stars is the number of stargazers of the GitHub repo.
	Stars int32 `protobuf:"varint,13,opt,name=Stars,proto3" json:"Stars,omitempty"`
	// Permissions describes the actions that the current user may
	// perform on this remote repository on the remote service it came
	// from. These permissions currently map directly to GitHub
	// permissions but will be generalized/modified in the future to
	// support more repo hosting services.
	Permissions *RepoPermissions `protobuf:"bytes,24,opt,name=Permissions" json:"Permissions,omitempty"`
}

func (m *RemoteRepo) Reset()                    { *m = RemoteRepo{} }
func (m *RemoteRepo) String() string            { return proto.CompactTextString(m) }
func (*RemoteRepo) ProtoMessage()               {}
func (*RemoteRepo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{40} }

// EmailAddr is an email address associated with a user.
type EmailAddr struct {
	// the email address (case-insensitively compared in the DB and API)
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// whether this email address has been verified
	Verified bool `protobuf:"varint,2,opt,name=Verified,proto3" json:"Verified,omitempty"`
	// indicates this is the user's primary email (only 1 email can be primary per user)
	Primary bool `protobuf:"varint,3,opt,name=Primary,proto3" json:"Primary,omitempty"`
	// whether Sourcegraph inferred via public data that this is an email for the user
	Guessed bool `protobuf:"varint,4,opt,name=Guessed,proto3" json:"Guessed,omitempty"`
	// indicates that this email should not be associated with the user (even if guessed in the future)
	Blacklisted bool `protobuf:"varint,5,opt,name=Blacklisted,proto3" json:"Blacklisted,omitempty"`
}

func (m *EmailAddr) Reset()                    { *m = EmailAddr{} }
func (m *EmailAddr) String() string            { return proto.CompactTextString(m) }
func (*EmailAddr) ProtoMessage()               {}
func (*EmailAddr) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{41} }

type UserList struct {
	Users []*User `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UserList) Reset()                    { *m = UserList{} }
func (m *UserList) String() string            { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()               {}
func (*UserList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{42} }

// User represents a registered user.
type User struct {
	// UID is the numeric primary key for a user.
	UID int32 `protobuf:"varint,1,opt,name=UID,proto3" json:"UID"`
	// Login is the user's username.
	Login string `protobuf:"bytes,2,opt,name=Login,proto3" json:"Login"`
	// Name is the (possibly empty) full name of the user.
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// IsOrganization is whether this user represents an organization.
	IsOrganization bool `protobuf:"varint,5,opt,name=IsOrganization,proto3" json:"IsOrganization,omitempty"`
	// AvatarURL is the URL to an avatar image specified by the user.
	AvatarURL string `protobuf:"bytes,6,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// Location is the user's physical location.
	Location string `protobuf:"bytes,7,opt,name=Location,proto3" json:"Location,omitempty"`
	// Company is the user's company.
	Company string `protobuf:"bytes,8,opt,name=Company,proto3" json:"Company,omitempty"`
	// HomepageURL is the user's homepage or blog URL.
	HomepageURL string `protobuf:"bytes,9,opt,name=HomepageURL,proto3" json:"HomepageURL,omitempty"`
	// Disabled is whether the user account is disabled.
	Disabled bool `protobuf:"varint,10,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
	// Admin is whether the user is a site admin for the site.
	Admin bool `protobuf:"varint,12,opt,name=Admin,proto3" json:"Admin,omitempty"`
	// Betas is a list of betas which the user is enrolled in. A user may be
	// granted access to any beta string listed in both:
	//
	//  pkg/betautil/betautil.go
	//  app/web_modules/sourcegraph/util/betautil.js
	//
	// Only admin users may set this field.
	Betas []string `protobuf:"bytes,14,rep,name=Betas" json:"Betas,omitempty"`
	// Write is whether the user has write access for the site.
	Write bool `protobuf:"varint,13,opt,name=Write,proto3" json:"Write,omitempty"`
	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	RegisteredAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=RegisteredAt" json:"RegisteredAt,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{43} }

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
type UserSpec struct {
	// UID is a user's UID.
	UID int32 `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *UserSpec) Reset()                    { *m = UserSpec{} }
func (m *UserSpec) String() string            { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()               {}
func (*UserSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{44} }

type EmailAddrList struct {
	EmailAddrs []*EmailAddr `protobuf:"bytes,1,rep,name=EmailAddrs" json:"EmailAddrs,omitempty"`
}

func (m *EmailAddrList) Reset()                    { *m = EmailAddrList{} }
func (m *EmailAddrList) String() string            { return proto.CompactTextString(m) }
func (*EmailAddrList) ProtoMessage()               {}
func (*EmailAddrList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{45} }

// UpdateEmailsOp represents options for updating a user's email addresses.
type UpdateEmailsOp struct {
	// UserSpec is the user whose email addresses are to be updated.
	UserSpec UserSpec `protobuf:"bytes,1,opt,name=UserSpec" json:"UserSpec"`
	// Add is a list of email addresses to add, if they do not already exist.
	Add *EmailAddrList `protobuf:"bytes,2,opt,name=Add" json:"Add,omitempty"`
}

func (m *UpdateEmailsOp) Reset()                    { *m = UpdateEmailsOp{} }
func (m *UpdateEmailsOp) String() string            { return proto.CompactTextString(m) }
func (*UpdateEmailsOp) ProtoMessage()               {}
func (*UpdateEmailsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{46} }

// BetaRegistration represents the user information needed to register for the
// beta program.
type BetaRegistration struct {
	// Email is the primary email address for the user. It is only used if the
	// user does not already have an email address set in their account, else
	// this field is no-op.
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// FirstName is the first name of the user.
	FirstName string `protobuf:"bytes,2,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	// LastName is the last name of the user.
	LastName string `protobuf:"bytes,3,opt,name=LastName,proto3" json:"LastName,omitempty"`
	// Languages is a list of programming languages the user is interested in.
	Languages []string `protobuf:"bytes,4,rep,name=Languages" json:"Languages,omitempty"`
	// Editors is a list of editors the user is interested in.
	Editors []string `protobuf:"bytes,5,rep,name=Editors" json:"Editors,omitempty"`
	// Message contains any additional comments the user may have.
	Message string `protobuf:"bytes,6,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *BetaRegistration) Reset()                    { *m = BetaRegistration{} }
func (m *BetaRegistration) String() string            { return proto.CompactTextString(m) }
func (*BetaRegistration) ProtoMessage()               {}
func (*BetaRegistration) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{47} }

// BetaResponse is a response to a user registering for beta access.
type BetaResponse struct {
	// EmailAddress is the email address that was registered and will be
	// contacted once approved by an admin.
	EmailAddress string `protobuf:"bytes,1,opt,name=EmailAddress,proto3" json:"EmailAddress,omitempty"`
}

func (m *BetaResponse) Reset()                    { *m = BetaResponse{} }
func (m *BetaResponse) String() string            { return proto.CompactTextString(m) }
func (*BetaResponse) ProtoMessage()               {}
func (*BetaResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{48} }

// AuthInfo describes the currently authenticated client and/or user
// (if any).
type AuthInfo struct {
	// UID is the UID of the currently authenticated user (if any).
	UID int32 `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
	// Login is the login of the currently authenticated user (if any).
	Login string `protobuf:"bytes,4,opt,name=Login,proto3" json:"Login,omitempty"`
	// Write is set if the user (if any) has write access on this server.
	Write bool `protobuf:"varint,5,opt,name=Write,proto3" json:"Write,omitempty"`
	// Admin is set if the user (if any) has admin access on this server.
	Admin bool `protobuf:"varint,6,opt,name=Admin,proto3" json:"Admin,omitempty"`
}

func (m *AuthInfo) Reset()                    { *m = AuthInfo{} }
func (m *AuthInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()               {}
func (*AuthInfo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{49} }

// ExternalToken specifies an auth token of a user for an external host.
type ExternalToken struct {
	// UID is the UID of the user authorized by the token.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Host is the external service which granted the token.
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// Token is the auth token authorizing a user on an external service.
	Token string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	// Scope lists the permissions the token is entitled to.
	Scope string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
}

func (m *ExternalToken) Reset()                    { *m = ExternalToken{} }
func (m *ExternalToken) String() string            { return proto.CompactTextString(m) }
func (*ExternalToken) ProtoMessage()               {}
func (*ExternalToken) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{50} }

// Def is a code def returned by the Sourcegraph API.
type Def struct {
	graph.Def  `protobuf:"bytes,1,opt,name=Def,embedded=Def" json:""`
	DocHTML    *pbtypes2.HTML          `protobuf:"bytes,2,opt,name=DocHTML" json:"DocHTML,omitempty"`
	FmtStrings *graph.DefFormatStrings `protobuf:"bytes,3,opt,name=FmtStrings" json:"FmtStrings,omitempty"`
	// StartLine and EndLine are populated if
	// DefGetOptions.ComputeLineRange is true.
	StartLine uint32 `protobuf:"varint,4,opt,name=StartLine,proto3" json:"StartLine,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=EndLine,proto3" json:"EndLine,omitempty"`
}

func (m *Def) Reset()                    { *m = Def{} }
func (m *Def) String() string            { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()               {}
func (*Def) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{51} }

// DefGetOptions specifies options for DefsService.Get.
type DefGetOptions struct {
	Doc bool `protobuf:"varint,1,opt,name=Doc,proto3" json:"Doc,omitempty" url:",omitempty"`
	// ComputeLineRange is whether the server should compute the start
	// and end line numbers (1-indexed). This incurs additional cost,
	// so it's not always desired.
	ComputeLineRange bool `protobuf:"varint,2,opt,name=ComputeLineRange,proto3" json:"ComputeLineRange,omitempty" url:",omitempty"`
}

func (m *DefGetOptions) Reset()                    { *m = DefGetOptions{} }
func (m *DefGetOptions) String() string            { return proto.CompactTextString(m) }
func (*DefGetOptions) ProtoMessage()               {}
func (*DefGetOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{52} }

// DefListOptions specifies options for DefsService.List.
type DefListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty" url:",omitempty"`
	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	Query string `protobuf:"bytes,2,opt,name=Query,proto3" json:"Query,omitempty" url:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteStart uint32 `protobuf:"varint,3,opt,name=ByteStart,proto3" json:"ByteStart,omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteEnd uint32 `protobuf:"varint,4,opt,name=ByteEnd,proto3" json:"ByteEnd,omitempty"`
	// DefKeys, if set, will return the definitions that match the given DefKey
	DefKeys []*graph.DefKey `protobuf:"bytes,5,rep,name=DefKeys" json:"DefKeys,omitempty"`
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	//
	// TODO(repo-key): Make this use repo IDs, not URIs.
	RepoRevs []string `protobuf:"bytes,6,rep,name=RepoRevs" json:"RepoRevs,omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,7,opt,name=UnitType,proto3" json:"UnitType,omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,8,opt,name=Unit,proto3" json:"Unit,omitempty" url:",omitempty"`
	Path     string   `protobuf:"bytes,9,opt,name=Path,proto3" json:"Path,omitempty" url:",omitempty"`
	// Files, if specified, will restrict the results to only defs defined in the
	// specified file.
	Files []string `protobuf:"bytes,10,rep,name=Files" json:"Files,omitempty" url:",omitempty"`
	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	FilePathPrefix string   `protobuf:"bytes,11,opt,name=FilePathPrefix,proto3" json:"FilePathPrefix,omitempty" url:",omitempty"`
	Kinds          []string `protobuf:"bytes,12,rep,name=Kinds" json:"Kinds,omitempty" url:",omitempty,comma"`
	Exported       bool     `protobuf:"varint,13,opt,name=Exported,proto3" json:"Exported,omitempty" url:",omitempty"`
	Nonlocal       bool     `protobuf:"varint,14,opt,name=Nonlocal,proto3" json:"Nonlocal,omitempty" url:",omitempty"`
	// IncludeTest is whether the results should include definitions in test files.
	IncludeTest bool `protobuf:"varint,15,opt,name=IncludeTest,proto3" json:"IncludeTest,omitempty" url:",omitempty"`
	// Enhancements
	Doc   bool `protobuf:"varint,16,opt,name=Doc,proto3" json:"Doc,omitempty" url:",omitempty"`
	Fuzzy bool `protobuf:"varint,17,opt,name=Fuzzy,proto3" json:"Fuzzy,omitempty" url:",omitempty"`
	// Sorting
	Sort      string `protobuf:"bytes,18,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	Direction string `protobuf:"bytes,19,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,20,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListOptions) Reset()                    { *m = DefListOptions{} }
func (m *DefListOptions) String() string            { return proto.CompactTextString(m) }
func (*DefListOptions) ProtoMessage()               {}
func (*DefListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{53} }

// DefListRefsOptions configures the scope of ref search for a def.
type DefListRefsOptions struct {
	Repo        int32    `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty" url:",omitempty"`
	CommitID    string   `protobuf:"bytes,4,opt,name=CommitID,proto3" json:"CommitID,omitempty" url:",omitempty"`
	Files       []string `protobuf:"bytes,2,rep,name=Files" json:"Files,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListRefsOptions) Reset()                    { *m = DefListRefsOptions{} }
func (m *DefListRefsOptions) String() string            { return proto.CompactTextString(m) }
func (*DefListRefsOptions) ProtoMessage()               {}
func (*DefListRefsOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{54} }

// DefSpec specifies a def.
type DefSpec struct {
	Repo     int32  `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	CommitID string `protobuf:"bytes,2,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	UnitType string `protobuf:"bytes,3,opt,name=UnitType,proto3" json:"UnitType,omitempty"`
	Unit     string `protobuf:"bytes,4,opt,name=Unit,proto3" json:"Unit,omitempty"`
	Path     string `protobuf:"bytes,5,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *DefSpec) Reset()                    { *m = DefSpec{} }
func (m *DefSpec) String() string            { return proto.CompactTextString(m) }
func (*DefSpec) ProtoMessage()               {}
func (*DefSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{55} }

type DefsGetOp struct {
	Def DefSpec        `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefGetOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsGetOp) Reset()                    { *m = DefsGetOp{} }
func (m *DefsGetOp) String() string            { return proto.CompactTextString(m) }
func (*DefsGetOp) ProtoMessage()               {}
func (*DefsGetOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{56} }

type DefList struct {
	Defs         []*Def `protobuf:"bytes,1,rep,name=Defs" json:"Defs,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=ListResponse,embedded=ListResponse" json:""`
}

func (m *DefList) Reset()                    { *m = DefList{} }
func (m *DefList) String() string            { return proto.CompactTextString(m) }
func (*DefList) ProtoMessage()               {}
func (*DefList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{57} }

type DefsListRefsOp struct {
	Def DefSpec             `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefListRefsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListRefsOp) Reset()                    { *m = DefsListRefsOp{} }
func (m *DefsListRefsOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListRefsOp) ProtoMessage()               {}
func (*DefsListRefsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{58} }

type RefList struct {
	Refs           []*graph1.Ref `protobuf:"bytes,1,rep,name=Refs" json:"Refs,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *RefList) Reset()                    { *m = RefList{} }
func (m *RefList) String() string            { return proto.CompactTextString(m) }
func (*RefList) ProtoMessage()               {}
func (*RefList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{59} }

// DefListRefLocationsOptions holds the options for fetching
// all locations referencing a def.
type DefListRefLocationsOptions struct {
	// Repos is the list of repos to restrict the results to.
	// If empty, all repos are searched for references.
	Repos []string `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty" url:",omitempty"`
	// ListOptions specifies options for paginating
	// the result.
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListRefLocationsOptions) Reset()         { *m = DefListRefLocationsOptions{} }
func (m *DefListRefLocationsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListRefLocationsOptions) ProtoMessage()    {}
func (*DefListRefLocationsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{60}
}

// DefListRefLocationsOptions holds the options for fetching
// all locations referencing the specified def.
type DefsListRefLocationsOp struct {
	// Def identifies the definition whose locations are requested.
	Def DefSpec `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	// Opt controls the scope of the search for ref locations of this def.
	Opt *DefListRefLocationsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListRefLocationsOp) Reset()         { *m = DefsListRefLocationsOp{} }
func (m *DefsListRefLocationsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListRefLocationsOp) ProtoMessage()    {}
func (*DefsListRefLocationsOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{61}
}

// DefsListExamples holds the options for fetching
// usage examples referencing the specified def.
type DefsListExamplesOp struct {
	// Def identifies the definition whose examples are requested.
	Def DefSpec `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	// ListOptions specifies options for paginating the result.
	ListOptions `protobuf:"bytes,2,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefsListExamplesOp) Reset()                    { *m = DefsListExamplesOp{} }
func (m *DefsListExamplesOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListExamplesOp) ProtoMessage()               {}
func (*DefsListExamplesOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{62} }

// RefLocationsList lists the repos and files that reference a def.
type RefLocationsList struct {
	// RepoRefs holds the repos and files referencing the def.
	RepoRefs []*DefRepoRef `protobuf:"bytes,1,rep,name=RepoRefs" json:"RepoRefs,omitempty"`
	// StreamResponse specifies if more results are available.
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
	// TotalRepos is the total number of repos which reference the def.
	TotalRepos int32 `protobuf:"varint,3,opt,name=TotalRepos,proto3" json:"TotalRepos,omitempty"`
}

func (m *RefLocationsList) Reset()                    { *m = RefLocationsList{} }
func (m *RefLocationsList) String() string            { return proto.CompactTextString(m) }
func (*RefLocationsList) ProtoMessage()               {}
func (*RefLocationsList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{63} }

// DefRepoRef identifies a repo and its files that reference a def.
type DefRepoRef struct {
	// Repo is the name of repo that references the def.
	Repo string `protobuf:"bytes,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Count is the number of references to the def in the repo.
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	// Score is the importance score of this repo for the def.
	Score float32 `protobuf:"fixed32,3,opt,name=Score,proto3" json:"Score,omitempty"`
	// Files is the list of files in this repo referencing the def.
	Files []*DefFileRef `protobuf:"bytes,4,rep,name=Files" json:"Files,omitempty"`
}

func (m *DefRepoRef) Reset()                    { *m = DefRepoRef{} }
func (m *DefRepoRef) String() string            { return proto.CompactTextString(m) }
func (*DefRepoRef) ProtoMessage()               {}
func (*DefRepoRef) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{64} }

// DefFileRef identifies a file that references a def.
type DefFileRef struct {
	// Path is the path of this file.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Count is the number of references to the def in this file.
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	// Score is the importance score of this file for the def.
	Score float32 `protobuf:"fixed32,3,opt,name=Score,proto3" json:"Score,omitempty"`
}

func (m *DefFileRef) Reset()                    { *m = DefFileRef{} }
func (m *DefFileRef) String() string            { return proto.CompactTextString(m) }
func (*DefFileRef) ProtoMessage()               {}
func (*DefFileRef) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{65} }

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
type RepoTreeGetOptions struct {
	ContentsAsString bool `protobuf:"varint,4,opt,name=ContentsAsString,proto3" json:"ContentsAsString,omitempty" url:",omitempty"`
	GetFileOptions   `protobuf:"bytes,5,opt,name=GetFileOptions,embedded=GetFileOptions" json:""`
	// NoSrclibAnns indicates whether or not srclib annotations should be
	// excluded in the (optional) returned list of annotations.
	NoSrclibAnns bool `protobuf:"varint,6,opt,name=NoSrclibAnns,proto3" json:"NoSrclibAnns,omitempty"`
}

func (m *RepoTreeGetOptions) Reset()                    { *m = RepoTreeGetOptions{} }
func (m *RepoTreeGetOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeGetOptions) ProtoMessage()               {}
func (*RepoTreeGetOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{66} }

// GetFileOptions specifies options for GetFileWithOptions.
type GetFileOptions struct {
	// line or byte range to fetch (can't set both line *and* byte range)
	FileRange `protobuf:"bytes,1,opt,name=FileRange,embedded=FileRange" json:""`
	// EntireFile is whether the entire file contents should be returned. If true,
	// Start/EndLine and Start/EndBytes are ignored.
	EntireFile bool `protobuf:"varint,2,opt,name=EntireFile,proto3" json:"EntireFile,omitempty" url:",omitempty"`
	// ExpandContextLines is how many lines of additional output context to include (if
	// Start/EndLine and Start/EndBytes are specified). For example, specifying 2 will
	// expand the range to include 2 full lines before the beginning and 2 full lines
	// after the end of the range specified by Start/EndLine and Start/EndBytes.
	ExpandContextLines int32 `protobuf:"varint,3,opt,name=ExpandContextLines,proto3" json:"ExpandContextLines,omitempty" url:",omitempty"`
	// FullLines is whether a range that includes partial lines should be extended to
	// the nearest line boundaries on both sides. It is only valid if StartByte and
	// EndByte are specified.
	FullLines bool `protobuf:"varint,4,opt,name=FullLines,proto3" json:"FullLines,omitempty" url:",omitempty"`
	// Recursive only applies if the returned entry is a directory. It will
	// return the full file tree of the host repository, recursing into all
	// sub-directories.
	Recursive bool `protobuf:"varint,5,opt,name=Recursive,proto3" json:"Recursive,omitempty" url:",omitempty"`
	// RecurseSingleSubfolderLimit only applies if the returned entry is a directory.
	// If nonzero, it will recursively find and include all singleton sub-directory chains,
	// up to a limit of RecurseSingleSubfolderLimit.
	RecurseSingleSubfolderLimit int32 `protobuf:"varint,6,opt,name=RecurseSingleSubfolderLimit,proto3" json:"RecurseSingleSubfolderLimit,omitempty" url:",omitempty"`
}

func (m *GetFileOptions) Reset()                    { *m = GetFileOptions{} }
func (m *GetFileOptions) String() string            { return proto.CompactTextString(m) }
func (*GetFileOptions) ProtoMessage()               {}
func (*GetFileOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{67} }

type RepoTreeSearchOptions struct {
	vcs.SearchOptions `protobuf:"bytes,1,opt,name=SearchOptions,embedded=SearchOptions" json:""`
}

func (m *RepoTreeSearchOptions) Reset()         { *m = RepoTreeSearchOptions{} }
func (m *RepoTreeSearchOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOptions) ProtoMessage()    {}
func (*RepoTreeSearchOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{68}
}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
type RepoTreeSearchResult struct {
	vcs.SearchResult `protobuf:"bytes,1,opt,name=SearchResult,embedded=SearchResult" json:""`
	RepoRev          RepoRevSpec `protobuf:"bytes,2,opt,name=RepoRev" json:"RepoRev"`
}

func (m *RepoTreeSearchResult) Reset()                    { *m = RepoTreeSearchResult{} }
func (m *RepoTreeSearchResult) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeSearchResult) ProtoMessage()               {}
func (*RepoTreeSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{69} }

type RepoTreeGetOp struct {
	Entry TreeEntrySpec       `protobuf:"bytes,1,opt,name=Entry" json:"Entry"`
	Opt   *RepoTreeGetOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *RepoTreeGetOp) Reset()                    { *m = RepoTreeGetOp{} }
func (m *RepoTreeGetOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeGetOp) ProtoMessage()               {}
func (*RepoTreeGetOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{70} }

type RepoTreeSearchOp struct {
	Rev RepoRevSpec            `protobuf:"bytes,1,opt,name=Rev" json:"Rev"`
	Opt *RepoTreeSearchOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *RepoTreeSearchOp) Reset()                    { *m = RepoTreeSearchOp{} }
func (m *RepoTreeSearchOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeSearchOp) ProtoMessage()               {}
func (*RepoTreeSearchOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{71} }

type RepoTreeListOp struct {
	Rev RepoRevSpec `protobuf:"bytes,1,opt,name=Rev" json:"Rev"`
}

func (m *RepoTreeListOp) Reset()                    { *m = RepoTreeListOp{} }
func (m *RepoTreeListOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeListOp) ProtoMessage()               {}
func (*RepoTreeListOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{72} }

type RepoTreeListResult struct {
	Files []string `protobuf:"bytes,1,rep,name=Files" json:"Files,omitempty"`
}

func (m *RepoTreeListResult) Reset()                    { *m = RepoTreeListResult{} }
func (m *RepoTreeListResult) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeListResult) ProtoMessage()               {}
func (*RepoTreeListResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{73} }

type VCSSearchResultList struct {
	SearchResults []*vcs.SearchResult `protobuf:"bytes,1,rep,name=SearchResults" json:"SearchResults,omitempty"`
	ListResponse  `protobuf:"bytes,2,opt,name=ListResponse,embedded=ListResponse" json:""`
}

func (m *VCSSearchResultList) Reset()                    { *m = VCSSearchResultList{} }
func (m *VCSSearchResultList) String() string            { return proto.CompactTextString(m) }
func (*VCSSearchResultList) ProtoMessage()               {}
func (*VCSSearchResultList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{74} }

// TreeEntry is a file or directory in a repository.
type TreeEntry struct {
	*BasicTreeEntry `protobuf:"bytes,1,opt,name=BasicTreeEntry,embedded=BasicTreeEntry" json:""`
	*FileRange      `protobuf:"bytes,2,opt,name=FileRange,embedded=FileRange" json:""`
	ContentsString  string `protobuf:"bytes,3,opt,name=ContentsString,proto3" json:"ContentsString,omitempty"`
}

func (m *TreeEntry) Reset()                    { *m = TreeEntry{} }
func (m *TreeEntry) String() string            { return proto.CompactTextString(m) }
func (*TreeEntry) ProtoMessage()               {}
func (*TreeEntry) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{75} }

type BasicTreeEntry struct {
	Name     string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type     TreeEntryType     `protobuf:"varint,2,opt,name=Type,proto3,enum=sourcegraph.TreeEntryType" json:"Type,omitempty"`
	CommitID string            `protobuf:"bytes,3,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	Contents []byte            `protobuf:"bytes,5,opt,name=Contents,proto3" json:"Contents,omitempty"`
	Entries  []*BasicTreeEntry `protobuf:"bytes,6,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *BasicTreeEntry) Reset()                    { *m = BasicTreeEntry{} }
func (m *BasicTreeEntry) String() string            { return proto.CompactTextString(m) }
func (*BasicTreeEntry) ProtoMessage()               {}
func (*BasicTreeEntry) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{76} }

type TreeEntrySpec struct {
	RepoRev RepoRevSpec `protobuf:"bytes,1,opt,name=RepoRev" json:"RepoRev"`
	Path    string      `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *TreeEntrySpec) Reset()                    { *m = TreeEntrySpec{} }
func (m *TreeEntrySpec) String() string            { return proto.CompactTextString(m) }
func (*TreeEntrySpec) ProtoMessage()               {}
func (*TreeEntrySpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{77} }

// FileRange is a line and byte range in a file.
type FileRange struct {
	// start of line range
	StartLine int64 `protobuf:"varint,1,opt,name=StartLine,proto3" json:"StartLine,omitempty" url:",omitempty"`
	// end of line range
	EndLine int64 `protobuf:"varint,2,opt,name=EndLine,proto3" json:"EndLine,omitempty" url:",omitempty"`
	// start of byte range
	StartByte int64 `protobuf:"varint,3,opt,name=StartByte,proto3" json:"StartByte,omitempty" url:",omitempty"`
	// end of byte range
	EndByte int64 `protobuf:"varint,4,opt,name=EndByte,proto3" json:"EndByte,omitempty" url:",omitempty"`
}

func (m *FileRange) Reset()                    { *m = FileRange{} }
func (m *FileRange) String() string            { return proto.CompactTextString(m) }
func (*FileRange) ProtoMessage()               {}
func (*FileRange) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{78} }

type DefsRefreshIndexOp struct {
	// Repo is the repo whose graph data is to be re-indexed
	// for global ref locations.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// RefreshRefLocations refreshes the global ref locations index for
	// the specified repository.
	RefreshRefLocations bool `protobuf:"varint,2,opt,name=RefreshRefLocations,proto3" json:"RefreshRefLocations,omitempty"`
	// Force ensures we reindex, even if we have already indexed the latest
	// commit for repo
	Force bool `protobuf:"varint,3,opt,name=Force,proto3" json:"Force,omitempty"`
}

func (m *DefsRefreshIndexOp) Reset()                    { *m = DefsRefreshIndexOp{} }
func (m *DefsRefreshIndexOp) String() string            { return proto.CompactTextString(m) }
func (*DefsRefreshIndexOp) ProtoMessage()               {}
func (*DefsRefreshIndexOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{79} }

type AsyncRefreshIndexesOp struct {
	// Repo will have all of its indexes refreshed.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Source helps tie back async jobs to their source.
	Source string `protobuf:"bytes,2,opt,name=Source,proto3" json:"Source,omitempty"`
	// Force will ensure all indexes are refreshed, even if the index
	// already includes the latest commit.
	Force bool `protobuf:"varint,3,opt,name=Force,proto3" json:"Force,omitempty"`
}

func (m *AsyncRefreshIndexesOp) Reset()         { *m = AsyncRefreshIndexesOp{} }
func (m *AsyncRefreshIndexesOp) String() string { return proto.CompactTextString(m) }
func (*AsyncRefreshIndexesOp) ProtoMessage()    {}
func (*AsyncRefreshIndexesOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{80}
}

type AuthorshipInfo struct {
	LastCommitDate pbtypes.Timestamp `protobuf:"bytes,1,opt,name=LastCommitDate" json:"LastCommitDate"`
	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	LastCommitID string `protobuf:"bytes,2,opt,name=LastCommitID,proto3" json:"LastCommitID,omitempty"`
}

func (m *AuthorshipInfo) Reset()                    { *m = AuthorshipInfo{} }
func (m *AuthorshipInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthorshipInfo) ProtoMessage()               {}
func (*AuthorshipInfo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{81} }

type DefAuthor struct {
	// Email is the author's email. It may be obfuscated or truncated
	// to prevent spam.
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// AvatarURL is the URL to the author's avatar image, if any.
	AvatarURL string `protobuf:"bytes,2,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// DefAuthorship contains statistics about the author's contributions
	// to the def.
	DefAuthorship `protobuf:"bytes,3,opt,name=DefAuthorship,embedded=DefAuthorship" json:""`
}

func (m *DefAuthor) Reset()                    { *m = DefAuthor{} }
func (m *DefAuthor) String() string            { return proto.CompactTextString(m) }
func (*DefAuthor) ProtoMessage()               {}
func (*DefAuthor) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{82} }

type DefAuthorship struct {
	AuthorshipInfo  `protobuf:"bytes,1,opt,name=AuthorshipInfo,embedded=AuthorshipInfo" json:""`
	Bytes           int32   `protobuf:"varint,3,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	BytesProportion float64 `protobuf:"fixed64,4,opt,name=BytesProportion,proto3" json:"BytesProportion,omitempty"`
}

func (m *DefAuthorship) Reset()                    { *m = DefAuthorship{} }
func (m *DefAuthorship) String() string            { return proto.CompactTextString(m) }
func (*DefAuthorship) ProtoMessage()               {}
func (*DefAuthorship) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{83} }

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
type DefListAuthorsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListAuthorsOptions) Reset()         { *m = DefListAuthorsOptions{} }
func (m *DefListAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListAuthorsOptions) ProtoMessage()    {}
func (*DefListAuthorsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{84}
}

type DefsListAuthorsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefListAuthorsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListAuthorsOp) Reset()                    { *m = DefsListAuthorsOp{} }
func (m *DefsListAuthorsOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListAuthorsOp) ProtoMessage()               {}
func (*DefsListAuthorsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{85} }

type DefAuthorList struct {
	DefAuthors []*DefAuthor `protobuf:"bytes,1,rep,name=DefAuthors" json:"DefAuthors,omitempty"`
}

func (m *DefAuthorList) Reset()                    { *m = DefAuthorList{} }
func (m *DefAuthorList) String() string            { return proto.CompactTextString(m) }
func (*DefAuthorList) ProtoMessage()               {}
func (*DefAuthorList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{86} }

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
type ServerConfig struct {
	// Version is the version of Sourcegraph that this server is
	// running.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	AppURL string `protobuf:"bytes,2,opt,name=AppURL,proto3" json:"AppURL,omitempty"`
}

func (m *ServerConfig) Reset()                    { *m = ServerConfig{} }
func (m *ServerConfig) String() string            { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()               {}
func (*ServerConfig) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{87} }

// UserEvent encodes any user initiated event on the local instance.
type UserEvent struct {
	Type    string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	UID     int32  `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
	Service string `protobuf:"bytes,4,opt,name=Service,proto3" json:"Service,omitempty"`
	Method  string `protobuf:"bytes,5,opt,name=Method,proto3" json:"Method,omitempty"`
	Result  string `protobuf:"bytes,6,opt,name=Result,proto3" json:"Result,omitempty"`
	// CreatedAt holds the time when this event was logged.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
	Message   string             `protobuf:"bytes,8,opt,name=Message,proto3" json:"Message,omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,9,opt,name=Version,proto3" json:"Version,omitempty"`
	// URL holds the http request url.
	URL string `protobuf:"bytes,10,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *UserEvent) Reset()                    { *m = UserEvent{} }
func (m *UserEvent) String() string            { return proto.CompactTextString(m) }
func (*UserEvent) ProtoMessage()               {}
func (*UserEvent) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{88} }

// Event is any action logged on a Sourcegraph instance.
type Event struct {
	// Type specifies the action type, eg. "AccountCreate" or "AddRepo".
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// UserID is the unique identifier of a user on a Sourcegraph instance.
	// It is constructed as "login@short-client-id", where short-client-id
	// is the first 6 characters of this sourcegraph instance's public key
	// fingerprint (i.e. it's ClientID).
	UserID string `protobuf:"bytes,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// DeviceID is the unique identifier of an anonymous user on a Sourcegraph
	// instance.
	DeviceID string `protobuf:"bytes,3,opt,name=DeviceID,proto3" json:"DeviceID,omitempty"`
	// Timestamp records the instant when this event was logged.
	Timestamp *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=Timestamp" json:"Timestamp,omitempty"`
	// UserProperties holds metadata relating to user who performed this
	// action, eg. "Email".
	UserProperties map[string]string `protobuf:"bytes,6,rep,name=UserProperties" json:"UserProperties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// EventProperties holds metadata relating to the action logged by
	// this event, eg. for "AddRepo" event, a property is "Source" which
	// specifies if the repo is local or mirrored.
	EventProperties map[string]string `protobuf:"bytes,7,rep,name=EventProperties" json:"EventProperties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{89} }

// EventList is a list of logged Sourcegraph events.
type EventList struct {
	// Events holds the list of events.
	Events []*Event `protobuf:"bytes,1,rep,name=Events" json:"Events,omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	// AppURL holds the base URL of the Sourcegraph app.
	AppURL string `protobuf:"bytes,3,opt,name=AppURL,proto3" json:"AppURL,omitempty"`
}

func (m *EventList) Reset()                    { *m = EventList{} }
func (m *EventList) String() string            { return proto.CompactTextString(m) }
func (*EventList) ProtoMessage()               {}
func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{90} }

// An Annotation is metadata (such as a srclib ref) attached to a
// portion of a file.
type Annotation struct {
	// URL is the location where more information about the
	// annotation's topic may be found (e.g., for a srclib ref, it's
	// the def's URL).
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	// StartByte is the start of the byte range.
	StartByte uint32 `protobuf:"varint,2,opt,name=StartByte,proto3" json:"StartByte"`
	// EndByte is the end of the byte range.
	EndByte uint32 `protobuf:"varint,3,opt,name=EndByte,proto3" json:"EndByte"`
	// Class is the HTML class name that should be applied to this
	// region.
	Class string `protobuf:"bytes,4,opt,name=Class,proto3" json:"Class,omitempty"`
	// Def is whether this annotation marks the definition of the
	// item described in URL or URLs. For example, "Foo" in "func Foo() {}"
	// would have its annotation with Def=true.
	//
	// Marking whether this annotation is a def lets us
	// jump-to-definition here from other refs in the same file
	// without needing to load the defs for those refs.
	Def bool `protobuf:"varint,7,opt,name=Def,proto3" json:"Def,omitempty"`
	// WantInner indicates that this annotation, when being applied to
	// the underlying text, should be inner (i.e., more deeply
	// nested). Larger numbers mean greater precedence for being
	// nested more deeply.
	WantInner int32 `protobuf:"varint,5,opt,name=WantInner,proto3" json:"WantInner,omitempty"`
	// URLs can be set instead of URL if there are multiple URLs on an
	// annotation.
	URLs []string `protobuf:"bytes,6,rep,name=URLs" json:"URLs,omitempty"`
}

func (m *Annotation) Reset()                    { *m = Annotation{} }
func (m *Annotation) String() string            { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()               {}
func (*Annotation) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{91} }

// AnnotationList is a list of annotations.
type AnnotationList struct {
	Annotations    []*Annotation `protobuf:"bytes,1,rep,name=Annotations" json:"Annotations,omitempty"`
	LineStartBytes []uint32      `protobuf:"varint,2,rep,name=LineStartBytes" json:"LineStartBytes,omitempty"`
}

func (m *AnnotationList) Reset()                    { *m = AnnotationList{} }
func (m *AnnotationList) String() string            { return proto.CompactTextString(m) }
func (*AnnotationList) ProtoMessage()               {}
func (*AnnotationList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{92} }

// AnnotationsListOptions specifies options for Annotations.List.
type AnnotationsListOptions struct {
	// Entry specifies the file in a specific repository at a specific
	// version.
	Entry TreeEntrySpec `protobuf:"bytes,1,opt,name=Entry" json:"Entry"`
	// Range specifies the range within the file that annotations
	// should be fetched for. If it is not set, then all of the file's
	// annotations are returned.
	Range *FileRange `protobuf:"bytes,2,opt,name=Range" json:"Range,omitempty"`
	// NoSrclibAnns indicates whether or not srclib annotations should be
	// excluded in the returned list of annotations.
	NoSrclibAnns bool `protobuf:"varint,3,opt,name=NoSrclibAnns,proto3" json:"NoSrclibAnns,omitempty"`
}

func (m *AnnotationsListOptions) Reset()         { *m = AnnotationsListOptions{} }
func (m *AnnotationsListOptions) String() string { return proto.CompactTextString(m) }
func (*AnnotationsListOptions) ProtoMessage()    {}
func (*AnnotationsListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{93}
}

// AnnotationsGetDefAtPosOptions specifies options for Annotations.GetDefAtPos
type AnnotationsGetDefAtPosOptions struct {
	// Entry specifies the file in a specific repository at a specific
	// version.
	Entry TreeEntrySpec `protobuf:"bytes,1,opt,name=Entry" json:"Entry"`
	// Line specifies the line of the ref (zero based).
	Line uint32 `protobuf:"varint,2,opt,name=Line,proto3" json:"Line,omitempty"`
	// Character specifies the character of the ref in the line (zero based).
	Character uint32 `protobuf:"varint,3,opt,name=Character,proto3" json:"Character,omitempty"`
}

func (m *AnnotationsGetDefAtPosOptions) Reset()         { *m = AnnotationsGetDefAtPosOptions{} }
func (m *AnnotationsGetDefAtPosOptions) String() string { return proto.CompactTextString(m) }
func (*AnnotationsGetDefAtPosOptions) ProtoMessage()    {}
func (*AnnotationsGetDefAtPosOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{94}
}

// SearchOptions configures the scope of a global search.
type SearchOptions struct {
	// Repos is the list of repos to restrict the results to.
	// If empty, all repos are searched.
	Repos []int32 `protobuf:"varint,1,rep,name=Repos" json:"Repos,omitempty" url:",omitempty"`
	// NotRepos is the list of repos from which to exclude results.
	// If empty, then no repositories are excluded.
	NotRepos []int32 `protobuf:"varint,2,rep,name=NotRepos" json:"NotRepos,omitempty" url:",omitempty"`
	// Languages, if specified, limits the returned results to just the
	// specified languages.
	//
	// The values are case-insensitive, e.g. "java", "Java", and "jAvA" will
	// all match the Java programming language.
	Languages []string `protobuf:"bytes,6,rep,name=Languages" json:"Languages,omitempty"`
	// NotLanguages, if specified, excludes the specified languages from the
	// returned results.
	//
	// The values are case-insensitive, e.g. "java", "Java", and "jAvA" will
	// all exclude the Java programming language.
	NotLanguages []string `protobuf:"bytes,7,rep,name=NotLanguages" json:"NotLanguages,omitempty"`
	// Kinds, if specified, limits the returned results to just the specified
	// kinds of definitions (func, var, etc).
	Kinds []string `protobuf:"bytes,8,rep,name=Kinds" json:"Kinds,omitempty"`
	// NotKinds, if specified, excludes the specified kinds of definitions
	// (func, var, etc) from the returned results.
	NotKinds []string `protobuf:"bytes,9,rep,name=NotKinds" json:"NotKinds,omitempty"`
	// ListOptions specifies options for paginating
	// the result.
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
	// IncludeRepos indicates whether to include repository search results.
	IncludeRepos bool `protobuf:"varint,4,opt,name=IncludeRepos,proto3" json:"IncludeRepos,omitempty"`
	// Fast specifies that the client would like results returned more quickly at
	// the cost of missing lower ranked results. If there are no high-ranking results
	// and Fast is set to true, there may be no results returned at all.
	Fast bool `protobuf:"varint,10,opt,name=Fast,proto3" json:"Fast,omitempty"`
	// AllowEmpty may be used to signal that a query with undefined search parameters is still valid.
	// It was introduced with the sole purpose of running offline queries against all defs.
	// Do not use in the product, as it will likely cause a significant performance hit.
	AllowEmpty bool `protobuf:"varint,11,opt,name=AllowEmpty,proto3" json:"AllowEmpty,omitempty"`
}

func (m *SearchOptions) Reset()                    { *m = SearchOptions{} }
func (m *SearchOptions) String() string            { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()               {}
func (*SearchOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{95} }

// SearchOp holds the options for global search for a given query.
type SearchOp struct {
	// Query is the text string being searched for.
	Query string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	// Opt controls the scope of the search.
	Opt *SearchOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *SearchOp) Reset()                    { *m = SearchOp{} }
func (m *SearchOp) String() string            { return proto.CompactTextString(m) }
func (*SearchOp) ProtoMessage()               {}
func (*SearchOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{96} }

// RepoSearchResult holds a result of a global repo search.
type RepoSearchResult struct {
	// Repo represents a source code repository.
	Repo *Repo `protobuf:"bytes,1,opt,name=Repo" json:"Repo,omitempty"`
}

func (m *RepoSearchResult) Reset()                    { *m = RepoSearchResult{} }
func (m *RepoSearchResult) String() string            { return proto.CompactTextString(m) }
func (*RepoSearchResult) ProtoMessage()               {}
func (*RepoSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{97} }

// SearchReposOp holds the options for repos search for a given query.
type SearchReposOp struct {
	// Query is the repo search query.
	Query string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
}

func (m *SearchReposOp) Reset()                    { *m = SearchReposOp{} }
func (m *SearchReposOp) String() string            { return proto.CompactTextString(m) }
func (*SearchReposOp) ProtoMessage()               {}
func (*SearchReposOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{98} }

// SearchReposResultList holds a result of a repo search.
type SearchReposResultList struct {
	// Repos is the list of repo search results.
	Repos []*Repo `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *SearchReposResultList) Reset()         { *m = SearchReposResultList{} }
func (m *SearchReposResultList) String() string { return proto.CompactTextString(m) }
func (*SearchReposResultList) ProtoMessage()    {}
func (*SearchReposResultList) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{99}
}

// DefSearchResult holds a result of a global def search.
type DefSearchResult struct {
	// Def is the def matching the search query.
	Def `protobuf:"bytes,1,opt,name=Def,embedded=Def" json:""`
	// Score is the computed relevance of this result to the search query.
	Score float32 `protobuf:"fixed32,2,opt,name=Score,proto3" json:"Score,omitempty"`
	// RefCount is global ref count for this def.
	RefCount int32 `protobuf:"varint,3,opt,name=RefCount,proto3" json:"RefCount,omitempty"`
}

func (m *DefSearchResult) Reset()                    { *m = DefSearchResult{} }
func (m *DefSearchResult) String() string            { return proto.CompactTextString(m) }
func (*DefSearchResult) ProtoMessage()               {}
func (*DefSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{100} }

// SearchResultsList is a list of results to a global search.
type SearchResultsList struct {
	// RepoResults is the list of repo search results
	RepoResults []*RepoSearchResult `protobuf:"bytes,1,rep,name=RepoResults" json:"RepoResults,omitempty"`
	// DefResults is the list of def search results
	DefResults []*DefSearchResult `protobuf:"bytes,2,rep,name=DefResults" json:"DefResults,omitempty"`
	// SearchOptions is a list of options to a global search query.
	SearchQueryOptions []*SearchOptions `protobuf:"bytes,3,rep,name=SearchQueryOptions" json:"SearchQueryOptions,omitempty"`
}

func (m *SearchResultsList) Reset()                    { *m = SearchResultsList{} }
func (m *SearchResultsList) String() string            { return proto.CompactTextString(m) }
func (*SearchResultsList) ProtoMessage()               {}
func (*SearchResultsList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{101} }

func init() {
	proto.RegisterType((*Origin)(nil), "sourcegraph.Origin")
	proto.RegisterType((*CombinedStatus)(nil), "sourcegraph.CombinedStatus")
	proto.RegisterType((*ListOptions)(nil), "sourcegraph.ListOptions")
	proto.RegisterType((*ListResponse)(nil), "sourcegraph.ListResponse")
	proto.RegisterType((*StreamResponse)(nil), "sourcegraph.StreamResponse")
	proto.RegisterType((*RepoConfig)(nil), "sourcegraph.RepoConfig")
	proto.RegisterType((*Repo)(nil), "sourcegraph.Repo")
	proto.RegisterType((*RepoPermissions)(nil), "sourcegraph.RepoPermissions")
	proto.RegisterType((*RepoListOptions)(nil), "sourcegraph.RepoListOptions")
	proto.RegisterType((*RepoWebhookOptions)(nil), "sourcegraph.RepoWebhookOptions")
	proto.RegisterType((*RepoRevSpec)(nil), "sourcegraph.RepoRevSpec")
	proto.RegisterType((*RepoSpec)(nil), "sourcegraph.RepoSpec")
	proto.RegisterType((*RepoStatus)(nil), "sourcegraph.RepoStatus")
	proto.RegisterType((*RepoStatusList)(nil), "sourcegraph.RepoStatusList")
	proto.RegisterType((*RepoStatusesCreateOp)(nil), "sourcegraph.RepoStatusesCreateOp")
	proto.RegisterType((*RepoList)(nil), "sourcegraph.RepoList")
	proto.RegisterType((*ReposResolveRevOp)(nil), "sourcegraph.ReposResolveRevOp")
	proto.RegisterType((*ResolvedRev)(nil), "sourcegraph.ResolvedRev")
	proto.RegisterType((*ReceivePackOp)(nil), "sourcegraph.ReceivePackOp")
	proto.RegisterType((*UploadPackOp)(nil), "sourcegraph.UploadPackOp")
	proto.RegisterType((*URIList)(nil), "sourcegraph.URIList")
	proto.RegisterType((*Packet)(nil), "sourcegraph.Packet")
	proto.RegisterType((*RepoResolveOp)(nil), "sourcegraph.RepoResolveOp")
	proto.RegisterType((*RepoResolution)(nil), "sourcegraph.RepoResolution")
	proto.RegisterType((*SrclibDataVersion)(nil), "sourcegraph.SrclibDataVersion")
	proto.RegisterType((*ReposCreateOp)(nil), "sourcegraph.ReposCreateOp")
	proto.RegisterType((*ReposCreateOp_NewRepo)(nil), "sourcegraph.ReposCreateOp.NewRepo")
	proto.RegisterType((*ReposUpdateOp)(nil), "sourcegraph.ReposUpdateOp")
	proto.RegisterType((*ReposListCommitsOp)(nil), "sourcegraph.ReposListCommitsOp")
	proto.RegisterType((*RepoListCommitsOptions)(nil), "sourcegraph.RepoListCommitsOptions")
	proto.RegisterType((*CommitList)(nil), "sourcegraph.CommitList")
	proto.RegisterType((*ReposListBranchesOp)(nil), "sourcegraph.ReposListBranchesOp")
	proto.RegisterType((*RepoListBranchesOptions)(nil), "sourcegraph.RepoListBranchesOptions")
	proto.RegisterType((*BranchList)(nil), "sourcegraph.BranchList")
	proto.RegisterType((*ReposListTagsOp)(nil), "sourcegraph.ReposListTagsOp")
	proto.RegisterType((*ReposListCommittersOp)(nil), "sourcegraph.ReposListCommittersOp")
	proto.RegisterType((*RepoListCommittersOptions)(nil), "sourcegraph.RepoListCommittersOptions")
	proto.RegisterType((*CommitterList)(nil), "sourcegraph.CommitterList")
	proto.RegisterType((*RepoListTagsOptions)(nil), "sourcegraph.RepoListTagsOptions")
	proto.RegisterType((*TagList)(nil), "sourcegraph.TagList")
	proto.RegisterType((*MirrorReposRefreshVCSOp)(nil), "sourcegraph.MirrorReposRefreshVCSOp")
	proto.RegisterType((*RemoteRepo)(nil), "sourcegraph.RemoteRepo")
	proto.RegisterType((*EmailAddr)(nil), "sourcegraph.EmailAddr")
	proto.RegisterType((*UserList)(nil), "sourcegraph.UserList")
	proto.RegisterType((*User)(nil), "sourcegraph.User")
	proto.RegisterType((*UserSpec)(nil), "sourcegraph.UserSpec")
	proto.RegisterType((*EmailAddrList)(nil), "sourcegraph.EmailAddrList")
	proto.RegisterType((*UpdateEmailsOp)(nil), "sourcegraph.UpdateEmailsOp")
	proto.RegisterType((*BetaRegistration)(nil), "sourcegraph.BetaRegistration")
	proto.RegisterType((*BetaResponse)(nil), "sourcegraph.BetaResponse")
	proto.RegisterType((*AuthInfo)(nil), "sourcegraph.AuthInfo")
	proto.RegisterType((*ExternalToken)(nil), "sourcegraph.ExternalToken")
	proto.RegisterType((*Def)(nil), "sourcegraph.Def")
	proto.RegisterType((*DefGetOptions)(nil), "sourcegraph.DefGetOptions")
	proto.RegisterType((*DefListOptions)(nil), "sourcegraph.DefListOptions")
	proto.RegisterType((*DefListRefsOptions)(nil), "sourcegraph.DefListRefsOptions")
	proto.RegisterType((*DefSpec)(nil), "sourcegraph.DefSpec")
	proto.RegisterType((*DefsGetOp)(nil), "sourcegraph.DefsGetOp")
	proto.RegisterType((*DefList)(nil), "sourcegraph.DefList")
	proto.RegisterType((*DefsListRefsOp)(nil), "sourcegraph.DefsListRefsOp")
	proto.RegisterType((*RefList)(nil), "sourcegraph.RefList")
	proto.RegisterType((*DefListRefLocationsOptions)(nil), "sourcegraph.DefListRefLocationsOptions")
	proto.RegisterType((*DefsListRefLocationsOp)(nil), "sourcegraph.DefsListRefLocationsOp")
	proto.RegisterType((*DefsListExamplesOp)(nil), "sourcegraph.DefsListExamplesOp")
	proto.RegisterType((*RefLocationsList)(nil), "sourcegraph.RefLocationsList")
	proto.RegisterType((*DefRepoRef)(nil), "sourcegraph.DefRepoRef")
	proto.RegisterType((*DefFileRef)(nil), "sourcegraph.DefFileRef")
	proto.RegisterType((*RepoTreeGetOptions)(nil), "sourcegraph.RepoTreeGetOptions")
	proto.RegisterType((*GetFileOptions)(nil), "sourcegraph.GetFileOptions")
	proto.RegisterType((*RepoTreeSearchOptions)(nil), "sourcegraph.RepoTreeSearchOptions")
	proto.RegisterType((*RepoTreeSearchResult)(nil), "sourcegraph.RepoTreeSearchResult")
	proto.RegisterType((*RepoTreeGetOp)(nil), "sourcegraph.RepoTreeGetOp")
	proto.RegisterType((*RepoTreeSearchOp)(nil), "sourcegraph.RepoTreeSearchOp")
	proto.RegisterType((*RepoTreeListOp)(nil), "sourcegraph.RepoTreeListOp")
	proto.RegisterType((*RepoTreeListResult)(nil), "sourcegraph.RepoTreeListResult")
	proto.RegisterType((*VCSSearchResultList)(nil), "sourcegraph.VCSSearchResultList")
	proto.RegisterType((*TreeEntry)(nil), "sourcegraph.TreeEntry")
	proto.RegisterType((*BasicTreeEntry)(nil), "sourcegraph.BasicTreeEntry")
	proto.RegisterType((*TreeEntrySpec)(nil), "sourcegraph.TreeEntrySpec")
	proto.RegisterType((*FileRange)(nil), "sourcegraph.FileRange")
	proto.RegisterType((*DefsRefreshIndexOp)(nil), "sourcegraph.DefsRefreshIndexOp")
	proto.RegisterType((*AsyncRefreshIndexesOp)(nil), "sourcegraph.AsyncRefreshIndexesOp")
	proto.RegisterType((*AuthorshipInfo)(nil), "sourcegraph.AuthorshipInfo")
	proto.RegisterType((*DefAuthor)(nil), "sourcegraph.DefAuthor")
	proto.RegisterType((*DefAuthorship)(nil), "sourcegraph.DefAuthorship")
	proto.RegisterType((*DefListAuthorsOptions)(nil), "sourcegraph.DefListAuthorsOptions")
	proto.RegisterType((*DefsListAuthorsOp)(nil), "sourcegraph.DefsListAuthorsOp")
	proto.RegisterType((*DefAuthorList)(nil), "sourcegraph.DefAuthorList")
	proto.RegisterType((*ServerConfig)(nil), "sourcegraph.ServerConfig")
	proto.RegisterType((*UserEvent)(nil), "sourcegraph.UserEvent")
	proto.RegisterType((*Event)(nil), "sourcegraph.Event")
	proto.RegisterType((*EventList)(nil), "sourcegraph.EventList")
	proto.RegisterType((*Annotation)(nil), "sourcegraph.Annotation")
	proto.RegisterType((*AnnotationList)(nil), "sourcegraph.AnnotationList")
	proto.RegisterType((*AnnotationsListOptions)(nil), "sourcegraph.AnnotationsListOptions")
	proto.RegisterType((*AnnotationsGetDefAtPosOptions)(nil), "sourcegraph.AnnotationsGetDefAtPosOptions")
	proto.RegisterType((*SearchOptions)(nil), "sourcegraph.SearchOptions")
	proto.RegisterType((*SearchOp)(nil), "sourcegraph.SearchOp")
	proto.RegisterType((*RepoSearchResult)(nil), "sourcegraph.RepoSearchResult")
	proto.RegisterType((*SearchReposOp)(nil), "sourcegraph.SearchReposOp")
	proto.RegisterType((*SearchReposResultList)(nil), "sourcegraph.SearchReposResultList")
	proto.RegisterType((*DefSearchResult)(nil), "sourcegraph.DefSearchResult")
	proto.RegisterType((*SearchResultsList)(nil), "sourcegraph.SearchResultsList")
	proto.RegisterEnum("sourcegraph.TreeEntryType", TreeEntryType_name, TreeEntryType_value)
	proto.RegisterEnum("sourcegraph.Origin_ServiceType", Origin_ServiceType_name, Origin_ServiceType_value)
	proto.RegisterEnum("sourcegraph.ReposUpdateOp_BoolType", ReposUpdateOp_BoolType_name, ReposUpdateOp_BoolType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
	// GetCoverage fetches the coverage data for all repositories.
	GetCoverage(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RepoStatusList, error)
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) GetCoverage(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RepoStatusList, error) {
	out := new(RepoStatusList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCoverage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
	// GetCoverage fetches the coverage data for all repositories.
	GetCoverage(context.Context, *pbtypes1.Void) (*RepoStatusList, error)
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_GetCoverage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCoverage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
		{
			MethodName: "GetCoverage",
			Handler:    _RepoStatuses_GetCoverage_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// Resolve looks up a repo from its "path", which is a
	// slash-separated string (e.g., "github.com/user/repo"). Resolve
	// may have to consult external sources (such as GitHub) to
	// resolve a path. It returns the repo's ID if it has been created
	// on Sourcegraph, plus additional metadata about the repository
	// that was determined during the resolution operation.
	//
	// Example use case: The app calls Resolve to support navigating
	// directly to "https://sourcegraph.com/github.com/my/repo" when
	// that has not been created yet. It calls Resolve with
	// "github.com/my/repo". The app will transparently call
	// Repos.Create if it gets a remote Repo back from Resolve.
	Resolve(ctx context.Context, in *RepoResolveOp, opts ...grpc.CallOption) (*RepoResolution, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// Create creates a new repository.
	Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error)
	// Update updates a repository.
	Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error)
	// Delete removes a repository.
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	// ResolveRev resolves a VCS revision specifier (e.g., a branch or
	// "master~7") to its underlying commit ID.
	ResolveRev(ctx context.Context, in *ReposResolveRevOp, opts ...grpc.CallOption) (*ResolvedRev, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
	// EnableWebhook adds webhook to the repository to trigger build on pushes.
	EnableWebhook(ctx context.Context, in *RepoWebhookOptions, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	ListDeps(ctx context.Context, in *URIList, opts ...grpc.CallOption) (*URIList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error)
	ReceivePack(ctx context.Context, in *ReceivePackOp, opts ...grpc.CallOption) (*Packet, error)
	UploadPack(ctx context.Context, in *UploadPackOp, opts ...grpc.CallOption) (*Packet, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Resolve(ctx context.Context, in *RepoResolveOp, opts ...grpc.CallOption) (*RepoResolution, error) {
	out := new(RepoResolution)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Resolve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error) {
	out := new(RepoConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ResolveRev(ctx context.Context, in *ReposResolveRevOp, opts ...grpc.CallOption) (*ResolvedRev, error) {
	out := new(ResolvedRev)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ResolveRev", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) EnableWebhook(ctx context.Context, in *RepoWebhookOptions, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/EnableWebhook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListDeps(ctx context.Context, in *URIList, opts ...grpc.CallOption) (*URIList, error) {
	out := new(URIList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListDeps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error) {
	out := new(CommitterList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommitters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error) {
	out := new(SrclibDataVersion)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetSrclibDataVersionForPath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error) {
	out := new(inventory.Inventory)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetInventory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ReceivePack(ctx context.Context, in *ReceivePackOp, opts ...grpc.CallOption) (*Packet, error) {
	out := new(Packet)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ReceivePack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) UploadPack(ctx context.Context, in *UploadPackOp, opts ...grpc.CallOption) (*Packet, error) {
	out := new(Packet)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/UploadPack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// Resolve looks up a repo from its "path", which is a
	// slash-separated string (e.g., "github.com/user/repo"). Resolve
	// may have to consult external sources (such as GitHub) to
	// resolve a path. It returns the repo's ID if it has been created
	// on Sourcegraph, plus additional metadata about the repository
	// that was determined during the resolution operation.
	//
	// Example use case: The app calls Resolve to support navigating
	// directly to "https://sourcegraph.com/github.com/my/repo" when
	// that has not been created yet. It calls Resolve with
	// "github.com/my/repo". The app will transparently call
	// Repos.Create if it gets a remote Repo back from Resolve.
	Resolve(context.Context, *RepoResolveOp) (*RepoResolution, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// Create creates a new repository.
	Create(context.Context, *ReposCreateOp) (*Repo, error)
	// Update updates a repository.
	Update(context.Context, *ReposUpdateOp) (*Repo, error)
	// Delete removes a repository.
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(context.Context, *RepoSpec) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	// ResolveRev resolves a VCS revision specifier (e.g., a branch or
	// "master~7") to its underlying commit ID.
	ResolveRev(context.Context, *ReposResolveRevOp) (*ResolvedRev, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
	// EnableWebhook adds webhook to the repository to trigger build on pushes.
	EnableWebhook(context.Context, *RepoWebhookOptions) (*pbtypes1.Void, error)
	ListDeps(context.Context, *URIList) (*URIList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(context.Context, *ReposListCommittersOp) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(context.Context, *TreeEntrySpec) (*SrclibDataVersion, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(context.Context, *RepoRevSpec) (*inventory.Inventory, error)
	ReceivePack(context.Context, *ReceivePackOp) (*Packet, error)
	UploadPack(context.Context, *UploadPackOp) (*Packet, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoResolveOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Resolve(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetConfig(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ResolveRev_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposResolveRevOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ResolveRev(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_EnableWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoWebhookOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).EnableWebhook(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListDeps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(URIList)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListDeps(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommitters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommittersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommitters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetSrclibDataVersionForPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TreeEntrySpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetSrclibDataVersionForPath(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetInventory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ReceivePack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReceivePackOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ReceivePack(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_UploadPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UploadPackOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).UploadPack(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "Resolve",
			Handler:    _Repos_Resolve_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Repos_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Repos_GetConfig_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ResolveRev",
			Handler:    _Repos_ResolveRev_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
		{
			MethodName: "EnableWebhook",
			Handler:    _Repos_EnableWebhook_Handler,
		},
		{
			MethodName: "ListDeps",
			Handler:    _Repos_ListDeps_Handler,
		},
		{
			MethodName: "ListCommitters",
			Handler:    _Repos_ListCommitters_Handler,
		},
		{
			MethodName: "GetSrclibDataVersionForPath",
			Handler:    _Repos_GetSrclibDataVersionForPath_Handler,
		},
		{
			MethodName: "GetInventory",
			Handler:    _Repos_GetInventory_Handler,
		},
		{
			MethodName: "ReceivePack",
			Handler:    _Repos_ReceivePack_Handler,
		},
		{
			MethodName: "UploadPack",
			Handler:    _Repos_UploadPack_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *MirrorReposRefreshVCSOp) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirrorReposRefreshVCSOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Defs service

type DefsClient interface {
	// Get fetches a def.
	Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error)
	// List defs.
	List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error)
	// ListRefLocations lists repos and files that refer to def.
	ListRefLocations(ctx context.Context, in *DefsListRefLocationsOp, opts ...grpc.CallOption) (*RefLocationsList, error)
	// ListExamples lists usage examples for a given def.
	ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*RefLocationsList, error)
	// ListAuthors lists people who committed parts of def's definition.
	ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error)
	// RefreshIndex updates the precomputed indexes used for answering
	// ListRefLocations queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(ctx context.Context, in *DefsRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type defsClient struct {
	cc *grpc.ClientConn
}

func NewDefsClient(cc *grpc.ClientConn) DefsClient {
	return &defsClient{cc}
}

func (c *defsClient) Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error) {
	out := new(Def)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error) {
	out := new(RefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefLocations(ctx context.Context, in *DefsListRefLocationsOp, opts ...grpc.CallOption) (*RefLocationsList, error) {
	out := new(RefLocationsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefLocations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*RefLocationsList, error) {
	out := new(RefLocationsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListExamples", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error) {
	out := new(DefAuthorList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) RefreshIndex(ctx context.Context, in *DefsRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/RefreshIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Defs service

type DefsServer interface {
	// Get fetches a def.
	Get(context.Context, *DefsGetOp) (*Def, error)
	// List defs.
	List(context.Context, *DefListOptions) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(context.Context, *DefsListRefsOp) (*RefList, error)
	// ListRefLocations lists repos and files that refer to def.
	ListRefLocations(context.Context, *DefsListRefLocationsOp) (*RefLocationsList, error)
	// ListExamples lists usage examples for a given def.
	ListExamples(context.Context, *DefsListExamplesOp) (*RefLocationsList, error)
	// ListAuthors lists people who committed parts of def's definition.
	ListAuthors(context.Context, *DefsListAuthorsOp) (*DefAuthorList, error)
	// RefreshIndex updates the precomputed indexes used for answering
	// ListRefLocations queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(context.Context, *DefsRefreshIndexOp) (*pbtypes1.Void, error)
}

func RegisterDefsServer(s *grpc.Server, srv DefsServer) {
	s.RegisterService(&_Defs_serviceDesc, srv)
}

func _Defs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefLocationsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefLocations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListExamplesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListExamples(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_RefreshIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsRefreshIndexOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).RefreshIndex(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Defs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Defs",
	HandlerType: (*DefsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Defs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Defs_List_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Defs_ListRefs_Handler,
		},
		{
			MethodName: "ListRefLocations",
			Handler:    _Defs_ListRefLocations_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Defs_ListExamples_Handler,
		},
		{
			MethodName: "ListAuthors",
			Handler:    _Defs_ListAuthors_Handler,
		},
		{
			MethodName: "RefreshIndex",
			Handler:    _Defs_RefreshIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Async service

type AsyncClient interface {
	// RefreshIndexes refreshes indexes we keep on a repo (GlobalRefs,
	// Defs, etc)
	RefreshIndexes(ctx context.Context, in *AsyncRefreshIndexesOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type asyncClient struct {
	cc *grpc.ClientConn
}

func NewAsyncClient(cc *grpc.ClientConn) AsyncClient {
	return &asyncClient{cc}
}

func (c *asyncClient) RefreshIndexes(ctx context.Context, in *AsyncRefreshIndexesOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Async/RefreshIndexes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Async service

type AsyncServer interface {
	// RefreshIndexes refreshes indexes we keep on a repo (GlobalRefs,
	// Defs, etc)
	RefreshIndexes(context.Context, *AsyncRefreshIndexesOp) (*pbtypes1.Void, error)
}

func RegisterAsyncServer(s *grpc.Server, srv AsyncServer) {
	s.RegisterService(&_Async_serviceDesc, srv)
}

func _Async_RefreshIndexes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AsyncRefreshIndexesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AsyncServer).RefreshIndexes(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Async_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Async",
	HandlerType: (*AsyncServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshIndexes",
			Handler:    _Async_RefreshIndexes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoTree service

type RepoTreeClient interface {
	Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error)
	Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error)
}

type repoTreeClient struct {
	cc *grpc.ClientConn
}

func NewRepoTreeClient(cc *grpc.ClientConn) RepoTreeClient {
	return &repoTreeClient{cc}
}

func (c *repoTreeClient) Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error) {
	out := new(TreeEntry)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error) {
	out := new(RepoTreeListResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoTree service

type RepoTreeServer interface {
	Get(context.Context, *RepoTreeGetOp) (*TreeEntry, error)
	Search(context.Context, *RepoTreeSearchOp) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(context.Context, *RepoTreeListOp) (*RepoTreeListResult, error)
}

func RegisterRepoTreeServer(s *grpc.Server, srv RepoTreeServer) {
	s.RegisterService(&_RepoTree_serviceDesc, srv)
}

func _RepoTree_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeSearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoTree_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoTree",
	HandlerType: (*RepoTreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RepoTree_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _RepoTree_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RepoTree_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Meta service

type MetaClient interface {
	// Config returns the server's configuration.
	Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error) {
	out := new(ServerConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Config", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	// Config returns the server's configuration.
	Config(context.Context, *pbtypes1.Void) (*ServerConfig, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Config(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Config",
			Handler:    _Meta_Config_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Annotations service

type AnnotationsClient interface {
	// List lists matching annotations.
	List(ctx context.Context, in *AnnotationsListOptions, opts ...grpc.CallOption) (*AnnotationList, error)
	GetDefAtPos(ctx context.Context, in *AnnotationsGetDefAtPosOptions, opts ...grpc.CallOption) (*DefSpec, error)
}

type annotationsClient struct {
	cc *grpc.ClientConn
}

func NewAnnotationsClient(cc *grpc.ClientConn) AnnotationsClient {
	return &annotationsClient{cc}
}

func (c *annotationsClient) List(ctx context.Context, in *AnnotationsListOptions, opts ...grpc.CallOption) (*AnnotationList, error) {
	out := new(AnnotationList)
	err := grpc.Invoke(ctx, "/sourcegraph.Annotations/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationsClient) GetDefAtPos(ctx context.Context, in *AnnotationsGetDefAtPosOptions, opts ...grpc.CallOption) (*DefSpec, error) {
	out := new(DefSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Annotations/GetDefAtPos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Annotations service

type AnnotationsServer interface {
	// List lists matching annotations.
	List(context.Context, *AnnotationsListOptions) (*AnnotationList, error)
	GetDefAtPos(context.Context, *AnnotationsGetDefAtPosOptions) (*DefSpec, error)
}

func RegisterAnnotationsServer(s *grpc.Server, srv AnnotationsServer) {
	s.RegisterService(&_Annotations_serviceDesc, srv)
}

func _Annotations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AnnotationsListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AnnotationsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Annotations_GetDefAtPos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AnnotationsGetDefAtPosOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AnnotationsServer).GetDefAtPos(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Annotations_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Annotations",
	HandlerType: (*AnnotationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Annotations_List_Handler,
		},
		{
			MethodName: "GetDefAtPos",
			Handler:    _Annotations_GetDefAtPos_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Search service

type SearchClient interface {
	// Search returns a list of defs matching the given query string.
	Search(ctx context.Context, in *SearchOp, opts ...grpc.CallOption) (*SearchResultsList, error)
	// SearchRepos returns a list of repos matching the given query string.
	//
	// DEPRECATED
	SearchRepos(ctx context.Context, in *SearchReposOp, opts ...grpc.CallOption) (*SearchReposResultList, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) Search(ctx context.Context, in *SearchOp, opts ...grpc.CallOption) (*SearchResultsList, error) {
	out := new(SearchResultsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) SearchRepos(ctx context.Context, in *SearchReposOp, opts ...grpc.CallOption) (*SearchReposResultList, error) {
	out := new(SearchReposResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/SearchRepos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	// Search returns a list of defs matching the given query string.
	Search(context.Context, *SearchOp) (*SearchResultsList, error)
	// SearchRepos returns a list of repos matching the given query string.
	//
	// DEPRECATED
	SearchRepos(context.Context, *SearchReposOp) (*SearchReposResultList, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_SearchRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SearchReposOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).SearchRepos(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Search_Search_Handler,
		},
		{
			MethodName: "SearchRepos",
			Handler:    _Search_SearchRepos_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *Origin) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Origin) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.Service != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Service))
	}
	if len(m.APIBaseURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.APIBaseURL)))
		i += copy(data[i:], m.APIBaseURL)
	}
	return i, nil
}

func (m *CombinedStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CombinedStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.Statuses) > 0 {
		for _, msg := range m.Statuses {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rev) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *ListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerPage != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PerPage))
	}
	if m.Page != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Total))
	}
	return i, nil
}

func (m *StreamResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		data[i] = 0x8
		i++
		if m.HasMore {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Repo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Repo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.SSHCloneURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SSHCloneURL)))
		i += copy(data[i:], m.SSHCloneURL)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Language) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.Blocked {
		data[i] = 0x50
		i++
		if m.Blocked {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Deprecated {
		data[i] = 0x58
		i++
		if m.Deprecated {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fork {
		data[i] = 0x60
		i++
		if m.Fork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Mirror {
		data[i] = 0x68
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Private {
		data[i] = 0x70
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UpdatedAt != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
		n2, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PushedAt != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PushedAt.Size()))
		n3, err := m.PushedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ID != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if m.Origin != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Origin.Size()))
		n4, err := m.Origin.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.VCSSyncedAt != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.VCSSyncedAt.Size()))
		n5, err := m.VCSSyncedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Permissions != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Permissions.Size()))
		n6, err := m.Permissions.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *RepoPermissions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoPermissions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pull {
		data[i] = 0x8
		i++
		if m.Pull {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Push {
		data[i] = 0x10
		i++
		if m.Push {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x18
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Sort) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	if m.NoFork {
		data[i] = 0x38
		i++
		if m.NoFork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if m.RemoteOnly {
		data[i] = 0x60
		i++
		if m.RemoteOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x6a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n7, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *RepoWebhookOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoWebhookOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	return i, nil
}

func (m *RepoRevSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoRevSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *RepoSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *RepoStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.TargetURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TargetURL)))
		i += copy(data[i:], m.TargetURL)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Context) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	data[i] = 0x32
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n8, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	data[i] = 0x3a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
	n9, err := m.UpdatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *RepoStatusList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatusList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoStatuses) > 0 {
		for _, msg := range m.RepoStatuses {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RepoStatusesCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatusesCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n10, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Status.Size()))
	n11, err := m.Status.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *RepoList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, msg := range m.Repos {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReposResolveRevOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposResolveRevOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Rev) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *ResolvedRev) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResolvedRev) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *ReceivePackOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReceivePackOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Data) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	if m.AdvertiseRefs {
		data[i] = 0x20
		i++
		if m.AdvertiseRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UploadPackOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UploadPackOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Data) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	if m.AdvertiseRefs {
		data[i] = 0x20
		i++
		if m.AdvertiseRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *URIList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *URIList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Packet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Packet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *RepoResolveOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoResolveOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Remote {
		data[i] = 0x10
		i++
		if m.Remote {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoResolution) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoResolution) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.RemoteRepo != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RemoteRepo.Size()))
		n12, err := m.RemoteRepo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.CanonicalPath) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CanonicalPath)))
		i += copy(data[i:], m.CanonicalPath)
	}
	return i, nil
}

func (m *SrclibDataVersion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SrclibDataVersion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if m.CommitsBehind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CommitsBehind))
	}
	return i, nil
}

func (m *ReposCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		nn13, err := m.Op.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	return i, nil
}

func (m *ReposCreateOp_New) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.New != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.New.Size()))
		n14, err := m.New.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *ReposCreateOp_FromGitHubID) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x10
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FromGitHubID))
	return i, nil
}
func (m *ReposCreateOp_Origin) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Origin != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Origin.Size()))
		n15, err := m.Origin.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *ReposCreateOp_NewRepo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposCreateOp_NewRepo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.CloneURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CloneURL)))
		i += copy(data[i:], m.CloneURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if m.Mirror {
		data[i] = 0x28
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Description) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	return i, nil
}

func (m *ReposUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.URI) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.SSHCloneURL) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SSHCloneURL)))
		i += copy(data[i:], m.SSHCloneURL)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Language) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.Blocked != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Blocked))
	}
	if m.Deprecated != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Deprecated))
	}
	if m.Fork != 0 {
		data[i] = 0x70
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Fork))
	}
	if m.Mirror != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Mirror))
	}
	if m.Private != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Private))
	}
	if m.Origin != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Origin.Size()))
		n16, err := m.Origin.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ReposListCommitsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommitsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n17, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *RepoListCommitsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommitsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Head)))
		i += copy(data[i:], m.Head)
	}
	if len(m.Base) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Base)))
		i += copy(data[i:], m.Base)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n18, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Path) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *CommitList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n19, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	return i, nil
}

func (m *ReposListBranchesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListBranchesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n20, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *RepoListBranchesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListBranchesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n21, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if m.IncludeCommit {
		data[i] = 0x20
		i++
		if m.IncludeCommit {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.BehindAheadBranch) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BehindAheadBranch)))
		i += copy(data[i:], m.BehindAheadBranch)
	}
	if len(m.ContainsCommit) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContainsCommit)))
		i += copy(data[i:], m.ContainsCommit)
	}
	return i, nil
}

func (m *BranchList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BranchList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, msg := range m.Branches {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n22, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	return i, nil
}

func (m *ReposListTagsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListTagsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n23, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *ReposListCommittersOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommittersOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n24, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *RepoListCommittersOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommittersOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rev) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n25, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	return i, nil
}

func (m *CommitterList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitterList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, msg := range m.Committers {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n26, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	return i, nil
}

func (m *RepoListTagsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListTagsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n27, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	return i, nil
}

func (m *TagList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TagList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n28, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	return i, nil
}

func (m *MirrorReposRefreshVCSOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MirrorReposRefreshVCSOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.AsUser != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.AsUser.Size()))
		n29, err := m.AsUser.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *RemoteRepo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RemoteRepo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GitHubID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.GitHubID))
	}
	if len(m.Owner) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.VCS) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.VCS)))
		i += copy(data[i:], m.VCS)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Description) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.UpdatedAt != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
		n30, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Private {
		data[i] = 0x50
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fork {
		data[i] = 0x58
		i++
		if m.Fork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Mirror {
		data[i] = 0x60
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Stars != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Stars))
	}
	if m.PushedAt != nil {
		data[i] = 0x72
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PushedAt.Size()))
		n31, err := m.PushedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.OwnerIsOrg {
		data[i] = 0x78
		i++
		if m.OwnerIsOrg {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Permissions != nil {
		data[i] = 0xc2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Permissions.Size()))
		n32, err := m.Permissions.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *EmailAddr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Verified {
		data[i] = 0x10
		i++
		if m.Verified {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Primary {
		data[i] = 0x18
		i++
		if m.Primary {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Guessed {
		data[i] = 0x20
		i++
		if m.Guessed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Blacklisted {
		data[i] = 0x28
		i++
		if m.Blacklisted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Name) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.IsOrganization {
		data[i] = 0x28
		i++
		if m.IsOrganization {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	if len(m.Location) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Location)))
		i += copy(data[i:], m.Location)
	}
	if len(m.Company) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Company)))
		i += copy(data[i:], m.Company)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if m.Disabled {
		data[i] = 0x50
		i++
		if m.Disabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RegisteredAt != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RegisteredAt.Size()))
		n33, err := m.RegisteredAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Admin {
		data[i] = 0x60
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Write {
		data[i] = 0x68
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Betas) > 0 {
		for _, s := range m.Betas {
			data[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *UserSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *EmailAddrList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddrList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, msg := range m.EmailAddrs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateEmailsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateEmailsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.UserSpec.Size()))
	n34, err := m.UserSpec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	if m.Add != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Add.Size()))
		n35, err := m.Add.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *BetaRegistration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BetaRegistration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FirstName)))
		i += copy(data[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LastName)))
		i += copy(data[i:], m.LastName)
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Editors) > 0 {
		for _, s := range m.Editors {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Message) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *BetaResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BetaResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmailAddress) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.EmailAddress)))
		i += copy(data[i:], m.EmailAddress)
	}
	return i, nil
}

func (m *AuthInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.Write {
		data[i] = 0x28
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x30
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ExternalToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExternalToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Token) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	if len(m.Scope) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Scope)))
		i += copy(data[i:], m.Scope)
	}
	return i, nil
}

func (m *Def) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Def) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n36, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	if m.DocHTML != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.DocHTML.Size()))
		n37, err := m.DocHTML.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.FmtStrings != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FmtStrings.Size()))
		n38, err := m.FmtStrings.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.StartLine != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndLine))
	}
	return i, nil
}

func (m *DefGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Doc {
		data[i] = 0x8
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ComputeLineRange {
		data[i] = 0x10
		i++
		if m.ComputeLineRange {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DefListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.ByteStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, msg := range m.DefKeys {
			data[i] = 0x2a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.FilePathPrefix) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FilePathPrefix)))
		i += copy(data[i:], m.FilePathPrefix)
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Exported {
		data[i] = 0x68
		i++
		if m.Exported {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Nonlocal {
		data[i] = 0x70
		i++
		if m.Nonlocal {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IncludeTest {
		data[i] = 0x78
		i++
		if m.IncludeTest {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Doc {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fuzzy {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		if m.Fuzzy {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Sort) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0xa2
	i++
	data[i] = 0x1
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n39, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n39
	return i, nil
}

func (m *DefListRefsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListRefsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n40, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	if len(m.CommitID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *DefSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *DefsGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n41, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n41
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n42, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *DefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n43, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n43
	return i, nil
}

func (m *DefsListRefsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListRefsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n44, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n44
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n45, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *RefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, msg := range m.Refs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n46, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n46
	return i, nil
}

func (m *DefListRefLocationsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListRefLocationsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, s := range m.Repos {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n47, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n47
	return i, nil
}

func (m *DefsListRefLocationsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListRefLocationsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n48, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n48
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n49, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}

func (m *DefsListExamplesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListExamplesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n50, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n50
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n51, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n51
	return i, nil
}

func (m *RefLocationsList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RefLocationsList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoRefs) > 0 {
		for _, msg := range m.RepoRefs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n52, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n52
	if m.TotalRepos != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.TotalRepos))
	}
	return i, nil
}

func (m *DefRepoRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefRepoRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	if m.Score != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			data[i] = 0x22
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefFileRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefFileRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	if m.Score != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	return i, nil
}

func (m *RepoTreeGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContentsAsString {
		data[i] = 0x20
		i++
		if m.ContentsAsString {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.GetFileOptions.Size()))
	n53, err := m.GetFileOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n53
	if m.NoSrclibAnns {
		data[i] = 0x30
		i++
		if m.NoSrclibAnns {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetFileOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetFileOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FileRange.Size()))
	n54, err := m.FileRange.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n54
	if m.EntireFile {
		data[i] = 0x10
		i++
		if m.EntireFile {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ExpandContextLines != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ExpandContextLines))
	}
	if m.FullLines {
		data[i] = 0x20
		i++
		if m.FullLines {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Recursive {
		data[i] = 0x28
		i++
		if m.Recursive {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RecurseSingleSubfolderLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RecurseSingleSubfolderLimit))
	}
	return i, nil
}

func (m *RepoTreeSearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchOptions.Size()))
	n55, err := m.SearchOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n55
	return i, nil
}

func (m *RepoTreeSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchResult.Size()))
	n56, err := m.SearchResult.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n56
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n57, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n57
	return i, nil
}

func (m *RepoTreeGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n58, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n58
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n59, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *RepoTreeSearchOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n60, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n60
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n61, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *RepoTreeListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n62, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n62
	return i, nil
}

func (m *RepoTreeListResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VCSSearchResultList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VCSSearchResultList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, msg := range m.SearchResults {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n63, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n63
	return i, nil
}

func (m *TreeEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BasicTreeEntry != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BasicTreeEntry.Size()))
		n64, err := m.BasicTreeEntry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.FileRange != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FileRange.Size()))
		n65, err := m.FileRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if len(m.ContentsString) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContentsString)))
		i += copy(data[i:], m.ContentsString)
	}
	return i, nil
}

func (m *BasicTreeEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BasicTreeEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Type != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Type))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Contents) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Contents)))
		i += copy(data[i:], m.Contents)
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x32
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TreeEntrySpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntrySpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n66, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n66
	if len(m.Path) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *FileRange) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileRange) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartLine != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndLine))
	}
	if m.StartByte != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	return i, nil
}

func (m *DefsRefreshIndexOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsRefreshIndexOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.RefreshRefLocations {
		data[i] = 0x10
		i++
		if m.RefreshRefLocations {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Force {
		data[i] = 0x18
		i++
		if m.Force {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AsyncRefreshIndexesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AsyncRefreshIndexesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Source) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Source)))
		i += copy(data[i:], m.Source)
	}
	if m.Force {
		data[i] = 0x18
		i++
		if m.Force {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AuthorshipInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorshipInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.LastCommitDate.Size()))
	n67, err := m.LastCommitDate.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n67
	if len(m.LastCommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LastCommitID)))
		i += copy(data[i:], m.LastCommitID)
	}
	return i, nil
}

func (m *DefAuthor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DefAuthorship.Size()))
	n68, err := m.DefAuthorship.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n68
	return i, nil
}

func (m *DefAuthorship) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorship) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.AuthorshipInfo.Size()))
	n69, err := m.AuthorshipInfo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n69
	if m.Bytes != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Sourcegraph(data, i, uint64(math.Float64bits(float64(m.BytesProportion))))
	}
	return i, nil
}

func (m *DefListAuthorsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListAuthorsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n70, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n70
	return i, nil
}

func (m *DefsListAuthorsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListAuthorsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n71, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n71
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n72, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}

func (m *DefAuthorList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, msg := range m.DefAuthors {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServerConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServerConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	return i, nil
}

func (m *UserEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Service) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Service)))
		i += copy(data[i:], m.Service)
	}
	if len(m.Method) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Method)))
		i += copy(data[i:], m.Method)
	}
	if len(m.Result) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Result)))
		i += copy(data[i:], m.Result)
	}
	if m.CreatedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n73, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.Message) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if len(m.Version) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.URL) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	return i, nil
}

func (m *Event) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Event) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.UserID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UserID)))
		i += copy(data[i:], m.UserID)
	}
	if len(m.DeviceID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DeviceID)))
		i += copy(data[i:], m.DeviceID)
	}
	if m.Timestamp != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Timestamp.Size()))
		n74, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if len(m.UserProperties) > 0 {
		for k, _ := range m.UserProperties {
			data[i] = 0x32
			i++
			v := m.UserProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.EventProperties) > 0 {
		for k, _ := range m.EventProperties {
			data[i] = 0x3a
			i++
			v := m.EventProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *EventList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	return i, nil
}

func (m *Annotation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Annotation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if m.StartByte != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	if len(m.Class) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Class)))
		i += copy(data[i:], m.Class)
	}
	if m.WantInner != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.WantInner))
	}
	if len(m.URLs) > 0 {
		for _, s := range m.URLs {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Def {
		data[i] = 0x38
		i++
		if m.Def {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AnnotationList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnnotationList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, msg := range m.Annotations {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LineStartBytes) > 0 {
		for _, num := range m.LineStartBytes {
			data[i] = 0x10
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *AnnotationsListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnnotationsListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n75, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n75
	if m.Range != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Range.Size()))
		n76, err := m.Range.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.NoSrclibAnns {
		data[i] = 0x18
		i++
		if m.NoSrclibAnns {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AnnotationsGetDefAtPosOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnnotationsGetDefAtPosOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n77, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n77
	if m.Line != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Line))
	}
	if m.Character != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Character))
	}
	return i, nil
}

func (m *SearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, num := range m.Repos {
			data[i] = 0x8
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	if len(m.NotRepos) > 0 {
		for _, num := range m.NotRepos {
			data[i] = 0x10
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n78, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n78
	if m.IncludeRepos {
		data[i] = 0x20
		i++
		if m.IncludeRepos {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.NotLanguages) > 0 {
		for _, s := range m.NotLanguages {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.NotKinds) > 0 {
		for _, s := range m.NotKinds {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Fast {
		data[i] = 0x50
		i++
		if m.Fast {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.AllowEmpty {
		data[i] = 0x58
		i++
		if m.AllowEmpty {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SearchOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n79, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}

func (m *RepoSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
		n80, err := m.Repo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *SearchReposOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchReposOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	return i, nil
}

func (m *SearchReposResultList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchReposResultList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, msg := range m.Repos {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n81, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n81
	if m.Score != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if m.RefCount != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RefCount))
	}
	return i, nil
}

func (m *SearchResultsList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResultsList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoResults) > 0 {
		for _, msg := range m.RepoResults {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DefResults) > 0 {
		for _, msg := range m.DefResults {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SearchQueryOptions) > 0 {
		for _, msg := range m.SearchQueryOptions {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Sourcegraph(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sourcegraph(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSourcegraph(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Origin) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Service != 0 {
		n += 1 + sovSourcegraph(uint64(m.Service))
	}
	l = len(m.APIBaseURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *CombinedStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	var l int
	_ = l
	if m.PerPage != 0 {
		n += 1 + sovSourcegraph(uint64(m.PerPage))
	}
	if m.Page != 0 {
		n += 1 + sovSourcegraph(uint64(m.Page))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovSourcegraph(uint64(m.Total))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *RepoConfig) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Repo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SSHCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Blocked {
		n += 2
	}
	if m.Deprecated {
		n += 2
	}
	if m.Fork {
		n += 2
	}
	if m.Mirror {
		n += 2
	}
	if m.Private {
		n += 2
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.PushedAt != nil {
		l = m.PushedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.ID != 0 {
		n += 2 + sovSourcegraph(uint64(m.ID))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.VCSSyncedAt != nil {
		l = m.VCSSyncedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoPermissions) Size() (n int) {
	var l int
	_ = l
	if m.Pull {
		n += 2
	}
	if m.Push {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *RepoListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoFork {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.RemoteOnly {
		n += 2
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoWebhookOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoRevSpec) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSpec) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *RepoStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.TargetURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.UpdatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoStatusList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoStatuses) > 0 {
		for _, e := range m.RepoStatuses {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *RepoStatusesCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoList) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ReposResolveRevOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ResolvedRev) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReceivePackOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.AdvertiseRefs {
		n += 2
	}
	return n
}

func (m *UploadPackOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.AdvertiseRefs {
		n += 2
	}
	return n
}

func (m *URIList) Size() (n int) {
	var l int
	_ = l
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Packet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoResolveOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Remote {
		n += 2
	}
	return n
}

func (m *RepoResolution) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.RemoteRepo != nil {
		l = m.RemoteRepo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CanonicalPath)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *SrclibDataVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CommitsBehind != 0 {
		n += 1 + sovSourcegraph(uint64(m.CommitsBehind))
	}
	return n
}

func (m *ReposCreateOp) Size() (n int) {
	var l int
	_ = l
	if m.Op != nil {
		n += m.Op.Size()
	}
	return n
}

func (m *ReposCreateOp_New) Size() (n int) {
	var l int
	_ = l
	if m.New != nil {
		l = m.New.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *ReposCreateOp_FromGitHubID) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSourcegraph(uint64(m.FromGitHubID))
	return n
}
func (m *ReposCreateOp_Origin) Size() (n int) {
	var l int
	_ = l
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *ReposCreateOp_NewRepo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Mirror {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposUpdateOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SSHCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Blocked != 0 {
		n += 1 + sovSourcegraph(uint64(m.Blocked))
	}
	if m.Deprecated != 0 {
		n += 1 + sovSourcegraph(uint64(m.Deprecated))
	}
	if m.Fork != 0 {
		n += 1 + sovSourcegraph(uint64(m.Fork))
	}
	if m.Mirror != 0 {
		n += 1 + sovSourcegraph(uint64(m.Mirror))
	}
	if m.Private != 0 {
		n += 2 + sovSourcegraph(uint64(m.Private))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListCommitsOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommitsOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Base)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *CommitList) Size() (n int) {
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListBranchesOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListBranchesOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.IncludeCommit {
		n += 2
	}
	l = len(m.BehindAheadBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContainsCommit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BranchList) Size() (n int) {
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListTagsOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListCommittersOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommittersOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *CommitterList) Size() (n int) {
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, e := range m.Committers {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoListTagsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TagList) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *MirrorReposRefreshVCSOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.AsUser != nil {
		l = m.AsUser.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RemoteRepo) Size() (n int) {
	var l int
	_ = l
	if m.GitHubID != 0 {
		n += 1 + sovSourcegraph(uint64(m.GitHubID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.VCS)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Private {
		n += 2
	}
	if m.Fork {
		n += 2
	}
	if m.Mirror {
		n += 2
	}
	if m.Stars != 0 {
		n += 1 + sovSourcegraph(uint64(m.Stars))
	}
	if m.PushedAt != nil {
		l = m.PushedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.OwnerIsOrg {
		n += 2
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *EmailAddr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Guessed {
		n += 2
	}
	if m.Blacklisted {
		n += 2
	}
	return n
}

func (m *UserList) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.IsOrganization {
		n += 2
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if m.RegisteredAt != nil {
		l = m.RegisteredAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Admin {
		n += 2
	}
	if m.Write {
		n += 2
	}
	if len(m.Betas) > 0 {
		for _, s := range m.Betas {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *EmailAddrList) Size() (n int) {
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, e := range m.EmailAddrs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UpdateEmailsOp) Size() (n int) {
	var l int
	_ = l
	l = m.UserSpec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Add != nil {
		l = m.Add.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BetaRegistration) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.Editors) > 0 {
		for _, s := range m.Editors {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BetaResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.EmailAddress)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *AuthInfo) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *ExternalToken) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Def) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.DocHTML != nil {
		l = m.DocHTML.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FmtStrings != nil {
		l = m.FmtStrings.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.StartLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndLine))
	}
	return n
}

func (m *DefGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.Doc {
		n += 2
	}
	if m.ComputeLineRange {
		n += 2
	}
	return n
}

func (m *DefListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ByteStart != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, e := range m.DefKeys {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.FilePathPrefix)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Exported {
		n += 2
	}
	if m.Nonlocal {
		n += 2
	}
	if m.IncludeTest {
		n += 2
	}
	if m.Doc {
		n += 3
	}
	if m.Fuzzy {
		n += 3
	}
	l = len(m.Sort)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 2 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListRefsOptions) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefSpec) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListRefsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListRefLocationsOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, s := range m.Repos {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListRefLocationsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsListExamplesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RefLocationsList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoRefs) > 0 {
		for _, e := range m.RepoRefs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.TotalRepos != 0 {
		n += 1 + sovSourcegraph(uint64(m.TotalRepos))
	}
	return n
}

func (m *DefRepoRef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	if m.Score != 0 {
		n += 5
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DefFileRef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	if m.Score != 0 {
		n += 5
	}
	return n
}

func (m *RepoTreeGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.ContentsAsString {
		n += 2
	}
	l = m.GetFileOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.NoSrclibAnns {
		n += 2
	}
	return n
}

func (m *GetFileOptions) Size() (n int) {
	var l int
	_ = l
	l = m.FileRange.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.EntireFile {
		n += 2
	}
	if m.ExpandContextLines != 0 {
		n += 1 + sovSourcegraph(uint64(m.ExpandContextLines))
	}
	if m.FullLines {
		n += 2
	}
	if m.Recursive {
		n += 2
	}
	if m.RecurseSingleSubfolderLimit != 0 {
		n += 1 + sovSourcegraph(uint64(m.RecurseSingleSubfolderLimit))
	}
	return n
}

func (m *RepoTreeSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = m.SearchOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeSearchResult) Size() (n int) {
	var l int
	_ = l
	l = m.SearchResult.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeSearchOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeListOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeListResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *VCSSearchResultList) Size() (n int) {
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, e := range m.SearchResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TreeEntry) Size() (n int) {
	var l int
	_ = l
	if m.BasicTreeEntry != nil {
		l = m.BasicTreeEntry.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FileRange != nil {
		l = m.FileRange.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContentsString)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BasicTreeEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovSourcegraph(uint64(m.Type))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *TreeEntrySpec) Size() (n int) {
	var l int
	_ = l
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *FileRange) Size() (n int) {
	var l int
	_ = l
	if m.StartLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndLine))
	}
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	return n
}

func (m *DefsRefreshIndexOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.RefreshRefLocations {
		n += 2
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *AsyncRefreshIndexesOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *AuthorshipInfo) Size() (n int) {
	var l int
	_ = l
	l = m.LastCommitDate.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.LastCommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefAuthor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.DefAuthorship.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefAuthorship) Size() (n int) {
	var l int
	_ = l
	l = m.AuthorshipInfo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Bytes != 0 {
		n += 1 + sovSourcegraph(uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		n += 9
	}
	return n
}

func (m *DefListAuthorsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListAuthorsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefAuthorList) Size() (n int) {
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, e := range m.DefAuthors {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ServerConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UserEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.UserProperties) > 0 {
		for k, v := range m.UserProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	if len(m.EventProperties) > 0 {
		for k, v := range m.EventProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Annotation) Size() (n int) {
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	l = len(m.Class)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.WantInner != 0 {
		n += 1 + sovSourcegraph(uint64(m.WantInner))
	}
	if len(m.URLs) > 0 {
		for _, s := range m.URLs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Def {
		n += 2
	}
	return n
}

func (m *AnnotationList) Size() (n int) {
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.LineStartBytes) > 0 {
		for _, e := range m.LineStartBytes {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	return n
}

func (m *AnnotationsListOptions) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoSrclibAnns {
		n += 2
	}
	return n
}

func (m *AnnotationsGetDefAtPosOptions) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Line != 0 {
		n += 1 + sovSourcegraph(uint64(m.Line))
	}
	if m.Character != 0 {
		n += 1 + sovSourcegraph(uint64(m.Character))
	}
	return n
}

func (m *SearchOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	if len(m.NotRepos) > 0 {
		for _, e := range m.NotRepos {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.IncludeRepos {
		n += 2
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.NotLanguages) > 0 {
		for _, s := range m.NotLanguages {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.NotKinds) > 0 {
		for _, s := range m.NotKinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Fast {
		n += 2
	}
	if m.AllowEmpty {
		n += 2
	}
	return n
}

func (m *SearchOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSearchResult) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *SearchReposOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *SearchReposResultList) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DefSearchResult) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Score != 0 {
		n += 5
	}
	if m.RefCount != 0 {
		n += 1 + sovSourcegraph(uint64(m.RefCount))
	}
	return n
}

func (m *SearchResultsList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoResults) > 0 {
		for _, e := range m.RepoResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.DefResults) > 0 {
		for _, e := range m.DefResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.SearchQueryOptions) > 0 {
		for _, e := range m.SearchQueryOptions {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func sovSourcegraph(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSourcegraph(x uint64) (n int) {
	return sovSourcegraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Origin) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Origin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Origin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Service |= (Origin_ServiceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIBaseURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIBaseURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinedStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinedStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinedStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, &RepoStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerPage", wireType)
			}
			m.PerPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PerPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deprecated = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fork = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &pbtypes.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedAt == nil {
				m.PushedAt = &pbtypes.Timestamp{}
			}
			if err := m.PushedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &Origin{}
			}
			if err := m.Origin.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCSSyncedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VCSSyncedAt == nil {
				m.VCSSyncedAt = &pbtypes.Timestamp{}
			}
			if err := m.VCSSyncedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &RepoPermissions{}
			}
			if err := m.Permissions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoPermissions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Push", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Push = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoFork = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteOnly = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoWebhookOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoWebhookOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoWebhookOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoRevSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoRevSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoRevSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatusList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatusList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatusList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoStatuses = append(m.RepoStatuses, &RepoStatus{})
			if err := m.RepoStatuses[len(m.RepoStatuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatusesCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, &Repo{})
			if err := m.Repos[len(m.Repos)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposResolveRevOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposResolveRevOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposResolveRevOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedRev) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedRev: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedRev: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceivePackOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceivePackOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceivePackOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseRefs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadPackOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadPackOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadPackOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseRefs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URIList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URIList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URIList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoResolveOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoResolveOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoResolveOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remote = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoResolution) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoResolution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoResolution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteRepo == nil {
				m.RemoteRepo = &Repo{}
			}
			if err := m.RemoteRepo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanonicalPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrclibDataVersion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrclibDataVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrclibDataVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitsBehind", wireType)
			}
			m.CommitsBehind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitsBehind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReposCreateOp_NewRepo{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &ReposCreateOp_New{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGitHubID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &ReposCreateOp_FromGitHubID{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Origin{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &ReposCreateOp_Origin{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposCreateOp_NewRepo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRepo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRepo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			m.Blocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Blocked |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			m.Deprecated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Deprecated |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			m.Fork = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Fork |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			m.Mirror = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mirror |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			m.Private = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Private |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &Origin{}
			}
			if err := m.Origin.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommitsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommitsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommitsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommitsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommitsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommitsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommitsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &vcs.Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListBranchesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListBranchesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListBranchesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListBranchesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListBranchesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListBranchesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListBranchesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BehindAheadBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BehindAheadBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainsCommit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &vcs.Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListTagsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListTagsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListTagsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListTagsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommittersOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommittersOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommittersOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommittersOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommittersOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommittersOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommittersOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitterList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committers = append(m.Committers, &vcs.Committer{})
			if err := m.Committers[len(m.Committers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListTagsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListTagsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListTagsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &vcs.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorReposRefreshVCSOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsUser == nil {
				m.AsUser = &UserSpec{}
			}
			if err := m.AsUser.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteRepo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteRepo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteRepo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHubID", wireType)
			}
			m.GitHubID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GitHubID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCS = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &pbtypes.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fork = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			m.Stars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Stars |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedAt == nil {
				m.PushedAt = &pbtypes.Timestamp{}
			}
			if err := m.PushedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerIsOrg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OwnerIsOrg = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &RepoPermissions{}
			}
			if err := m.Permissions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guessed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Guessed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklisted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blacklisted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOrganization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOrganization = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredAt == nil {
				m.RegisteredAt = &pbtypes.Timestamp{}
			}
			if err := m.RegisteredAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Betas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Betas = append(m.Betas, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddrList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailAddrs = append(m.EmailAddrs, &EmailAddr{})
			if err := m.EmailAddrs[len(m.EmailAddrs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEmailsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEmailsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEmailsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UserSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Add == nil {
				m.Add = &EmailAddrList{}
			}
			if err := m.Add.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetaRegistration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetaRegistration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetaRegistration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Editors = append(m.Editors, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetaResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailAddress = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Def) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Def: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Def: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocHTML", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocHTML == nil {
				m.DocHTML = &pbtypes2.HTML{}
			}
			if err := m.DocHTML.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmtStrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmtStrings == nil {
				m.FmtStrings = &graph.DefFormatStrings{}
			}
			if err := m.FmtStrings.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeLineRange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ComputeLineRange = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteStart", wireType)
			}
			m.ByteStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteStart |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteEnd", wireType)
			}
			m.ByteEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteEnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefKeys = append(m.DefKeys, &graph.DefKey{})
			if err := m.DefKeys[len(m.DefKeys)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRevs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRevs = append(m.RepoRevs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePathPrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exported = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonlocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nonlocal = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeTest = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fuzzy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fuzzy = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListRefsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListRefsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListRefsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &Def{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListRefsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListRefsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListRefsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListRefsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &graph1.Ref{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListRefLocationsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListRefLocationsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListRefLocationsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListRefLocationsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListRefLocationsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListRefLocationsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListRefLocationsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListExamplesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListExamplesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListExamplesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefLocationsList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefLocationsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefLocationsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRefs = append(m.RepoRefs, &DefRepoRef{})
			if err := m.RepoRefs[len(m.RepoRefs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRepos", wireType)
			}
			m.TotalRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalRepos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefRepoRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefRepoRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefRepoRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &DefFileRef{})
			if err := m.Files[len(m.Files)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefFileRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefFileRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefFileRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsAsString", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentsAsString = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFileOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetFileOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSrclibAnns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoSrclibAnns = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntireFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntireFile = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandContextLines", wireType)
			}
			m.ExpandContextLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpandContextLines |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullLines", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullLines = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurseSingleSubfolderLimit", wireType)
			}
			m.RecurseSingleSubfolderLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RecurseSingleSubfolderLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchResult.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeSearchOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VCSSearchResultList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VCSSearchResultList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VCSSearchResultList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchResults = append(m.SearchResults, &vcs.SearchResult{})
			if err := m.SearchResults[len(m.SearchResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicTreeEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicTreeEntry == nil {
				m.BasicTreeEntry = &BasicTreeEntry{}
			}
			if err := m.BasicTreeEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileRange == nil {
				m.FileRange = &FileRange{}
			}
			if err := m.FileRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentsString = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicTreeEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicTreeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicTreeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (TreeEntryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], data[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &BasicTreeEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntrySpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntrySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntrySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileRange) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsRefreshIndexOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsRefreshIndexOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsRefreshIndexOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRefLocations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshRefLocations = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsyncRefreshIndexesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsyncRefreshIndexesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsyncRefreshIndexesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorshipInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorshipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorshipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCommitDate.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthorship", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefAuthorship.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorship) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorshipInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthorshipInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Bytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesProportion", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.BytesProportion = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListAuthorsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListAuthorsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListAuthorsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListAuthorsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListAuthorsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListAuthorsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListAuthorsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefAuthors = append(m.DefAuthors, &DefAuthor{})
			if err := m.DefAuthors[len(m.DefAuthors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &pbtypes.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.UserProperties == nil {
				m.UserProperties = make(map[string]string)
			}
			m.UserProperties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.EventProperties == nil {
				m.EventProperties = make(map[string]string)
			}
			m.EventProperties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Annotation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Class = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantInner", wireType)
			}
			m.WantInner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WantInner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLs = append(m.URLs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Def = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotationList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Annotation{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineStartBytes", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LineStartBytes = append(m.LineStartBytes, v)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotationsListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationsListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationsListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &FileRange{}
			}
			if err := m.Range.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSrclibAnns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoSrclibAnns = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotationsGetDefAtPosOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationsGetDefAtPosOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationsGetDefAtPosOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Line |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Character", wireType)
			}
			m.Character = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Character |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Repos = append(m.Repos, v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotRepos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotRepos = append(m.NotRepos, v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRepos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRepos = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotLanguages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotLanguages = append(m.NotLanguages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotKinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotKinds = append(m.NotKinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &SearchOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReposOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReposOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReposOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReposResultList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReposResultList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReposResultList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, &Repo{})
			if err := m.Repos[len(m.Repos)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCount", wireType)
			}
			m.RefCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RefCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResultsList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResultsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResultsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoResults = append(m.RepoResults, &RepoSearchResult{})
			if err := m.RepoResults[len(m.RepoResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefResults = append(m.DefResults, &DefSearchResult{})
			if err := m.DefResults[len(m.DefResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchQueryOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchQueryOptions = append(m.SearchQueryOptions, &SearchOptions{})
			if err := m.SearchQueryOptions[len(m.SearchQueryOptions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSourcegraph(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSourcegraph
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSourcegraph
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSourcegraph(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSourcegraph = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSourcegraph   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorSourcegraph = []byte{
	// 5449 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x3c, 0x4b, 0x6c, 0x1b, 0x49,
	0x76, 0x6e, 0xfe, 0xf9, 0x48, 0xd1, 0x72, 0x59, 0xf6, 0x70, 0x38, 0x1a, 0xcb, 0xe9, 0x9d, 0xf1,
	0x78, 0xbd, 0x1e, 0xd9, 0xab, 0x99, 0xb5, 0xc7, 0xf3, 0x17, 0x45, 0xfd, 0x76, 0x64, 0x49, 0xd3,
	0x94, 0x3c, 0x19, 0x20, 0x9b, 0x41, 0x8b, 0x2c, 0x49, 0x1d, 0x93, 0xdd, 0xdc, 0xee, 0x26, 0x6d,
	0x3a, 0xd9, 0xc3, 0x22, 0x40, 0xb0, 0xbb, 0x08, 0x90, 0x60, 0x93, 0x00, 0x01, 0x72, 0x4b, 0x2e,
	0x01, 0x72, 0x4c, 0x2e, 0x09, 0x72, 0x4a, 0x2e, 0x03, 0x64, 0x03, 0x2c, 0x10, 0x6c, 0x4e, 0x81,
	0xb3, 0x19, 0x04, 0x39, 0x0c, 0x72, 0xda, 0x9c, 0x72, 0x0b, 0x5e, 0x7d, 0xba, 0xab, 0x9b, 0xdd,
	0x94, 0xe4, 0xd8, 0x07, 0x5b, 0x5d, 0x55, 0xef, 0xd5, 0xef, 0x7d, 0xea, 0x7d, 0xaa, 0x08, 0x17,
	0x3c, 0x67, 0xe8, 0x76, 0xe8, 0x91, 0x6b, 0x0e, 0x8e, 0x17, 0x07, 0xae, 0xe3, 0x3b, 0xa4, 0xa2,
	0x54, 0x35, 0xde, 0x3c, 0xb2, 0xfc, 0xe3, 0xe1, 0xc1, 0x62, 0xc7, 0xe9, 0xdf, 0x3a, 0x72, 0x8e,
	0x9c, 0x5b, 0x0c, 0xe6, 0x60, 0x78, 0xc8, 0x4a, 0xac, 0xc0, 0xbe, 0x38, 0x6e, 0xe3, 0x9e, 0xda,
	0x1d, 0xe2, 0x28, 0xe5, 0xc8, 0xf7, 0xe0, 0xe1, 0xd1, 0xad, 0x51, 0xc7, 0xc3, 0x7f, 0x02, 0x75,
	0x69, 0x2a, 0xaa, 0xdb, 0xe9, 0x59, 0x07, 0xb7, 0x78, 0xa1, 0x4b, 0x0f, 0xcf, 0x8c, 0xe3, 0x06,
	0x38, 0xdf, 0x9a, 0xc0, 0xf9, 0xbe, 0x77, 0x6b, 0x70, 0xe0, 0x8f, 0x07, 0xd4, 0xbb, 0xe5, 0x5b,
	0x7d, 0xea, 0xf9, 0x66, 0x7f, 0x20, 0x80, 0xaf, 0x4d, 0x03, 0x1e, 0x39, 0x56, 0xf7, 0x34, 0x70,
	0xc7, 0x7e, 0xbf, 0x27, 0xe0, 0x56, 0xcf, 0xb2, 0x3f, 0x96, 0x3d, 0xa2, 0xb6, 0xef, 0xb8, 0xe3,
	0xf0, 0x8b, 0x77, 0xa3, 0xff, 0xb1, 0x06, 0x85, 0x1d, 0xd7, 0x3a, 0xb2, 0x6c, 0x52, 0x83, 0xcc,
	0x66, 0xab, 0xae, 0x5d, 0xd5, 0xae, 0x97, 0x8d, 0xcc, 0x66, 0x8b, 0x7c, 0x04, 0xc5, 0x36, 0x75,
	0x47, 0x56, 0x87, 0xd6, 0x33, 0x57, 0xb5, 0xeb, 0xb5, 0xa5, 0x85, 0x45, 0x75, 0x4c, 0x8e, 0xb5,
	0x28, 0x40, 0xf6, 0xc6, 0x03, 0xda, 0xcc, 0x7d, 0xfd, 0x74, 0xe1, 0x9c, 0x21, 0xb1, 0xc8, 0x15,
	0x80, 0xe5, 0xdd, 0xcd, 0xa6, 0xe9, 0xd1, 0x7d, 0x63, 0xab, 0x9e, 0x65, 0x1d, 0x2b, 0x35, 0xfa,
	0xcb, 0x50, 0x51, 0xb0, 0x09, 0x40, 0x61, 0xdd, 0xf2, 0x37, 0x86, 0x07, 0xb3, 0xe7, 0xf4, 0x1f,
	0x6b, 0x50, 0x5b, 0x71, 0xfa, 0x07, 0x96, 0x4d, 0xbb, 0x6d, 0xdf, 0xf4, 0x87, 0x1e, 0x69, 0x40,
	0x69, 0xc5, 0xe9, 0xf7, 0x2d, 0x3f, 0x98, 0x64, 0x50, 0x26, 0x73, 0x90, 0x47, 0x28, 0x3e, 0xd1,
	0xb2, 0xc1, 0x0b, 0xe4, 0x2d, 0x28, 0x71, 0x5c, 0xea, 0xd5, 0xb3, 0x57, 0xb3, 0xd7, 0x2b, 0x4b,
	0x2f, 0x45, 0x56, 0x60, 0xd0, 0x81, 0xc3, 0x01, 0x8c, 0x00, 0x90, 0xcc, 0x42, 0xd6, 0xa0, 0xa3,
	0x7a, 0x8e, 0x75, 0x84, 0x9f, 0xfa, 0x11, 0x54, 0xb6, 0x2c, 0xcf, 0xdf, 0x19, 0xf8, 0x96, 0x63,
	0x7b, 0x64, 0x11, 0x8a, 0xbb, 0xd4, 0xdd, 0x35, 0x8f, 0x28, 0x9b, 0x46, 0xbe, 0x39, 0xf7, 0xab,
	0xa7, 0x0b, 0xb3, 0x43, 0xb7, 0xf7, 0xae, 0x7e, 0xd3, 0xe9, 0x5b, 0x3e, 0xed, 0x0f, 0xfc, 0xb1,
	0x6e, 0x48, 0x20, 0x72, 0x1d, 0x72, 0x0c, 0x38, 0x33, 0x05, 0x98, 0x41, 0xe8, 0xef, 0x42, 0x15,
	0x07, 0x32, 0xa8, 0x37, 0x70, 0x6c, 0x8f, 0x92, 0x1b, 0x90, 0xdf, 0x73, 0x7c, 0xb3, 0x37, 0x75,
	0x1c, 0x0e, 0xa2, 0x7f, 0x0c, 0xb5, 0xb6, 0xef, 0x52, 0xb3, 0x1f, 0x60, 0x2f, 0x42, 0x71, 0xc3,
	0xf4, 0xee, 0x3b, 0x2e, 0x9f, 0x67, 0x29, 0x6d, 0x9e, 0x02, 0x48, 0xaf, 0x02, 0xe0, 0x86, 0xac,
	0x38, 0xf6, 0xa1, 0x75, 0xa4, 0xff, 0x22, 0x0f, 0x39, 0x2c, 0xe2, 0x7e, 0xec, 0x1b, 0x9b, 0x62,
	0xc7, 0xf1, 0x13, 0x37, 0x7b, 0xe7, 0x91, 0x4d, 0x5d, 0xb9, 0xd9, 0xac, 0x40, 0x08, 0xe4, 0xb6,
	0xcd, 0x3e, 0x15, 0x64, 0x66, 0xdf, 0xe4, 0x2a, 0x54, 0x5a, 0xd4, 0xeb, 0xb8, 0x16, 0xdb, 0x3a,
	0xb1, 0xa7, 0x6a, 0x15, 0xd1, 0xa1, 0xba, 0xb1, 0xb7, 0xb7, 0xbb, 0xd2, 0x73, 0x6c, 0xc6, 0x24,
	0x79, 0x06, 0x12, 0xa9, 0xc3, 0x5e, 0xda, 0xed, 0x8d, 0x00, 0xa4, 0xc0, 0x7b, 0x51, 0xaa, 0x10,
	0x62, 0xc3, 0xe9, 0xd3, 0x81, 0x79, 0xc4, 0x20, 0x8a, 0x1c, 0x42, 0xa9, 0x22, 0xaf, 0xc1, 0x4c,
	0x8b, 0x1e, 0x9a, 0xc3, 0x9e, 0xdf, 0x74, 0x4d, 0xbb, 0x73, 0x5c, 0x2f, 0x31, 0x98, 0x68, 0x25,
	0xb2, 0xd8, 0x96, 0x69, 0x1f, 0x0d, 0x91, 0x5c, 0x65, 0xce, 0x62, 0xb2, 0x4c, 0xea, 0x50, 0x6c,
	0xf6, 0x9c, 0xce, 0x43, 0xda, 0xad, 0x03, 0x6e, 0xa7, 0x21, 0x8b, 0xc8, 0xe6, 0x2d, 0x3a, 0x70,
	0x69, 0xc7, 0xf4, 0x69, 0xb7, 0x5e, 0x61, 0x8d, 0x4a, 0x0d, 0xee, 0xcc, 0x9a, 0xe3, 0x3e, 0xac,
	0x57, 0x59, 0x0b, 0xfb, 0x26, 0x97, 0xa1, 0x70, 0xdf, 0x72, 0x5d, 0xc7, 0xad, 0xcf, 0xb0, 0x5a,
	0x51, 0xc2, 0x51, 0x76, 0x5d, 0x6b, 0x84, 0xac, 0x5c, 0xe3, 0xa3, 0x88, 0x22, 0xb9, 0x0d, 0xe5,
	0x15, 0x97, 0x62, 0x87, 0xcb, 0x7e, 0xfd, 0xfc, 0x55, 0xed, 0x7a, 0x65, 0x89, 0x2c, 0x0a, 0xbd,
	0xb0, 0xb8, 0x27, 0x95, 0x8d, 0x11, 0x02, 0x21, 0xc6, 0xfe, 0xa0, 0x2b, 0x30, 0x66, 0xd3, 0x31,
	0x02, 0x20, 0xb2, 0x08, 0xa5, 0xdd, 0xa1, 0x77, 0xcc, 0x10, 0x2e, 0xa4, 0x22, 0x04, 0x30, 0x42,
	0x63, 0x10, 0xe4, 0x4e, 0xa6, 0x31, 0xbe, 0x25, 0x75, 0x49, 0xfd, 0x22, 0xc3, 0xbe, 0x98, 0xa0,
	0x30, 0x0c, 0xa9, 0x6e, 0xde, 0x86, 0xca, 0x83, 0x95, 0x76, 0x7b, 0x6c, 0x77, 0xd8, 0x78, 0x73,
	0xa9, 0xe3, 0xa9, 0x60, 0xe4, 0x43, 0xa8, 0xec, 0x52, 0xb7, 0x6f, 0x79, 0x1e, 0x0a, 0x63, 0xfd,
	0x12, 0xc3, 0x9a, 0x9f, 0x10, 0x6b, 0x05, 0xc6, 0x50, 0x11, 0xf4, 0x1d, 0x38, 0x1f, 0x6b, 0x47,
	0xfa, 0xec, 0x0e, 0x7b, 0x5c, 0xca, 0x4a, 0x06, 0xfb, 0xe6, 0x75, 0xde, 0x31, 0x63, 0x71, 0x56,
	0xe7, 0x1d, 0x23, 0xdf, 0x2f, 0x77, 0xfb, 0x96, 0xcd, 0x58, 0xbc, 0x64, 0xf0, 0x82, 0xfe, 0xbf,
	0x59, 0xde, 0xa3, 0xaa, 0x22, 0xae, 0x0b, 0x59, 0x60, 0x42, 0x93, 0x26, 0xf2, 0x4c, 0x42, 0x6e,
	0x40, 0xfe, 0xd3, 0x21, 0x75, 0xc7, 0x5c, 0x96, 0xd2, 0x44, 0x9c, 0x81, 0x90, 0x45, 0xc8, 0xed,
	0x1b, 0x9b, 0x5c, 0x95, 0x95, 0x9b, 0x8d, 0x5f, 0x3d, 0x5d, 0xb8, 0xcc, 0x41, 0x3b, 0x4e, 0xbf,
	0x6f, 0x46, 0xfa, 0x46, 0x38, 0x9c, 0x45, 0xdb, 0x71, 0x7d, 0x2e, 0x53, 0x69, 0xb3, 0x40, 0x08,
	0xb2, 0x04, 0xe5, 0x96, 0xe5, 0xd2, 0x0e, 0x93, 0xd2, 0xc2, 0x14, 0xf0, 0x10, 0x8c, 0xdc, 0x84,
	0xc2, 0xb6, 0xc3, 0xf8, 0xba, 0x38, 0x45, 0xbb, 0x08, 0x18, 0x9c, 0x0b, 0xea, 0x78, 0x2e, 0x76,
	0x69, 0x73, 0x61, 0xa7, 0xc0, 0x0d, 0xa9, 0x5d, 0x60, 0xda, 0x8e, 0x70, 0x9d, 0xf3, 0x36, 0xaa,
	0xac, 0xbe, 0xe3, 0xd3, 0x1d, 0xbb, 0x37, 0xe6, 0xf2, 0x95, 0x82, 0xa0, 0xc0, 0x91, 0x8d, 0x88,
	0x3e, 0x67, 0x02, 0x58, 0x59, 0xaa, 0x47, 0x58, 0x48, 0x69, 0x6f, 0x56, 0xbf, 0x7c, 0xba, 0x70,
	0xee, 0xe7, 0x4f, 0x17, 0x34, 0x76, 0xb8, 0xa9, 0xa8, 0xfa, 0x35, 0x20, 0x48, 0xfa, 0xcf, 0xe8,
	0xc1, 0xb1, 0xe3, 0x3c, 0x94, 0xd4, 0x9f, 0xd0, 0x98, 0xfa, 0x07, 0x50, 0x41, 0x38, 0x83, 0x8e,
	0xda, 0x03, 0xda, 0x41, 0xe6, 0xc2, 0x22, 0x57, 0xeb, 0x06, 0x57, 0xb3, 0xea, 0xe9, 0x96, 0x89,
	0x9e, 0x6e, 0x7a, 0x03, 0x4a, 0xec, 0xa8, 0x42, 0xdc, 0xf0, 0x90, 0x66, 0x22, 0xa7, 0xff, 0xb7,
	0xc6, 0xd5, 0xb6, 0x38, 0x24, 0x93, 0x0f, 0xc2, 0x79, 0x28, 0xef, 0x99, 0xee, 0x11, 0xf5, 0xc3,
	0x73, 0x38, 0xac, 0x38, 0x85, 0x96, 0xae, 0x43, 0x71, 0xc5, 0xb1, 0x7d, 0xfa, 0x58, 0x30, 0x93,
	0x21, 0x8b, 0xe4, 0x8e, 0xaa, 0x95, 0x0a, 0x69, 0x22, 0xdc, 0xcc, 0xe1, 0x1e, 0xaa, 0xba, 0xe9,
	0x8e, 0xaa, 0x9b, 0x8a, 0x27, 0xe1, 0x05, 0xa0, 0xfa, 0x7d, 0xa8, 0x85, 0xab, 0x45, 0x52, 0x90,
	0xf7, 0xa0, 0x1a, 0xd6, 0x50, 0xaf, 0xae, 0x4d, 0x3f, 0xe8, 0x23, 0xc0, 0xfa, 0x0f, 0x35, 0x98,
	0x53, 0x2b, 0xf8, 0x04, 0x77, 0x06, 0x64, 0x49, 0x21, 0x51, 0x9c, 0x39, 0x14, 0x52, 0x8a, 0x09,
	0x72, 0x12, 0x7e, 0x07, 0x0a, 0xbc, 0x1f, 0xb6, 0xf9, 0xe9, 0x73, 0x10, 0x48, 0x02, 0x58, 0x7f,
	0x8b, 0x53, 0x97, 0x2d, 0xe6, 0x0d, 0xc8, 0xe3, 0xb7, 0x5c, 0xc5, 0x85, 0xc9, 0x71, 0x79, 0xbb,
	0x7e, 0x0f, 0x2e, 0xb0, 0x0f, 0x83, 0x7a, 0x4e, 0x6f, 0x44, 0x0d, 0x3a, 0xda, 0x19, 0x20, 0x5f,
	0xb9, 0x0a, 0x5f, 0xb9, 0xe2, 0xf8, 0x76, 0xe9, 0x48, 0xb0, 0x03, 0x7e, 0xea, 0xdf, 0x44, 0x66,
	0x64, 0x58, 0x5d, 0x83, 0x8e, 0xa6, 0x99, 0x55, 0xfa, 0xf7, 0x60, 0xc6, 0xa0, 0x1d, 0x6a, 0x8d,
	0xe8, 0xae, 0xd9, 0x79, 0x98, 0x32, 0x02, 0x81, 0x5c, 0xd7, 0xf4, 0x4d, 0xc6, 0x57, 0x55, 0x83,
	0x7d, 0xe3, 0x71, 0x6b, 0x76, 0x47, 0xd4, 0xf5, 0x2d, 0x8f, 0x1a, 0xf4, 0xd0, 0x63, 0x4c, 0x55,
	0x32, 0xa2, 0x95, 0xfa, 0x6f, 0x40, 0x75, 0x7f, 0xd0, 0x73, 0xcc, 0xee, 0x0b, 0xe9, 0xfd, 0x55,
	0x28, 0xee, 0x1b, 0x9b, 0x6c, 0x5b, 0x89, 0xd0, 0x9c, 0xb8, 0xab, 0x65, 0xae, 0x1d, 0xf5, 0x79,
	0x28, 0xe0, 0xb0, 0xd4, 0x0f, 0x86, 0xd0, 0xc2, 0x21, 0xf4, 0xf7, 0x70, 0xe5, 0x48, 0x66, 0xb6,
	0x51, 0x7c, 0x6e, 0x03, 0xd3, 0x3f, 0x16, 0x5b, 0xc4, 0xbe, 0xf1, 0x10, 0x77, 0x99, 0x5a, 0x11,
	0xc7, 0x84, 0x28, 0xe9, 0x3f, 0xe0, 0x4c, 0xca, 0x90, 0x87, 0x4c, 0x80, 0x92, 0x24, 0xfe, 0xdb,
	0x52, 0x79, 0xb1, 0x16, 0xce, 0x32, 0x09, 0x04, 0x57, 0x80, 0x70, 0xe1, 0x2b, 0xa6, 0xed, 0xd8,
	0x56, 0xc7, 0xec, 0xed, 0xe2, 0x6c, 0xb8, 0x2c, 0x47, 0x2b, 0xf5, 0x7d, 0xb8, 0xd0, 0x66, 0x0e,
	0x4b, 0xcb, 0xf4, 0xcd, 0x07, 0xd4, 0xc5, 0x53, 0x6e, 0xaa, 0xf5, 0x8c, 0xdd, 0xb2, 0x6f, 0xaf,
	0x49, 0x8f, 0x2d, 0xbb, 0xcb, 0x4d, 0x55, 0x23, 0x5a, 0xa9, 0xff, 0x5b, 0x86, 0xef, 0x49, 0x28,
	0x24, 0x77, 0x20, 0xbb, 0x4d, 0x1f, 0x09, 0x19, 0xd1, 0x27, 0xa6, 0x1e, 0x00, 0x2e, 0x6e, 0xd3,
	0x47, 0x58, 0xb1, 0x71, 0xce, 0x40, 0x04, 0x72, 0x1d, 0xaa, 0x6b, 0xae, 0xd3, 0xe7, 0xc6, 0xbe,
	0xd0, 0x77, 0xf9, 0x66, 0xa6, 0xae, 0x6d, 0x9c, 0x33, 0x22, 0x2d, 0xe4, 0xcd, 0xc0, 0xa0, 0xc8,
	0xa6, 0x1a, 0x14, 0x1b, 0xe7, 0xa4, 0x49, 0xd1, 0xf8, 0x6b, 0x0d, 0x8a, 0x62, 0xac, 0x04, 0xbb,
	0x15, 0xb7, 0x40, 0x1a, 0x91, 0x59, 0xb1, 0x05, 0xd2, 0x82, 0x9c, 0xb0, 0x0f, 0x73, 0x49, 0xf6,
	0x61, 0x68, 0xb5, 0xe5, 0x23, 0x56, 0x5b, 0x4c, 0x83, 0x16, 0x26, 0x35, 0xa8, 0x6a, 0x59, 0x16,
	0xa3, 0x96, 0x65, 0x33, 0x07, 0x99, 0x9d, 0x81, 0xfe, 0xf7, 0x79, 0xb1, 0xbd, 0x5c, 0xd9, 0x71,
	0x96, 0x9b, 0x60, 0x1a, 0xb1, 0xaa, 0x4c, 0x82, 0x35, 0x9e, 0x4d, 0xb2, 0xc6, 0x73, 0xe9, 0xd6,
	0x78, 0xfe, 0x64, 0x6b, 0xbc, 0x70, 0xb2, 0x35, 0x5e, 0x3c, 0xd1, 0x1a, 0x2f, 0x9d, 0xc2, 0x1a,
	0x87, 0x93, 0xac, 0xf1, 0x4a, 0xcc, 0x1a, 0xff, 0x20, 0xb4, 0xc6, 0xab, 0xcc, 0x37, 0xfd, 0xc6,
	0x24, 0xfb, 0xc9, 0x8d, 0x5c, 0x6c, 0x3a, 0x4e, 0x0f, 0x6d, 0x8b, 0xd0, 0x64, 0x5f, 0x89, 0x98,
	0xec, 0x33, 0xa7, 0xef, 0x41, 0xb5, 0xeb, 0xef, 0x0a, 0xbb, 0xbe, 0x76, 0x7a, 0x74, 0x6e, 0xfc,
	0xbf, 0x17, 0xb0, 0xd1, 0xf9, 0xd3, 0xa3, 0x4a, 0x5e, 0xfb, 0x20, 0xf4, 0x10, 0x66, 0xcf, 0xb0,
	0x72, 0xe9, 0x46, 0x9c, 0xc5, 0x44, 0xd7, 0xbf, 0x09, 0x25, 0xd9, 0x03, 0x29, 0x41, 0x6e, 0x7b,
	0x67, 0x7b, 0x75, 0xf6, 0x1c, 0x7e, 0xed, 0x19, 0xfb, 0xab, 0xb3, 0x1a, 0x29, 0x43, 0x7e, 0x6d,
	0x79, 0xab, 0xbd, 0x3a, 0x9b, 0xd1, 0xbf, 0xe0, 0xa6, 0x10, 0x3b, 0x93, 0x85, 0xde, 0x48, 0x61,
	0xe1, 0xef, 0x40, 0x76, 0x67, 0xe0, 0x0b, 0x85, 0x37, 0x39, 0xf9, 0x48, 0x07, 0xcc, 0xa0, 0x32,
	0x10, 0x5e, 0xff, 0xa5, 0x06, 0x97, 0x93, 0xdb, 0xd1, 0xb8, 0xdc, 0xa0, 0x66, 0x77, 0xba, 0xb9,
	0x8d, 0x10, 0x08, 0xd9, 0x34, 0x3d, 0x3a, 0xd5, 0xda, 0x66, 0x10, 0x71, 0x23, 0x31, 0xfb, 0xcc,
	0x46, 0x22, 0xf7, 0xff, 0x7d, 0xa1, 0x51, 0xd2, 0xfd, 0x7f, 0xff, 0x58, 0xff, 0x3d, 0x0d, 0x80,
	0x2f, 0x8d, 0x9d, 0x5a, 0xaf, 0xa3, 0xd5, 0xc5, 0x16, 0x2a, 0xcc, 0x81, 0xca, 0xe2, 0xa8, 0xe3,
	0x2d, 0xf2, 0x3a, 0x43, 0xb6, 0x91, 0x4f, 0xe3, 0x9e, 0xbf, 0xd8, 0xda, 0x57, 0x22, 0x93, 0x8d,
	0x82, 0xc4, 0xe6, 0x1b, 0xeb, 0x40, 0x37, 0xe1, 0x62, 0x40, 0x4c, 0x2e, 0x8c, 0x34, 0x8d, 0x9a,
	0x77, 0x54, 0x6a, 0xbe, 0x96, 0x48, 0xcd, 0xb0, 0x07, 0x85, 0x9c, 0xff, 0xae, 0xc1, 0x4b, 0x29,
	0x00, 0xcf, 0x71, 0xef, 0x5f, 0x83, 0x99, 0x4d, 0xbb, 0xd3, 0x1b, 0x76, 0x29, 0xdf, 0x2d, 0x69,
	0x29, 0x44, 0x2a, 0xc9, 0x4d, 0xb8, 0xc0, 0xcf, 0xb8, 0xe5, 0x63, 0x6a, 0x76, 0x85, 0x4a, 0xe2,
	0xea, 0x71, 0xb2, 0x81, 0x5c, 0x83, 0x1a, 0x5a, 0xbf, 0xa6, 0x65, 0x7b, 0xa2, 0x53, 0xae, 0x26,
	0x63, 0xb5, 0xfa, 0x8f, 0x34, 0x00, 0x8e, 0x22, 0x4c, 0xbb, 0x92, 0x5c, 0x67, 0x84, 0x9c, 0xbc,
	0xd2, 0x08, 0x1a, 0x5f, 0x04, 0x3d, 0x3f, 0xe7, 0x2e, 0x2a, 0xa3, 0xe7, 0x9e, 0x79, 0x94, 0x46,
	0xcb, 0x25, 0x95, 0x96, 0x57, 0x13, 0x69, 0xc9, 0xb1, 0x15, 0x3a, 0x52, 0xb8, 0x14, 0x93, 0x7b,
	0x9f, 0xba, 0x69, 0x03, 0xbc, 0xa3, 0x0e, 0x70, 0x6d, 0x8a, 0xe8, 0xf3, 0x3e, 0x94, 0x61, 0x1e,
	0xc1, 0xcb, 0xa9, 0x10, 0x32, 0x64, 0xa7, 0x05, 0x21, 0xbb, 0x38, 0x07, 0x65, 0x9e, 0xdd, 0xc5,
	0xfb, 0xa9, 0x26, 0x8d, 0x23, 0x9f, 0xba, 0x8c, 0x90, 0x8b, 0x52, 0x48, 0x71, 0x0a, 0x82, 0x94,
	0x35, 0x45, 0x32, 0x7d, 0xea, 0x1a, 0x0a, 0xc4, 0x8b, 0xa0, 0xe7, 0x17, 0x5c, 0x3e, 0x63, 0x04,
	0x79, 0x7e, 0x72, 0xa3, 0x3f, 0x81, 0xe2, 0x9e, 0x79, 0xc4, 0x96, 0x3b, 0x0f, 0x39, 0x1c, 0x43,
	0x2c, 0xb4, 0xc4, 0x16, 0xba, 0x67, 0x1e, 0x19, 0xac, 0xf6, 0x45, 0x2c, 0xee, 0x00, 0x5e, 0xe2,
	0x47, 0x9d, 0x70, 0x70, 0x0e, 0x5d, 0xea, 0x1d, 0x3f, 0x58, 0x69, 0xa7, 0xf0, 0xd4, 0x9b, 0x50,
	0x58, 0xf6, 0xf6, 0x3d, 0x61, 0x00, 0x55, 0x96, 0x2e, 0x45, 0x46, 0xc6, 0x06, 0x74, 0xd4, 0x0c,
	0x01, 0xf4, 0xdd, 0x5c, 0x29, 0x33, 0x9b, 0xd5, 0x7f, 0x92, 0x53, 0x8d, 0x6f, 0xb4, 0x34, 0x02,
	0x63, 0x94, 0xf7, 0x1d, 0x94, 0xcf, 0x10, 0xed, 0x9c, 0x85, 0xec, 0x83, 0x95, 0xb6, 0x8c, 0x1c,
	0x3f, 0x58, 0x69, 0x9f, 0x2a, 0xba, 0x39, 0x61, 0x0b, 0x15, 0x92, 0x6c, 0xa1, 0x98, 0xed, 0x56,
	0x9c, 0x6e, 0x61, 0x96, 0x62, 0xd6, 0x52, 0x24, 0x12, 0x58, 0x3e, 0x4d, 0x24, 0x50, 0x89, 0x43,
	0x42, 0x34, 0x0e, 0x29, 0xa3, 0x99, 0x95, 0xc4, 0x68, 0x66, 0x35, 0x62, 0x17, 0xf3, 0x68, 0x84,
	0xcb, 0x63, 0x2c, 0x79, 0x83, 0x17, 0x22, 0x51, 0xc6, 0xda, 0x29, 0xa2, 0x8c, 0x57, 0x00, 0xd8,
	0xa6, 0x6f, 0x7a, 0x3b, 0xee, 0x11, 0x33, 0x99, 0x4a, 0x86, 0x52, 0x13, 0x0f, 0x09, 0xd6, 0xcf,
	0x1a, 0x12, 0xfc, 0x23, 0x0d, 0xca, 0xab, 0x7d, 0xd3, 0xea, 0x2d, 0x77, 0xbb, 0x6c, 0xce, 0xac,
	0x20, 0xd4, 0x09, 0x2f, 0xe0, 0xee, 0x3e, 0xa0, 0xae, 0x75, 0x68, 0xd1, 0xae, 0x70, 0xf6, 0x82,
	0xb2, 0xd8, 0xab, 0xbe, 0xe9, 0x8e, 0x45, 0x64, 0x50, 0x16, 0xb1, 0x65, 0x7d, 0x48, 0x3d, 0x8f,
	0x76, 0xc5, 0xc1, 0x23, 0x8b, 0x48, 0xcf, 0x66, 0xcf, 0xec, 0x3c, 0xec, 0x59, 0x1e, 0x5a, 0xa0,
	0xdc, 0x9d, 0x50, 0xab, 0xf4, 0xb7, 0xa0, 0x84, 0x0c, 0x2b, 0xc3, 0x02, 0xf8, 0x9d, 0x1c, 0x16,
	0xc0, 0x16, 0x83, 0xb7, 0xeb, 0x3f, 0xc9, 0x42, 0x0e, 0xbf, 0xc8, 0xcb, 0x90, 0xdd, 0x97, 0xcc,
	0xdc, 0x2c, 0x7e, 0xfd, 0x74, 0x01, 0x8b, 0x06, 0xfe, 0x47, 0x16, 0x20, 0xbf, 0xe5, 0xa0, 0x01,
	0xc8, 0x8d, 0xa0, 0xf2, 0xd7, 0x4f, 0x17, 0x78, 0x85, 0xc1, 0xff, 0x24, 0xfa, 0x0e, 0xd7, 0xa0,
	0xc6, 0x36, 0xdb, 0xb4, 0xad, 0x27, 0x66, 0xe0, 0x3e, 0x94, 0x8c, 0x58, 0x2d, 0x99, 0x87, 0xf2,
	0xf2, 0xc8, 0xf4, 0x4d, 0x37, 0x74, 0x1f, 0xc2, 0x0a, 0xc6, 0xa3, 0x4e, 0xc7, 0x54, 0x58, 0x38,
	0x28, 0xf3, 0x18, 0x53, 0x7f, 0x60, 0xda, 0x63, 0xc1, 0xbe, 0xb2, 0x18, 0xf7, 0x27, 0xca, 0x93,
	0xfe, 0x44, 0x03, 0x4a, 0x2d, 0xcb, 0x33, 0x0f, 0x7a, 0x41, 0x70, 0x3e, 0x28, 0x93, 0x3b, 0x50,
	0x35, 0xe8, 0x11, 0xee, 0xa9, 0xcb, 0x38, 0xae, 0x92, 0xca, 0x71, 0x11, 0xb8, 0x30, 0xda, 0x5b,
	0x55, 0xa2, 0xbd, 0x58, 0xfb, 0x99, 0x6b, 0xf9, 0x54, 0x84, 0xed, 0x79, 0x01, 0x6b, 0x9b, 0xd4,
	0x37, 0xbd, 0x7a, 0x8d, 0x05, 0x18, 0x78, 0x41, 0x9f, 0xe7, 0x14, 0x64, 0x61, 0xbb, 0x59, 0x4e,
	0x0f, 0xee, 0x58, 0xe3, 0xa7, 0xbe, 0x0e, 0x33, 0x01, 0xd3, 0x31, 0x22, 0xdf, 0x01, 0x08, 0x2a,
	0x24, 0xa5, 0x2f, 0x47, 0x28, 0x1d, 0x34, 0x1b, 0x0a, 0xa4, 0xfe, 0x08, 0x6a, 0x5c, 0x6e, 0x59,
	0x1d, 0x1e, 0xbd, 0x77, 0xc3, 0x81, 0x85, 0x73, 0x9e, 0xac, 0x14, 0x45, 0x20, 0x2a, 0x9c, 0xe5,
	0x4d, 0xc8, 0x2e, 0x77, 0xbb, 0x42, 0x85, 0x37, 0x92, 0xc7, 0x66, 0x19, 0x2a, 0x04, 0xd3, 0xff,
	0x46, 0x83, 0x59, 0x5c, 0x29, 0xdf, 0x36, 0x97, 0x93, 0x31, 0x59, 0x7c, 0xe6, 0xa1, 0xbc, 0x66,
	0xb9, 0x9e, 0xcf, 0xf8, 0x8a, 0x2b, 0xd2, 0xb0, 0x82, 0xab, 0x2e, 0xd1, 0x98, 0x95, 0xaa, 0x4b,
	0xb4, 0xcd, 0x43, 0x59, 0xaa, 0x31, 0xaf, 0x9e, 0x63, 0xdb, 0x1b, 0x56, 0x20, 0xd3, 0xac, 0x76,
	0x2d, 0xdf, 0x71, 0xbd, 0x7a, 0x9e, 0xb5, 0xc9, 0x22, 0xb6, 0xdc, 0xa7, 0x9e, 0x87, 0xda, 0x90,
	0xb3, 0xa1, 0x2c, 0xea, 0x4b, 0x50, 0xe5, 0xb3, 0x16, 0x79, 0x32, 0x1d, 0xaa, 0xc1, 0xe2, 0xa8,
	0xe7, 0x89, 0x89, 0x47, 0xea, 0xf4, 0xdf, 0x84, 0xd2, 0xf2, 0xd0, 0x3f, 0xde, 0xb4, 0x0f, 0x9d,
	0x49, 0x52, 0xe2, 0x9a, 0xb9, 0x44, 0x71, 0x89, 0x11, 0x62, 0x14, 0xb0, 0x4a, 0x3e, 0xc6, 0x2a,
	0x9c, 0xad, 0x0a, 0x6a, 0x12, 0xe1, 0xb7, 0x60, 0x66, 0xf5, 0xb1, 0x4f, 0x5d, 0xdb, 0xec, 0xed,
	0x39, 0x0f, 0xa9, 0x8d, 0xf2, 0x3b, 0xb4, 0xba, 0x52, 0x7e, 0xbf, 0x92, 0xf2, 0x3b, 0xb4, 0x58,
	0x3a, 0xe9, 0xd8, 0xf1, 0x7c, 0xb1, 0x8d, 0xec, 0x1b, 0x7b, 0xf5, 0x11, 0x4f, 0x06, 0x01, 0x58,
	0x01, 0x6b, 0xbd, 0x8e, 0x33, 0x90, 0x92, 0xcc, 0x0b, 0xfa, 0x3f, 0x69, 0x90, 0x6d, 0xd1, 0x43,
	0x72, 0x83, 0xfd, 0x11, 0x0c, 0x02, 0x8b, 0x9c, 0xcc, 0x2d, 0x7a, 0x18, 0x3b, 0x9e, 0x19, 0xec,
	0x1b, 0x50, 0x6c, 0x39, 0x9d, 0x8d, 0xbd, 0xfb, 0x5b, 0x82, 0x39, 0x66, 0x02, 0xf9, 0xc1, 0x4a,
	0x43, 0xb6, 0x92, 0xbb, 0x00, 0x6b, 0x7d, 0xbf, 0xed, 0xbb, 0x96, 0x7d, 0x24, 0x2d, 0x90, 0x97,
	0xc2, 0xbe, 0xd7, 0x1c, 0xb7, 0x6f, 0xca, 0x66, 0x43, 0x01, 0x45, 0x3a, 0xe3, 0xe9, 0xe0, 0x6f,
	0x59, 0x36, 0x9f, 0xef, 0x8c, 0x11, 0x56, 0x30, 0x3a, 0xdb, 0x5d, 0xd6, 0x96, 0x67, 0x6d, 0xb2,
	0xa8, 0x8f, 0xd9, 0xf1, 0xb9, 0x4e, 0x03, 0x93, 0xff, 0x1a, 0x64, 0x5b, 0x4e, 0x67, 0x6a, 0xca,
	0x13, 0x01, 0xc8, 0xc7, 0x30, 0x8b, 0x0a, 0x66, 0xe8, 0x53, 0xec, 0xc7, 0x30, 0x6d, 0x91, 0xa2,
	0x4d, 0x43, 0x9a, 0x80, 0xd6, 0xff, 0xb6, 0x08, 0xb5, 0x16, 0x3d, 0x7c, 0xf1, 0x89, 0x9f, 0x79,
	0x28, 0x37, 0xc7, 0x3e, 0x65, 0xdb, 0xc1, 0xf6, 0x74, 0xc6, 0x08, 0x2b, 0x58, 0x62, 0x72, 0xec,
	0xd3, 0x55, 0xbb, 0x2b, 0xf6, 0x4d, 0x16, 0x19, 0xd5, 0xe8, 0xe1, 0x27, 0x74, 0xcc, 0xa5, 0x03,
	0xa9, 0x16, 0x50, 0xe2, 0x13, 0x3a, 0x36, 0x64, 0x2b, 0xb9, 0xc3, 0x43, 0xd0, 0x06, 0x1d, 0x79,
	0xf5, 0x42, 0x3c, 0xbb, 0x14, 0xcc, 0x87, 0xe7, 0x99, 0x74, 0x23, 0x80, 0x25, 0xb7, 0xa1, 0xb4,
	0x6f, 0x5b, 0x3e, 0xcb, 0xec, 0x14, 0xa7, 0xac, 0x23, 0x80, 0xc2, 0x0d, 0xc2, 0xef, 0xe9, 0x79,
	0x20, 0x84, 0x08, 0xdc, 0xe6, 0xf2, 0x49, 0x6e, 0x33, 0x6e, 0xe5, 0x9a, 0xd5, 0xa3, 0x5e, 0x1d,
	0xd8, 0xd4, 0x53, 0xb6, 0x92, 0x81, 0x90, 0xf7, 0xa1, 0x86, 0x1f, 0x88, 0xb7, 0xeb, 0xd2, 0x43,
	0xeb, 0x31, 0x8f, 0x2c, 0xa5, 0x20, 0xc5, 0x60, 0xc9, 0x6d, 0xc8, 0x7f, 0x62, 0xd9, 0x5d, 0xaf,
	0x5e, 0x3d, 0x71, 0x93, 0x38, 0x20, 0xee, 0xd0, 0xea, 0xe3, 0x81, 0xe3, 0xca, 0x30, 0x53, 0x1a,
	0x77, 0x05, 0x50, 0x88, 0xb1, 0xed, 0xd8, 0x3d, 0xa7, 0x63, 0xf6, 0x78, 0x0a, 0x38, 0x0d, 0x43,
	0x42, 0x91, 0x3b, 0x50, 0x11, 0xfe, 0xec, 0x1e, 0xf5, 0x78, 0x6e, 0x38, 0x0d, 0x49, 0x05, 0x94,
	0x92, 0x32, 0x7b, 0x92, 0xa4, 0xe0, 0xfe, 0x0e, 0x9f, 0x3c, 0x19, 0xb3, 0x94, 0x70, 0x29, 0x75,
	0x7f, 0x11, 0x24, 0xc8, 0x39, 0x92, 0xb3, 0xe5, 0x1c, 0x2f, 0x9e, 0x2e, 0xe7, 0x18, 0x73, 0x70,
	0xe6, 0x9e, 0xdd, 0xc1, 0xf9, 0x2f, 0x0d, 0x88, 0x90, 0x5d, 0x83, 0x1e, 0xaa, 0x91, 0xa4, 0xd0,
	0xc1, 0x48, 0x9b, 0x3e, 0x73, 0x19, 0x02, 0xa6, 0xcb, 0x9c, 0xcc, 0x74, 0xcf, 0x2f, 0x9e, 0x71,
	0x5b, 0x89, 0xe2, 0x4f, 0x8b, 0x27, 0x85, 0x29, 0x9c, 0x1f, 0x30, 0x1d, 0xf0, 0x2c, 0x69, 0x47,
	0x6c, 0x0b, 0xa4, 0x5b, 0x1c, 0xcb, 0x81, 0x1c, 0x13, 0x21, 0xc7, 0xc2, 0x46, 0x64, 0x12, 0x4b,
	0x84, 0xc4, 0x72, 0x2f, 0x87, 0x87, 0xb4, 0x8e, 0xa0, 0xdc, 0xa2, 0x87, 0x1e, 0xd3, 0xcf, 0x68,
	0x5e, 0x84, 0x27, 0xce, 0x5c, 0x64, 0xfd, 0x62, 0x8e, 0xc2, 0x22, 0x61, 0x67, 0xce, 0x4d, 0x35,
	0x58, 0xd0, 0x88, 0x43, 0x87, 0x1a, 0x9f, 0x07, 0x08, 0x7e, 0x87, 0xad, 0x93, 0x19, 0x52, 0xaf,
	0x41, 0x0e, 0xc7, 0x14, 0x26, 0xd4, 0x6c, 0x1c, 0xd3, 0x60, 0xad, 0xe4, 0x93, 0xe8, 0x65, 0x1b,
	0x31, 0xce, 0xcb, 0x13, 0x54, 0x49, 0xf1, 0x5a, 0x23, 0xc8, 0xfa, 0xf7, 0xd9, 0x49, 0xe0, 0x85,
	0xec, 0x74, 0xc6, 0xb5, 0x7e, 0x5b, 0x5d, 0xeb, 0x42, 0x1c, 0x3a, 0xc6, 0xa5, 0xc1, 0x82, 0x0d,
	0xb1, 0xe0, 0x2b, 0x48, 0xd8, 0x60, 0xc1, 0xf2, 0x28, 0x37, 0x70, 0xa9, 0x58, 0xff, 0x22, 0x9c,
	0xf4, 0x9f, 0x6a, 0xd0, 0x08, 0x67, 0x26, 0x8d, 0xf8, 0x40, 0x8e, 0x6e, 0xa8, 0x79, 0xcc, 0x54,
	0xe9, 0x60, 0x20, 0xcf, 0x31, 0x6a, 0xf1, 0x43, 0x0d, 0x2e, 0x2b, 0x64, 0x50, 0x66, 0x75, 0x46,
	0x72, 0xdc, 0x53, 0xc9, 0xf1, 0x46, 0x0a, 0x39, 0xe2, 0x8b, 0xe6, 0x64, 0xf9, 0x7d, 0xae, 0x58,
	0xd8, 0x1c, 0x56, 0x1f, 0x9b, 0xfd, 0x41, 0x8f, 0x9e, 0x7d, 0xfc, 0xe7, 0x17, 0xbe, 0xfa, 0x3b,
	0x0d, 0x66, 0xd5, 0xb9, 0x32, 0x7e, 0x79, 0x4b, 0x1e, 0xf7, 0x87, 0xc9, 0xe9, 0x72, 0x14, 0x12,
	0xde, 0x6e, 0x04, 0x80, 0x2f, 0x80, 0x89, 0xd0, 0xb1, 0x67, 0x97, 0xd7, 0x38, 0xab, 0x64, 0x99,
	0x5a, 0x52, 0x6a, 0xf4, 0xdf, 0x06, 0x08, 0xa7, 0x12, 0x51, 0x5f, 0x65, 0xa1, 0xbe, 0xe6, 0x20,
	0xbf, 0xe2, 0x0c, 0x6d, 0x5f, 0x58, 0xe3, 0xbc, 0xc0, 0xc2, 0x0e, 0x1d, 0xc7, 0xe5, 0x5a, 0x2b,
	0x63, 0xf0, 0x02, 0x79, 0x53, 0x6a, 0xec, 0x5c, 0xf2, 0x92, 0xb1, 0x11, 0x97, 0xcc, 0xa1, 0xf4,
	0x2d, 0x36, 0xb8, 0xa8, 0x0c, 0x74, 0x9b, 0x16, 0xea, 0xb6, 0xb3, 0x0c, 0xae, 0xff, 0xb3, 0xc6,
	0xf3, 0x23, 0x7b, 0x2e, 0xa5, 0x8a, 0xb1, 0xca, 0x8c, 0x50, 0xdb, 0xa7, 0xb6, 0xef, 0x2d, 0x7b,
	0xdc, 0x14, 0xe6, 0x91, 0x82, 0x74, 0x23, 0x34, 0x0a, 0x8d, 0x64, 0x59, 0xa7, 0x3e, 0x4e, 0x53,
	0x72, 0x4b, 0x3e, 0x81, 0x2c, 0x51, 0x90, 0x38, 0x59, 0xa2, 0xad, 0xe8, 0x10, 0x6d, 0x3b, 0x3c,
	0x83, 0xbc, 0x6c, 0xdb, 0x9e, 0xf0, 0x54, 0x22, 0x75, 0xfa, 0x1f, 0x66, 0xe3, 0xe3, 0x92, 0x26,
	0xfa, 0x78, 0x3d, 0x61, 0x49, 0x73, 0x46, 0x8f, 0xba, 0xaf, 0x41, 0x6b, 0x6c, 0xfc, 0x10, 0x8d,
	0xbc, 0x0d, 0xb0, 0x6a, 0xfb, 0x96, 0x4b, 0xb1, 0x6a, 0xaa, 0x39, 0xae, 0xc0, 0x91, 0x16, 0x90,
	0xd5, 0xc7, 0x03, 0xd3, 0xee, 0x8a, 0x5b, 0x29, 0x68, 0xa2, 0x0b, 0x7e, 0x4a, 0xc1, 0x4e, 0x80,
	0x47, 0x83, 0x64, 0x6d, 0xd8, 0xeb, 0x71, 0xe4, 0x69, 0x44, 0x08, 0xc1, 0x10, 0xc7, 0xa0, 0x9d,
	0xa1, 0xeb, 0x59, 0x23, 0xe1, 0xe7, 0xa5, 0xe1, 0x04, 0x60, 0xe4, 0x01, 0xbc, 0xc2, 0x0b, 0xb4,
	0x6d, 0xd9, 0x47, 0x3d, 0xda, 0x1e, 0x1e, 0x1c, 0x3a, 0xbd, 0x2e, 0x75, 0xb7, 0x2c, 0x99, 0x4c,
	0x48, 0x9b, 0xf6, 0x34, 0x44, 0xfd, 0x0b, 0x1e, 0x89, 0x47, 0x0e, 0x6b, 0x53, 0xd3, 0xed, 0x1c,
	0x4b, 0xc2, 0xac, 0xc1, 0x4c, 0xa4, 0x42, 0x10, 0x87, 0xb0, 0x50, 0x6e, 0xa4, 0x25, 0x46, 0x98,
	0x28, 0x9a, 0xfe, 0x27, 0xe2, 0xb2, 0x4c, 0x38, 0x82, 0x41, 0xbd, 0x61, 0xcf, 0x27, 0x2b, 0x50,
	0x55, 0xcb, 0xa2, 0xff, 0x0b, 0x4a, 0xff, 0xbc, 0x21, 0x7e, 0x84, 0x46, 0x3a, 0x79, 0x07, 0xcf,
	0x33, 0xe6, 0x57, 0x24, 0xea, 0xbb, 0xc9, 0x4b, 0x37, 0x12, 0x5c, 0x7f, 0xc2, 0x13, 0xe7, 0x81,
	0x68, 0x91, 0x3b, 0x90, 0x5f, 0xb5, 0x7d, 0x77, 0x2c, 0x26, 0x12, 0xb5, 0x1d, 0x10, 0x8c, 0xb5,
	0x2a, 0x5d, 0x71, 0xf0, 0x69, 0xa7, 0xf0, 0xa4, 0xec, 0x72, 0x75, 0xff, 0x04, 0xd5, 0x6b, 0x74,
	0xd3, 0xc9, 0xed, 0x30, 0x1d, 0x71, 0xf2, 0x2a, 0x58, 0xba, 0xe2, 0x6d, 0x75, 0x60, 0x3d, 0x71,
	0xe0, 0x08, 0x29, 0xf8, 0xd8, 0x4d, 0x7e, 0xcd, 0x04, 0x5b, 0xb9, 0xca, 0x3f, 0xfb, 0xc8, 0xfa,
	0x8d, 0x50, 0x2d, 0x09, 0x83, 0x06, 0x69, 0x31, 0x27, 0x55, 0x25, 0xbf, 0x30, 0x23, 0x34, 0xe2,
	0x9f, 0x69, 0x70, 0xf1, 0xc1, 0x4a, 0x5b, 0xa5, 0x1a, 0x3b, 0x4e, 0xee, 0x4a, 0xfe, 0xe2, 0x75,
	0x61, 0x94, 0x32, 0x4e, 0x7f, 0x23, 0x0a, 0xf7, 0x7c, 0x4d, 0xb0, 0x7f, 0xd0, 0xa0, 0x1c, 0xd0,
	0x96, 0xdc, 0x87, 0x5a, 0xd3, 0xf4, 0xac, 0x4e, 0x50, 0x23, 0x36, 0x25, 0xaa, 0x16, 0xa3, 0x20,
	0xcd, 0x52, 0xa8, 0x12, 0xa3, 0x2d, 0xe4, 0x43, 0x55, 0xb7, 0x65, 0xa6, 0xea, 0xb6, 0x52, 0x92,
	0x5e, 0x13, 0x39, 0x43, 0xd4, 0xdc, 0x42, 0xcb, 0x67, 0xc3, 0x9c, 0x61, 0x58, 0xab, 0xff, 0xa3,
	0x16, 0x9f, 0x77, 0x10, 0x8d, 0xd5, 0x94, 0x68, 0xec, 0xa2, 0xb8, 0x4d, 0xc9, 0xaf, 0xe5, 0xa7,
	0xf0, 0x37, 0xbf, 0x70, 0xc0, 0xac, 0x75, 0xd5, 0xca, 0xcf, 0x4e, 0x5a, 0xf9, 0x72, 0x12, 0x4c,
	0x83, 0x55, 0x8d, 0xa0, 0x4c, 0xbe, 0x03, 0x45, 0xec, 0xca, 0xa2, 0x3c, 0x2c, 0x30, 0x7d, 0xfb,
	0x0c, 0x09, 0xab, 0x7f, 0x0f, 0x66, 0x22, 0x52, 0xa6, 0xca, 0xb6, 0x76, 0x26, 0xd9, 0x0e, 0xce,
	0xdd, 0x8c, 0xe2, 0x53, 0xfc, 0x8b, 0xa6, 0x50, 0x03, 0x55, 0x70, 0x18, 0x38, 0xc2, 0xde, 0xb3,
	0x69, 0x2a, 0x38, 0x0c, 0x27, 0x2d, 0x86, 0xe1, 0xa4, 0xcc, 0x14, 0x0c, 0x09, 0x14, 0x8c, 0xd1,
	0x1c, 0xfb, 0xfc, 0x5c, 0x9f, 0x3e, 0x06, 0x82, 0x89, 0x31, 0x18, 0x46, 0xee, 0x84, 0x31, 0x10,
	0x48, 0x1f, 0x70, 0xbb, 0x51, 0xe4, 0xbb, 0x36, 0xed, 0x2e, 0x7d, 0x9c, 0x92, 0xf1, 0xba, 0x0d,
	0x17, 0x05, 0x94, 0x6a, 0xd9, 0x89, 0xb4, 0x44, 0x52, 0x13, 0x93, 0x67, 0xc7, 0xed, 0x50, 0x79,
	0x73, 0x99, 0x15, 0xf4, 0xcf, 0xe1, 0xd2, 0xb2, 0x37, 0xb6, 0x3b, 0xea, 0x90, 0xa9, 0x79, 0xfe,
	0xcb, 0x50, 0x68, 0x33, 0x92, 0x09, 0x52, 0x88, 0x52, 0x4a, 0xd7, 0x23, 0xa8, 0x2d, 0x0f, 0xfd,
	0x63, 0xc7, 0xf5, 0x8e, 0xad, 0x01, 0x8b, 0x9a, 0x7e, 0x0c, 0xb5, 0x2d, 0x53, 0x26, 0x6f, 0x5b,
	0xa6, 0x4f, 0x83, 0x53, 0x28, 0xed, 0xd6, 0x67, 0x0c, 0x1e, 0xcd, 0x92, 0xb0, 0x26, 0x70, 0x57,
	0x23, 0x75, 0xfa, 0x1f, 0x68, 0xcc, 0xdf, 0xe4, 0x63, 0xa7, 0xc7, 0xa2, 0xc3, 0x14, 0x45, 0x26,
	0x9e, 0xa2, 0xd8, 0x66, 0xf1, 0xc4, 0x70, 0xf2, 0xc2, 0x1f, 0x99, 0xf0, 0x3f, 0x43, 0x88, 0xf8,
	0xa1, 0x19, 0x69, 0xd4, 0xff, 0x5c, 0x8b, 0x75, 0x88, 0x16, 0x5b, 0x74, 0x6f, 0x12, 0x55, 0x53,
	0x14, 0x24, 0x6e, 0xb1, 0xc5, 0x36, 0x77, 0x0e, 0xf2, 0xc8, 0x43, 0xd2, 0x86, 0xe6, 0x05, 0x72,
	0x1d, 0xce, 0xb3, 0x8f, 0x5d, 0xd7, 0x19, 0x38, 0x6e, 0x70, 0xb7, 0x57, 0x33, 0xe2, 0xd5, 0xba,
	0x09, 0x97, 0x84, 0x5f, 0x23, 0x3a, 0x4e, 0xc9, 0x28, 0x6b, 0xcf, 0xee, 0x88, 0x3c, 0x82, 0x0b,
	0xd2, 0x2d, 0x0a, 0xc6, 0x38, 0xa3, 0x57, 0x34, 0xe5, 0x94, 0x4c, 0x9c, 0x3d, 0x3f, 0x25, 0xd7,
	0x95, 0xfd, 0x97, 0x79, 0x96, 0x90, 0x20, 0x89, 0x79, 0x96, 0xa0, 0xd9, 0x50, 0x20, 0xf5, 0x8f,
	0xd1, 0xca, 0x71, 0x47, 0xd4, 0xe5, 0x2f, 0x64, 0x48, 0x1d, 0x8a, 0xe2, 0x72, 0xa5, 0xe0, 0x2f,
	0x59, 0x44, 0x59, 0x59, 0x1e, 0x0c, 0x42, 0xf6, 0x12, 0x25, 0xfd, 0x7f, 0x34, 0x28, 0xef, 0x7b,
	0xd4, 0x5d, 0x1d, 0x51, 0x9b, 0x85, 0x4b, 0x98, 0x12, 0x17, 0x8a, 0x9d, 0x29, 0xea, 0xc9, 0xdc,
	0x42, 0x3d, 0x7c, 0x84, 0xc5, 0x63, 0x2d, 0xc1, 0xeb, 0xaa, 0xcb, 0x50, 0xb8, 0x4f, 0xfd, 0x63,
	0xa7, 0x2b, 0x02, 0x2e, 0xa2, 0x84, 0xf5, 0xc2, 0x0e, 0xe3, 0x89, 0x0f, 0x51, 0x8a, 0x3e, 0x20,
	0x29, 0x9e, 0xe6, 0x01, 0x89, 0x92, 0x43, 0x29, 0x45, 0x72, 0x28, 0xea, 0xda, 0xcb, 0xd1, 0xb5,
	0xb3, 0x0b, 0x8a, 0x5b, 0xe2, 0x42, 0x1f, 0x7e, 0xea, 0x7f, 0x95, 0x85, 0x7c, 0xfa, 0x8a, 0x2f,
	0x43, 0x01, 0xb7, 0x24, 0x90, 0x67, 0x51, 0x62, 0x29, 0x3d, 0x8a, 0xeb, 0x0c, 0x8f, 0x2c, 0x59,
	0xc6, 0x95, 0x04, 0xf3, 0x15, 0xee, 0x4e, 0xe2, 0x4a, 0x82, 0x4f, 0xb2, 0x0d, 0x35, 0xec, 0x17,
	0x59, 0x9e, 0xba, 0x7e, 0x78, 0x9e, 0x45, 0xef, 0xa0, 0xb0, 0x59, 0x2e, 0x46, 0x01, 0xf9, 0xd1,
	0x16, 0xc3, 0x26, 0x9f, 0xc2, 0x79, 0x06, 0xac, 0x74, 0x58, 0x64, 0x1d, 0xbe, 0x91, 0xd0, 0x61,
	0x0c, 0x92, 0xf7, 0x18, 0xc7, 0x6f, 0x2c, 0xc3, 0xc5, 0x84, 0x91, 0x71, 0x3f, 0x1f, 0xd2, 0xb1,
	0xbc, 0xdb, 0xf2, 0x90, 0x8e, 0x51, 0xd8, 0x47, 0x66, 0x6f, 0x18, 0x5c, 0xf1, 0x67, 0x85, 0x77,
	0x33, 0xef, 0x68, 0x8d, 0x26, 0xcc, 0x25, 0x8d, 0x75, 0x96, 0x3e, 0x74, 0x0b, 0xca, 0xac, 0x0f,
	0x26, 0x2a, 0x37, 0xa0, 0xc0, 0x0a, 0x52, 0x4c, 0xc8, 0xe4, 0xea, 0x0c, 0x01, 0xa1, 0xb2, 0x44,
	0x26, 0x4d, 0x1c, 0xb2, 0x11, 0x71, 0xf8, 0x99, 0x06, 0xb0, 0x6c, 0xdb, 0x8e, 0xcf, 0x33, 0x87,
	0x82, 0x73, 0x82, 0x0b, 0xbb, 0x5b, 0xe4, 0x5b, 0xea, 0xb1, 0x8b, 0x9d, 0xce, 0x34, 0x67, 0xbe,
	0x7e, 0xba, 0x10, 0x56, 0xaa, 0xe7, 0xed, 0xeb, 0xe1, 0x79, 0xcb, 0x52, 0x24, 0xcd, 0xca, 0xd7,
	0x4f, 0x17, 0x64, 0x55, 0x70, 0xcc, 0x32, 0xa7, 0xbd, 0x67, 0x7a, 0x9e, 0xcc, 0x89, 0xb1, 0x02,
	0x9e, 0x09, 0x9f, 0x99, 0xb6, 0xbf, 0x69, 0xdb, 0x94, 0xdf, 0xed, 0xcd, 0x1b, 0x61, 0x05, 0xbf,
	0x3e, 0xbe, 0x25, 0x52, 0x23, 0x06, 0xfb, 0xc6, 0xd9, 0xa2, 0xea, 0x62, 0x6f, 0x5f, 0x98, 0x7a,
	0xd2, 0x3d, 0xa8, 0x85, 0xab, 0x61, 0xdb, 0x77, 0x0f, 0x2a, 0x61, 0x4d, 0x72, 0xa8, 0x25, 0x6c,
	0x37, 0x54, 0x58, 0x34, 0x18, 0xd1, 0xf2, 0x08, 0x96, 0xc7, 0xe3, 0xcc, 0x33, 0x46, 0xac, 0x16,
	0x8f, 0x97, 0xcb, 0x0a, 0x9e, 0x1a, 0x2b, 0x7e, 0x56, 0x2f, 0xe8, 0x26, 0xe4, 0x4f, 0x61, 0xe7,
	0x1a, 0x1c, 0x68, 0x22, 0x58, 0x90, 0x4d, 0x08, 0x16, 0xfc, 0x58, 0x83, 0x57, 0x95, 0x49, 0xae,
	0x53, 0x1f, 0xd5, 0xaa, 0xbf, 0xeb, 0x78, 0xff, 0xdf, 0xb9, 0x12, 0xc8, 0x05, 0x56, 0xdc, 0x8c,
	0xc1, 0xbe, 0x91, 0x96, 0x2b, 0xc7, 0xa6, 0x6b, 0x76, 0x7c, 0x71, 0x27, 0x68, 0xc6, 0x08, 0x2b,
	0xf4, 0xdf, 0xcd, 0xc6, 0xbc, 0xe1, 0x68, 0xac, 0x32, 0x3f, 0x3d, 0x56, 0xc9, 0x92, 0x33, 0x3e,
	0x07, 0xcf, 0x4c, 0x01, 0x0f, 0xa0, 0x9e, 0x63, 0xec, 0x5f, 0x87, 0xaa, 0xc8, 0xde, 0xf0, 0xf1,
	0xf9, 0x8d, 0x92, 0x48, 0x5d, 0x34, 0x5b, 0x5e, 0x88, 0x67, 0xcb, 0x19, 0xad, 0xfc, 0x10, 0xa0,
	0xc8, 0x00, 0x22, 0x75, 0x28, 0x1f, 0x3c, 0xc5, 0x55, 0xe2, 0xae, 0x1f, 0x4f, 0x63, 0x35, 0xd8,
	0xba, 0x79, 0x43, 0x99, 0x35, 0x04, 0x65, 0x76, 0x21, 0xc8, 0xf4, 0x7c, 0x71, 0xf1, 0x82, 0x7d,
	0xb3, 0x97, 0xbf, 0xbd, 0x9e, 0xf3, 0x68, 0x15, 0xb7, 0x43, 0x3e, 0x89, 0x0c, 0x6b, 0xf4, 0x6d,
	0x28, 0x05, 0xee, 0xf2, 0x9c, 0xcc, 0x84, 0x0a, 0x2b, 0x8d, 0xe7, 0x3c, 0xa7, 0x44, 0xff, 0x13,
	0x5c, 0xe1, 0x7b, 0xdc, 0x0d, 0x8f, 0x04, 0x14, 0x5e, 0x8f, 0x3c, 0xe1, 0x49, 0x78, 0x59, 0xc1,
	0x9a, 0xf5, 0xd7, 0x43, 0xef, 0x75, 0x80, 0x0c, 0x99, 0x3c, 0x1f, 0xfd, 0x63, 0xb8, 0xa4, 0x80,
	0x29, 0xde, 0xef, 0xa9, 0x9f, 0xec, 0x0c, 0xe1, 0x3c, 0x1a, 0x35, 0xea, 0x14, 0x6f, 0xab, 0xf6,
	0xcf, 0x44, 0xa2, 0x22, 0x29, 0x11, 0x1f, 0x44, 0x17, 0x33, 0x6a, 0x68, 0x93, 0x3d, 0x10, 0x3b,
	0xe4, 0xc1, 0x48, 0x6e, 0x02, 0x06, 0x65, 0xfd, 0xa9, 0x06, 0x17, 0x22, 0x6e, 0x37, 0x9b, 0xf5,
	0x47, 0xf2, 0x45, 0x9a, 0xea, 0xb1, 0xbf, 0x3a, 0xf9, 0x60, 0x49, 0xf5, 0xde, 0x55, 0x0c, 0xf2,
	0xbe, 0x88, 0xcd, 0x72, 0xfc, 0x0c, 0xc3, 0x9f, 0x9f, 0xb0, 0xe0, 0x54, 0x74, 0x05, 0x9e, 0x7c,
	0x17, 0x08, 0x6f, 0x63, 0x9b, 0x1b, 0x0a, 0x47, 0xf6, 0x04, 0x62, 0x27, 0x60, 0xdd, 0xf8, 0x75,
	0xc5, 0xdb, 0x64, 0x26, 0xc5, 0x0c, 0x77, 0x0f, 0x59, 0xc5, 0xec, 0x39, 0x52, 0x85, 0x52, 0xcb,
	0x72, 0x79, 0x49, 0x23, 0xb3, 0x50, 0x6d, 0x8f, 0xfb, 0x3d, 0xcb, 0x7e, 0xc8, 0x6b, 0x32, 0x84,
	0x40, 0xad, 0x3d, 0x3c, 0xe8, 0x3b, 0xdd, 0xa1, 0xc4, 0xc9, 0x36, 0x72, 0x3f, 0xfa, 0x8b, 0x2b,
	0xe7, 0x96, 0x7e, 0xa1, 0x45, 0xdf, 0x96, 0x91, 0x16, 0x54, 0xd6, 0xa9, 0x2f, 0xdf, 0xa5, 0x93,
	0x54, 0x2f, 0xb6, 0x11, 0xb5, 0xe5, 0x63, 0x0f, 0xd9, 0xef, 0x89, 0x5e, 0x46, 0xd4, 0x45, 0x5b,
	0x2a, 0xbc, 0x4a, 0xf1, 0xc0, 0xb1, 0xba, 0x31, 0xd4, 0xd8, 0x63, 0xb7, 0x16, 0x14, 0xb8, 0x79,
	0x46, 0x7e, 0x2d, 0x05, 0x2c, 0x7c, 0xc3, 0xd6, 0x48, 0x7b, 0x7f, 0xb6, 0xf4, 0xb3, 0xb2, 0xe0,
	0x59, 0x72, 0x0b, 0xb2, 0xeb, 0xd4, 0x27, 0x97, 0x26, 0x21, 0x71, 0x15, 0x93, 0xbc, 0x4c, 0x9a,
	0xe8, 0xc9, 0xb3, 0x37, 0x51, 0xa4, 0x91, 0xb0, 0x7a, 0xf1, 0x5a, 0x2a, 0x61, 0x11, 0xca, 0x63,
	0xa8, 0xf7, 0x50, 0x69, 0x7b, 0x3e, 0x99, 0x4f, 0xbc, 0x00, 0x2c, 0xc8, 0xda, 0xb8, 0x94, 0xd8,
	0x4a, 0xee, 0x06, 0x3b, 0xd0, 0x48, 0x7f, 0x70, 0x94, 0x34, 0xf3, 0xbb, 0x50, 0xe0, 0xd7, 0xa4,
	0x92, 0x10, 0xe5, 0x83, 0x89, 0x24, 0xc4, 0x45, 0x28, 0xb4, 0x68, 0x8f, 0xfa, 0x34, 0x6d, 0x9b,
	0xa2, 0x04, 0x24, 0xef, 0x41, 0x99, 0x91, 0x97, 0x39, 0x09, 0x29, 0x28, 0x93, 0xa4, 0x11, 0xf0,
	0x4b, 0x02, 0x99, 0xdd, 0x4b, 0x4f, 0xe7, 0x2f, 0xf5, 0x25, 0x00, 0x59, 0x03, 0x08, 0x9f, 0x01,
	0x92, 0x2b, 0x93, 0xab, 0x53, 0x1f, 0x09, 0x36, 0xe2, 0x9d, 0x86, 0x2f, 0x01, 0xd7, 0xf9, 0x51,
	0x25, 0xdf, 0x15, 0x4c, 0x06, 0x40, 0xa3, 0x8f, 0x3b, 0x62, 0x8b, 0x50, 0x1e, 0x2e, 0x6c, 0xf2,
	0xb8, 0x5e, 0x70, 0xa3, 0xfd, 0x6a, 0x72, 0x4f, 0xe1, 0xb5, 0xff, 0x58, 0x57, 0xca, 0xad, 0xf9,
	0x0f, 0xa1, 0x24, 0x6f, 0x39, 0x27, 0xf0, 0x8b, 0x72, 0xa1, 0xbd, 0x11, 0x75, 0x1f, 0xe5, 0xed,
	0xe5, 0x8f, 0x60, 0x66, 0xd5, 0x36, 0x0f, 0x7a, 0x54, 0xbc, 0xd1, 0x4d, 0x58, 0x55, 0xf4, 0xf5,
	0x6e, 0x9c, 0x9a, 0x77, 0xf8, 0x04, 0x5a, 0x74, 0xe0, 0x91, 0xe8, 0x10, 0xe2, 0x71, 0x61, 0x23,
	0xb1, 0x96, 0xec, 0xa2, 0x01, 0xa7, 0x5e, 0x56, 0x27, 0xfa, 0xb4, 0xfd, 0xe4, 0xd7, 0xd9, 0x1b,
	0x8d, 0x84, 0x2d, 0x95, 0xf7, 0xce, 0x3f, 0x87, 0x57, 0xd6, 0xa9, 0x3f, 0xf1, 0xb2, 0x6f, 0xcd,
	0x71, 0x59, 0x36, 0x6a, 0x8a, 0xcd, 0xd4, 0x88, 0xf2, 0xc4, 0xe4, 0xe3, 0xc0, 0x0f, 0xa1, 0xba,
	0x4e, 0xfd, 0x4d, 0xf9, 0xd3, 0x20, 0x53, 0x18, 0x6f, 0x6e, 0x31, 0xfc, 0x01, 0x91, 0x10, 0xfe,
	0x43, 0x3c, 0x4d, 0x82, 0x77, 0xa2, 0x13, 0x02, 0xa6, 0xbc, 0x20, 0x6d, 0x44, 0xdf, 0x1b, 0x89,
	0x17, 0x98, 0xef, 0x03, 0x84, 0x0f, 0x41, 0x49, 0x34, 0x00, 0xac, 0xbe, 0x10, 0x4d, 0xc4, 0x5e,
	0xda, 0x85, 0x8a, 0x72, 0x61, 0x9c, 0x2c, 0xa3, 0x38, 0xc8, 0x4b, 0xe3, 0x24, 0xfa, 0x24, 0x25,
	0xe5, 0x62, 0x79, 0x8c, 0xe8, 0x4b, 0xff, 0x99, 0xe5, 0x57, 0x08, 0xa4, 0x7e, 0x9c, 0x08, 0x0f,
	0xf0, 0x0b, 0x0d, 0x8d, 0x89, 0x23, 0x9b, 0xdc, 0x13, 0xba, 0xed, 0x95, 0xa4, 0xf0, 0x84, 0x64,
	0xb1, 0xb9, 0xa4, 0x46, 0xf2, 0x01, 0xe7, 0x34, 0x96, 0x6c, 0x9d, 0x40, 0x57, 0xae, 0x16, 0xc4,
	0xd0, 0xe5, 0x25, 0x80, 0x07, 0x30, 0x1b, 0x4f, 0x4c, 0x93, 0x6f, 0xa4, 0x75, 0xa3, 0xe4, 0xae,
	0x1b, 0xaf, 0x4e, 0x74, 0x17, 0x49, 0x16, 0x6f, 0x73, 0x61, 0x96, 0xb9, 0x6c, 0xb2, 0x90, 0xd8,
	0x67, 0x98, 0xea, 0x3e, 0xa9, 0xbf, 0x4d, 0xae, 0x65, 0x44, 0x54, 0x25, 0xa6, 0xae, 0x26, 0x42,
	0x44, 0x8d, 0x94, 0xc0, 0x9b, 0x50, 0x0e, 0x55, 0x35, 0x76, 0x99, 0x30, 0xb5, 0x68, 0x34, 0x35,
	0x4e, 0xe6, 0x2d, 0xc8, 0xb3, 0x00, 0x28, 0x59, 0x81, 0x5a, 0x34, 0x08, 0x1a, 0x13, 0xd6, 0xc4,
	0x30, 0x69, 0xbc, 0xb7, 0x7f, 0xd5, 0x78, 0x5a, 0x1d, 0x45, 0x8f, 0xdc, 0xe3, 0x8c, 0xd3, 0x48,
	0x4f, 0x22, 0x35, 0x2e, 0x27, 0x0b, 0x2c, 0xd9, 0x84, 0x02, 0xb7, 0x72, 0xc8, 0xab, 0x53, 0x33,
	0x41, 0x8d, 0xa8, 0x5a, 0x4d, 0xca, 0xcc, 0xb4, 0x12, 0xb9, 0x31, 0x9a, 0x34, 0x6a, 0x2c, 0xa4,
	0x36, 0xf2, 0x9e, 0x96, 0xde, 0x85, 0xdc, 0x7d, 0xea, 0x9b, 0x64, 0x09, 0x0a, 0xe2, 0x94, 0x8a,
	0x99, 0x2c, 0x2f, 0xc7, 0x2c, 0xb6, 0x30, 0x48, 0xb6, 0xf4, 0x97, 0x5a, 0xc4, 0x07, 0x26, 0x1b,
	0x62, 0x46, 0xdf, 0x48, 0xf1, 0x82, 0x55, 0x0f, 0x36, 0x66, 0x45, 0xc4, 0x9c, 0xeb, 0x1d, 0x66,
	0x45, 0x49, 0x47, 0x92, 0xdc, 0x48, 0xeb, 0x70, 0xd2, 0xdb, 0x6c, 0x24, 0x46, 0x1a, 0x97, 0xfe,
	0x54, 0x0b, 0x36, 0xfe, 0xa3, 0xe0, 0xeb, 0x52, 0xa2, 0x31, 0x1a, 0x57, 0xa8, 0x13, 0xe6, 0xf5,
	0x7d, 0xa8, 0x28, 0xde, 0x02, 0x69, 0x24, 0x82, 0x33, 0x77, 0xa3, 0xa1, 0xa7, 0xb5, 0x85, 0x74,
	0x6c, 0xce, 0x7e, 0xf9, 0x1f, 0x57, 0xce, 0x7d, 0xf9, 0xd5, 0x15, 0xed, 0xe7, 0x5f, 0x5d, 0xd1,
	0x7e, 0xf9, 0xd5, 0x15, 0xed, 0xa0, 0xc0, 0x7e, 0xbd, 0xe9, 0xad, 0xff, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0x25, 0xdb, 0x02, 0x70, 0x75, 0x4b, 0x00, 0x00,
}
