// Package license handles license key generation and verification. A Sourcegraph Server license has two parts:
// a site ID value, which is used to identify the site in telemetry and must equal the site ID configured for the
// server, and an expiry, which is the expiration date of the license.
//
// License keys are generated by cryptographically signing the JSON value of a license and Base64-encoding the
// license and signature. License keys are verified by Base64-decoding the license key, cryptographically
// verifying the signature, and checking that the license's site ID matches the configured site ID.
package license

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"errors"
	"time"

	"golang.org/x/crypto/ssh"
)

// License is the license metadata.
type License struct {
	SiteID string
	Expiry *time.Time
}

// UnmarshalJSON implements json.Unmarshaler to support unmarshaling
// licenses that use the old AppID field (renamed to SiteID).
func (l *License) UnmarshalJSON(data []byte) error {
	var v struct {
		// These fields must match that of License.
		SiteID string
		Expiry *time.Time

		AppID string // legacy field
	}
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	if v.SiteID != "" && v.AppID != "" {
		return errors.New("license must have either AppID or SiteID field, not both") // unexpected!
	}
	*l = License{Expiry: v.Expiry}
	if v.SiteID != "" {
		l.SiteID = v.SiteID
	} else {
		l.SiteID = v.AppID
	}
	return nil
}

// Expired is true if the license has expired.
func (l License) Expired() bool {
	return l.Expiry != nil && l.Expiry.Before(time.Now())
}

func (l License) signature(privateKey ssh.Signer) (*ssh.Signature, error) {
	message, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return privateKey.Sign(rand.Reader, message)
}

type signedLicense struct {
	License
	Signature *ssh.Signature
}

func (l *signedLicense) UnmarshalJSON(data []byte) error {
	// Because signedLicense's anonymous field License defines a custom
	// UnmarshalJSON method, we need to define our own, or else only l.License's
	// UnmarshalJSON method would be called for json.Unmarshal on a signedLicense type
	// (because of how encoding/json and Go anonymous struct field methods work).
	var v0 License
	if err := json.Unmarshal(data, &v0); err != nil {
		return err
	}
	var v1 struct{ Signature *ssh.Signature }
	if err := json.Unmarshal(data, &v1); err != nil {
		return err
	}
	*l = signedLicense{
		License:   v0,
		Signature: v1.Signature,
	}
	return nil
}

func decode(encoded string) (*signedLicense, error) {
	b, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}
	var l signedLicense
	if err := json.Unmarshal(b, &l); err != nil {
		return nil, err
	}
	return &l, nil
}

func (l signedLicense) encode() (string, error) {
	b, err := json.Marshal(l)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(b), nil
}

func verify(l *signedLicense, publicKey ssh.PublicKey) bool {
	m, err := json.Marshal(l.License)
	if err != nil {
		return false
	}
	return publicKey.Verify(m, l.Signature) == nil
}

func generate(siteID string, expiry *time.Time, privateKey ssh.Signer) (string, error) {
	l := License{SiteID: siteID, Expiry: expiry}
	sig, err := l.signature(privateKey)
	if err != nil {
		return "", err
	}
	return signedLicense{License: l, Signature: sig}.encode()
}
