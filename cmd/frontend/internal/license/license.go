// package license handles license key generation and verification. A Sourcegraph Server license has two parts:
// an AppID, which is used to identify the instance in telemetry and must equal the TRACKING_APP_ID
// environment variable, and an expiry, which is the expiration date of the license.
//
// License keys are generated by cryptographically signing the JSON value of a license and Base64-encoding the
// license and signature. License keys are verified by Base64-decoding the license key, cryptographically
// verifying the signature, and checking the AppID matches the value of the TRACKING_APP_ID environment
// variable.
package license

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"time"

	"golang.org/x/crypto/ssh"
)

// License is the license metadata.
type License struct {
	AppID  string
	Expiry *time.Time
}

// Expired is true if the license has expired.
func (l License) Expired() bool {
	return l.Expiry != nil && l.Expiry.Before(time.Now())
}

func (l License) signature(privateKey ssh.Signer) (*ssh.Signature, error) {
	message, err := json.Marshal(l)
	if err != nil {
		return nil, err
	}
	return privateKey.Sign(rand.Reader, message)
}

type signedLicense struct {
	License
	Signature *ssh.Signature
}

func decode(encoded string) (*signedLicense, error) {
	b, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}
	var l signedLicense
	if err := json.Unmarshal(b, &l); err != nil {
		return nil, err
	}
	return &l, nil
}

func (l signedLicense) encode() (string, error) {
	b, err := json.Marshal(l)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(b), nil
}

func verify(l *signedLicense, publicKey ssh.PublicKey) bool {
	m, err := json.Marshal(l.License)
	if err != nil {
		return false
	}
	return publicKey.Verify(m, l.Signature) == nil
}

func generate(appID string, expiry *time.Time, privateKey ssh.Signer) (string, error) {
	l := License{AppID: appID, Expiry: expiry}
	sig, err := l.signature(privateKey)
	if err != nil {
		return "", err
	}
	return signedLicense{License: l, Signature: sig}.encode()
}
