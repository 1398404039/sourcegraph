/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var errors = require('vs/base/common/errors');
var files_1 = require('vs/workbench/parts/files/common/files');
var textfiles_1 = require('vs/workbench/services/textfile/common/textfiles');
var platform_1 = require('vs/base/common/platform');
var windowService_1 = require('vs/workbench/services/window/electron-browser/windowService');
var editor_1 = require('vs/platform/editor/common/editor');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var lifecycle_1 = require('vs/platform/lifecycle/common/lifecycle');
var lifecycle_2 = require('vs/base/common/lifecycle');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var activityService_1 = require('vs/workbench/services/activity/common/activityService');
var untitledEditorService_1 = require('vs/workbench/services/untitled/common/untitledEditorService');
var arrays = require('vs/base/common/arrays');
var electron_1 = require('electron');
var DirtyFilesTracker = (function () {
    function DirtyFilesTracker(textFileService, lifecycleService, editorGroupService, editorService, activityService, windowService, untitledEditorService) {
        this.textFileService = textFileService;
        this.lifecycleService = lifecycleService;
        this.editorService = editorService;
        this.activityService = activityService;
        this.windowService = windowService;
        this.untitledEditorService = untitledEditorService;
        this.toUnbind = [];
        this.isDocumentedEdited = false;
        this.pendingDirtyResources = [];
        this.stacks = editorGroupService.getStacksModel();
        this.registerListeners();
    }
    DirtyFilesTracker.prototype.registerListeners = function () {
        var _this = this;
        // Local text file changes
        this.toUnbind.push(this.untitledEditorService.onDidChangeDirty(function (e) { return _this.onUntitledDidChangeDirty(e); }));
        this.toUnbind.push(this.textFileService.models.onModelDirty(function (e) { return _this.onTextFileDirty(e); }));
        this.toUnbind.push(this.textFileService.models.onModelSaved(function (e) { return _this.onTextFileSaved(e); }));
        this.toUnbind.push(this.textFileService.models.onModelSaveError(function (e) { return _this.onTextFileSaveError(e); }));
        this.toUnbind.push(this.textFileService.models.onModelReverted(function (e) { return _this.onTextFileReverted(e); }));
        // Lifecycle
        this.lifecycleService.onShutdown(this.dispose, this);
    };
    DirtyFilesTracker.prototype.onUntitledDidChangeDirty = function (resource) {
        var gotDirty = this.untitledEditorService.isDirty(resource);
        if ((!this.isDocumentedEdited && gotDirty) || (this.isDocumentedEdited && !gotDirty)) {
            this.updateDocumentEdited();
        }
        if (gotDirty || this.lastDirtyCount > 0) {
            this.updateActivityBadge();
        }
    };
    DirtyFilesTracker.prototype.onTextFileDirty = function (e) {
        var _this = this;
        if ((this.textFileService.getAutoSaveMode() !== textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) && !this.isDocumentedEdited) {
            this.updateDocumentEdited(); // no indication needed when auto save is enabled for short delay
        }
        if (this.textFileService.getAutoSaveMode() !== textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) {
            this.updateActivityBadge(); // no indication needed when auto save is enabled for short delay
        }
        // If a file becomes dirty but is not opened, we open it in the background
        // Since it might be the intent of whoever created the model to show it shortly
        // after, we delay this a little bit and check again if the editor has not been
        // opened meanwhile
        this.pendingDirtyResources.push(e.resource);
        if (!this.pendingDirtyHandle) {
            this.pendingDirtyHandle = setTimeout(function () { return _this.doOpenDirtyResources(); }, 250);
        }
    };
    DirtyFilesTracker.prototype.doOpenDirtyResources = function () {
        var _this = this;
        var dirtyNotOpenedResources = arrays.distinct(this.pendingDirtyResources.filter(function (r) { return !_this.stacks.isOpen(r) && _this.textFileService.isDirty(r); }), function (r) { return r.toString(); });
        // Reset
        this.pendingDirtyHandle = void 0;
        this.pendingDirtyResources = [];
        var activeEditor = this.editorService.getActiveEditor();
        var activePosition = activeEditor ? activeEditor.position : editor_1.Position.LEFT;
        // Open
        this.editorService.openEditors(dirtyNotOpenedResources.map(function (resource) {
            return {
                input: {
                    resource: resource,
                    options: { inactive: true, pinned: true, preserveFocus: true }
                },
                position: activePosition
            };
        })).done(null, errors.onUnexpectedError);
    };
    DirtyFilesTracker.prototype.onTextFileSaved = function (e) {
        if (this.isDocumentedEdited) {
            this.updateDocumentEdited();
        }
        if (this.lastDirtyCount > 0) {
            this.updateActivityBadge();
        }
    };
    DirtyFilesTracker.prototype.onTextFileSaveError = function (e) {
        if (!this.isDocumentedEdited) {
            this.updateDocumentEdited();
        }
        this.updateActivityBadge();
    };
    DirtyFilesTracker.prototype.onTextFileReverted = function (e) {
        if (this.isDocumentedEdited) {
            this.updateDocumentEdited();
        }
        if (this.lastDirtyCount > 0) {
            this.updateActivityBadge();
        }
    };
    DirtyFilesTracker.prototype.updateActivityBadge = function () {
        var dirtyCount = this.textFileService.getDirty().length;
        this.lastDirtyCount = dirtyCount;
        if (dirtyCount > 0) {
            this.activityService.showActivity(files_1.VIEWLET_ID, new activityService_1.NumberBadge(dirtyCount, function (num) { return nls.localize('dirtyFiles', "{0} unsaved files", dirtyCount); }), 'explorer-viewlet-label');
        }
        else {
            this.activityService.clearActivity(files_1.VIEWLET_ID);
        }
    };
    DirtyFilesTracker.prototype.updateDocumentEdited = function () {
        if (platform_1.platform === platform_1.Platform.Mac) {
            var hasDirtyFiles = this.textFileService.isDirty();
            this.isDocumentedEdited = hasDirtyFiles;
            electron_1.ipcRenderer.send('vscode:setDocumentEdited', this.windowService.getWindowId(), hasDirtyFiles); // handled from browser process
        }
    };
    DirtyFilesTracker.prototype.getId = function () {
        return 'vs.files.dirtyFilesTracker';
    };
    DirtyFilesTracker.prototype.dispose = function () {
        this.toUnbind = lifecycle_2.dispose(this.toUnbind);
    };
    DirtyFilesTracker = __decorate([
        __param(0, textfiles_1.ITextFileService),
        __param(1, lifecycle_1.ILifecycleService),
        __param(2, groupService_1.IEditorGroupService),
        __param(3, editorService_1.IWorkbenchEditorService),
        __param(4, activityService_1.IActivityService),
        __param(5, windowService_1.IWindowService),
        __param(6, untitledEditorService_1.IUntitledEditorService)
    ], DirtyFilesTracker);
    return DirtyFilesTracker;
}());
exports.DirtyFilesTracker = DirtyFilesTracker;
