/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var errors = require('vs/base/common/errors');
var uri_1 = require('vs/base/common/uri');
var paths = require('vs/base/common/paths');
var diffEditorInput_1 = require('vs/workbench/common/editor/diffEditorInput');
var files_1 = require('vs/workbench/parts/files/common/files');
var textfiles_1 = require('vs/workbench/services/textfile/common/textfiles');
var files_2 = require('vs/platform/files/common/files');
var fileEditorInput_1 = require('vs/workbench/parts/files/common/editors/fileEditorInput');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var lifecycle_1 = require('vs/platform/lifecycle/common/lifecycle');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var event_1 = require('vs/platform/event/common/event');
var lifecycle_2 = require('vs/base/common/lifecycle');
var FileEditorTracker = (function () {
    function FileEditorTracker(eventService, editorService, textFileService, lifecycleService, editorGroupService) {
        this.eventService = eventService;
        this.editorService = editorService;
        this.textFileService = textFileService;
        this.lifecycleService = lifecycleService;
        this.editorGroupService = editorGroupService;
        this.toUnbind = [];
        this.stacks = editorGroupService.getStacksModel();
        this.registerListeners();
    }
    FileEditorTracker.prototype.getId = function () {
        return 'vs.files.fileEditorTracker';
    };
    FileEditorTracker.prototype.registerListeners = function () {
        var _this = this;
        // Update editors from local changes and saves
        this.toUnbind.push(this.eventService.addListener2('files.internal:fileChanged', function (e) { return _this.onLocalFileChange(e); }));
        // Update editors from disk changes
        this.toUnbind.push(this.eventService.addListener2(files_2.EventType.FILE_CHANGES, function (e) { return _this.onFileChanges(e); }));
        // Lifecycle
        this.lifecycleService.onShutdown(this.dispose, this);
    };
    // Note: there is some duplication with the other file event handler below. Since we cannot always rely on the disk events
    // carrying all necessary data in all environments, we also use the local file events to make sure operations are handled.
    // In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case
    // that the event ordering is random as well as might not carry all information needed.
    FileEditorTracker.prototype.onLocalFileChange = function (e) {
        // Handle moves specially when file is opened
        if (e.gotMoved()) {
            var before_1 = e.getBefore();
            var after_1 = e.getAfter();
            this.handleMovedFileInOpenedEditors(before_1 ? before_1.resource : null, after_1 ? after_1.resource : null);
        }
    };
    FileEditorTracker.prototype.handleMovedFileInOpenedEditors = function (oldResource, newResource) {
        var _this = this;
        var stacks = this.editorGroupService.getStacksModel();
        stacks.groups.forEach(function (group) {
            group.getEditors().forEach(function (input) {
                if (input instanceof fileEditorInput_1.FileEditorInput) {
                    var resource = input.getResource();
                    // Update Editor if file (or any parent of the input) got renamed or moved
                    if (paths.isEqualOrParent(resource.fsPath, oldResource.fsPath)) {
                        var reopenFileResource = void 0;
                        if (oldResource.toString() === resource.toString()) {
                            reopenFileResource = newResource; // file got moved
                        }
                        else {
                            var index = resource.fsPath.indexOf(oldResource.fsPath);
                            reopenFileResource = uri_1.default.file(paths.join(newResource.fsPath, resource.fsPath.substr(index + oldResource.fsPath.length + 1))); // parent folder got moved
                        }
                        // Reopen
                        _this.editorService.openEditor({ resource: reopenFileResource, options: { preserveFocus: true, pinned: group.isPinned(input), index: group.indexOf(input), inactive: !group.isActive(input) } }, stacks.positionOfGroup(group)).done(null, errors.onUnexpectedError);
                    }
                }
            });
        });
    };
    FileEditorTracker.prototype.onFileChanges = function (e) {
        // Handle updates to visible editors
        this.handleUpdatesToVisibleEditors(e);
    };
    FileEditorTracker.prototype.handleUpdatesToVisibleEditors = function (e) {
        var _this = this;
        var editors = this.editorService.getVisibleEditors();
        editors.forEach(function (editor) {
            var input = editor.input;
            if (input instanceof diffEditorInput_1.DiffEditorInput) {
                input = _this.getMatchingFileEditorInputFromDiff(input, e);
            }
            // File Editor Input
            if (input instanceof fileEditorInput_1.FileEditorInput) {
                var fileInputResource = input.getResource();
                // Input got added or updated, so check for model and update
                // Note: we also consider the added event because it could be that a file was added
                // and updated right after.
                if (e.contains(fileInputResource, files_2.FileChangeType.UPDATED) || e.contains(fileInputResource, files_2.FileChangeType.ADDED)) {
                    var textModel_1 = _this.textFileService.models.get(fileInputResource);
                    // Text file: check for last save time
                    if (textModel_1) {
                        // We only ever update models that are in good saved state
                        if (textModel_1.getState() === textfiles_1.ModelState.SAVED) {
                            var lastSaveTime = textModel_1.getLastSaveAttemptTime();
                            // Force a reopen of the input if this change came in later than our wait interval before we consider it
                            if (Date.now() - lastSaveTime > FileEditorTracker.FILE_CHANGE_UPDATE_DELAY) {
                                var codeEditor_1 = editor.getControl();
                                var viewState_1 = codeEditor_1.saveViewState();
                                var currentMtime_1 = textModel_1.getLastModifiedTime(); // optimize for the case where the file did actually not change
                                textModel_1.load().done(function () {
                                    if (textModel_1.getLastModifiedTime() !== currentMtime_1 && _this.isEditorShowingPath(editor, textModel_1.getResource())) {
                                        codeEditor_1.restoreViewState(viewState_1);
                                    }
                                }, errors.onUnexpectedError);
                            }
                        }
                    }
                    else if (editor.getId() === files_1.BINARY_FILE_EDITOR_ID) {
                        _this.editorService.openEditor(editor.input, { forceOpen: true, preserveFocus: true }, editor.position).done(null, errors.onUnexpectedError);
                    }
                }
            }
        });
    };
    FileEditorTracker.prototype.isEditorShowingPath = function (editor, resource) {
        // Only relevant if Editor is visible
        if (!editor.isVisible()) {
            return false;
        }
        // Only relevant if Input is set
        var input = editor.input;
        if (!input) {
            return false;
        }
        // Support diff editor input too
        if (input instanceof diffEditorInput_1.DiffEditorInput) {
            input = input.modifiedInput;
        }
        return input instanceof fileEditorInput_1.FileEditorInput && input.getResource().toString() === resource.toString();
    };
    FileEditorTracker.prototype.getMatchingFileEditorInputFromDiff = function (input, arg) {
        // First try modifiedInput
        var modifiedInput = input.modifiedInput;
        var res = this.getMatchingFileEditorInputFromInput(modifiedInput, arg);
        if (res) {
            return res;
        }
        // Second try originalInput
        return this.getMatchingFileEditorInputFromInput(input.originalInput, arg);
    };
    FileEditorTracker.prototype.getMatchingFileEditorInputFromInput = function (input, arg) {
        if (input instanceof fileEditorInput_1.FileEditorInput) {
            if (arg instanceof uri_1.default) {
                var deletedResource = arg;
                if (this.containsResource(input, deletedResource)) {
                    return input;
                }
            }
            else {
                var updatedFiles = arg;
                if (updatedFiles.contains(input.getResource(), files_2.FileChangeType.UPDATED)) {
                    return input;
                }
            }
        }
        return null;
    };
    FileEditorTracker.prototype.containsResource = function (input, resource) {
        var fileResource;
        if (input instanceof fileEditorInput_1.FileEditorInput) {
            fileResource = input.getResource();
        }
        if (paths.isEqualOrParent(fileResource.fsPath, resource.fsPath)) {
            return true;
        }
        return false;
    };
    FileEditorTracker.prototype.dispose = function () {
        this.toUnbind = lifecycle_2.dispose(this.toUnbind);
    };
    // Delay in ms that we wait at minimum before we update a model from a file change event.
    // This reduces the chance that a save from the client triggers an update of the editor.
    FileEditorTracker.FILE_CHANGE_UPDATE_DELAY = 2000;
    FileEditorTracker = __decorate([
        __param(0, event_1.IEventService),
        __param(1, editorService_1.IWorkbenchEditorService),
        __param(2, textfiles_1.ITextFileService),
        __param(3, lifecycle_1.ILifecycleService),
        __param(4, groupService_1.IEditorGroupService)
    ], FileEditorTracker);
    return FileEditorTracker;
}());
exports.FileEditorTracker = FileEditorTracker;
