/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var event_1 = require('vs/base/common/event');
var winjs_base_1 = require('vs/base/common/winjs.base');
var textFileEditorModel_1 = require('vs/workbench/parts/files/common/editors/textFileEditorModel');
var lifecycle_1 = require('vs/base/common/lifecycle');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var files_1 = require('vs/workbench/parts/files/common/files');
var lifecycle_2 = require('vs/platform/lifecycle/common/lifecycle');
var event_2 = require('vs/platform/event/common/event');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var files_2 = require('vs/platform/files/common/files');
var TextFileEditorModelManager = (function () {
    function TextFileEditorModelManager(lifecycleService, eventService, instantiationService, editorGroupService) {
        this.lifecycleService = lifecycleService;
        this.eventService = eventService;
        this.instantiationService = instantiationService;
        this.editorGroupService = editorGroupService;
        this.toUnbind = [];
        this._onModelDirty = new event_1.Emitter();
        this._onModelSaveError = new event_1.Emitter();
        this._onModelSaved = new event_1.Emitter();
        this._onModelReverted = new event_1.Emitter();
        this._onModelEncodingChanged = new event_1.Emitter();
        this.toUnbind.push(this._onModelDirty);
        this.toUnbind.push(this._onModelSaveError);
        this.toUnbind.push(this._onModelSaved);
        this.toUnbind.push(this._onModelReverted);
        this.toUnbind.push(this._onModelEncodingChanged);
        this.mapResourceToModel = Object.create(null);
        this.mapResourceToDisposeListener = Object.create(null);
        this.mapResourceToStateChangeListener = Object.create(null);
        this.mapResourceToPendingModelLoaders = Object.create(null);
        this.registerListeners();
    }
    TextFileEditorModelManager.prototype.registerListeners = function () {
        var _this = this;
        // Editors changing
        this.toUnbind.push(this.editorGroupService.onEditorsChanged(function () { return _this.onEditorsChanged(); }));
        // File changes
        this.toUnbind.push(this.eventService.addListener2('files.internal:fileChanged', function (e) { return _this.onLocalFileChange(e); }));
        this.toUnbind.push(this.eventService.addListener2(files_2.EventType.FILE_CHANGES, function (e) { return _this.onFileChanges(e); }));
        // Lifecycle
        this.lifecycleService.onShutdown(this.dispose, this);
    };
    TextFileEditorModelManager.prototype.onEditorsChanged = function () {
        this.disposeUnusedModels();
    };
    TextFileEditorModelManager.prototype.disposeModelIfPossible = function (resource) {
        var model = this.get(resource);
        if (this.canDispose(model)) {
            model.dispose();
        }
    };
    TextFileEditorModelManager.prototype.onLocalFileChange = function (e) {
        if (e.gotMoved() || e.gotDeleted()) {
            this.disposeModelIfPossible(e.getBefore().resource); // dispose models of moved or deleted files
        }
    };
    TextFileEditorModelManager.prototype.onFileChanges = function (e) {
        var _this = this;
        // Dispose inputs that got deleted
        e.getDeleted().forEach(function (deleted) {
            _this.disposeModelIfPossible(deleted.resource);
        });
        // Dispose models that got changed and are not visible. We do this because otherwise
        // cached file models will be stale from the contents on disk.
        e.getUpdated()
            .map(function (u) { return _this.get(u.resource); })
            .filter(function (model) {
            if (!model) {
                return false;
            }
            if (Date.now() - model.getLastSaveAttemptTime() < TextFileEditorModelManager.FILE_CHANGE_UPDATE_DELAY) {
                return false; // this is a weak check to see if the change came from outside the editor or not
            }
            return true; // ok boss
        })
            .forEach(function (model) { return _this.disposeModelIfPossible(model.getResource()); });
    };
    TextFileEditorModelManager.prototype.canDispose = function (textModel) {
        if (!textModel) {
            return false; // we need data!
        }
        if (textModel.isDisposed()) {
            return false; // already disposed
        }
        if (textModel.textEditorModel && textModel.textEditorModel.isAttachedToEditor()) {
            return false; // never dispose when attached to editor
        }
        if (textModel.getState() !== files_1.ModelState.SAVED) {
            return false; // never dispose unsaved models
        }
        if (this.mapResourceToPendingModelLoaders[textModel.getResource().toString()]) {
            return false; // never dispose models that we are about to load at the same time
        }
        return true;
    };
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelDirty", {
        get: function () {
            return this._onModelDirty.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaveError", {
        get: function () {
            return this._onModelSaveError.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaved", {
        get: function () {
            return this._onModelSaved.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelReverted", {
        get: function () {
            return this._onModelReverted.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelEncodingChanged", {
        get: function () {
            return this._onModelEncodingChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    TextFileEditorModelManager.prototype.get = function (resource) {
        return this.mapResourceToModel[resource.toString()];
    };
    TextFileEditorModelManager.prototype.loadOrCreate = function (resource, encoding, refresh) {
        var _this = this;
        // Return early if model is currently being loaded
        var pendingLoad = this.mapResourceToPendingModelLoaders[resource.toString()];
        if (pendingLoad) {
            return pendingLoad;
        }
        var modelPromise;
        // Model exists
        var model = this.get(resource);
        if (model) {
            if (!refresh) {
                modelPromise = winjs_base_1.TPromise.as(model);
            }
            else {
                modelPromise = model.load();
            }
        }
        else {
            model = this.instantiationService.createInstance(textFileEditorModel_1.TextFileEditorModel, resource, encoding);
            modelPromise = model.load();
            // Install state change listener
            this.mapResourceToStateChangeListener[resource.toString()] = model.onDidStateChange(function (state) {
                var event = new files_1.TextFileModelChangeEvent(model, state);
                switch (state) {
                    case files_1.StateChange.DIRTY:
                        _this._onModelDirty.fire(event);
                        break;
                    case files_1.StateChange.SAVE_ERROR:
                        _this._onModelSaveError.fire(event);
                        break;
                    case files_1.StateChange.SAVED:
                        _this._onModelSaved.fire(event);
                        break;
                    case files_1.StateChange.REVERTED:
                        _this._onModelReverted.fire(event);
                        break;
                    case files_1.StateChange.ENCODING:
                        _this._onModelEncodingChanged.fire(event);
                        break;
                }
            });
        }
        // Store pending loads to avoid race conditions
        this.mapResourceToPendingModelLoaders[resource.toString()] = modelPromise;
        return modelPromise.then(function (model) {
            // Make known to manager (if not already known)
            _this.add(resource, model);
            // Remove from pending loads
            _this.mapResourceToPendingModelLoaders[resource.toString()] = null;
            return model;
        }, function (error) {
            // Free resources of this invalid model
            model.dispose();
            // Remove from pending loads
            _this.mapResourceToPendingModelLoaders[resource.toString()] = null;
            return winjs_base_1.TPromise.wrapError(error);
        });
    };
    TextFileEditorModelManager.prototype.getAll = function (resource) {
        var _this = this;
        return Object.keys(this.mapResourceToModel)
            .filter(function (r) { return !resource || resource.toString() === r; })
            .map(function (r) { return _this.mapResourceToModel[r]; });
    };
    TextFileEditorModelManager.prototype.add = function (resource, model) {
        var _this = this;
        var knownModel = this.mapResourceToModel[resource.toString()];
        if (knownModel === model) {
            return; // already cached
        }
        // dispose any previously stored dispose listener for this resource
        var disposeListener = this.mapResourceToDisposeListener[resource.toString()];
        if (disposeListener) {
            disposeListener.dispose();
        }
        // store in cache but remove when model gets disposed
        this.mapResourceToModel[resource.toString()] = model;
        this.mapResourceToDisposeListener[resource.toString()] = model.onDispose(function () { return _this.remove(resource); });
    };
    TextFileEditorModelManager.prototype.remove = function (resource) {
        delete this.mapResourceToModel[resource.toString()];
        var disposeListener = this.mapResourceToDisposeListener[resource.toString()];
        if (disposeListener) {
            lifecycle_1.dispose(disposeListener);
            delete this.mapResourceToDisposeListener[resource.toString()];
        }
        var stateChangeListener = this.mapResourceToStateChangeListener[resource.toString()];
        if (stateChangeListener) {
            lifecycle_1.dispose(stateChangeListener);
            delete this.mapResourceToStateChangeListener[resource.toString()];
        }
    };
    TextFileEditorModelManager.prototype.clear = function () {
        var _this = this;
        // model cache
        this.mapResourceToModel = Object.create(null);
        // dispose dispose listeners
        var keys = Object.keys(this.mapResourceToDisposeListener);
        lifecycle_1.dispose(keys.map(function (k) { return _this.mapResourceToDisposeListener[k]; }));
        this.mapResourceToDisposeListener = Object.create(null);
        // dispose state change listeners
        keys = Object.keys(this.mapResourceToStateChangeListener);
        lifecycle_1.dispose(keys.map(function (k) { return _this.mapResourceToStateChangeListener[k]; }));
        this.mapResourceToStateChangeListener = Object.create(null);
    };
    TextFileEditorModelManager.prototype.disposeUnusedModels = function () {
        // To not grow our text file model cache infinitly, we dispose models that
        // are not showing up in any opened editor.
        var _this = this;
        // Get all cached file models
        this.getAll()
            .filter(function (model) { return !_this.editorGroupService.getStacksModel().isOpen(model.getResource()); })
            .forEach(function (model) { return _this.disposeModelIfPossible(model.getResource()); });
    };
    TextFileEditorModelManager.prototype.dispose = function () {
        this.toUnbind = lifecycle_1.dispose(this.toUnbind);
    };
    // Delay in ms that we wait at minimum before we update a model from a file change event.
    // This reduces the chance that a save from the client triggers an update of the editor.
    TextFileEditorModelManager.FILE_CHANGE_UPDATE_DELAY = 2000;
    TextFileEditorModelManager = __decorate([
        __param(0, lifecycle_2.ILifecycleService),
        __param(1, event_2.IEventService),
        __param(2, instantiation_1.IInstantiationService),
        __param(3, groupService_1.IEditorGroupService)
    ], TextFileEditorModelManager);
    return TextFileEditorModelManager;
}());
exports.TextFileEditorModelManager = TextFileEditorModelManager;
