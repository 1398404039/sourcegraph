/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var cp = require('child_process');
var processes = require('vs/base/node/processes');
var nls = require('vs/nls');
var errors = require('vs/base/common/errors');
var winjs_base_1 = require('vs/base/common/winjs.base');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var terminal_1 = require('vs/workbench/parts/execution/electron-browser/terminal');
var uri_1 = require('vs/base/common/uri');
var TERMINAL_TITLE = nls.localize('console.title', "VS Code Console");
var WinTerminalService = (function () {
    function WinTerminalService(_configurationService) {
        this._configurationService = _configurationService;
    }
    WinTerminalService.prototype.openTerminal = function (path) {
        var configuration = this._configurationService.getConfiguration();
        this.spawnTerminal(cp, configuration, processes.getWindowsShell(), path)
            .done(null, errors.onUnexpectedError);
    };
    WinTerminalService.prototype.runInTerminal = function (title, dir, args, envVars) {
        var configuration = this._configurationService.getConfiguration();
        var terminalConfig = configuration.terminal.external;
        var exec = terminalConfig.windowsExec || terminal_1.DEFAULT_TERMINAL_WINDOWS;
        return new winjs_base_1.TPromise(function (c, e) {
            var title = "\"" + dir + " - " + TERMINAL_TITLE + "\"";
            var command = "\"\"" + args.join('" "') + "\" & pause\""; // use '|' to only pause on non-zero exit code
            var cmdArgs = [
                '/c', 'start', title, '/wait', exec, '/c', command
            ];
            // merge environment variables into a copy of the process.env
            var env = extendObject(extendObject({}, process.env), envVars);
            var options = {
                cwd: dir,
                env: env,
                windowsVerbatimArguments: true
            };
            var cmd = cp.spawn(WinTerminalService.CMD, cmdArgs, options);
            cmd.on('error', e);
            c(null);
        });
    };
    WinTerminalService.prototype.spawnTerminal = function (spawner, configuration, command, path) {
        var terminalConfig = configuration.terminal.external;
        var exec = terminalConfig.windowsExec || terminal_1.DEFAULT_TERMINAL_WINDOWS;
        // The '""' argument is the window title. Without this, exec doesn't work when the path
        // contains spaces
        var cmdArgs = ['/c', 'start', '/wait', '""', exec];
        // Make the drive letter uppercase on Windows (see #9448)
        if (path && path[1] === ':') {
            path = path[0].toUpperCase() + path.substr(1);
        }
        return new winjs_base_1.TPromise(function (c, e) {
            var env = path ? { cwd: path } : void 0;
            var child = spawner.spawn(command, cmdArgs, env);
            child.on('error', e);
            child.on('exit', function () { return c(null); });
        });
    };
    WinTerminalService.CMD = 'cmd.exe';
    WinTerminalService = __decorate([
        __param(0, configuration_1.IConfigurationService)
    ], WinTerminalService);
    return WinTerminalService;
}());
exports.WinTerminalService = WinTerminalService;
var MacTerminalService = (function () {
    function MacTerminalService(_configurationService) {
        this._configurationService = _configurationService;
    }
    MacTerminalService.prototype.openTerminal = function (path) {
        var configuration = this._configurationService.getConfiguration();
        this.spawnTerminal(cp, configuration, path).done(null, errors.onUnexpectedError);
    };
    MacTerminalService.prototype.runInTerminal = function (title, dir, args, envVars) {
        var configuration = this._configurationService.getConfiguration();
        var terminalConfig = configuration.terminal.external;
        var terminalApp = terminalConfig.osxExec || terminal_1.DEFAULT_TERMINAL_OSX;
        return new winjs_base_1.TPromise(function (c, e) {
            if (terminalApp === terminal_1.DEFAULT_TERMINAL_OSX || terminalApp === 'iTerm.app') {
                // On OS X we launch an AppleScript that creates (or reuses) a Terminal window
                // and then launches the program inside that window.
                var script_1 = terminalApp === terminal_1.DEFAULT_TERMINAL_OSX ? 'TerminalHelper' : 'iTermHelper';
                var scriptpath = uri_1.default.parse(require.toUrl("vs/workbench/parts/execution/electron-browser/" + script_1 + ".scpt")).fsPath;
                var osaArgs = [
                    scriptpath,
                    '-t', title || TERMINAL_TITLE,
                    '-w', dir,
                ];
                for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
                    var a = args_1[_i];
                    osaArgs.push('-a');
                    osaArgs.push(a);
                }
                if (envVars) {
                    for (var key in envVars) {
                        osaArgs.push('-e');
                        osaArgs.push(key + '=' + envVars[key]);
                    }
                }
                var stderr_1 = '';
                var osa = cp.spawn(MacTerminalService.OSASCRIPT, osaArgs);
                osa.on('error', e);
                osa.stderr.on('data', function (data) {
                    stderr_1 += data.toString();
                });
                osa.on('exit', function (code) {
                    if (code === 0) {
                        c(null);
                    }
                    else {
                        if (stderr_1) {
                            var lines = stderr_1.split('\n', 1);
                            e(new Error(lines[0]));
                        }
                        else {
                            e(new Error(nls.localize('mac.terminal.script.failed', "script '{0}' failed with exit code {1}", script_1, code)));
                        }
                    }
                });
            }
            else {
                e(new Error(nls.localize('mac.terminal.type.not.supported', "'{0}' not supported", terminalApp)));
            }
        });
    };
    MacTerminalService.prototype.spawnTerminal = function (spawner, configuration, path) {
        var terminalConfig = configuration.terminal.external;
        var terminalApp = terminalConfig.osxExec || terminal_1.DEFAULT_TERMINAL_OSX;
        return new winjs_base_1.TPromise(function (c, e) {
            var child = spawner.spawn('/usr/bin/open', ['-a', terminalApp, path]);
            child.on('error', e);
            child.on('exit', function () { return c(null); });
        });
    };
    MacTerminalService.OSASCRIPT = '/usr/bin/osascript'; // osascript is the AppleScript interpreter on OS X
    MacTerminalService = __decorate([
        __param(0, configuration_1.IConfigurationService)
    ], MacTerminalService);
    return MacTerminalService;
}());
exports.MacTerminalService = MacTerminalService;
var LinuxTerminalService = (function () {
    function LinuxTerminalService(_configurationService) {
        this._configurationService = _configurationService;
    }
    LinuxTerminalService.prototype.openTerminal = function (path) {
        var configuration = this._configurationService.getConfiguration();
        this.spawnTerminal(cp, configuration, path)
            .done(null, errors.onUnexpectedError);
    };
    LinuxTerminalService.prototype.runInTerminal = function (title, dir, args, envVars) {
        var configuration = this._configurationService.getConfiguration();
        var terminalConfig = configuration.terminal.external;
        var exec = terminalConfig.linuxExec || terminal_1.DEFAULT_TERMINAL_LINUX;
        return new winjs_base_1.TPromise(function (c, e) {
            var termArgs = [];
            //termArgs.push('--title');
            //termArgs.push(`"${TERMINAL_TITLE}"`);
            if (exec.indexOf('gnome-terminal') >= 0) {
                termArgs.push('-x');
            }
            else {
                termArgs.push('-e');
            }
            termArgs.push('bash');
            termArgs.push('-c');
            var bashCommand = quote(args) + "; echo; read -p \"" + LinuxTerminalService.WAIT_MESSAGE + "\" -n1;";
            termArgs.push("''" + bashCommand + "''"); // wrapping argument in two sets of ' because node is so "friendly" that it removes one set...
            // merge environment variables into a copy of the process.env
            var env = extendObject(extendObject({}, process.env), envVars);
            var options = {
                cwd: dir,
                env: env
            };
            var stderr = '';
            var cmd = cp.spawn(exec, termArgs, options);
            cmd.on('error', e);
            cmd.stderr.on('data', function (data) {
                stderr += data.toString();
            });
            cmd.on('exit', function (code) {
                if (code === 0) {
                    c(null);
                }
                else {
                    if (stderr) {
                        var lines = stderr.split('\n', 1);
                        e(new Error(lines[0]));
                    }
                    else {
                        e(new Error(nls.localize('linux.term.failed', "'{0}' failed with exit code {1}", exec, code)));
                    }
                }
            });
        });
    };
    LinuxTerminalService.prototype.spawnTerminal = function (spawner, configuration, path) {
        var terminalConfig = configuration.terminal.external;
        var exec = terminalConfig.linuxExec || terminal_1.DEFAULT_TERMINAL_LINUX;
        var env = path ? { cwd: path } : void 0;
        return new winjs_base_1.TPromise(function (c, e) {
            var child = spawner.spawn(exec, [], env);
            child.on('error', e);
            child.on('exit', function () { return c(null); });
        });
    };
    LinuxTerminalService.WAIT_MESSAGE = nls.localize('press.any.key', "Press any key to continue...");
    LinuxTerminalService = __decorate([
        __param(0, configuration_1.IConfigurationService)
    ], LinuxTerminalService);
    return LinuxTerminalService;
}());
exports.LinuxTerminalService = LinuxTerminalService;
function extendObject(objectCopy, object) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            objectCopy[key] = object[key];
        }
    }
    return objectCopy;
}
/**
 * Quote args if necessary and combine into a space separated string.
 */
function quote(args) {
    var r = '';
    for (var _i = 0, args_2 = args; _i < args_2.length; _i++) {
        var a = args_2[_i];
        if (a.indexOf(' ') >= 0) {
            r += '"' + a + '"';
        }
        else {
            r += a;
        }
        r += ' ';
    }
    return r;
}
