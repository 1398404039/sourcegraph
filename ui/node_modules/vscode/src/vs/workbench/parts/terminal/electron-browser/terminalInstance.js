/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DOM = require('vs/base/browser/dom');
var event_1 = require('vs/base/common/event');
var uri_1 = require('vs/base/common/uri');
var cp = require('child_process');
var lifecycle = require('vs/base/common/lifecycle');
var nls = require('vs/nls');
var os = require('os');
var path = require('path');
var platform = require('vs/base/common/platform');
var xterm = require('xterm');
var builder_1 = require('vs/base/browser/builder');
var keybinding_1 = require('vs/platform/keybinding/common/keybinding');
var message_1 = require('vs/platform/message/common/message');
var keyboardEvent_1 = require('vs/base/browser/keyboardEvent');
var commonEditorConfig_1 = require('vs/editor/common/config/commonEditorConfig');
var TerminalInstance = (function () {
    function TerminalInstance(_terminalFocusContextKey, _configHelper, _container, workspace, name, shell, _keybindingService, _messageService) {
        this._terminalFocusContextKey = _terminalFocusContextKey;
        this._configHelper = _configHelper;
        this._container = _container;
        this._keybindingService = _keybindingService;
        this._messageService = _messageService;
        this._toDispose = [];
        this._skipTerminalKeybindings = [];
        this._isExiting = false;
        this._isVisible = false;
        this._id = TerminalInstance._idCounter++;
        this._onDisposed = new event_1.Emitter();
        this._onProcessIdReady = new event_1.Emitter();
        this._onTitleChanged = new event_1.Emitter();
        this._createProcess(workspace, name, shell);
        if (_container) {
            this.attachToElement(_container);
        }
    }
    Object.defineProperty(TerminalInstance.prototype, "id", {
        get: function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "processId", {
        get: function () { return this._processId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onClosed", {
        get: function () { return this._onDisposed.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onProcessIdReady", {
        get: function () { return this._onProcessIdReady.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onTitleChanged", {
        get: function () { return this._onTitleChanged.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "title", {
        get: function () { return this._title; },
        enumerable: true,
        configurable: true
    });
    TerminalInstance.prototype.addDisposable = function (disposable) {
        this._toDispose.push(disposable);
    };
    TerminalInstance.prototype.attachToElement = function (container) {
        var _this = this;
        if (this._wrapperElement) {
            throw new Error('The terminal instance has already been attached to a container');
        }
        this._container = container;
        this._wrapperElement = document.createElement('div');
        DOM.addClass(this._wrapperElement, 'terminal-wrapper');
        this._xtermElement = document.createElement('div');
        this._xterm = xterm();
        this._xterm.open(this._xtermElement);
        this._process.on('message', function (message) {
            if (message.type === 'data') {
                _this._xterm.write(message.content);
            }
        });
        this._xterm.on('data', function (data) {
            _this._process.send({
                event: 'input',
                data: _this.sanitizeInput(data)
            });
            return false;
        });
        this._xterm.attachCustomKeydownHandler(function (event) {
            // Allow the toggle tab mode keybinding to pass through the terminal so that focus can
            // be escaped
            var standardKeyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(event);
            if (_this._skipTerminalKeybindings.some(function (k) { return standardKeyboardEvent.equals(k.value); })) {
                event.preventDefault();
                return false;
            }
            // If tab focus mode is on, tab is not passed to the terminal
            if (commonEditorConfig_1.TabFocus.getTabFocusMode() && event.keyCode === 9) {
                return false;
            }
        });
        var xtermHelper = this._xterm.element.querySelector('.xterm-helpers');
        var focusTrap = document.createElement('div');
        focusTrap.setAttribute('tabindex', '0');
        DOM.addClass(focusTrap, 'focus-trap');
        focusTrap.addEventListener('focus', function (event) {
            var currentElement = focusTrap;
            while (!DOM.hasClass(currentElement, 'part')) {
                currentElement = currentElement.parentElement;
            }
            var hidePanelElement = currentElement.querySelector('.hide-panel-action');
            hidePanelElement.focus();
        });
        xtermHelper.insertBefore(focusTrap, this._xterm.textarea);
        this._toDispose.push(DOM.addDisposableListener(this._xterm.textarea, 'focus', function (event) {
            _this._terminalFocusContextKey.set(true);
        }));
        this._toDispose.push(DOM.addDisposableListener(this._xterm.textarea, 'blur', function (event) {
            _this._terminalFocusContextKey.reset();
        }));
        this._toDispose.push(DOM.addDisposableListener(this._xterm.element, 'focus', function (event) {
            _this._terminalFocusContextKey.set(true);
        }));
        this._toDispose.push(DOM.addDisposableListener(this._xterm.element, 'blur', function (event) {
            _this._terminalFocusContextKey.reset();
        }));
        this._wrapperElement.appendChild(this._xtermElement);
        this._container.appendChild(this._wrapperElement);
        var computedStyle = window.getComputedStyle(this._container);
        var width = parseInt(computedStyle.getPropertyValue('width').replace('px', ''), 10);
        var height = parseInt(computedStyle.getPropertyValue('height').replace('px', ''), 10);
        this.layout(new builder_1.Dimension(width, height));
        this.setVisible(this._isVisible);
    };
    TerminalInstance.prototype.copySelection = function () {
        if (document.activeElement.classList.contains('xterm')) {
            document.execCommand('copy');
        }
        else {
            this._messageService.show(message_1.Severity.Warning, nls.localize('terminal.integrated.copySelection.noSelection', 'Cannot copy terminal selection when terminal does not have focus'));
        }
    };
    TerminalInstance.prototype.dispose = function () {
        this._isExiting = true;
        if (this._wrapperElement) {
            this._container.removeChild(this._wrapperElement);
            this._wrapperElement = null;
        }
        if (this._xterm) {
            this._xterm.destroy();
            this._xterm = null;
        }
        if (this._process) {
            if (this._process.connected) {
                this._process.kill();
            }
            this._process = null;
        }
        this._onDisposed.fire(this);
        this._toDispose = lifecycle.dispose(this._toDispose);
    };
    TerminalInstance.prototype.focus = function (force) {
        if (!this._xterm) {
            return;
        }
        var text = window.getSelection().toString();
        if (!text || force) {
            this._xterm.focus();
        }
    };
    TerminalInstance.prototype.paste = function () {
        this.focus();
        document.execCommand('paste');
    };
    TerminalInstance.prototype.sendText = function (text, addNewLine) {
        if (addNewLine && text.substr(text.length - os.EOL.length) !== os.EOL) {
            text += os.EOL;
        }
        this._process.send({
            event: 'input',
            data: text
        });
    };
    TerminalInstance.prototype.setVisible = function (visible) {
        this._isVisible = visible;
        if (this._wrapperElement) {
            DOM.toggleClass(this._wrapperElement, 'active', visible);
        }
    };
    TerminalInstance.prototype.scrollDownLine = function () {
        this._xterm.scrollDisp(1);
    };
    TerminalInstance.prototype.scrollDownPage = function () {
        this._xterm.scrollDisp(this._xterm.rows - 1);
    };
    TerminalInstance.prototype.scrollUpLine = function () {
        this._xterm.scrollDisp(-1);
    };
    TerminalInstance.prototype.scrollUpPage = function () {
        this._xterm.scrollDisp(-(this._xterm.rows - 1));
    };
    TerminalInstance.prototype.clear = function () {
        this._xterm.clear();
    };
    TerminalInstance.prototype.sanitizeInput = function (data) {
        return typeof data === 'string' ? data.replace(TerminalInstance.EOL_REGEX, os.EOL) : data;
    };
    TerminalInstance.prototype._createProcess = function (workspace, name, shell) {
        var _this = this;
        var locale = this._configHelper.isSetLocaleVariables() ? platform.locale : undefined;
        if (!shell.executable) {
            shell = this._configHelper.getShell();
        }
        var env = TerminalInstance.createTerminalEnv(process.env, shell, workspace, locale);
        this._title = name ? name : '';
        this._process = cp.fork('./terminalProcess', [], {
            env: env,
            cwd: uri_1.default.parse(path.dirname(require.toUrl('./terminalProcess'))).fsPath
        });
        if (!name) {
            // Only listen for process title changes when a name is not provided
            this._process.on('message', function (message) {
                if (message.type === 'title') {
                    _this._title = message.content ? message.content : '';
                    _this._onTitleChanged.fire(_this._title);
                }
            });
        }
        this._process.on('message', function (message) {
            if (message.type === 'pid') {
                _this._processId = message.content;
                _this._onProcessIdReady.fire(_this);
            }
        });
        this._process.on('exit', function (exitCode) {
            // Prevent dispose functions being triggered multiple times
            if (!_this._isExiting) {
                _this.dispose();
                if (exitCode) {
                    _this._messageService.show(message_1.Severity.Error, nls.localize('terminal.integrated.exitedWithCode', 'The terminal process terminated with exit code: {0}', exitCode));
                }
            }
        });
    };
    TerminalInstance.createTerminalEnv = function (parentEnv, shell, workspace, locale) {
        var env = TerminalInstance._cloneEnv(parentEnv);
        env['PTYPID'] = process.pid.toString();
        env['PTYSHELL'] = shell.executable;
        if (shell.args) {
            shell.args.forEach(function (arg, i) {
                env[("PTYSHELLARG" + i)] = arg;
            });
        }
        env['PTYCWD'] = TerminalInstance._sanitizeCwd(workspace ? workspace.resource.fsPath : os.homedir());
        if (locale) {
            env['LANG'] = TerminalInstance._getLangEnvVariable(locale);
        }
        return env;
    };
    TerminalInstance._sanitizeCwd = function (cwd) {
        // Make the drive letter uppercase on Windows (see #9448)
        if (platform.platform === platform.Platform.Windows && cwd && cwd[1] === ':') {
            return cwd[0].toUpperCase() + cwd.substr(1);
        }
        return cwd;
    };
    TerminalInstance._cloneEnv = function (env) {
        var newEnv = Object.create(null);
        Object.keys(env).forEach(function (key) {
            newEnv[key] = env[key];
        });
        return newEnv;
    };
    TerminalInstance._getLangEnvVariable = function (locale) {
        var parts = locale.split('-');
        var n = parts.length;
        if (n > 1) {
            parts[n - 1] = parts[n - 1].toUpperCase();
        }
        return parts.join('_') + '.UTF-8';
    };
    TerminalInstance.prototype.setCursorBlink = function (blink) {
        if (this._xterm && this._xterm.getOption('cursorBlink') !== blink) {
            this._xterm.setOption('cursorBlink', blink);
            this._xterm.refresh(0, this._xterm.rows - 1);
        }
    };
    TerminalInstance.prototype.setCommandsToSkipShell = function (commands) {
        var _this = this;
        this._skipTerminalKeybindings = commands.map(function (c) {
            return _this._keybindingService.lookupKeybindings(c);
        }).reduce(function (prev, curr) {
            return prev.concat(curr);
        }, []);
    };
    TerminalInstance.prototype.layout = function (dimension) {
        var font = this._configHelper.getFont();
        if (!font || !font.charWidth || !font.charHeight) {
            return;
        }
        if (!dimension.height) {
            return;
        }
        else {
            // Trigger scroll event manually so that the viewport's scroll area is synced. This
            // needs to happen otherwise its scrollTop value is invalid when the panel is toggled as
            // it gets removed and then added back to the DOM (resetting scrollTop to 0).
            // Upstream issue: https://github.com/sourcelair/xterm.js/issues/291
            this._xterm.emit('scroll', this._xterm.ydisp);
        }
        var leftPadding = parseInt(getComputedStyle(document.querySelector('.terminal-outer-container')).paddingLeft.split('px')[0], 10);
        var innerWidth = dimension.width - leftPadding;
        var cols = Math.floor(innerWidth / font.charWidth);
        var rows = Math.floor(dimension.height / font.charHeight);
        if (this._xterm) {
            this._xterm.resize(cols, rows);
            this._xterm.element.style.width = innerWidth + 'px';
        }
        if (this._process.connected) {
            this._process.send({
                event: 'resize',
                cols: cols,
                rows: rows
            });
        }
    };
    TerminalInstance.EOL_REGEX = /\r?\n/g;
    TerminalInstance._idCounter = 1;
    TerminalInstance = __decorate([
        __param(6, keybinding_1.IKeybindingService),
        __param(7, message_1.IMessageService)
    ], TerminalInstance);
    return TerminalInstance;
}());
exports.TerminalInstance = TerminalInstance;
