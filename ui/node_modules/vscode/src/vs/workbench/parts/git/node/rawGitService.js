/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var path_1 = require('path');
var winjs_base_1 = require('vs/base/common/winjs.base');
var mime_1 = require('vs/base/node/mime');
var pfs_1 = require('vs/base/node/pfs');
var git_lib_1 = require('vs/workbench/parts/git/node/git.lib');
var git_1 = require('vs/workbench/parts/git/common/git');
var event_1 = require('vs/base/common/event');
var RawGitService = (function () {
    function RawGitService(repo) {
        var _this = this;
        this.repo = repo;
        var listener;
        this._onOutput = new event_1.Emitter({
            onFirstListenerAdd: function () {
                listener = _this.repo.onOutput(function (output) { return _this._onOutput.fire(output); });
            },
            onLastListenerRemove: function () {
                listener();
                listener = null;
            }
        });
    }
    Object.defineProperty(RawGitService.prototype, "onOutput", {
        get: function () { return this._onOutput.event; },
        enumerable: true,
        configurable: true
    });
    RawGitService.prototype.getVersion = function () {
        if (!this.repo) {
            return winjs_base_1.TPromise.as(null);
        }
        return winjs_base_1.TPromise.as(this.repo.version);
    };
    RawGitService.prototype.getRepositoryRoot = function () {
        return this._repositoryRoot || (this._repositoryRoot = pfs_1.realpath(this.repo.path));
    };
    RawGitService.prototype.serviceState = function () {
        return winjs_base_1.TPromise.as(this.repo
            ? git_1.RawServiceState.OK
            : git_1.RawServiceState.GitNotFound);
    };
    RawGitService.prototype.statusCount = function () {
        if (!this.repo) {
            return winjs_base_1.TPromise.as(0);
        }
        return this.status().then(function (r) { return r ? r.status.length : 0; });
    };
    RawGitService.prototype.status = function () {
        var _this = this;
        return this.repo.getStatus()
            .then(function (status) { return _this.repo.getHEAD()
            .then(function (HEAD) {
            if (HEAD.name) {
                return _this.repo.getBranch(HEAD.name).then(null, function () { return HEAD; });
            }
            else {
                return HEAD;
            }
        }, function () { return null; })
            .then(function (HEAD) { return winjs_base_1.Promise.join([_this.getRepositoryRoot(), _this.repo.getRefs(), _this.repo.getRemotes()]).then(function (r) {
            return {
                repositoryRoot: r[0],
                status: status,
                HEAD: HEAD,
                refs: r[1],
                remotes: r[2]
            };
        }); }); })
            .then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.BadConfigFile) {
                return winjs_base_1.Promise.wrapError(err);
            }
            else if (err.gitErrorCode === git_1.GitErrorCodes.NotAtRepositoryRoot) {
                return winjs_base_1.Promise.wrapError(err);
            }
            return null;
        });
    };
    RawGitService.prototype.init = function () {
        var _this = this;
        return this.repo.init().then(function () { return _this.status(); });
    };
    RawGitService.prototype.add = function (filePaths) {
        var _this = this;
        return this.repo.add(filePaths).then(function () { return _this.status(); });
    };
    RawGitService.prototype.stage = function (filePath, content) {
        var _this = this;
        return this.repo.stage(filePath, content).then(function () { return _this.status(); });
    };
    RawGitService.prototype.branch = function (name, checkout) {
        var _this = this;
        return this.repo.branch(name, checkout).then(function () { return _this.status(); });
    };
    RawGitService.prototype.checkout = function (treeish, filePaths) {
        var _this = this;
        return this.repo.checkout(treeish, filePaths).then(function () { return _this.status(); });
    };
    RawGitService.prototype.clean = function (filePaths) {
        var _this = this;
        return this.repo.clean(filePaths).then(function () { return _this.status(); });
    };
    RawGitService.prototype.undo = function () {
        var _this = this;
        return this.repo.undo().then(function () { return _this.status(); });
    };
    RawGitService.prototype.reset = function (treeish, hard) {
        var _this = this;
        return this.repo.reset(treeish, hard).then(function () { return _this.status(); });
    };
    RawGitService.prototype.revertFiles = function (treeish, filePaths) {
        var _this = this;
        return this.repo.revertFiles(treeish, filePaths).then(function () { return _this.status(); });
    };
    RawGitService.prototype.fetch = function () {
        var _this = this;
        return this.repo.fetch().then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.NoRemoteRepositorySpecified) {
                return winjs_base_1.TPromise.as(null);
            }
            return winjs_base_1.Promise.wrapError(err);
        }).then(function () { return _this.status(); });
    };
    RawGitService.prototype.pull = function (rebase) {
        var _this = this;
        return this.repo.pull(rebase).then(function () { return _this.status(); });
    };
    RawGitService.prototype.push = function (remote, name, options) {
        var _this = this;
        return this.repo.push(remote, name, options).then(function () { return _this.status(); });
    };
    RawGitService.prototype.sync = function () {
        var _this = this;
        return this.repo.sync().then(function () { return _this.status(); });
    };
    RawGitService.prototype.commit = function (message, amend, stage, signoff) {
        var _this = this;
        var promise = winjs_base_1.TPromise.as(null);
        if (stage) {
            promise = this.repo.add(null);
        }
        return promise
            .then(function () { return _this.repo.commit(message, stage, amend, signoff); })
            .then(function () { return _this.status(); });
    };
    RawGitService.prototype.detectMimetypes = function (filePath, treeish) {
        var _this = this;
        return pfs_1.exists(path_1.join(this.repo.path, filePath)).then(function (exists) {
            if (exists) {
                return new winjs_base_1.TPromise(function (c, e) {
                    mime_1.detectMimesFromFile(path_1.join(_this.repo.path, filePath), function (err, result) {
                        if (err) {
                            e(err);
                        }
                        else {
                            c(result.mimes);
                        }
                    });
                });
            }
            var child = _this.repo.show(treeish + ':' + filePath);
            return new winjs_base_1.TPromise(function (c, e) {
                mime_1.detectMimesFromStream(child.stdout, filePath, function (err, result) {
                    if (err) {
                        e(err);
                    }
                    else {
                        c(result.mimes);
                    }
                });
            });
        });
    };
    // careful, this buffers the whole object into memory
    RawGitService.prototype.show = function (filePath, treeish) {
        treeish = (!treeish || treeish === '~') ? '' : treeish;
        return this.repo.buffer(treeish + ':' + filePath).then(null, function (e) {
            if (e instanceof git_lib_1.GitError) {
                return ''; // mostly untracked files end up in a git error
            }
            return winjs_base_1.TPromise.wrapError(e);
        });
    };
    RawGitService.prototype.getCommitTemplate = function () {
        return this.repo.getCommitTemplate();
    };
    RawGitService.prototype.getCommit = function (ref) {
        return this.repo.getCommit(ref);
    };
    return RawGitService;
}());
exports.RawGitService = RawGitService;
var DelayedRawGitService = (function () {
    function DelayedRawGitService(raw) {
        this.raw = raw;
        this.onOutput = event_1.delayed(this.raw.then(function (r) { return r.onOutput; }));
    }
    DelayedRawGitService.prototype.getVersion = function () { return this.raw.then(function (r) { return r.getVersion(); }); };
    DelayedRawGitService.prototype.serviceState = function () { return this.raw.then(function (r) { return r.serviceState(); }); };
    DelayedRawGitService.prototype.statusCount = function () { return this.raw.then(function (r) { return r.statusCount(); }); };
    DelayedRawGitService.prototype.status = function () { return this.raw.then(function (r) { return r.status(); }); };
    DelayedRawGitService.prototype.init = function () { return this.raw.then(function (r) { return r.init(); }); };
    DelayedRawGitService.prototype.add = function (filesPaths) { return this.raw.then(function (r) { return r.add(filesPaths); }); };
    DelayedRawGitService.prototype.stage = function (filePath, content) { return this.raw.then(function (r) { return r.stage(filePath, content); }); };
    DelayedRawGitService.prototype.branch = function (name, checkout) { return this.raw.then(function (r) { return r.branch(name, checkout); }); };
    DelayedRawGitService.prototype.checkout = function (treeish, filePaths) { return this.raw.then(function (r) { return r.checkout(treeish, filePaths); }); };
    DelayedRawGitService.prototype.clean = function (filePaths) { return this.raw.then(function (r) { return r.clean(filePaths); }); };
    DelayedRawGitService.prototype.undo = function () { return this.raw.then(function (r) { return r.undo(); }); };
    DelayedRawGitService.prototype.reset = function (treeish, hard) { return this.raw.then(function (r) { return r.reset(treeish, hard); }); };
    DelayedRawGitService.prototype.revertFiles = function (treeish, filePaths) { return this.raw.then(function (r) { return r.revertFiles(treeish, filePaths); }); };
    DelayedRawGitService.prototype.fetch = function () { return this.raw.then(function (r) { return r.fetch(); }); };
    DelayedRawGitService.prototype.pull = function (rebase) { return this.raw.then(function (r) { return r.pull(rebase); }); };
    DelayedRawGitService.prototype.push = function (remote, name, options) { return this.raw.then(function (r) { return r.push(remote, name, options); }); };
    DelayedRawGitService.prototype.sync = function () { return this.raw.then(function (r) { return r.sync(); }); };
    DelayedRawGitService.prototype.commit = function (message, amend, stage, signoff) { return this.raw.then(function (r) { return r.commit(message, amend, stage, signoff); }); };
    DelayedRawGitService.prototype.detectMimetypes = function (path, treeish) { return this.raw.then(function (r) { return r.detectMimetypes(path, treeish); }); };
    DelayedRawGitService.prototype.show = function (path, treeish) { return this.raw.then(function (r) { return r.show(path, treeish); }); };
    DelayedRawGitService.prototype.getCommitTemplate = function () { return this.raw.then(function (r) { return r.getCommitTemplate(); }); };
    DelayedRawGitService.prototype.getCommit = function (ref) { return this.raw.then(function (r) { return r.getCommit(ref); }); };
    return DelayedRawGitService;
}());
exports.DelayedRawGitService = DelayedRawGitService;
