/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var winjs_base_1 = require('vs/base/common/winjs.base');
var ipc_1 = require('vs/base/parts/ipc/common/ipc');
var git_1 = require('./git');
var RawFileStatusSerializer = {
    to: function (a) { return [a.x, a.y, a.path, a.mimetype, a.rename]; },
    from: function (b) { return ({ x: b[0], y: b[1], path: b[2], mimetype: b[3], rename: b[4] }); }
};
var BranchSerializer = {
    to: function (a) { return [a.name, a.commit, a.type, a.remote, a.upstream, a.ahead, a.behind]; },
    from: function (b) { return ({ name: b[0], commit: b[1], type: b[2], remote: b[3], upstream: b[4], ahead: b[5], behind: b[6] }); }
};
var RefSerializer = {
    to: function (a) { return [a.name, a.commit, a.type, a.remote]; },
    from: function (b) { return ({ name: b[0], commit: b[1], type: b[2], remote: b[3] }); }
};
var RemoteSerializer = {
    to: function (a) { return [a.name, a.url]; },
    from: function (b) { return ({ name: b[0], url: b[1] }); }
};
var RawStatusSerializer = {
    to: function (a) { return !a ? null : [
        a.repositoryRoot,
        a.state,
        a.status.map(RawFileStatusSerializer.to),
        BranchSerializer.to(a.HEAD),
        a.refs.map(RefSerializer.to),
        a.remotes.map(RemoteSerializer.to)
    ]; },
    from: function (b) { return !b ? null : {
        repositoryRoot: b[0],
        state: b[1],
        status: b[2].map(RawFileStatusSerializer.from),
        HEAD: BranchSerializer.from(b[3]),
        refs: b[4].map(RefSerializer.from),
        remotes: b[5].map(RemoteSerializer.from)
    }; }
};
var GitChannel = (function () {
    function GitChannel(service) {
        this.service = service;
    }
    GitChannel.prototype.call = function (command, args) {
        switch (command) {
            case 'getVersion': return this.service.then(function (s) { return s.getVersion(); });
            case 'serviceState': return this.service.then(function (s) { return s.serviceState(); });
            case 'statusCount': return this.service.then(function (s) { return s.statusCount(); });
            case 'status': return this.service.then(function (s) { return s.status(); }).then(RawStatusSerializer.to);
            case 'init': return this.service.then(function (s) { return s.init(); }).then(RawStatusSerializer.to);
            case 'add': return this.service.then(function (s) { return s.add(args); }).then(RawStatusSerializer.to);
            case 'stage': return this.service.then(function (s) { return s.stage(args[0], args[1]); }).then(RawStatusSerializer.to);
            case 'branch': return this.service.then(function (s) { return s.branch(args[0], args[1]); }).then(RawStatusSerializer.to);
            case 'checkout': return this.service.then(function (s) { return s.checkout(args[0], args[1]); }).then(RawStatusSerializer.to);
            case 'clean': return this.service.then(function (s) { return s.clean(args); }).then(RawStatusSerializer.to);
            case 'undo': return this.service.then(function (s) { return s.undo(); }).then(RawStatusSerializer.to);
            case 'reset': return this.service.then(function (s) { return s.reset(args[0], args[1]); }).then(RawStatusSerializer.to);
            case 'revertFiles': return this.service.then(function (s) { return s.revertFiles(args[0], args[1]); }).then(RawStatusSerializer.to);
            case 'fetch': return this.service.then(function (s) { return s.fetch(); }).then(RawStatusSerializer.to);
            case 'pull': return this.service.then(function (s) { return s.pull(args); }).then(RawStatusSerializer.to);
            case 'push': return this.service.then(function (s) { return s.push(args[0], args[1], args[2]); }).then(RawStatusSerializer.to);
            case 'sync': return this.service.then(function (s) { return s.sync(); }).then(RawStatusSerializer.to);
            case 'commit': return this.service.then(function (s) { return s.commit(args[0], args[1], args[2], args[3]); }).then(RawStatusSerializer.to);
            case 'detectMimetypes': return this.service.then(function (s) { return s.detectMimetypes(args[0], args[1]); });
            case 'show': return this.service.then(function (s) { return s.show(args[0], args[1]); });
            case 'onOutput': return this.service.then(function (s) { return ipc_1.eventToCall(s.onOutput); });
            case 'getCommitTemplate': return this.service.then(function (s) { return s.getCommitTemplate(); });
            case 'getCommit': return this.service.then(function (s) { return s.getCommit(args); });
        }
    };
    return GitChannel;
}());
exports.GitChannel = GitChannel;
var UnavailableGitChannel = (function () {
    function UnavailableGitChannel() {
    }
    UnavailableGitChannel.prototype.call = function (command) {
        switch (command) {
            case 'serviceState': return winjs_base_1.TPromise.as(git_1.RawServiceState.GitNotFound);
            default: return winjs_base_1.TPromise.as(null);
        }
    };
    return UnavailableGitChannel;
}());
exports.UnavailableGitChannel = UnavailableGitChannel;
var GitChannelClient = (function () {
    function GitChannelClient(channel) {
        this.channel = channel;
        this._onOutput = ipc_1.eventFromCall(this.channel, 'onOutput');
    }
    Object.defineProperty(GitChannelClient.prototype, "onOutput", {
        get: function () { return this._onOutput; },
        enumerable: true,
        configurable: true
    });
    GitChannelClient.prototype.getVersion = function () {
        return this.channel.call('getVersion');
    };
    GitChannelClient.prototype.serviceState = function () {
        return this.channel.call('serviceState');
    };
    GitChannelClient.prototype.statusCount = function () {
        return this.channel.call('statusCount');
    };
    GitChannelClient.prototype.status = function () {
        return this.channel.call('status').then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.init = function () {
        return this.channel.call('init').then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.add = function (filesPaths) {
        return this.channel.call('add', filesPaths).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.stage = function (filePath, content) {
        return this.channel.call('stage', [filePath, content]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.branch = function (name, checkout) {
        return this.channel.call('branch', [name, checkout]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.checkout = function (treeish, filePaths) {
        return this.channel.call('checkout', [treeish, filePaths]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.clean = function (filePaths) {
        return this.channel.call('clean', filePaths).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.undo = function () {
        return this.channel.call('undo').then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.reset = function (treeish, hard) {
        return this.channel.call('reset', [treeish, hard]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.revertFiles = function (treeish, filePaths) {
        return this.channel.call('revertFiles', [treeish, filePaths]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.fetch = function () {
        return this.channel.call('fetch').then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.pull = function (rebase) {
        return this.channel.call('pull', rebase).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.push = function (remote, name, options) {
        return this.channel.call('push', [remote, name, options]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.sync = function () {
        return this.channel.call('sync').then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.commit = function (message, amend, stage, signoff) {
        return this.channel.call('commit', [message, amend, stage, signoff]).then(RawStatusSerializer.from);
    };
    GitChannelClient.prototype.detectMimetypes = function (path, treeish) {
        return this.channel.call('detectMimetypes', [path, treeish]);
    };
    GitChannelClient.prototype.show = function (path, treeish) {
        return this.channel.call('show', [path, treeish]);
    };
    GitChannelClient.prototype.getCommitTemplate = function () {
        return this.channel.call('getCommitTemplate');
    };
    GitChannelClient.prototype.getCommit = function (ref) {
        return this.channel.call('getCommit', ref);
    };
    return GitChannelClient;
}());
exports.GitChannelClient = GitChannelClient;
var AskpassChannel = (function () {
    function AskpassChannel(service) {
        this.service = service;
    }
    AskpassChannel.prototype.call = function (command, args) {
        switch (command) {
            case 'askpass': return this.service.askpass(args[0], args[1], args[2]);
        }
    };
    return AskpassChannel;
}());
exports.AskpassChannel = AskpassChannel;
var AskpassChannelClient = (function () {
    function AskpassChannelClient(channel) {
        this.channel = channel;
    }
    AskpassChannelClient.prototype.askpass = function (id, host, command) {
        return this.channel.call('askpass', [id, host, command]);
    };
    return AskpassChannelClient;
}());
exports.AskpassChannelClient = AskpassChannelClient;
