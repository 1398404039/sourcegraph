/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var nls = require("vs/nls");
var lifecycle_1 = require("vs/base/common/lifecycle");
var types_1 = require("vs/base/common/types");
var actions_1 = require("vs/base/common/actions");
var model = require("vs/workbench/parts/git/common/gitModel");
var inputs = require("vs/workbench/parts/git/browser/gitEditorInputs");
var editor_1 = require("vs/workbench/common/editor");
var errors = require("vs/base/common/errors");
var platform = require("vs/base/common/platform");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var event_1 = require("vs/platform/event/common/event");
var files_1 = require("vs/platform/files/common/files");
var message_1 = require("vs/platform/message/common/message");
var severity_1 = require("vs/base/common/severity");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var git_1 = require("vs/workbench/parts/git/common/git");
var quickOpenService_1 = require("vs/workbench/services/quickopen/common/quickOpenService");
var paths = require("vs/base/common/paths");
var uri_1 = require("vs/base/common/uri");
var configurationEditing_1 = require("vs/workbench/services/configuration/common/configurationEditing");
function flatten(context, preferFocus) {
    if (preferFocus === void 0) { preferFocus = false; }
    if (!context) {
        return context;
    }
    else if (Array.isArray(context)) {
        if (context.some(function (c) { return !(c instanceof model.FileStatus); })) {
            throw new Error('Invalid context.');
        }
        return context;
    }
    else if (context instanceof model.FileStatus) {
        return [context];
    }
    else if (context instanceof model.StatusGroup) {
        return context.all();
    }
    else if (context.tree) {
        var elements = context.tree.getSelection();
        return elements.indexOf(context.fileStatus) > -1 ? elements : [context.fileStatus];
    }
    else if (context.selection) {
        return !preferFocus && context.selection.indexOf(context.focus) > -1 ? context.selection : [context.focus];
    }
    else {
        throw new Error('Invalid context.');
    }
}
var GitAction = (function (_super) {
    __extends(GitAction, _super);
    function GitAction(id, label, cssClass, gitService) {
        var _this = _super.call(this, id, label, cssClass, false) || this;
        _this.gitService = gitService;
        _this.toDispose = [_this.gitService.addBulkListener2(function () { return _this.onGitServiceChange(); })];
        _this.onGitServiceChange();
        return _this;
    }
    GitAction.prototype.onGitServiceChange = function () {
        this.updateEnablement();
    };
    GitAction.prototype.updateEnablement = function () {
        this.enabled = this.isEnabled();
    };
    GitAction.prototype.isEnabled = function () {
        return !!this.gitService;
    };
    GitAction.prototype.dispose = function () {
        this.gitService = null;
        this.toDispose = lifecycle_1.dispose(this.toDispose);
        _super.prototype.dispose.call(this);
    };
    return GitAction;
}(actions_1.Action));
exports.GitAction = GitAction;
var OpenChangeAction = (function (_super) {
    __extends(OpenChangeAction, _super);
    function OpenChangeAction(editorService, gitService) {
        var _this = _super.call(this, OpenChangeAction.ID, nls.localize('openChange', "Open Change"), 'git-action open-change', gitService) || this;
        _this.editorService = editorService;
        _this.onGitServiceChange();
        return _this;
    }
    OpenChangeAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && !!this.editorService;
    };
    OpenChangeAction.prototype.run = function (context) {
        var _this = this;
        var statuses = flatten(context, true);
        return this.gitService.getInput(statuses[0]).then(function (input) {
            var options = new editor_1.TextDiffEditorOptions();
            options.forceOpen = true;
            return _this.editorService.openEditor(input, options);
        });
    };
    return OpenChangeAction;
}(GitAction));
OpenChangeAction.ID = 'workbench.action.git.openChange';
OpenChangeAction = __decorate([
    __param(0, editorService_1.IWorkbenchEditorService), __param(1, git_1.IGitService)
], OpenChangeAction);
exports.OpenChangeAction = OpenChangeAction;
var OpenFileAction = (function (_super) {
    __extends(OpenFileAction, _super);
    function OpenFileAction(editorService, fileService, gitService, contextService) {
        var _this = _super.call(this, OpenFileAction.ID, nls.localize('openFile', "Open File"), 'git-action open-file', gitService) || this;
        _this.fileService = fileService;
        _this.editorService = editorService;
        _this.contextService = contextService;
        _this.onGitServiceChange();
        return _this;
    }
    OpenFileAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && !!this.editorService || !!this.fileService;
    };
    OpenFileAction.prototype.getPath = function (status) {
        if (status.getStatus() === git_1.Status.INDEX_RENAMED) {
            return status.getRename();
        }
        else {
            var indexStatus = this.gitService.getModel().getStatus().find(status.getPath(), git_1.StatusType.INDEX);
            if (indexStatus && indexStatus.getStatus() === git_1.Status.INDEX_RENAMED) {
                return status.getRename();
            }
            else {
                return status.getPath();
            }
        }
    };
    OpenFileAction.prototype.run = function (context) {
        var _this = this;
        var statuses = flatten(context, true);
        var status = statuses[0];
        if (!(status instanceof model.FileStatus)) {
            return winjs_base_1.Promise.wrapError(new Error('Can\'t open file.'));
        }
        if (OpenFileAction.DELETED_STATES.indexOf(status.getStatus()) > -1) {
            return winjs_base_1.Promise.wrapError(new Error('Can\'t open file which has been deleted.'));
        }
        var resource = uri_1.default.file(paths.join(this.gitService.getModel().getRepositoryRoot(), this.getPath(status)));
        return this.fileService.resolveFile(resource)
            .then(function (stat) { return _this.editorService.openEditor({
            resource: stat.resource,
            options: { forceOpen: true }
        }); });
    };
    return OpenFileAction;
}(GitAction));
OpenFileAction.DELETED_STATES = [git_1.Status.BOTH_DELETED, git_1.Status.DELETED, git_1.Status.DELETED_BY_US, git_1.Status.INDEX_DELETED];
OpenFileAction.ID = 'workbench.action.git.openFile';
OpenFileAction = __decorate([
    __param(0, editorService_1.IWorkbenchEditorService), __param(1, files_1.IFileService), __param(2, git_1.IGitService), __param(3, workspace_1.IWorkspaceContextService)
], OpenFileAction);
exports.OpenFileAction = OpenFileAction;
var InitAction = (function (_super) {
    __extends(InitAction, _super);
    function InitAction(gitService) {
        return _super.call(this, InitAction.ID, nls.localize('init', "Init"), 'git-action init', gitService) || this;
    }
    InitAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && this.gitService.getState() === git_1.ServiceState.NotARepo;
    };
    InitAction.prototype.run = function () {
        return this.gitService.init();
    };
    return InitAction;
}(GitAction));
InitAction.ID = 'workbench.action.git.init';
InitAction = __decorate([
    __param(0, git_1.IGitService)
], InitAction);
exports.InitAction = InitAction;
var RefreshAction = (function (_super) {
    __extends(RefreshAction, _super);
    function RefreshAction(gitService) {
        return _super.call(this, RefreshAction.ID, nls.localize('refresh', "Refresh"), 'git-action refresh', gitService) || this;
    }
    RefreshAction.prototype.run = function () {
        return this.gitService.status();
    };
    return RefreshAction;
}(GitAction));
RefreshAction.ID = 'workbench.action.git.refresh';
RefreshAction = __decorate([
    __param(0, git_1.IGitService)
], RefreshAction);
exports.RefreshAction = RefreshAction;
var BaseStageAction = (function (_super) {
    __extends(BaseStageAction, _super);
    function BaseStageAction(id, label, className, gitService, editorService) {
        var _this = _super.call(this, id, label, className, gitService) || this;
        _this.editorService = editorService;
        return _this;
    }
    BaseStageAction.prototype.run = function (context) {
        var _this = this;
        var flatContext = flatten(context);
        return this.gitService.add(flatContext).then(function (status) {
            var targetEditor = _this.findGitWorkingTreeEditor();
            if (!targetEditor) {
                return winjs_base_1.TPromise.as(status);
            }
            var currentGitEditorInput = targetEditor.input;
            var currentFileStatus = currentGitEditorInput.getFileStatus();
            if (flatContext && flatContext.every(function (f) { return f !== currentFileStatus; })) {
                return winjs_base_1.TPromise.as(status);
            }
            var path = currentGitEditorInput.getFileStatus().getPath();
            var fileStatus = status.getStatus().find(path, git_1.StatusType.INDEX);
            if (!fileStatus) {
                return winjs_base_1.TPromise.as(status);
            }
            var editorControl = targetEditor.getControl();
            var viewState = editorControl ? editorControl.saveViewState() : null;
            return _this.gitService.getInput(fileStatus).then(function (input) {
                var options = new editor_1.TextDiffEditorOptions();
                options.forceOpen = true;
                return _this.editorService.openEditor(input, options, targetEditor.position).then(function (editor) {
                    if (viewState) {
                        editorControl.restoreViewState(viewState);
                    }
                    return status;
                });
            });
        });
    };
    BaseStageAction.prototype.findGitWorkingTreeEditor = function () {
        var editors = this.editorService.getVisibleEditors();
        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (inputs.isGitEditorInput(editor.input)) {
                return editor;
            }
        }
        return null;
    };
    BaseStageAction.prototype.dispose = function () {
        this.editorService = null;
        _super.prototype.dispose.call(this);
    };
    return BaseStageAction;
}(GitAction));
exports.BaseStageAction = BaseStageAction;
var StageAction = (function (_super) {
    __extends(StageAction, _super);
    function StageAction(gitService, editorService) {
        return _super.call(this, StageAction.ID, StageAction.LABEL, 'git-action stage', gitService, editorService) || this;
    }
    return StageAction;
}(BaseStageAction));
StageAction.ID = 'workbench.action.git.stage';
StageAction.LABEL = nls.localize('stageChanges', "Stage");
StageAction = __decorate([
    __param(0, git_1.IGitService),
    __param(1, editorService_1.IWorkbenchEditorService)
], StageAction);
exports.StageAction = StageAction;
var GlobalStageAction = (function (_super) {
    __extends(GlobalStageAction, _super);
    function GlobalStageAction(gitService, editorService) {
        return _super.call(this, GlobalStageAction.ID, nls.localize('stageAllChanges', "Stage All"), 'git-action stage', gitService, editorService) || this;
    }
    GlobalStageAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && this.gitService.getModel().getStatus().getWorkingTreeStatus().all().length > 0;
    };
    GlobalStageAction.prototype.run = function (context) {
        return _super.prototype.run.call(this);
    };
    return GlobalStageAction;
}(BaseStageAction));
GlobalStageAction.ID = 'workbench.action.git.stageAll';
GlobalStageAction = __decorate([
    __param(0, git_1.IGitService), __param(1, editorService_1.IWorkbenchEditorService)
], GlobalStageAction);
exports.GlobalStageAction = GlobalStageAction;
var BaseUndoAction = (function (_super) {
    __extends(BaseUndoAction, _super);
    function BaseUndoAction(id, label, className, gitService, eventService, messageService, fileService, editorService, contextService) {
        var _this = _super.call(this, id, label, className, gitService) || this;
        _this.eventService = eventService;
        _this.editorService = editorService;
        _this.messageService = messageService;
        _this.fileService = fileService;
        _this.contextService = contextService;
        _this.onGitServiceChange();
        return _this;
    }
    BaseUndoAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && !!this.eventService && !!this.editorService && !!this.fileService;
    };
    BaseUndoAction.prototype.run = function (context) {
        var _this = this;
        if (!this.messageService.confirm(this.getConfirm(context))) {
            return winjs_base_1.TPromise.as(null);
        }
        var promises = [];
        if (context instanceof model.StatusGroup) {
            promises = [this.gitService.undo()];
        }
        else {
            var all = flatten(context);
            var toClean = [];
            var toCheckout = [];
            for (var i = 0; i < all.length; i++) {
                var status = all[i].clone();
                switch (status.getStatus()) {
                    case git_1.Status.UNTRACKED:
                    case git_1.Status.IGNORED:
                        toClean.push(status);
                        break;
                    default:
                        toCheckout.push(status);
                        break;
                }
            }
            if (toClean.length > 0) {
                promises.push(this.gitService.clean(toClean));
            }
            if (toCheckout.length > 0) {
                promises.push(this.gitService.checkout('', toCheckout));
            }
        }
        return winjs_base_1.Promise.join(promises).then(function (statuses) {
            if (statuses.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            var status = statuses[statuses.length - 1];
            var targetEditor = _this.findWorkingTreeDiffEditor();
            if (!targetEditor) {
                return winjs_base_1.TPromise.as(status);
            }
            var currentGitEditorInput = targetEditor.input;
            var currentFileStatus = currentGitEditorInput.getFileStatus();
            if (all && all.every(function (f) { return f !== currentFileStatus; })) {
                return winjs_base_1.TPromise.as(status);
            }
            var path = currentGitEditorInput.getFileStatus().getPath();
            var editor = targetEditor.getControl();
            var modifiedEditorControl = editor ? editor.getModifiedEditor() : null;
            var modifiedViewState = modifiedEditorControl ? modifiedEditorControl.saveViewState() : null;
            return _this.fileService.resolveFile(_this.contextService.toResource(path)).then(function (stat) {
                return _this.editorService.openEditor({
                    resource: stat.resource,
                    options: {
                        forceOpen: true
                    }
                }, targetEditor.position).then(function (editor) {
                    if (modifiedViewState) {
                        var codeEditor = targetEditor.getControl();
                        if (codeEditor) {
                            codeEditor.restoreViewState(modifiedViewState);
                        }
                    }
                });
            });
        }).then(null, function (errors) {
            console.error('One or more errors occurred', errors);
            return winjs_base_1.Promise.wrapError(errors[0]);
        });
    };
    BaseUndoAction.prototype.findWorkingTreeDiffEditor = function () {
        var editors = this.editorService.getVisibleEditors();
        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (editor.input instanceof inputs.GitWorkingTreeDiffEditorInput) {
                return editor;
            }
        }
        return null;
    };
    BaseUndoAction.prototype.getConfirm = function (context) {
        var all = flatten(context);
        if (all.length > 1) {
            var count = all.length;
            return {
                message: nls.localize('confirmUndoMessage', "Are you sure you want to clean all changes?"),
                detail: count === 1
                    ? nls.localize('confirmUndoAllOne', "There are unstaged changes in {0} file.\n\nThis action is irreversible!", count)
                    : nls.localize('confirmUndoAllMultiple', "There are unstaged changes in {0} files.\n\nThis action is irreversible!", count),
                primaryButton: nls.localize({ key: 'cleanChangesLabel', comment: ['&& denotes a mnemonic'] }, "&&Clean Changes")
            };
        }
        var label = all[0].getPathComponents().reverse()[0];
        return {
            message: nls.localize('confirmUndo', "Are you sure you want to clean changes in '{0}'?", label),
            detail: nls.localize('irreversible', "This action is irreversible!"),
            primaryButton: nls.localize({ key: 'cleanChangesLabel', comment: ['&& denotes a mnemonic'] }, "&&Clean Changes")
        };
    };
    BaseUndoAction.prototype.dispose = function () {
        this.eventService = null;
        this.editorService = null;
        this.fileService = null;
        _super.prototype.dispose.call(this);
    };
    return BaseUndoAction;
}(GitAction));
exports.BaseUndoAction = BaseUndoAction;
var UndoAction = (function (_super) {
    __extends(UndoAction, _super);
    function UndoAction(gitService, eventService, messageService, fileService, editorService, contextService) {
        return _super.call(this, UndoAction.ID, nls.localize('undoChanges', "Clean"), 'git-action undo', gitService, eventService, messageService, fileService, editorService, contextService) || this;
    }
    return UndoAction;
}(BaseUndoAction));
UndoAction.ID = 'workbench.action.git.undo';
UndoAction = __decorate([
    __param(0, git_1.IGitService), __param(1, event_1.IEventService), __param(2, message_1.IMessageService), __param(3, files_1.IFileService), __param(4, editorService_1.IWorkbenchEditorService), __param(5, workspace_1.IWorkspaceContextService)
], UndoAction);
exports.UndoAction = UndoAction;
var GlobalUndoAction = (function (_super) {
    __extends(GlobalUndoAction, _super);
    function GlobalUndoAction(gitService, eventService, messageService, fileService, editorService, contextService) {
        return _super.call(this, GlobalUndoAction.ID, nls.localize('undoAllChanges', "Clean All"), 'git-action undo', gitService, eventService, messageService, fileService, editorService, contextService) || this;
    }
    GlobalUndoAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && this.gitService.getModel().getStatus().getWorkingTreeStatus().all().length > 0;
    };
    GlobalUndoAction.prototype.run = function (context) {
        return _super.prototype.run.call(this, this.gitService.getModel().getStatus().getWorkingTreeStatus());
    };
    return GlobalUndoAction;
}(BaseUndoAction));
GlobalUndoAction.ID = 'workbench.action.git.undoAll';
GlobalUndoAction = __decorate([
    __param(0, git_1.IGitService), __param(1, event_1.IEventService), __param(2, message_1.IMessageService), __param(3, files_1.IFileService), __param(4, editorService_1.IWorkbenchEditorService), __param(5, workspace_1.IWorkspaceContextService)
], GlobalUndoAction);
exports.GlobalUndoAction = GlobalUndoAction;
var BaseUnstageAction = (function (_super) {
    __extends(BaseUnstageAction, _super);
    function BaseUnstageAction(id, label, className, gitService, editorService) {
        var _this = _super.call(this, id, label, className, gitService) || this;
        _this.editorService = editorService;
        _this.onGitServiceChange();
        return _this;
    }
    BaseUnstageAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && !!this.editorService;
    };
    BaseUnstageAction.prototype.run = function (context) {
        var _this = this;
        var flatContext = flatten(context);
        return this.gitService.revertFiles('HEAD', flatContext).then(function (status) {
            var targetEditor = _this.findGitIndexEditor();
            if (!targetEditor) {
                return winjs_base_1.TPromise.as(status);
            }
            var currentGitEditorInput = targetEditor.input;
            var currentFileStatus = currentGitEditorInput.getFileStatus();
            if (flatContext && flatContext.every(function (f) { return f !== currentFileStatus; })) {
                return winjs_base_1.TPromise.as(status);
            }
            var path = currentGitEditorInput.getFileStatus().getPath();
            var fileStatus = status.getStatus().find(path, git_1.StatusType.WORKING_TREE);
            if (!fileStatus) {
                return winjs_base_1.TPromise.as(status);
            }
            var editorControl = targetEditor.getControl();
            var viewState = editorControl ? editorControl.saveViewState() : null;
            return _this.gitService.getInput(fileStatus).then(function (input) {
                var options = new editor_1.TextDiffEditorOptions();
                options.forceOpen = true;
                return _this.editorService.openEditor(input, options, targetEditor.position).then(function (editor) {
                    if (viewState) {
                        editorControl.restoreViewState(viewState);
                    }
                    return status;
                });
            });
        });
    };
    BaseUnstageAction.prototype.findGitIndexEditor = function () {
        var editors = this.editorService.getVisibleEditors();
        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (inputs.isGitEditorInput(editor.input)) {
                return editor;
            }
        }
        return null;
    };
    BaseUnstageAction.prototype.dispose = function () {
        this.editorService = null;
        _super.prototype.dispose.call(this);
    };
    return BaseUnstageAction;
}(GitAction));
exports.BaseUnstageAction = BaseUnstageAction;
var UnstageAction = (function (_super) {
    __extends(UnstageAction, _super);
    function UnstageAction(gitService, editorService) {
        return _super.call(this, UnstageAction.ID, UnstageAction.LABEL, 'git-action unstage', gitService, editorService) || this;
    }
    return UnstageAction;
}(BaseUnstageAction));
UnstageAction.ID = 'workbench.action.git.unstage';
UnstageAction.LABEL = nls.localize('unstage', "Unstage");
UnstageAction = __decorate([
    __param(0, git_1.IGitService),
    __param(1, editorService_1.IWorkbenchEditorService)
], UnstageAction);
exports.UnstageAction = UnstageAction;
var GlobalUnstageAction = (function (_super) {
    __extends(GlobalUnstageAction, _super);
    function GlobalUnstageAction(gitService, editorService) {
        return _super.call(this, GlobalUnstageAction.ID, nls.localize('unstageAllChanges', "Unstage All"), 'git-action unstage', gitService, editorService) || this;
    }
    GlobalUnstageAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && this.gitService.getModel().getStatus().getIndexStatus().all().length > 0;
    };
    GlobalUnstageAction.prototype.run = function (context) {
        return _super.prototype.run.call(this);
    };
    return GlobalUnstageAction;
}(BaseUnstageAction));
GlobalUnstageAction.ID = 'workbench.action.git.unstageAll';
GlobalUnstageAction = __decorate([
    __param(0, git_1.IGitService), __param(1, editorService_1.IWorkbenchEditorService)
], GlobalUnstageAction);
exports.GlobalUnstageAction = GlobalUnstageAction;
var LifecycleState;
(function (LifecycleState) {
    LifecycleState[LifecycleState["Alive"] = 0] = "Alive";
    LifecycleState[LifecycleState["Disposing"] = 1] = "Disposing";
    LifecycleState[LifecycleState["Disposed"] = 2] = "Disposed";
})(LifecycleState || (LifecycleState = {}));
var CheckoutAction = (function (_super) {
    __extends(CheckoutAction, _super);
    function CheckoutAction(branch, gitService, editorService) {
        var _this = _super.call(this, CheckoutAction.ID, branch.name, 'git-action checkout', gitService) || this;
        _this.editorService = editorService;
        _this.branch = branch;
        _this.HEAD = null;
        _this.state = LifecycleState.Alive;
        _this.runPromises = [];
        _this.onGitServiceChange();
        return _this;
    }
    CheckoutAction.prototype.onGitServiceChange = function () {
        if (this.gitService.getState() === git_1.ServiceState.OK) {
            this.HEAD = this.gitService.getModel().getHEAD();
            if (this.HEAD && this.HEAD.name === this.branch.name) {
                this.class = 'git-action checkout HEAD';
            }
            else {
                this.class = 'git-action checkout';
            }
        }
        _super.prototype.onGitServiceChange.call(this);
    };
    CheckoutAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && !!this.HEAD;
    };
    CheckoutAction.prototype.run = function (context) {
        var _this = this;
        if (this.state !== LifecycleState.Alive) {
            return winjs_base_1.Promise.wrapError('action disposed');
        }
        else if (this.HEAD && this.HEAD.name === this.branch.name) {
            return winjs_base_1.TPromise.as(null);
        }
        var result = this.gitService.checkout(this.branch.name).then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.DirtyWorkTree) {
                return winjs_base_1.Promise.wrapError(new Error(nls.localize('dirtyTreeCheckout', "Can't checkout. Please commit or stash your work first.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
        this.runPromises.push(result);
        result.done(function () { return _this.runPromises.splice(_this.runPromises.indexOf(result), 1); });
        return result;
    };
    CheckoutAction.prototype.dispose = function () {
        var _this = this;
        if (this.state !== LifecycleState.Alive) {
            return;
        }
        this.state = LifecycleState.Disposing;
        winjs_base_1.Promise.join(this.runPromises).done(function () { return _this.actuallyDispose(); });
    };
    CheckoutAction.prototype.actuallyDispose = function () {
        this.editorService = null;
        this.branch = null;
        this.HEAD = null;
        _super.prototype.dispose.call(this);
        this.state = LifecycleState.Disposed;
    };
    return CheckoutAction;
}(GitAction));
CheckoutAction.ID = 'workbench.action.git.checkout';
CheckoutAction = __decorate([
    __param(1, git_1.IGitService), __param(2, editorService_1.IWorkbenchEditorService)
], CheckoutAction);
exports.CheckoutAction = CheckoutAction;
var BranchAction = (function (_super) {
    __extends(BranchAction, _super);
    function BranchAction(checkout, gitService) {
        var _this = _super.call(this, BranchAction.ID, 'Branch', 'git-action checkout', gitService) || this;
        _this.checkout = checkout;
        return _this;
    }
    BranchAction.prototype.run = function (context) {
        if (!types_1.isString(context)) {
            return winjs_base_1.TPromise.as(false);
        }
        return this.gitService.branch(context, this.checkout);
    };
    return BranchAction;
}(GitAction));
BranchAction.ID = 'workbench.action.git.branch';
BranchAction = __decorate([
    __param(1, git_1.IGitService)
], BranchAction);
exports.BranchAction = BranchAction;
var BaseCommitAction = (function (_super) {
    __extends(BaseCommitAction, _super);
    function BaseCommitAction(commitState, id, label, cssClass, gitService) {
        var _this = _super.call(this, id, label, cssClass, gitService) || this;
        _this.commitState = commitState;
        _this.toDispose.push(commitState.addListener2('change/commitInputBox', function () {
            _this.updateEnablement();
        }));
        _this.onGitServiceChange();
        return _this;
    }
    BaseCommitAction.prototype.isEnabled = function () {
        return _super.prototype.isEnabled.call(this) && this.gitService.getModel().getStatus().getIndexStatus().all().length > 0;
    };
    BaseCommitAction.prototype.run = function (context) {
        if (!this.commitState.getCommitMessage()) {
            this.commitState.onEmptyCommitMessage();
            return winjs_base_1.TPromise.as(null);
        }
        return this.commit();
    };
    return BaseCommitAction;
}(GitAction));
exports.BaseCommitAction = BaseCommitAction;
var CommitAction = (function (_super) {
    __extends(CommitAction, _super);
    function CommitAction(commitState, gitService) {
        return _super.call(this, commitState, CommitAction.ID, nls.localize('commitStaged', "Commit Staged"), 'git-action commit', gitService) || this;
    }
    CommitAction.prototype.commit = function () {
        return this.gitService.commit(this.commitState.getCommitMessage());
    };
    return CommitAction;
}(BaseCommitAction));
CommitAction.ID = 'workbench.action.git.commit';
CommitAction = __decorate([
    __param(1, git_1.IGitService)
], CommitAction);
exports.CommitAction = CommitAction;
var CommitSignedOffAction = (function (_super) {
    __extends(CommitSignedOffAction, _super);
    function CommitSignedOffAction(commitState, gitService) {
        return _super.call(this, commitState, CommitAction.ID, nls.localize('commitStagedSignedOff', "Commit Staged (Signed Off)"), 'git-action commit-signed-off', gitService) || this;
    }
    CommitSignedOffAction.prototype.commit = function () {
        return this.gitService.commit(this.commitState.getCommitMessage(), undefined, undefined, true);
    };
    return CommitSignedOffAction;
}(BaseCommitAction));
CommitSignedOffAction.ID = 'workbench.action.git.commitSignedOff';
CommitSignedOffAction = __decorate([
    __param(1, git_1.IGitService)
], CommitSignedOffAction);
exports.CommitSignedOffAction = CommitSignedOffAction;
var InputCommitAction = (function (_super) {
    __extends(InputCommitAction, _super);
    function InputCommitAction(id, label, gitService, quickOpenService) {
        if (id === void 0) { id = InputCommitAction.ID; }
        if (label === void 0) { label = InputCommitAction.LABEL; }
        var _this = _super.call(this, id, label, '', gitService) || this;
        _this.quickOpenService = quickOpenService;
        return _this;
    }
    InputCommitAction.prototype.isEnabled = function () {
        if (!this.gitService) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var status = this.gitService.getModel().getStatus();
        return status.getIndexStatus().all().length > 0 || status.getWorkingTreeStatus().all().length > 0;
    };
    InputCommitAction.prototype.run = function () {
        var _this = this;
        if (!this.enabled) {
            return winjs_base_1.TPromise.as(null);
        }
        var status = this.gitService.getModel().getStatus();
        return this.quickOpenService.input({ prompt: nls.localize('commitMessage', "Commit Message") })
            .then(function (message) { return message && _this.gitService.commit(message, false, status.getIndexStatus().all().length === 0); });
    };
    return InputCommitAction;
}(GitAction));
InputCommitAction.ID = 'workbench.action.git.input-commit';
InputCommitAction.LABEL = nls.localize('commit', "Commit");
InputCommitAction = __decorate([
    __param(2, git_1.IGitService),
    __param(3, quickOpenService_1.IQuickOpenService)
], InputCommitAction);
exports.InputCommitAction = InputCommitAction;
var StageAndCommitAction = (function (_super) {
    __extends(StageAndCommitAction, _super);
    function StageAndCommitAction(commitState, id, label, cssClass, gitService) {
        if (id === void 0) { id = StageAndCommitAction.ID; }
        if (label === void 0) { label = StageAndCommitAction.LABEL; }
        if (cssClass === void 0) { cssClass = StageAndCommitAction.CSSCLASS; }
        return _super.call(this, commitState, id, label, cssClass, gitService) || this;
    }
    StageAndCommitAction.prototype.isEnabled = function () {
        if (!this.gitService) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var status = this.gitService.getModel().getStatus();
        return status.getIndexStatus().all().length > 0
            || status.getWorkingTreeStatus().all().length > 0;
    };
    StageAndCommitAction.prototype.commit = function () {
        return this.gitService.commit(this.commitState.getCommitMessage(), false, true);
    };
    return StageAndCommitAction;
}(BaseCommitAction));
StageAndCommitAction.ID = 'workbench.action.git.stageAndCommit';
StageAndCommitAction.LABEL = nls.localize('commitAll', "Commit All");
StageAndCommitAction.CSSCLASS = 'git-action stage-and-commit';
StageAndCommitAction = __decorate([
    __param(4, git_1.IGitService)
], StageAndCommitAction);
exports.StageAndCommitAction = StageAndCommitAction;
var StageAndCommitSignedOffAction = (function (_super) {
    __extends(StageAndCommitSignedOffAction, _super);
    function StageAndCommitSignedOffAction(commitState, gitService) {
        return _super.call(this, commitState, StageAndCommitAction.ID, nls.localize('commitAllSignedOff', "Commit All (Signed Off)"), 'git-action stage-and-commit-signed-off', gitService) || this;
    }
    StageAndCommitSignedOffAction.prototype.commit = function () {
        return this.gitService.commit(this.commitState.getCommitMessage(), false, true, true);
    };
    return StageAndCommitSignedOffAction;
}(StageAndCommitAction));
StageAndCommitSignedOffAction.ID = 'workbench.action.git.stageAndCommitSignedOff';
StageAndCommitSignedOffAction = __decorate([
    __param(1, git_1.IGitService)
], StageAndCommitSignedOffAction);
exports.StageAndCommitSignedOffAction = StageAndCommitSignedOffAction;
var SmartCommitAction = (function (_super) {
    __extends(SmartCommitAction, _super);
    function SmartCommitAction(commitState, gitService, messageService) {
        var _this = _super.call(this, commitState, SmartCommitAction.ID, SmartCommitAction.ALL, 'git-action smart-commit', gitService) || this;
        _this.messageService = messageService;
        _this.onGitServiceChange();
        return _this;
    }
    SmartCommitAction.prototype.onGitServiceChange = function () {
        _super.prototype.onGitServiceChange.call(this);
        if (!this.enabled) {
            this.label = SmartCommitAction.ALL;
            return;
        }
        var status = this.gitService.getModel().getStatus();
        if (status.getIndexStatus().all().length > 0) {
            this.label = SmartCommitAction.STAGED;
        }
        else {
            this.label = SmartCommitAction.ALL;
        }
        this.label += ' (' + (platform.isMacintosh ? 'Cmd+Enter' : 'Ctrl+Enter') + ')';
    };
    SmartCommitAction.prototype.isEnabled = function () {
        if (!this.gitService) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var status = this.gitService.getModel().getStatus();
        return status.getIndexStatus().all().length > 0
            || status.getWorkingTreeStatus().all().length > 0;
    };
    SmartCommitAction.prototype.commit = function () {
        var status = this.gitService.getModel().getStatus();
        return this.gitService.commit(this.commitState.getCommitMessage(), false, status.getIndexStatus().all().length === 0);
    };
    return SmartCommitAction;
}(BaseCommitAction));
SmartCommitAction.ID = 'workbench.action.git.commitAll';
SmartCommitAction.ALL = nls.localize('commitAll2', "Commit All");
SmartCommitAction.STAGED = nls.localize('commitStaged2', "Commit Staged");
SmartCommitAction = __decorate([
    __param(1, git_1.IGitService), __param(2, message_1.IMessageService)
], SmartCommitAction);
exports.SmartCommitAction = SmartCommitAction;
var PullAction = (function (_super) {
    __extends(PullAction, _super);
    function PullAction(id, label, gitService) {
        if (id === void 0) { id = PullAction.ID; }
        if (label === void 0) { label = PullAction.LABEL; }
        return _super.call(this, id, label, 'git-action pull', gitService) || this;
    }
    PullAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        var HEAD = model.getHEAD();
        if (!HEAD || !HEAD.name || !HEAD.upstream) {
            return false;
        }
        return true;
    };
    PullAction.prototype.run = function (context) {
        return this.pull();
    };
    PullAction.prototype.pull = function (rebase) {
        if (rebase === void 0) { rebase = false; }
        return this.gitService.pull(rebase).then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.DirtyWorkTree) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('dirtyTreePull', "Can't pull. Please commit or stash your work first."), { severity: severity_1.default.Warning }));
            }
            else if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('authFailed', "Authentication failed on the git remote.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
    };
    return PullAction;
}(GitAction));
PullAction.ID = 'workbench.action.git.pull';
PullAction.LABEL = 'Pull';
PullAction = __decorate([
    __param(2, git_1.IGitService)
], PullAction);
exports.PullAction = PullAction;
var PullWithRebaseAction = (function (_super) {
    __extends(PullWithRebaseAction, _super);
    function PullWithRebaseAction(gitService) {
        return _super.call(this, PullWithRebaseAction.ID, PullWithRebaseAction.LABEL, gitService) || this;
    }
    PullWithRebaseAction.prototype.run = function (context) {
        return this.pull(true);
    };
    return PullWithRebaseAction;
}(PullAction));
PullWithRebaseAction.ID = 'workbench.action.git.pull.rebase';
PullWithRebaseAction.LABEL = 'Pull (Rebase)';
PullWithRebaseAction = __decorate([
    __param(0, git_1.IGitService)
], PullWithRebaseAction);
exports.PullWithRebaseAction = PullWithRebaseAction;
var PushAction = (function (_super) {
    __extends(PushAction, _super);
    function PushAction(id, label, gitService) {
        if (id === void 0) { id = PushAction.ID; }
        if (label === void 0) { label = PushAction.LABEL; }
        return _super.call(this, id, label, 'git-action push', gitService) || this;
    }
    PushAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        var HEAD = model.getHEAD();
        if (!HEAD || !HEAD.name || !HEAD.upstream) {
            return false;
        }
        if (!HEAD.ahead) {
            return false;
        }
        return true;
    };
    PushAction.prototype.run = function (context) {
        return this.gitService.push().then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('authFailed', "Authentication failed on the git remote.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
    };
    return PushAction;
}(GitAction));
PushAction.ID = 'workbench.action.git.push';
PushAction.LABEL = 'Push';
PushAction = __decorate([
    __param(2, git_1.IGitService)
], PushAction);
exports.PushAction = PushAction;
var PushToRemoteAction = (function (_super) {
    __extends(PushToRemoteAction, _super);
    function PushToRemoteAction(id, label, gitService, quickOpenService) {
        if (id === void 0) { id = PushToRemoteAction.ID; }
        if (label === void 0) { label = PushToRemoteAction.LABEL; }
        var _this = _super.call(this, id, label, 'git-action publish', gitService) || this;
        _this.quickOpenService = quickOpenService;
        return _this;
    }
    PushToRemoteAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        if (model.getRemotes().length === 0) {
            return false;
        }
        var HEAD = model.getHEAD();
        if (!HEAD || !HEAD.name) {
            return false;
        }
        return true;
    };
    PushToRemoteAction.prototype.run = function (context) {
        var _this = this;
        var model = this.gitService.getModel();
        var remotes = model.getRemotes();
        var branchName = model.getHEAD().name;
        var picks = remotes.map(function (_a) {
            var name = _a.name, url = _a.url;
            return ({ label: name, description: url });
        });
        var placeHolder = nls.localize('pushToRemotePickMessage', "Pick a remote to push the branch '{0}' to:", branchName);
        return this.quickOpenService.pick(picks, { placeHolder: placeHolder })
            .then(function (pick) { return pick && pick.label; })
            .then(function (remote) { return remote && _this.gitService.push(remote, branchName); })
            .then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('authFailed', "Authentication failed on the git remote.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
    };
    return PushToRemoteAction;
}(GitAction));
PushToRemoteAction.ID = 'workbench.action.git.pushToRemote';
PushToRemoteAction.LABEL = nls.localize('pushToRemote', "Push to...");
PushToRemoteAction = __decorate([
    __param(2, git_1.IGitService),
    __param(3, quickOpenService_1.IQuickOpenService)
], PushToRemoteAction);
exports.PushToRemoteAction = PushToRemoteAction;
var PublishAction = (function (_super) {
    __extends(PublishAction, _super);
    function PublishAction(id, label, gitService, quickOpenService, messageService) {
        if (id === void 0) { id = PublishAction.ID; }
        if (label === void 0) { label = PublishAction.LABEL; }
        var _this = _super.call(this, id, label, 'git-action publish', gitService) || this;
        _this.quickOpenService = quickOpenService;
        _this.messageService = messageService;
        return _this;
    }
    PublishAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        if (model.getRemotes().length === 0) {
            return false;
        }
        var HEAD = model.getHEAD();
        if (!HEAD || !HEAD.name || HEAD.upstream) {
            return false;
        }
        return true;
    };
    PublishAction.prototype.run = function (context) {
        var _this = this;
        var model = this.gitService.getModel();
        var remotes = model.getRemotes();
        var branchName = model.getHEAD().name;
        var promise;
        if (remotes.length === 1) {
            var remoteName = remotes[0].name;
            var result = this.messageService.confirm({
                message: nls.localize('confirmPublishMessage', "Are you sure you want to publish '{0}' to '{1}'?", branchName, remoteName),
                primaryButton: nls.localize({ key: 'confirmPublishMessageButton', comment: ['&& denotes a mnemonic'] }, "&&Publish")
            });
            promise = winjs_base_1.TPromise.as(result ? remoteName : null);
        }
        else {
            var picks = remotes.map(function (_a) {
                var name = _a.name, url = _a.url;
                return ({
                    label: name,
                    description: url
                });
            });
            var placeHolder = nls.localize('publishPickMessage', "Pick a remote to publish the branch '{0}' to:", branchName);
            promise = this.quickOpenService.pick(picks, { placeHolder: placeHolder })
                .then(function (pick) { return pick && pick.label; });
        }
        return promise
            .then(function (remote) { return remote && _this.gitService.push(remote, branchName, { setUpstream: true }); })
            .then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('authFailed', "Authentication failed on the git remote.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
    };
    return PublishAction;
}(GitAction));
PublishAction.ID = 'workbench.action.git.publish';
PublishAction.LABEL = nls.localize('publish', "Publish");
PublishAction = __decorate([
    __param(2, git_1.IGitService),
    __param(3, quickOpenService_1.IQuickOpenService),
    __param(4, message_1.IMessageService)
], PublishAction);
exports.PublishAction = PublishAction;
var SyncAction = (function (_super) {
    __extends(SyncAction, _super);
    function SyncAction(id, label, gitService, configurationService, configurationEditingService, choiceService) {
        var _this = _super.call(this, id, label, 'git-action sync', gitService) || this;
        _this.configurationService = configurationService;
        _this.configurationEditingService = configurationEditingService;
        _this.choiceService = choiceService;
        return _this;
    }
    SyncAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        var HEAD = model.getHEAD();
        if (!HEAD || !HEAD.name || !HEAD.upstream) {
            return false;
        }
        return true;
    };
    SyncAction.prototype.run = function (context) {
        var _this = this;
        if (!this.enabled) {
            return winjs_base_1.TPromise.as(null);
        }
        var shouldPrompt = this.configurationService.getConfiguration('git').confirmSync;
        if (!shouldPrompt) {
            return this.sync();
        }
        var model = this.gitService.getModel();
        var HEAD = model.getHEAD();
        var message = nls.localize('sync is unpredictable', "This action will push and pull commits to and from '{0}'.", HEAD.upstream);
        var options = [nls.localize('ok', "OK"), nls.localize('cancel', "Cancel"), nls.localize('never again', "OK, Never Show Again")];
        return this.choiceService.choose(severity_1.default.Warning, message, options).then(function (choice) {
            switch (choice) {
                case 0:
                    return _this.sync();
                case 1:
                    return winjs_base_1.TPromise.as(null);
                case 2:
                    return _this.configurationEditingService.writeConfiguration(configurationEditing_1.ConfigurationTarget.USER, { key: 'git.confirmSync', value: false })
                        .then(function () { return _this.sync(); });
                default:
                    return winjs_base_1.TPromise.as(null);
            }
        });
    };
    SyncAction.prototype.sync = function () {
        return this.gitService.sync().then(null, function (err) {
            if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                return winjs_base_1.Promise.wrapError(errors.create(nls.localize('authFailed', "Authentication failed on the git remote.")));
            }
            return winjs_base_1.Promise.wrapError(err);
        });
    };
    return SyncAction;
}(GitAction));
SyncAction.ID = 'workbench.action.git.sync';
SyncAction.LABEL = 'Sync';
SyncAction = __decorate([
    __param(2, git_1.IGitService),
    __param(3, configuration_1.IConfigurationService),
    __param(4, configurationEditing_1.IConfigurationEditingService),
    __param(5, message_1.IChoiceService)
], SyncAction);
exports.SyncAction = SyncAction;
var UndoLastCommitAction = (function (_super) {
    __extends(UndoLastCommitAction, _super);
    function UndoLastCommitAction(id, label, gitService) {
        if (id === void 0) { id = UndoLastCommitAction.ID; }
        if (label === void 0) { label = UndoLastCommitAction.LABEL; }
        return _super.call(this, UndoLastCommitAction.ID, UndoLastCommitAction.LABEL, 'git-action undo-last-commit', gitService) || this;
    }
    UndoLastCommitAction.prototype.isEnabled = function () {
        if (!_super.prototype.isEnabled.call(this)) {
            return false;
        }
        if (!this.gitService.isIdle()) {
            return false;
        }
        var model = this.gitService.getModel();
        var HEAD = model.getHEAD();
        return !!(HEAD && HEAD.commit);
    };
    UndoLastCommitAction.prototype.run = function () {
        return this.gitService.reset('HEAD~');
    };
    return UndoLastCommitAction;
}(GitAction));
UndoLastCommitAction.ID = 'workbench.action.git.undoLastCommit';
UndoLastCommitAction.LABEL = nls.localize('undoLastCommit', "Undo Last Commit");
UndoLastCommitAction = __decorate([
    __param(2, git_1.IGitService)
], UndoLastCommitAction);
exports.UndoLastCommitAction = UndoLastCommitAction;
var StartGitCheckoutAction = (function (_super) {
    __extends(StartGitCheckoutAction, _super);
    function StartGitCheckoutAction(id, label, quickOpenService) {
        var _this = _super.call(this, id, label) || this;
        _this.quickOpenService = quickOpenService;
        return _this;
    }
    StartGitCheckoutAction.prototype.run = function (event) {
        this.quickOpenService.show('git checkout ');
        return winjs_base_1.TPromise.as(null);
    };
    return StartGitCheckoutAction;
}(actions_1.Action));
StartGitCheckoutAction.ID = 'workbench.action.git.startGitCheckout';
StartGitCheckoutAction.LABEL = 'Checkout';
StartGitCheckoutAction = __decorate([
    __param(2, quickOpenService_1.IQuickOpenService)
], StartGitCheckoutAction);
exports.StartGitCheckoutAction = StartGitCheckoutAction;
var StartGitBranchAction = (function (_super) {
    __extends(StartGitBranchAction, _super);
    function StartGitBranchAction(id, label, quickOpenService) {
        var _this = _super.call(this, id, label) || this;
        _this.quickOpenService = quickOpenService;
        return _this;
    }
    StartGitBranchAction.prototype.run = function (event) {
        this.quickOpenService.show('git branch ');
        return winjs_base_1.TPromise.as(null);
    };
    return StartGitBranchAction;
}(actions_1.Action));
StartGitBranchAction.ID = 'workbench.action.git.startGitBranch';
StartGitBranchAction.LABEL = 'Branch';
StartGitBranchAction = __decorate([
    __param(2, quickOpenService_1.IQuickOpenService)
], StartGitBranchAction);
exports.StartGitBranchAction = StartGitBranchAction;
