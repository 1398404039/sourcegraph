/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var winjs_base_1 = require('vs/base/common/winjs.base');
var async_1 = require('vs/base/common/async');
var lifecycle = require('vs/base/common/lifecycle');
var env = require('vs/base/common/platform');
var actions_1 = require('vs/base/common/actions');
var editorBrowserExtensions_1 = require('vs/editor/browser/editorBrowserExtensions');
var editorcommon = require('vs/editor/common/editorCommon');
var debugHover_1 = require('vs/workbench/parts/debug/electron-browser/debugHover');
var debugactions = require('vs/workbench/parts/debug/browser/debugActions');
var debug = require('vs/workbench/parts/debug/common/debug');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var contextView_1 = require('vs/platform/contextview/browser/contextView');
var codeEditorService_1 = require('vs/editor/common/services/codeEditorService');
var HOVER_DELAY = 300;
var DebugEditorContribution = (function () {
    function DebugEditorContribution(editor, debugService, contextMenuService, instantiationService, codeEditorService) {
        var _this = this;
        this.editor = editor;
        this.debugService = debugService;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
        this.codeEditorService = codeEditorService;
        this.breakpointHintDecoration = [];
        this.hoverWidget = new debugHover_1.DebugHoverWidget(this.editor, this.debugService, this.instantiationService);
        this.toDispose = [this.hoverWidget];
        this.showHoverScheduler = new async_1.RunOnceScheduler(function () { return _this.showHover(_this.hoverRange, _this.hoveringOver, false); }, HOVER_DELAY);
        this.hideHoverScheduler = new async_1.RunOnceScheduler(function () { return _this.hoverWidget.hide(); }, HOVER_DELAY);
        this.registerListeners();
    }
    DebugEditorContribution.prototype.getContextMenuActions = function (breakpoint, uri, lineNumber) {
        var _this = this;
        var actions = [];
        if (breakpoint) {
            actions.push(this.instantiationService.createInstance(debugactions.RemoveBreakpointAction, debugactions.RemoveBreakpointAction.ID, debugactions.RemoveBreakpointAction.LABEL));
            actions.push(this.instantiationService.createInstance(debugactions.EditConditionalBreakpointAction, debugactions.EditConditionalBreakpointAction.ID, debugactions.EditConditionalBreakpointAction.LABEL, this.editor, lineNumber));
            actions.push(this.instantiationService.createInstance(debugactions.ToggleEnablementAction, debugactions.ToggleEnablementAction.ID, debugactions.ToggleEnablementAction.LABEL));
        }
        else {
            actions.push(new actions_1.Action('addBreakpoint', nls.localize('addBreakpoint', "Add Breakpoint"), null, true, function () { return _this.debugService.addBreakpoints([{ uri: uri, lineNumber: lineNumber }]); }));
            actions.push(this.instantiationService.createInstance(debugactions.AddConditionalBreakpointAction, debugactions.AddConditionalBreakpointAction.ID, debugactions.AddConditionalBreakpointAction.LABEL, this.editor, lineNumber));
        }
        return winjs_base_1.TPromise.as(actions);
    };
    DebugEditorContribution.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.editor.onMouseDown(function (e) {
            if (e.target.type !== editorcommon.MouseTargetType.GUTTER_GLYPH_MARGIN || e.target.detail) {
                return;
            }
            if (!_this.debugService.getConfigurationManager().canSetBreakpointsIn(_this.editor.getModel())) {
                return;
            }
            var lineNumber = e.target.position.lineNumber;
            var uri = _this.editor.getModel().uri;
            if (e.event.rightButton || (env.isMacintosh && e.event.leftButton && e.event.ctrlKey)) {
                var anchor_1 = { x: e.event.posx + 1, y: e.event.posy };
                var breakpoint_1 = _this.debugService.getModel().getBreakpoints().filter(function (bp) { return bp.lineNumber === lineNumber && bp.source.uri.toString() === uri.toString(); }).pop();
                _this.contextMenuService.showContextMenu({
                    getAnchor: function () { return anchor_1; },
                    getActions: function () { return _this.getContextMenuActions(breakpoint_1, uri, lineNumber); },
                    getActionsContext: function () { return breakpoint_1; }
                });
            }
            else {
                var breakpoint = _this.debugService.getModel().getBreakpoints()
                    .filter(function (bp) { return bp.source.uri.toString() === uri.toString() && bp.lineNumber === lineNumber; }).pop();
                if (breakpoint) {
                    _this.debugService.removeBreakpoints(breakpoint.getId());
                }
                else {
                    _this.debugService.addBreakpoints([{ uri: uri, lineNumber: lineNumber }]);
                }
            }
        }));
        this.toDispose.push(this.editor.onMouseMove(function (e) {
            var showBreakpointHintAtLineNumber = -1;
            if (e.target.type === editorcommon.MouseTargetType.GUTTER_GLYPH_MARGIN && _this.debugService.getConfigurationManager().canSetBreakpointsIn(_this.editor.getModel())) {
                if (!e.target.detail) {
                    // is not after last line
                    showBreakpointHintAtLineNumber = e.target.position.lineNumber;
                }
            }
            _this.ensureBreakpointHintDecoration(showBreakpointHintAtLineNumber);
        }));
        this.toDispose.push(this.editor.onMouseLeave(function (e) {
            _this.ensureBreakpointHintDecoration(-1);
        }));
        this.toDispose.push(this.debugService.onDidChangeState(function (state) { return _this.onDebugStateUpdate(state); }));
        // hover listeners & hover widget
        this.toDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
        this.toDispose.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
        this.toDispose.push(this.editor.onMouseLeave(function (e) {
            var rect = _this.hoverWidget.getDomNode().getBoundingClientRect();
            // Only hide the hover widget if the editor mouse leave event is outside the hover widget #3528
            if (e.event.posx < rect.left || e.event.posx > rect.right || e.event.posy < rect.top || e.event.posy > rect.bottom) {
                _this.hideHoverWidget();
            }
        }));
        this.toDispose.push(this.editor.onKeyDown(function (e) { return _this.onKeyDown(e); }));
        this.toDispose.push(this.editor.onDidChangeModel(function () { return _this.hideHoverWidget(); }));
        this.toDispose.push(this.editor.onDidScrollChange(function () { return _this.hideHoverWidget; }));
    };
    DebugEditorContribution.prototype.getId = function () {
        return debug.EDITOR_CONTRIBUTION_ID;
    };
    DebugEditorContribution.prototype.showHover = function (range, hoveringOver, focus) {
        return this.hoverWidget.showAt(range, hoveringOver, focus);
    };
    DebugEditorContribution.prototype.ensureBreakpointHintDecoration = function (showBreakpointHintAtLineNumber) {
        var newDecoration = [];
        if (showBreakpointHintAtLineNumber !== -1) {
            newDecoration.push({
                options: DebugEditorContribution.BREAKPOINT_HELPER_DECORATION,
                range: {
                    startLineNumber: showBreakpointHintAtLineNumber,
                    startColumn: 1,
                    endLineNumber: showBreakpointHintAtLineNumber,
                    endColumn: 1
                }
            });
        }
        this.breakpointHintDecoration = this.editor.deltaDecorations(this.breakpointHintDecoration, newDecoration);
    };
    DebugEditorContribution.prototype.onDebugStateUpdate = function (state) {
        if (state !== debug.State.Stopped) {
            this.hideHoverWidget();
        }
        this.codeEditorService.listCodeEditors().forEach(function (e) {
            e.updateOptions({ hover: state !== debug.State.Stopped });
        });
    };
    DebugEditorContribution.prototype.hideHoverWidget = function () {
        if (!this.hideHoverScheduler.isScheduled() && this.hoverWidget.isVisible) {
            this.hideHoverScheduler.schedule();
        }
        this.showHoverScheduler.cancel();
        this.hoveringOver = null;
    };
    // hover business
    DebugEditorContribution.prototype.onEditorMouseDown = function (mouseEvent) {
        if (mouseEvent.target.type === editorcommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === debugHover_1.DebugHoverWidget.ID) {
            return;
        }
        this.hideHoverWidget();
    };
    DebugEditorContribution.prototype.onEditorMouseMove = function (mouseEvent) {
        if (this.debugService.state !== debug.State.Stopped) {
            return;
        }
        var targetType = mouseEvent.target.type;
        var stopKey = env.isMacintosh ? 'metaKey' : 'ctrlKey';
        if (targetType === editorcommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === debugHover_1.DebugHoverWidget.ID && !mouseEvent.event[stopKey]) {
            // mouse moved on top of debug hover widget
            return;
        }
        if (targetType === editorcommon.MouseTargetType.CONTENT_TEXT) {
            var wordAtPosition = this.editor.getModel().getWordAtPosition(mouseEvent.target.range.getStartPosition());
            if (wordAtPosition && this.hoveringOver !== wordAtPosition.word) {
                this.hoverRange = mouseEvent.target.range;
                this.hoveringOver = wordAtPosition.word;
                this.showHoverScheduler.schedule();
            }
        }
        else {
            this.hideHoverWidget();
        }
    };
    DebugEditorContribution.prototype.onKeyDown = function (e) {
        var stopKey = env.isMacintosh ? 57 /* Meta */ : 5 /* Ctrl */;
        if (e.keyCode !== stopKey) {
            // do not hide hover when Ctrl/Meta is pressed
            this.hideHoverWidget();
        }
    };
    DebugEditorContribution.prototype.dispose = function () {
        this.toDispose = lifecycle.dispose(this.toDispose);
    };
    // end hover business
    DebugEditorContribution.BREAKPOINT_HELPER_DECORATION = {
        glyphMarginClassName: 'debug-breakpoint-hint-glyph',
        stickiness: editorcommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
    };
    DebugEditorContribution = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, debug.IDebugService),
        __param(2, contextView_1.IContextMenuService),
        __param(3, instantiation_1.IInstantiationService),
        __param(4, codeEditorService_1.ICodeEditorService)
    ], DebugEditorContribution);
    return DebugEditorContribution;
}());
exports.DebugEditorContribution = DebugEditorContribution;
