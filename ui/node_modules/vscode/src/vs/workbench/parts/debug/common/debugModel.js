/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var lifecycle = require("vs/base/common/lifecycle");
var event_1 = require("vs/base/common/event");
var uuid_1 = require("vs/base/common/uuid");
var objects_1 = require("vs/base/common/objects");
var types_1 = require("vs/base/common/types");
var strings = require("vs/base/common/strings");
var arrays_1 = require("vs/base/common/arrays");
var range_1 = require("vs/editor/common/core/range");
var debugSource_1 = require("vs/workbench/parts/debug/common/debugSource");
var MAX_REPL_LENGTH = 10000;
var UNKNOWN_SOURCE_LABEL = nls.localize('unknownSource', "Unknown Source");
var AbstractOutputElement = (function () {
    function AbstractOutputElement(id) {
        if (id === void 0) { id = AbstractOutputElement.ID_COUNTER++; }
        this.id = id;
        // noop
    }
    AbstractOutputElement.prototype.getId = function () {
        return "outputelement:" + this.id;
    };
    return AbstractOutputElement;
}());
AbstractOutputElement.ID_COUNTER = 0;
exports.AbstractOutputElement = AbstractOutputElement;
var OutputElement = (function (_super) {
    __extends(OutputElement, _super);
    function OutputElement(value, severity) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.severity = severity;
        _this.counter = 1;
        return _this;
    }
    return OutputElement;
}(AbstractOutputElement));
exports.OutputElement = OutputElement;
var OutputNameValueElement = (function (_super) {
    __extends(OutputNameValueElement, _super);
    function OutputNameValueElement(name, valueObj, annotation) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.valueObj = valueObj;
        _this.annotation = annotation;
        return _this;
    }
    Object.defineProperty(OutputNameValueElement.prototype, "value", {
        get: function () {
            if (this.valueObj === null) {
                return 'null';
            }
            else if (Array.isArray(this.valueObj)) {
                return "Array[" + this.valueObj.length + "]";
            }
            else if (types_1.isObject(this.valueObj)) {
                return 'Object';
            }
            else if (types_1.isString(this.valueObj)) {
                return "\"" + this.valueObj + "\"";
            }
            return String(this.valueObj) || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputNameValueElement.prototype, "hasChildren", {
        get: function () {
            return types_1.isObject(this.valueObj) && Object.getOwnPropertyNames(this.valueObj).length > 0;
        },
        enumerable: true,
        configurable: true
    });
    OutputNameValueElement.prototype.getChildren = function () {
        var _this = this;
        var result = [];
        if (Array.isArray(this.valueObj)) {
            result = this.valueObj.slice(0, OutputNameValueElement.MAX_CHILDREN)
                .map(function (v, index) { return new OutputNameValueElement(String(index), v); });
        }
        else if (types_1.isObject(this.valueObj)) {
            result = Object.getOwnPropertyNames(this.valueObj).slice(0, OutputNameValueElement.MAX_CHILDREN)
                .map(function (key) { return new OutputNameValueElement(key, _this.valueObj[key]); });
        }
        return winjs_base_1.TPromise.as(result);
    };
    return OutputNameValueElement;
}(AbstractOutputElement));
OutputNameValueElement.MAX_CHILDREN = 1000; // upper bound of children per value
exports.OutputNameValueElement = OutputNameValueElement;
var ExpressionContainer = (function () {
    function ExpressionContainer(process, reference, id, namedVariables, indexedVariables, startOfVariables) {
        if (namedVariables === void 0) { namedVariables = 0; }
        if (indexedVariables === void 0) { indexedVariables = 0; }
        if (startOfVariables === void 0) { startOfVariables = 0; }
        this.process = process;
        this.reference = reference;
        this.id = id;
        this.namedVariables = namedVariables;
        this.indexedVariables = indexedVariables;
        this.startOfVariables = startOfVariables;
    }
    ExpressionContainer.prototype.getChildren = function () {
        var _this = this;
        if (!this.hasChildren) {
            return winjs_base_1.TPromise.as([]);
        }
        if (!this.getChildrenInChunks) {
            return this.fetchVariables(undefined, undefined, undefined);
        }
        // Check if object has named variables, fetch them independent from indexed variables #9670
        return (!!this.namedVariables ? this.fetchVariables(undefined, undefined, 'named') : winjs_base_1.TPromise.as([])).then(function (childrenArray) {
            // Use a dynamic chunk size based on the number of elements #9774
            var chunkSize = ExpressionContainer.BASE_CHUNK_SIZE;
            while (_this.indexedVariables > chunkSize * ExpressionContainer.BASE_CHUNK_SIZE) {
                chunkSize *= ExpressionContainer.BASE_CHUNK_SIZE;
            }
            if (_this.indexedVariables > chunkSize) {
                // There are a lot of children, create fake intermediate values that represent chunks #9537
                var numberOfChunks = Math.ceil(_this.indexedVariables / chunkSize);
                for (var i = 0; i < numberOfChunks; i++) {
                    var start = _this.startOfVariables + i * chunkSize;
                    var count = Math.min(chunkSize, _this.indexedVariables - i * chunkSize);
                    childrenArray.push(new Variable(_this.process, _this, _this.reference, "[" + start + ".." + (start + count - 1) + "]", '', '', null, count, null, true, start));
                }
                return childrenArray;
            }
            return _this.fetchVariables(_this.startOfVariables, _this.indexedVariables, 'indexed')
                .then(function (variables) { return childrenArray.concat(variables); });
        });
    };
    ExpressionContainer.prototype.getId = function () {
        return this.id;
    };
    Object.defineProperty(ExpressionContainer.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (value) {
            this._value = value;
            this.valueChanged = ExpressionContainer.allValues[this.getId()] &&
                ExpressionContainer.allValues[this.getId()] !== Expression.DEFAULT_VALUE && ExpressionContainer.allValues[this.getId()] !== value;
            ExpressionContainer.allValues[this.getId()] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpressionContainer.prototype, "hasChildren", {
        get: function () {
            // only variables with reference > 0 have children.
            return this.reference > 0;
        },
        enumerable: true,
        configurable: true
    });
    ExpressionContainer.prototype.fetchVariables = function (start, count, filter) {
        var _this = this;
        return this.process.session.variables({
            variablesReference: this.reference,
            start: start,
            count: count,
            filter: filter
        }).then(function (response) {
            return response && response.body && response.body.variables ? arrays_1.distinct(response.body.variables.filter(function (v) { return !!v; }), function (v) { return v.name; }).map(function (v) { return new Variable(_this.process, _this, v.variablesReference, v.name, v.evaluateName, v.value, v.namedVariables, v.indexedVariables, v.type); }) : [];
        }, function (e) { return [new Variable(_this.process, _this, 0, null, e.message, '', 0, 0, null, false)]; });
    };
    Object.defineProperty(ExpressionContainer.prototype, "getChildrenInChunks", {
        // The adapter explicitly sents the children count of an expression only if there are lots of children which should be chunked.
        get: function () {
            return !!this.indexedVariables;
        },
        enumerable: true,
        configurable: true
    });
    return ExpressionContainer;
}());
ExpressionContainer.allValues = {};
// Use chunks to support variable paging #9537
ExpressionContainer.BASE_CHUNK_SIZE = 100;
exports.ExpressionContainer = ExpressionContainer;
var Expression = (function (_super) {
    __extends(Expression, _super);
    function Expression(name, id) {
        if (id === void 0) { id = uuid_1.generateUuid(); }
        var _this = _super.call(this, null, 0, id) || this;
        _this.name = name;
        _this.available = false;
        // name is not set if the expression is just being added
        // in that case do not set default value to prevent flashing #14499
        if (name) {
            _this.value = Expression.DEFAULT_VALUE;
        }
        return _this;
    }
    Expression.prototype.evaluate = function (process, stackFrame, context) {
        var _this = this;
        if (!process) {
            this.value = context === 'repl' ? nls.localize('startDebugFirst', "Please start a debug session to evaluate") : Expression.DEFAULT_VALUE;
            this.available = false;
            this.reference = 0;
            return winjs_base_1.TPromise.as(null);
        }
        this.process = process;
        return process.session.evaluate({
            expression: this.name,
            frameId: stackFrame ? stackFrame.frameId : undefined,
            context: context
        }).then(function (response) {
            _this.available = !!(response && response.body);
            if (response && response.body) {
                _this.value = response.body.result;
                _this.reference = response.body.variablesReference;
                _this.namedVariables = response.body.namedVariables;
                _this.indexedVariables = response.body.indexedVariables;
                _this.type = response.body.type;
            }
        }, function (err) {
            _this.value = err.message;
            _this.available = false;
            _this.reference = 0;
        });
    };
    return Expression;
}(ExpressionContainer));
Expression.DEFAULT_VALUE = nls.localize('notAvailable', "not available");
exports.Expression = Expression;
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(process, parent, reference, name, _evaluateName, value, namedVariables, indexedVariables, type, available, startOfVariables) {
        if (type === void 0) { type = null; }
        if (available === void 0) { available = true; }
        if (startOfVariables === void 0) { startOfVariables = 0; }
        var _this = _super.call(this, process, reference, "variable:" + parent.getId() + ":" + name + ":" + reference, namedVariables, indexedVariables, startOfVariables) || this;
        _this.parent = parent;
        _this.name = name;
        _this._evaluateName = _evaluateName;
        _this.type = type;
        _this.available = available;
        _this.value = value;
        return _this;
    }
    Object.defineProperty(Variable.prototype, "evaluateName", {
        get: function () {
            var _this = this;
            if (this._evaluateName) {
                return this._evaluateName;
            }
            // TODO@Isidor get rid of this ugly heuristic
            var names = [this.name];
            var v = this.parent;
            while (v instanceof Variable || v instanceof Expression) {
                names.push(v.name);
                v = v.parent;
            }
            names = names.reverse();
            var result = null;
            names.forEach(function (name) {
                if (!result) {
                    result = name;
                }
                else if (Variable.ARRAY_ELEMENT_SYNTAX.test(name) || (_this.process.session.configuration.type === 'node' && !Variable.NOT_PROPERTY_SYNTAX.test(name))) {
                    // use safe way to access node properties a['property_name']. Also handles array elements.
                    result = name && name.indexOf('[') === 0 ? "" + result + name : result + "['" + name + "']";
                }
                else {
                    result = result + "." + name;
                }
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Variable.prototype.setVariable = function (value) {
        var _this = this;
        return this.process.session.setVariable({
            name: this.name,
            value: value,
            variablesReference: this.parent.reference
        }).then(function (response) {
            if (response && response.body) {
                _this.value = response.body.value;
                _this.type = response.body.type || _this.type;
                _this.reference = response.body.variablesReference;
                _this.namedVariables = response.body.namedVariables;
                _this.indexedVariables = response.body.indexedVariables;
            }
        }, function (err) {
            _this.errorMessage = err.message;
        });
    };
    return Variable;
}(ExpressionContainer));
Variable.NOT_PROPERTY_SYNTAX = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
Variable.ARRAY_ELEMENT_SYNTAX = /\[.*\]$/;
exports.Variable = Variable;
var Scope = (function (_super) {
    __extends(Scope, _super);
    function Scope(stackFrame, name, reference, expensive, namedVariables, indexedVariables, range) {
        var _this = _super.call(this, stackFrame.thread.process, reference, "scope:" + stackFrame.getId() + ":" + name + ":" + reference, namedVariables, indexedVariables) || this;
        _this.name = name;
        _this.expensive = expensive;
        _this.range = range;
        return _this;
    }
    return Scope;
}(ExpressionContainer));
exports.Scope = Scope;
var StackFrame = (function () {
    function StackFrame(thread, frameId, source, name, lineNumber, column) {
        this.thread = thread;
        this.frameId = frameId;
        this.source = source;
        this.name = name;
        this.lineNumber = lineNumber;
        this.column = column;
        this.scopes = null;
    }
    StackFrame.prototype.getId = function () {
        return "stackframe:" + this.thread.getId() + ":" + this.frameId;
    };
    StackFrame.prototype.getScopes = function () {
        var _this = this;
        if (!this.scopes) {
            this.scopes = this.thread.process.session.scopes({ frameId: this.frameId }).then(function (response) {
                return response && response.body && response.body.scopes ?
                    response.body.scopes.map(function (rs) { return new Scope(_this, rs.name, rs.variablesReference, rs.expensive, rs.namedVariables, rs.indexedVariables, rs.line && rs.column && rs.endLine && rs.endColumn ? new range_1.Range(rs.line, rs.column, rs.endLine, rs.endColumn) : null); }) : [];
            }, function (err) { return []; });
        }
        return this.scopes;
    };
    StackFrame.prototype.restart = function () {
        return this.thread.process.session.restartFrame({ frameId: this.frameId });
    };
    return StackFrame;
}());
exports.StackFrame = StackFrame;
var Thread = (function () {
    function Thread(process, name, threadId) {
        this.process = process;
        this.name = name;
        this.threadId = threadId;
        this.promisedCallStack = null;
        this.stoppedDetails = null;
        this.cachedCallStack = null;
        this.stopped = false;
    }
    Thread.prototype.getId = function () {
        return "thread:" + this.process.getId() + ":" + this.name + ":" + this.threadId;
    };
    Thread.prototype.clearCallStack = function () {
        this.promisedCallStack = null;
        this.cachedCallStack = null;
    };
    Thread.prototype.getCallStack = function () {
        return this.cachedCallStack;
    };
    /**
     * Queries the debug adapter for the callstack and returns a promise with
     * the stack frames of the callstack.
     * If the thread is not stopped, it returns a promise to an empty array.
     * Only gets the first 20 stack frames. Calling this method consecutive times
     * with getAdditionalStackFrames = true gets the remainder of the call stack.
     */
    Thread.prototype.fetchCallStack = function (getAdditionalStackFrames) {
        var _this = this;
        if (getAdditionalStackFrames === void 0) { getAdditionalStackFrames = false; }
        if (!this.stopped) {
            return winjs_base_1.TPromise.as([]);
        }
        if (!this.promisedCallStack) {
            this.promisedCallStack = this.getCallStackImpl(0).then(function (callStack) {
                _this.cachedCallStack = callStack;
                return callStack;
            });
        }
        else if (getAdditionalStackFrames) {
            this.promisedCallStack = this.promisedCallStack.then(function (callStackFirstPart) { return _this.getCallStackImpl(callStackFirstPart.length).then(function (callStackSecondPart) {
                _this.cachedCallStack = callStackFirstPart.concat(callStackSecondPart);
                return _this.cachedCallStack;
            }); });
        }
        return this.promisedCallStack;
    };
    Thread.prototype.getCallStackImpl = function (startFrame) {
        var _this = this;
        return this.process.session.stackTrace({ threadId: this.threadId, startFrame: startFrame, levels: 20 }).then(function (response) {
            if (!response || !response.body) {
                return [];
            }
            if (_this.stoppedDetails) {
                _this.stoppedDetails.totalFrames = response.body.totalFrames;
            }
            return response.body.stackFrames.map(function (rsf, level) {
                if (!rsf) {
                    return new StackFrame(_this, 0, new debugSource_1.Source({ name: UNKNOWN_SOURCE_LABEL }, false), nls.localize('unknownStack', "Unknown stack location"), null, null);
                }
                return new StackFrame(_this, rsf.id, rsf.source ? new debugSource_1.Source(rsf.source) : new debugSource_1.Source({ name: UNKNOWN_SOURCE_LABEL }, false), rsf.name, rsf.line, rsf.column);
            });
        }, function (err) {
            if (_this.stoppedDetails) {
                _this.stoppedDetails.framesErrorMessage = err.message;
            }
            return [];
        });
    };
    Thread.prototype.next = function () {
        return this.process.session.next({ threadId: this.threadId });
    };
    Thread.prototype.stepIn = function () {
        return this.process.session.stepIn({ threadId: this.threadId });
    };
    Thread.prototype.stepOut = function () {
        return this.process.session.stepOut({ threadId: this.threadId });
    };
    Thread.prototype.stepBack = function () {
        return this.process.session.stepBack({ threadId: this.threadId });
    };
    Thread.prototype.continue = function () {
        return this.process.session.continue({ threadId: this.threadId });
    };
    Thread.prototype.pause = function () {
        return this.process.session.pause({ threadId: this.threadId });
    };
    Thread.prototype.reverseContinue = function () {
        return this.process.session.reverseContinue({ threadId: this.threadId });
    };
    return Thread;
}());
exports.Thread = Thread;
var Process = (function () {
    function Process(name, _session) {
        this.name = name;
        this._session = _session;
        this.threads = {};
    }
    Object.defineProperty(Process.prototype, "session", {
        get: function () {
            return this._session;
        },
        enumerable: true,
        configurable: true
    });
    Process.prototype.getThread = function (threadId) {
        return this.threads[threadId];
    };
    Process.prototype.getAllThreads = function () {
        var _this = this;
        return Object.keys(this.threads).map(function (key) { return _this.threads[key]; });
    };
    Process.prototype.getId = function () {
        return this._session.getId();
    };
    Process.prototype.rawUpdate = function (data) {
        var _this = this;
        if (data.thread && !this.threads[data.threadId]) {
            // A new thread came in, initialize it.
            this.threads[data.threadId] = new Thread(this, data.thread.name, data.thread.id);
        }
        if (data.stoppedDetails) {
            // Set the availability of the threads' callstacks depending on
            // whether the thread is stopped or not
            if (data.allThreadsStopped) {
                Object.keys(this.threads).forEach(function (ref) {
                    // Only update the details if all the threads are stopped
                    // because we don't want to overwrite the details of other
                    // threads that have stopped for a different reason
                    _this.threads[ref].stoppedDetails = objects_1.clone(data.stoppedDetails);
                    _this.threads[ref].stopped = true;
                    _this.threads[ref].clearCallStack();
                });
            }
            else {
                // One thread is stopped, only update that thread.
                this.threads[data.threadId].stoppedDetails = data.stoppedDetails;
                this.threads[data.threadId].clearCallStack();
                this.threads[data.threadId].stopped = true;
            }
        }
    };
    Process.prototype.clearThreads = function (removeThreads, reference) {
        var _this = this;
        if (reference === void 0) { reference = undefined; }
        if (reference) {
            if (this.threads[reference]) {
                this.threads[reference].clearCallStack();
                this.threads[reference].stoppedDetails = undefined;
                this.threads[reference].stopped = false;
                if (removeThreads) {
                    delete this.threads[reference];
                }
            }
        }
        else {
            Object.keys(this.threads).forEach(function (ref) {
                _this.threads[ref].clearCallStack();
                _this.threads[ref].stoppedDetails = undefined;
                _this.threads[ref].stopped = false;
            });
            if (removeThreads) {
                this.threads = {};
                ExpressionContainer.allValues = {};
            }
        }
    };
    Process.prototype.sourceIsUnavailable = function (source) {
        var _this = this;
        Object.keys(this.threads).forEach(function (key) {
            if (_this.threads[key].getCachedCallStack()) {
                _this.threads[key].getCachedCallStack().forEach(function (stackFrame) {
                    if (stackFrame.source.uri.toString() === source.uri.toString()) {
                        stackFrame.source.available = false;
                    }
                });
            }
        });
    };
    Process.prototype.completions = function (frameId, text, position, overwriteBefore) {
        if (!this.session.configuration.capabilities.supportsCompletionsRequest) {
            return winjs_base_1.TPromise.as([]);
        }
        return this.session.completions({
            frameId: frameId,
            text: text,
            column: position.column,
            line: position.lineNumber
        }).then(function (response) {
            return response && response.body && response.body.targets ? response.body.targets.map(function (item) { return ({
                label: item.label,
                insertText: item.text || item.label,
                type: item.type,
                overwriteBefore: item.length || overwriteBefore
            }); }) : [];
        }, function (err) { return []; });
    };
    return Process;
}());
exports.Process = Process;
var Breakpoint = (function () {
    function Breakpoint(uri, lineNumber, enabled, condition, hitCondition) {
        this.uri = uri;
        this.lineNumber = lineNumber;
        this.enabled = enabled;
        this.condition = condition;
        this.hitCondition = hitCondition;
        if (enabled === undefined) {
            this.enabled = true;
        }
        this.verified = false;
        this.id = uuid_1.generateUuid();
    }
    Breakpoint.prototype.getId = function () {
        return this.id;
    };
    return Breakpoint;
}());
exports.Breakpoint = Breakpoint;
var FunctionBreakpoint = (function () {
    function FunctionBreakpoint(name, enabled, hitCondition) {
        this.name = name;
        this.enabled = enabled;
        this.hitCondition = hitCondition;
        this.verified = false;
        this.id = uuid_1.generateUuid();
    }
    FunctionBreakpoint.prototype.getId = function () {
        return this.id;
    };
    return FunctionBreakpoint;
}());
exports.FunctionBreakpoint = FunctionBreakpoint;
var ExceptionBreakpoint = (function () {
    function ExceptionBreakpoint(filter, label, enabled) {
        this.filter = filter;
        this.label = label;
        this.enabled = enabled;
        this.id = uuid_1.generateUuid();
    }
    ExceptionBreakpoint.prototype.getId = function () {
        return this.id;
    };
    return ExceptionBreakpoint;
}());
exports.ExceptionBreakpoint = ExceptionBreakpoint;
var Model = (function () {
    function Model(breakpoints, breakpointsActivated, functionBreakpoints, exceptionBreakpoints, watchExpressions) {
        this.breakpoints = breakpoints;
        this.breakpointsActivated = breakpointsActivated;
        this.functionBreakpoints = functionBreakpoints;
        this.exceptionBreakpoints = exceptionBreakpoints;
        this.watchExpressions = watchExpressions;
        this.processes = [];
        this.replElements = [];
        this.toDispose = [];
        this._onDidChangeBreakpoints = new event_1.Emitter();
        this._onDidChangeCallStack = new event_1.Emitter();
        this._onDidChangeWatchExpressions = new event_1.Emitter();
        this._onDidChangeREPLElements = new event_1.Emitter();
    }
    Model.prototype.getId = function () {
        return 'root';
    };
    Model.prototype.getProcesses = function () {
        return this.processes;
    };
    Model.prototype.addProcess = function (name, session) {
        var process = new Process(name, session);
        this.processes.push(process);
        return process;
    };
    Model.prototype.removeProcess = function (id) {
        this.processes = this.processes.filter(function (p) { return p.getId() !== id; });
        this._onDidChangeCallStack.fire();
    };
    Object.defineProperty(Model.prototype, "onDidChangeBreakpoints", {
        get: function () {
            return this._onDidChangeBreakpoints.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Model.prototype, "onDidChangeCallStack", {
        get: function () {
            return this._onDidChangeCallStack.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Model.prototype, "onDidChangeWatchExpressions", {
        get: function () {
            return this._onDidChangeWatchExpressions.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Model.prototype, "onDidChangeReplElements", {
        get: function () {
            return this._onDidChangeREPLElements.event;
        },
        enumerable: true,
        configurable: true
    });
    Model.prototype.rawUpdate = function (data) {
        var process = this.processes.filter(function (p) { return p.getId() === data.sessionId; }).pop();
        if (process) {
            process.rawUpdate(data);
            this._onDidChangeCallStack.fire();
        }
    };
    Model.prototype.clearThreads = function (id, removeThreads, reference) {
        if (reference === void 0) { reference = undefined; }
        var process = this.processes.filter(function (p) { return p.getId() === id; }).pop();
        if (process) {
            process.clearThreads(removeThreads, reference);
            this._onDidChangeCallStack.fire();
        }
    };
    Model.prototype.getBreakpoints = function () {
        return this.breakpoints;
    };
    Model.prototype.getFunctionBreakpoints = function () {
        return this.functionBreakpoints;
    };
    Model.prototype.getExceptionBreakpoints = function () {
        return this.exceptionBreakpoints;
    };
    Model.prototype.setExceptionBreakpoints = function (data) {
        var _this = this;
        if (data) {
            this.exceptionBreakpoints = data.map(function (d) {
                var ebp = _this.exceptionBreakpoints.filter(function (ebp) { return ebp.filter === d.filter; }).pop();
                return new ExceptionBreakpoint(d.filter, d.label, ebp ? ebp.enabled : d.default);
            });
        }
    };
    Model.prototype.areBreakpointsActivated = function () {
        return this.breakpointsActivated;
    };
    Model.prototype.setBreakpointsActivated = function (activated) {
        this.breakpointsActivated = activated;
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.addBreakpoints = function (uri, rawData) {
        this.breakpoints = this.breakpoints.concat(rawData.map(function (rawBp) {
            return new Breakpoint(uri, rawBp.lineNumber, rawBp.enabled, rawBp.condition, rawBp.hitCondition);
        }));
        this.breakpointsActivated = true;
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.removeBreakpoints = function (toRemove) {
        this.breakpoints = this.breakpoints.filter(function (bp) { return !toRemove.some(function (toRemove) { return toRemove.getId() === bp.getId(); }); });
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.updateBreakpoints = function (data) {
        this.breakpoints.forEach(function (bp) {
            var bpData = data[bp.getId()];
            if (bpData) {
                bp.lineNumber = bpData.line ? bpData.line : bp.lineNumber;
                bp.verified = bpData.verified;
                bp.idFromAdapter = bpData.id;
                bp.message = bpData.message;
            }
        });
        // Remove duplicate breakpoints. This can happen when an adapter updates a line number of a breakpoint
        this.breakpoints = arrays_1.distinct(this.breakpoints, function (bp) { return bp.uri.toString() + bp.lineNumber; });
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.setEnablement = function (element, enable) {
        element.enabled = enable;
        if (element instanceof Breakpoint && !element.enabled) {
            var breakpoint = element;
            breakpoint.verified = false;
        }
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.enableOrDisableAllBreakpoints = function (enable) {
        this.breakpoints.forEach(function (bp) {
            bp.enabled = enable;
            if (!enable) {
                bp.verified = false;
            }
        });
        this.exceptionBreakpoints.forEach(function (ebp) { return ebp.enabled = enable; });
        this.functionBreakpoints.forEach(function (fbp) { return fbp.enabled = enable; });
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.addFunctionBreakpoint = function (functionName) {
        this.functionBreakpoints.push(new FunctionBreakpoint(functionName, true, null));
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.updateFunctionBreakpoints = function (data) {
        this.functionBreakpoints.forEach(function (fbp) {
            var fbpData = data[fbp.getId()];
            if (fbpData) {
                fbp.name = fbpData.name || fbp.name;
                fbp.verified = fbpData.verified;
                fbp.idFromAdapter = fbpData.id;
                fbp.hitCondition = fbpData.hitCondition;
            }
        });
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.removeFunctionBreakpoints = function (id) {
        this.functionBreakpoints = id ? this.functionBreakpoints.filter(function (fbp) { return fbp.getId() !== id; }) : [];
        this._onDidChangeBreakpoints.fire();
    };
    Model.prototype.getReplElements = function () {
        return this.replElements;
    };
    Model.prototype.addReplExpression = function (process, stackFrame, name) {
        var _this = this;
        var expression = new Expression(name);
        this.addReplElement(expression);
        return expression.evaluate(process, stackFrame, 'repl')
            .then(function () { return _this._onDidChangeREPLElements.fire(); });
    };
    Model.prototype.appendToRepl = function (output, severity) {
        var previousOutput = this.replElements.length && this.replElements[this.replElements.length - 1];
        var groupTogether = typeof output === 'string' && previousOutput instanceof OutputElement && severity === previousOutput.severity;
        if (groupTogether) {
            if (strings.endsWith(previousOutput.value, '\n') && previousOutput.value === output && output.trim()) {
                // we got the same output (but not an empty string when trimmed) so we just increment the counter
                previousOutput.counter++;
            }
            else {
                // append to previous line if same group
                previousOutput.value += output;
            }
        }
        else {
            var newReplElement = typeof output === 'string' ? new OutputElement(output, severity) : output;
            this.addReplElement(newReplElement);
        }
        this._onDidChangeREPLElements.fire();
    };
    Model.prototype.addReplElement = function (newElement) {
        this.replElements.push(newElement);
        if (this.replElements.length > MAX_REPL_LENGTH) {
            this.replElements.splice(0, this.replElements.length - MAX_REPL_LENGTH);
        }
    };
    Model.prototype.removeReplExpressions = function () {
        if (this.replElements.length > 0) {
            this.replElements = [];
            this._onDidChangeREPLElements.fire();
        }
    };
    Model.prototype.getWatchExpressions = function () {
        return this.watchExpressions;
    };
    Model.prototype.addWatchExpression = function (process, stackFrame, name) {
        var we = new Expression(name);
        this.watchExpressions.push(we);
        if (!name) {
            this._onDidChangeWatchExpressions.fire(we);
            return winjs_base_1.TPromise.as(null);
        }
        return this.evaluateWatchExpressions(process, stackFrame, we.getId());
    };
    Model.prototype.renameWatchExpression = function (process, stackFrame, id, newName) {
        var _this = this;
        var filtered = this.watchExpressions.filter(function (we) { return we.getId() === id; });
        if (filtered.length === 1) {
            filtered[0].name = newName;
            return filtered[0].evaluate(process, stackFrame, 'watch').then(function () {
                _this._onDidChangeWatchExpressions.fire(filtered[0]);
            });
        }
        return winjs_base_1.TPromise.as(null);
    };
    Model.prototype.evaluateWatchExpressions = function (process, stackFrame, id) {
        var _this = this;
        if (id === void 0) { id = null; }
        if (id) {
            var filtered_1 = this.watchExpressions.filter(function (we) { return we.getId() === id; });
            if (filtered_1.length !== 1) {
                return winjs_base_1.TPromise.as(null);
            }
            return filtered_1[0].evaluate(process, stackFrame, 'watch').then(function () {
                _this._onDidChangeWatchExpressions.fire(filtered_1[0]);
            });
        }
        return winjs_base_1.TPromise.join(this.watchExpressions.map(function (we) { return we.evaluate(process, stackFrame, 'watch'); })).then(function () {
            _this._onDidChangeWatchExpressions.fire();
        });
    };
    Model.prototype.removeWatchExpressions = function (id) {
        if (id === void 0) { id = null; }
        this.watchExpressions = id ? this.watchExpressions.filter(function (we) { return we.getId() !== id; }) : [];
        this._onDidChangeWatchExpressions.fire();
    };
    Model.prototype.moveWatchExpression = function (id, position) {
        var we = this.watchExpressions.filter(function (we) { return we.getId() === id; }).pop();
        this.watchExpressions = this.watchExpressions.filter(function (we) { return we.getId() !== id; });
        this.watchExpressions = this.watchExpressions.slice(0, position).concat(we, this.watchExpressions.slice(position));
        this._onDidChangeWatchExpressions.fire();
    };
    Model.prototype.sourceIsUnavailable = function (source) {
        this.processes.forEach(function (p) { return p.sourceIsUnavailable(source); });
        this._onDidChangeCallStack.fire();
    };
    Model.prototype.dispose = function () {
        this.toDispose = lifecycle.dispose(this.toDispose);
    };
    return Model;
}());
exports.Model = Model;
