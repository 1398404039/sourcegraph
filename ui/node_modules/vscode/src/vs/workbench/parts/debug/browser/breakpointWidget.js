/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
require('../browser/media/breakpointWidget.css');
var async = require('vs/base/common/async');
var errors = require('vs/base/common/errors');
var platform = require('vs/base/common/platform');
var lifecycle = require('vs/base/common/lifecycle');
var dom = require('vs/base/browser/dom');
var inputBox_1 = require('vs/base/browser/ui/inputbox/inputBox');
var editorCommonExtensions_1 = require('vs/editor/common/editorCommonExtensions');
var editorCommon_1 = require('vs/editor/common/editorCommon');
var zoneWidget_1 = require('vs/editor/contrib/zoneWidget/browser/zoneWidget');
var contextView_1 = require('vs/platform/contextview/browser/contextView');
var contextkey_1 = require('vs/platform/contextkey/common/contextkey');
var debug = require('vs/workbench/parts/debug/common/debug');
var $ = dom.$;
var CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new contextkey_1.RawContextKey('breakpointWidgetVisible', false);
var CLOSE_BREAKPOINT_WIDGET_COMMAND_ID = 'closeBreakpointWidget';
var BreakpointWidget = (function (_super) {
    __extends(BreakpointWidget, _super);
    function BreakpointWidget(editor, lineNumber, contextViewService, debugService, contextKeyService) {
        var _this = this;
        _super.call(this, editor, { showFrame: true, showArrow: false });
        this.lineNumber = lineNumber;
        this.contextViewService = contextViewService;
        this.debugService = debugService;
        this.toDispose = [];
        this.create();
        this.breakpointWidgetVisible = CONTEXT_BREAKPOINT_WIDGET_VISIBLE.bindTo(contextKeyService);
        this.breakpointWidgetVisible.set(true);
        BreakpointWidget.INSTANCE = this;
        this.toDispose.push(editor.onDidChangeModel(function () { return _this.dispose(); }));
    }
    BreakpointWidget.createInstance = function (editor, lineNumber, instantiationService) {
        if (BreakpointWidget.INSTANCE) {
            BreakpointWidget.INSTANCE.dispose();
        }
        instantiationService.createInstance(BreakpointWidget, editor, lineNumber);
        BreakpointWidget.INSTANCE.show({ lineNumber: lineNumber, column: 1 }, 2);
    };
    BreakpointWidget.prototype._fillContainer = function (container) {
        var _this = this;
        dom.addClass(container, 'breakpoint-widget');
        var uri = this.editor.getModel().uri;
        var breakpoint = this.debugService.getModel().getBreakpoints().filter(function (bp) { return bp.lineNumber === _this.lineNumber && bp.source.uri.toString() === uri.toString(); }).pop();
        var inputBoxContainer = dom.append(container, $('.inputBoxContainer'));
        this.inputBox = new inputBox_1.InputBox(inputBoxContainer, this.contextViewService, {
            placeholder: nls.localize('breakpointWidgetPlaceholder', "Breakpoint on line {0} will only stop if this condition is true.", this.lineNumber),
            ariaLabel: nls.localize('breakpointWidgetAriaLabel', "Type the breakpoint condition for line {0}. The program will only stop here if this condition is true. Press Enter to accept or Escape to cancel.")
        });
        this.toDispose.push(this.inputBox);
        dom.addClass(this.inputBox.inputElement, platform.isWindows ? 'windows' : platform.isMacintosh ? 'mac' : 'linux');
        this.inputBox.value = (breakpoint && breakpoint.condition) ? breakpoint.condition : '';
        // Due to an electron bug we have to do the timeout, otherwise we do not get focus
        setTimeout(function () { return _this.inputBox.focus(); }, 0);
        var disposed = false;
        var wrapUp = async.once(function (success) {
            if (!disposed) {
                disposed = true;
                if (success) {
                    var raw = {
                        uri: uri,
                        lineNumber: _this.lineNumber,
                        enabled: true,
                        condition: _this.inputBox.value
                    };
                    // if there is already a breakpoint on this location - remove it.
                    var oldBreakpoint = _this.debugService.getModel().getBreakpoints()
                        .filter(function (bp) { return bp.lineNumber === _this.lineNumber && bp.source.uri.toString() === uri.toString(); }).pop();
                    if (oldBreakpoint) {
                        _this.debugService.removeBreakpoints(oldBreakpoint.getId()).done(null, errors.onUnexpectedError);
                    }
                    _this.debugService.addBreakpoints([raw]).done(null, errors.onUnexpectedError);
                }
                _this.dispose();
            }
        });
        this.toDispose.push(dom.addStandardDisposableListener(this.inputBox.inputElement, 'keydown', function (e) {
            var isEscape = e.equals(9 /* Escape */);
            var isEnter = e.equals(3 /* Enter */);
            if (isEscape || isEnter) {
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
    };
    BreakpointWidget.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.breakpointWidgetVisible.reset();
        BreakpointWidget.INSTANCE = undefined;
        lifecycle.dispose(this.toDispose);
        setTimeout(function () { return _this.editor.focus(); }, 0);
    };
    BreakpointWidget = __decorate([
        __param(2, contextView_1.IContextViewService),
        __param(3, debug.IDebugService),
        __param(4, contextkey_1.IContextKeyService)
    ], BreakpointWidget);
    return BreakpointWidget;
}(zoneWidget_1.ZoneWidget));
exports.BreakpointWidget = BreakpointWidget;
var CloseBreakpointWidgetCommand = (function (_super) {
    __extends(CloseBreakpointWidgetCommand, _super);
    function CloseBreakpointWidgetCommand() {
        _super.call(this, {
            id: CLOSE_BREAKPOINT_WIDGET_COMMAND_ID,
            precondition: CONTEXT_BREAKPOINT_WIDGET_VISIBLE,
            kbOpts: {
                weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(8),
                kbExpr: editorCommon_1.EditorContextKeys.Focus,
                primary: 9 /* Escape */,
                secondary: [16384 /* Shift */ | 9 /* Escape */]
            }
        });
    }
    CloseBreakpointWidgetCommand.prototype.runEditorCommand = function (accessor, editor, args) {
        if (BreakpointWidget.INSTANCE) {
            BreakpointWidget.INSTANCE.dispose();
        }
    };
    return CloseBreakpointWidgetCommand;
}(editorCommonExtensions_1.EditorCommand));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new CloseBreakpointWidgetCommand());
