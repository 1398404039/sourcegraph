/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var uri_1 = require('vs/base/common/uri');
var paths = require('vs/base/common/paths');
var extfs = require('vs/base/node/extfs');
var objects = require('vs/base/common/objects');
var async_1 = require('vs/base/common/async');
var collections = require('vs/base/common/collections');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var environment_1 = require('vs/platform/environment/common/environment');
var event_1 = require('vs/platform/event/common/event');
var lifecycle_1 = require('vs/base/common/lifecycle');
var pfs_1 = require('vs/base/node/pfs');
var errors = require('vs/base/common/errors');
var model_1 = require('vs/workbench/services/configuration/common/model');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var configurationService_1 = require('vs/platform/configuration/node/configurationService');
var configuration_2 = require('vs/workbench/services/configuration/common/configuration');
var files_1 = require('vs/platform/files/common/files');
var event_2 = require('vs/base/common/event');
/**
 * Wraps around the basic configuration service and adds knowledge about workspace settings.
 */
var WorkspaceConfigurationService = (function () {
    function WorkspaceConfigurationService(contextService, eventService, environmentService, workspaceSettingsRootFolder) {
        var _this = this;
        if (workspaceSettingsRootFolder === void 0) { workspaceSettingsRootFolder = configuration_2.WORKSPACE_CONFIG_FOLDER_DEFAULT_NAME; }
        this.contextService = contextService;
        this.eventService = eventService;
        this.workspaceSettingsRootFolder = workspaceSettingsRootFolder;
        this.toDispose = [];
        this.workspaceFilePathToConfiguration = Object.create(null);
        this.cachedConfig = Object.create(null);
        this.cachedWorkspaceConfig = Object.create(null);
        this._onDidUpdateConfiguration = new event_2.Emitter();
        this.toDispose.push(this._onDidUpdateConfiguration);
        this.baseConfigurationService = new configurationService_1.ConfigurationService(environmentService);
        this.toDispose.push(this.baseConfigurationService);
        this.reloadConfigurationScheduler = new async_1.RunOnceScheduler(function () { return _this.doLoadConfiguration().then(function (config) { return _this._onDidUpdateConfiguration.fire({ config: config }); }).done(null, errors.onUnexpectedError); }, WorkspaceConfigurationService.RELOAD_CONFIGURATION_DELAY);
        this.toDispose.push(this.reloadConfigurationScheduler);
        this.registerListeners();
    }
    Object.defineProperty(WorkspaceConfigurationService.prototype, "onDidUpdateConfiguration", {
        get: function () {
            return this._onDidUpdateConfiguration.event;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceConfigurationService.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.eventService.addListener2(files_1.EventType.FILE_CHANGES, function (events) { return _this.handleWorkspaceFileEvents(events); }));
        this.toDispose.push(this.baseConfigurationService.onDidUpdateConfiguration(function () { return _this.onBaseConfigurationChanged(); }));
    };
    WorkspaceConfigurationService.prototype.onBaseConfigurationChanged = function () {
        // update cached config when base config changes
        var newConfig = objects.mixin(objects.clone(this.baseConfigurationService.getConfiguration()), // target: global/default values (do NOT modify)
        this.cachedWorkspaceConfig, // source: workspace configured values
        true // overwrite
        );
        // emit this as update to listeners if changed
        if (!objects.equals(this.cachedConfig, newConfig)) {
            this.cachedConfig = newConfig;
            this._onDidUpdateConfiguration.fire({ config: this.cachedConfig });
        }
    };
    WorkspaceConfigurationService.prototype.initialize = function () {
        return this.doLoadConfiguration().then(function () { return null; });
    };
    WorkspaceConfigurationService.prototype.getConfiguration = function (section) {
        return section ? this.cachedConfig[section] : this.cachedConfig;
    };
    WorkspaceConfigurationService.prototype.lookup = function (key) {
        var configurationValue = this.baseConfigurationService.lookup(key);
        return {
            default: configurationValue.default,
            user: configurationValue.user,
            workspace: configuration_1.getConfigurationValue(this.cachedWorkspaceConfig, key),
            value: configuration_1.getConfigurationValue(this.getConfiguration(), key)
        };
    };
    WorkspaceConfigurationService.prototype.reloadConfiguration = function (section) {
        var _this = this;
        // Reset caches to ensure we are hitting the disk
        this.bulkFetchFromWorkspacePromise = null;
        this.workspaceFilePathToConfiguration = Object.create(null);
        // Load configuration
        return this.baseConfigurationService.reloadConfiguration().then(function () { return _this.doLoadConfiguration(section); });
    };
    WorkspaceConfigurationService.prototype.doLoadConfiguration = function (section) {
        var _this = this;
        // Load workspace locals
        return this.loadWorkspaceConfigFiles().then(function (workspaceConfigFiles) {
            // Consolidate (support *.json files in the workspace settings folder)
            var workspaceConfig = model_1.consolidate(workspaceConfigFiles).contents;
            _this.cachedWorkspaceConfig = workspaceConfig;
            // Override base (global < user) with workspace locals (global < user < workspace)
            return objects.mixin(objects.clone(_this.baseConfigurationService.getConfiguration()), // target: global/default values (do NOT modify)
            _this.cachedWorkspaceConfig, // source: workspace configured values
            true // overwrite
            );
        }).then(function (result) {
            _this.cachedConfig = result;
            return _this.getConfiguration(section);
        });
    };
    WorkspaceConfigurationService.prototype.hasWorkspaceConfiguration = function () {
        return !!this.workspaceFilePathToConfiguration[(this.workspaceSettingsRootFolder + "/" + configuration_2.CONFIG_DEFAULT_NAME + ".json")];
    };
    WorkspaceConfigurationService.prototype.dispose = function () {
        this.toDispose = lifecycle_1.dispose(this.toDispose);
    };
    WorkspaceConfigurationService.prototype.loadWorkspaceConfigFiles = function () {
        var _this = this;
        // Return early if we don't have a workspace
        if (!this.contextService.getWorkspace()) {
            return winjs_base_1.TPromise.as(Object.create(null));
        }
        // once: when invoked for the first time we fetch *all* json files using the bulk stats and content routes
        if (!this.bulkFetchFromWorkspacePromise) {
            this.bulkFetchFromWorkspacePromise = resolveStat(this.contextService.toResource(this.workspaceSettingsRootFolder)).then(function (stat) {
                if (!stat.isDirectory) {
                    return winjs_base_1.TPromise.as([]);
                }
                return resolveContents(stat.children.filter(function (stat) { return paths.extname(stat.resource.fsPath) === '.json'; }).map(function (stat) { return stat.resource; }));
            }, function (err) {
                if (err) {
                    return []; // never fail this call
                }
            }).then(function (contents) {
                contents.forEach(function (content) { return _this.workspaceFilePathToConfiguration[_this.contextService.toWorkspaceRelativePath(content.resource)] = winjs_base_1.TPromise.as(model_1.newConfigFile(content.value)); });
            }, errors.onUnexpectedError);
        }
        // on change: join on *all* configuration file promises so that we can merge them into a single configuration object. this
        // happens whenever a config file changes, is deleted, or added
        return this.bulkFetchFromWorkspacePromise.then(function () { return winjs_base_1.TPromise.join(_this.workspaceFilePathToConfiguration); });
    };
    WorkspaceConfigurationService.prototype.handleWorkspaceFileEvents = function (event) {
        var events = event.changes;
        var affectedByChanges = false;
        // Find changes that affect workspace configuration files
        for (var i = 0, len = events.length; i < len; i++) {
            var workspacePath = this.contextService.toWorkspaceRelativePath(events[i].resource);
            if (!workspacePath) {
                continue; // event is not inside workspace
            }
            // Handle case where ".vscode" got deleted
            if (workspacePath === this.workspaceSettingsRootFolder && events[i].type === files_1.FileChangeType.DELETED) {
                this.workspaceFilePathToConfiguration = Object.create(null);
                affectedByChanges = true;
            }
            // outside my folder or not a *.json file
            if (paths.extname(workspacePath) !== '.json' || !paths.isEqualOrParent(workspacePath, this.workspaceSettingsRootFolder)) {
                continue;
            }
            // insert 'fetch-promises' for add and update events and
            // remove promises for delete events
            switch (events[i].type) {
                case files_1.FileChangeType.DELETED:
                    affectedByChanges = collections.remove(this.workspaceFilePathToConfiguration, workspacePath);
                    break;
                case files_1.FileChangeType.UPDATED:
                case files_1.FileChangeType.ADDED:
                    this.workspaceFilePathToConfiguration[workspacePath] = resolveContent(events[i].resource).then(function (content) { return model_1.newConfigFile(content.value); }, errors.onUnexpectedError);
                    affectedByChanges = true;
            }
        }
        // trigger reload of the configuration if we are affected by changes
        if (affectedByChanges && !this.reloadConfigurationScheduler.isScheduled()) {
            this.reloadConfigurationScheduler.schedule();
        }
    };
    Object.defineProperty(WorkspaceConfigurationService.prototype, "telemetryService", {
        set: function (value) {
            this.baseConfigurationService.telemetryService = value;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceConfigurationService.RELOAD_CONFIGURATION_DELAY = 50;
    WorkspaceConfigurationService = __decorate([
        __param(0, workspace_1.IWorkspaceContextService),
        __param(1, event_1.IEventService),
        __param(2, environment_1.IEnvironmentService)
    ], WorkspaceConfigurationService);
    return WorkspaceConfigurationService;
}());
exports.WorkspaceConfigurationService = WorkspaceConfigurationService;
// node.hs helper functions
function resolveContents(resources) {
    var contents = [];
    return winjs_base_1.TPromise.join(resources.map(function (resource) {
        return resolveContent(resource).then(function (content) {
            contents.push(content);
        });
    })).then(function () { return contents; });
}
function resolveContent(resource) {
    return pfs_1.readFile(resource.fsPath).then(function (contents) { return ({ resource: resource, value: contents.toString() }); });
}
function resolveStat(resource) {
    return new winjs_base_1.TPromise(function (c, e) {
        extfs.readdir(resource.fsPath, function (error, children) {
            if (error) {
                if (error.code === 'ENOTDIR') {
                    c({ resource: resource });
                }
                else {
                    e(error);
                }
            }
            else {
                c({
                    resource: resource,
                    isDirectory: true,
                    children: children.map(function (child) { return { resource: uri_1.default.file(paths.join(resource.fsPath, child)) }; })
                });
            }
        });
    });
}
