/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var uri_1 = require("vs/base/common/uri");
var json = require("vs/base/common/json");
var objects_1 = require("vs/base/common/objects");
var encoding = require("vs/base/node/encoding");
var strings = require("vs/base/common/strings");
var jsonEdit_1 = require("vs/base/common/jsonEdit");
var async_1 = require("vs/base/common/async");
var jsonFormatter_1 = require("vs/base/common/jsonFormatter");
var editOperation_1 = require("vs/editor/common/core/editOperation");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var environment_1 = require("vs/platform/environment/common/environment");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var configuration_2 = require("vs/workbench/services/configuration/common/configuration");
var files_1 = require("vs/platform/files/common/files");
var configurationEditing_1 = require("vs/workbench/services/configuration/common/configurationEditing");
var resolverService_1 = require("vs/editor/common/services/resolverService");
var ConfigurationEditingService = (function () {
    function ConfigurationEditingService(configurationService, contextService, environmentService, fileService, textModelResolverService, textFileService) {
        this.configurationService = configurationService;
        this.contextService = contextService;
        this.environmentService = environmentService;
        this.fileService = fileService;
        this.textModelResolverService = textModelResolverService;
        this.textFileService = textFileService;
        this.queue = new async_1.Queue();
    }
    ConfigurationEditingService.prototype.writeConfiguration = function (target, value, options) {
        var _this = this;
        if (options === void 0) { options = null; }
        var defaultOptions = { writeToBuffer: false, autoSave: false };
        options = objects_1.assign(defaultOptions, options || {});
        return this.queue.queue(function () { return _this.doWriteConfiguration(target, value, options); }); // queue up writes to prevent race conditions
    };
    ConfigurationEditingService.prototype.doWriteConfiguration = function (target, value, options) {
        var _this = this;
        var operation = this.getConfigurationEditOperation(target, value);
        // First validate before making any edits
        return this.validate(target, operation, options).then(function (validation) {
            if (typeof validation.error === 'number') {
                return _this.wrapError(validation.error, target);
            }
            // Create configuration file if missing
            var resource = operation.target;
            var ensureConfigurationFile = winjs_base_1.TPromise.as(null);
            var contents;
            if (!validation.exists) {
                contents = '{}';
                ensureConfigurationFile = _this.fileService.updateContent(resource, contents, { encoding: encoding.UTF8 });
            }
            else {
                contents = validation.contents;
            }
            return ensureConfigurationFile.then(function () {
                if (options.writeToBuffer) {
                    return _this.writeToBuffer(contents, operation, resource, options);
                }
                else {
                    return _this.writeToDisk(contents, operation, resource);
                }
            });
        });
    };
    ConfigurationEditingService.prototype.writeToBuffer = function (contents, operation, resource, options) {
        var _this = this;
        var isDirtyBefore = this.textFileService.isDirty(resource);
        var edit = this.getEdits(contents, operation)[0];
        return this.textModelResolverService.createModelReference(resource).
            then(function (reference) {
            if (_this.applyEditsToBuffer(edit, reference.object.textEditorModel)) {
                if (options.autoSave && !isDirtyBefore) {
                    _this.textFileService.save(resource);
                }
            }
            reference.dispose();
        });
    };
    ConfigurationEditingService.prototype.applyEditsToBuffer = function (edit, model) {
        var startPosition = model.getPositionAt(edit.offset);
        var endPosition = model.getPositionAt(edit.offset + edit.length);
        var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        var currentText = model.getValueInRange(range);
        if (edit.content !== currentText) {
            var editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
            model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], function () { return []; });
            return true;
        }
        return false;
    };
    ConfigurationEditingService.prototype.writeToDisk = function (contents, operation, resource) {
        var _this = this;
        // Apply all edits to the configuration file
        var result = this.applyEdits(contents, operation);
        return this.fileService.updateContent(resource, result, { encoding: encoding.UTF8 }).then(function () {
            // Reload the configuration so that we make sure all parties are updated
            return _this.configurationService.reloadConfiguration().then(function () { return void 0; });
        });
    };
    ConfigurationEditingService.prototype.wrapError = function (code, target) {
        var message = this.toErrorMessage(code, target);
        return winjs_base_1.TPromise.wrapError({
            code: code,
            message: message,
            toString: function () { return message; }
        });
    };
    ConfigurationEditingService.prototype.toErrorMessage = function (error, target) {
        switch (error) {
            // API constraints
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY: return nls.localize('errorUnknownKey', "Unable to write to the configuration file (Unknown Key)");
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_TARGET: return nls.localize('errorInvalidTarget', "Unable to write to the configuration file (Invalid Target)");
            // User issues
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED: return nls.localize('errorNoWorkspaceOpened', "Unable to write settings because no folder is opened. Please open a folder first and try again.");
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION:
                {
                    if (target === configurationEditing_1.ConfigurationTarget.USER) {
                        return nls.localize('errorInvalidConfiguration', "Unable to write settings. Please open **User Settings** to correct errors/warnings in the file and try again.");
                    }
                    return nls.localize('errorInvalidConfigurationWorkspace', "Unable to write settings. Please open **Workspace Settings** to correct errors/warnings in the file and try again.");
                }
                ;
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY:
                {
                    if (target === configurationEditing_1.ConfigurationTarget.USER) {
                        return nls.localize('errorConfigurationFileDirty', "Unable to write settings because the file is dirty. Please save the **User Settings** file and try again.");
                    }
                    return nls.localize('errorConfigurationFileDirtyWorkspace', "Unable to write settings because the file is dirty. Please save the **Workspace Settings** file and try again.");
                }
                ;
        }
    };
    ConfigurationEditingService.prototype.applyEdits = function (content, edit) {
        var _a = this.configurationService.getConfiguration('editor'), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        var key = edit.key, value = edit.value;
        // Without key, the entire settings file is being replaced, so we just use JSON.stringify
        if (!key) {
            return JSON.stringify(value, null, insertSpaces ? strings.repeat(' ', tabSize) : '\t');
        }
        var edits = this.getEdits(content, edit);
        content = jsonFormatter_1.applyEdits(content, edits);
        return content;
    };
    ConfigurationEditingService.prototype.getEdits = function (content, edit) {
        var _a = this.configurationService.getConfiguration('editor'), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        var eol = this.configurationService.getConfiguration('files').eol;
        var key = edit.key, value = edit.value;
        return jsonEdit_1.setProperty(content, [key], value, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol });
    };
    ConfigurationEditingService.prototype.validate = function (target, operation, options) {
        var _this = this;
        // Any key must be a known setting from the registry (unless this is a standalone config)
        if (!operation.isWorkspaceStandalone) {
            var validKeys = this.configurationService.keys().default;
            if (validKeys.indexOf(operation.key) < 0) {
                return winjs_base_1.TPromise.as({ error: configurationEditing_1.ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY });
            }
        }
        // Target cannot be user if is standalone
        if (operation.isWorkspaceStandalone && target === configurationEditing_1.ConfigurationTarget.USER) {
            return winjs_base_1.TPromise.as({ error: configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_TARGET });
        }
        // Target cannot be workspace if no workspace opened
        if (target === configurationEditing_1.ConfigurationTarget.WORKSPACE && !this.contextService.getWorkspace()) {
            return winjs_base_1.TPromise.as({ error: configurationEditing_1.ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED });
        }
        // Target cannot be dirty if not writing into buffer
        var resource = operation.target;
        if (!options.writeToBuffer && this.textFileService.isDirty(resource)) {
            return winjs_base_1.TPromise.as({ error: configurationEditing_1.ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY });
        }
        return this.fileService.existsFile(resource).then(function (exists) {
            if (!exists) {
                return { exists: exists };
            }
            return _this.resolveContent(resource, options).then(function (content) {
                // If we write to a workspace standalone file and replace the entire contents (no key provided)
                // we can return here because any parse errors can safely be ignored since all contents are replaced
                if (operation.isWorkspaceStandalone && !operation.key) {
                    return { exists: exists, contents: content };
                }
                // Target cannot contain JSON errors
                var parseErrors = [];
                json.parse(content, parseErrors);
                if (parseErrors.length > 0) {
                    return { error: configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION };
                }
                return { exists: exists, contents: content };
            });
        });
    };
    ConfigurationEditingService.prototype.resolveContent = function (resource, options) {
        if (options.writeToBuffer) {
            return this.textModelResolverService.createModelReference(resource).then(function (reference) { return reference.object.textEditorModel.getValue(); });
        }
        return this.fileService.resolveContent(resource, { acceptTextOnly: true, encoding: encoding.UTF8 }).then(function (content) { return content.value; });
    };
    ConfigurationEditingService.prototype.getConfigurationEditOperation = function (target, config) {
        // Check for standalone workspace configurations
        if (config.key) {
            var standaloneConfigurationKeys = Object.keys(configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS);
            for (var i = 0; i < standaloneConfigurationKeys.length; i++) {
                var key = standaloneConfigurationKeys[i];
                var target_1 = this.contextService.toResource(configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS[key]);
                // Check for prefix
                if (config.key === key) {
                    return { key: '', value: config.value, target: target_1, isWorkspaceStandalone: true };
                }
                // Check for prefix.<setting>
                var keyPrefix = key + ".";
                if (config.key.indexOf(keyPrefix) === 0) {
                    return { key: config.key.substr(keyPrefix.length), value: config.value, target: target_1, isWorkspaceStandalone: true };
                }
            }
        }
        if (target === configurationEditing_1.ConfigurationTarget.USER) {
            return { key: config.key, value: config.value, target: uri_1.default.file(this.environmentService.appSettingsPath) };
        }
        return { key: config.key, value: config.value, target: this.contextService.toResource(configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH) };
    };
    return ConfigurationEditingService;
}());
ConfigurationEditingService = __decorate([
    __param(0, configuration_1.IConfigurationService),
    __param(1, workspace_1.IWorkspaceContextService),
    __param(2, environment_1.IEnvironmentService),
    __param(3, files_1.IFileService),
    __param(4, resolverService_1.ITextModelResolverService),
    __param(5, textfiles_1.ITextFileService)
], ConfigurationEditingService);
exports.ConfigurationEditingService = ConfigurationEditingService;
