/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var fs = require('fs');
var gracefulFs = require('graceful-fs');
gracefulFs.gracefulify(fs);
var arrays = require('vs/base/common/arrays');
var comparers_1 = require('vs/base/common/comparers');
var objects = require('vs/base/common/objects');
var paths = require('vs/base/common/paths');
var scorer = require('vs/base/common/scorer');
var strings = require('vs/base/common/strings');
var winjs_base_1 = require('vs/base/common/winjs.base');
var files_1 = require('vs/platform/files/common/files');
var fileSearch_1 = require('vs/workbench/services/search/node/fileSearch');
var textSearch_1 = require('vs/workbench/services/search/node/textSearch');
var SearchService = (function () {
    function SearchService() {
        this.caches = Object.create(null);
    }
    SearchService.prototype.fileSearch = function (config) {
        return this.doFileSearch(fileSearch_1.Engine, config, SearchService.BATCH_SIZE);
    };
    SearchService.prototype.textSearch = function (config) {
        var engine = new textSearch_1.Engine(config, new fileSearch_1.FileWalker({
            rootFolders: config.rootFolders,
            extraFiles: config.extraFiles,
            includePattern: config.includePattern,
            excludePattern: config.excludePattern,
            filePattern: config.filePattern,
            maxFilesize: files_1.MAX_FILE_SIZE
        }));
        return this.doSearch(engine, SearchService.BATCH_SIZE);
    };
    SearchService.prototype.doFileSearch = function (EngineClass, config, batchSize) {
        var _this = this;
        if (config.sortByScore) {
            var sortedSearch_1 = this.trySortedSearchFromCache(config);
            if (!sortedSearch_1) {
                var walkerConfig = config.maxResults ? objects.assign({}, config, { maxResults: null }) : config;
                var engine = new EngineClass(walkerConfig);
                sortedSearch_1 = this.doSortedSearch(engine, config);
            }
            return new winjs_base_1.PPromise(function (c, e, p) {
                process.nextTick(function () {
                    sortedSearch_1.then(function (_a) {
                        var result = _a[0], rawMatches = _a[1];
                        var serializedMatches = rawMatches.map(function (rawMatch) { return _this.rawMatchToSearchItem(rawMatch); });
                        _this.sendProgress(serializedMatches, p, batchSize);
                        c(result);
                    }, e, p);
                });
            }, function () {
                sortedSearch_1.cancel();
            });
        }
        var searchPromise;
        return new winjs_base_1.PPromise(function (c, e, p) {
            var engine = new EngineClass(config);
            searchPromise = _this.doSearch(engine, batchSize)
                .then(c, e, function (progress) {
                if (Array.isArray(progress)) {
                    p(progress.map(function (m) { return _this.rawMatchToSearchItem(m); }));
                }
                else if (progress.relativePath) {
                    p(_this.rawMatchToSearchItem(progress));
                }
                else {
                    p(progress);
                }
            });
        }, function () {
            searchPromise.cancel();
        });
    };
    SearchService.prototype.rawMatchToSearchItem = function (match) {
        return { path: match.base ? [match.base, match.relativePath].join(paths.nativeSep) : match.relativePath };
    };
    SearchService.prototype.doSortedSearch = function (engine, config) {
        var _this = this;
        var searchPromise;
        var allResultsPromise = new winjs_base_1.PPromise(function (c, e, p) {
            var results = [];
            searchPromise = _this.doSearch(engine, -1)
                .then(function (result) {
                c([result, results]);
            }, e, function (progress) {
                if (Array.isArray(progress)) {
                    results = progress;
                }
                else {
                    p(progress);
                }
            });
        }, function () {
            searchPromise.cancel();
        });
        var cache;
        if (config.cacheKey) {
            cache = this.getOrCreateCache(config.cacheKey);
            cache.resultsToSearchCache[config.filePattern] = allResultsPromise;
            allResultsPromise.then(null, function (err) {
                delete cache.resultsToSearchCache[config.filePattern];
            });
            allResultsPromise = this.preventCancellation(allResultsPromise);
        }
        return new winjs_base_1.PPromise(function (c, e, p) {
            allResultsPromise.then(function (_a) {
                var result = _a[0], results = _a[1];
                var scorerCache = cache ? cache.scorerCache : Object.create(null);
                var unsortedResultTime = Date.now();
                var sortedResults = _this.sortResults(config, results, scorerCache);
                var sortedResultTime = Date.now();
                c([{
                        stats: objects.assign({}, result.stats, {
                            unsortedResultTime: unsortedResultTime,
                            sortedResultTime: sortedResultTime
                        }),
                        limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults
                    }, sortedResults]);
            }, e, p);
        }, function () {
            allResultsPromise.cancel();
        });
    };
    SearchService.prototype.getOrCreateCache = function (cacheKey) {
        var existing = this.caches[cacheKey];
        if (existing) {
            return existing;
        }
        return this.caches[cacheKey] = new Cache();
    };
    SearchService.prototype.trySortedSearchFromCache = function (config) {
        var _this = this;
        var cache = config.cacheKey && this.caches[config.cacheKey];
        if (!cache) {
            return;
        }
        var cacheLookupStartTime = Date.now();
        var cached = this.getResultsFromCache(cache, config.filePattern);
        if (cached) {
            return new winjs_base_1.PPromise(function (c, e, p) {
                cached.then(function (_a) {
                    var result = _a[0], results = _a[1], cacheStats = _a[2];
                    var cacheLookupResultTime = Date.now();
                    var sortedResults = _this.sortResults(config, results, cache.scorerCache);
                    var sortedResultTime = Date.now();
                    var stats = {
                        fromCache: true,
                        cacheLookupStartTime: cacheLookupStartTime,
                        cacheFilterStartTime: cacheStats.cacheFilterStartTime,
                        cacheLookupResultTime: cacheLookupResultTime,
                        cacheEntryCount: cacheStats.cacheFilterResultCount,
                        resultCount: results.length
                    };
                    if (config.sortByScore) {
                        stats.unsortedResultTime = cacheLookupResultTime;
                        stats.sortedResultTime = sortedResultTime;
                    }
                    if (!cacheStats.cacheWasResolved) {
                        stats.joined = result.stats;
                    }
                    c([
                        {
                            limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,
                            stats: stats
                        },
                        sortedResults
                    ]);
                }, e, p);
            }, function () {
                cached.cancel();
            });
        }
    };
    SearchService.prototype.sortResults = function (config, results, scorerCache) {
        var filePattern = config.filePattern;
        var normalizedSearchValue = strings.stripWildcards(filePattern).toLowerCase();
        var compare = function (elementA, elementB) { return comparers_1.compareByScore(elementA, elementB, FileMatchAccessor, filePattern, normalizedSearchValue, scorerCache); };
        return arrays.top(results, compare, config.maxResults);
    };
    SearchService.prototype.sendProgress = function (results, progressCb, batchSize) {
        if (batchSize && batchSize > 0) {
            for (var i = 0; i < results.length; i += batchSize) {
                progressCb(results.slice(i, i + batchSize));
            }
        }
        else {
            progressCb(results);
        }
    };
    SearchService.prototype.getResultsFromCache = function (cache, searchValue) {
        if (paths.isAbsolute(searchValue)) {
            return null; // bypass cache if user looks up an absolute path where matching goes directly on disk
        }
        // Find cache entries by prefix of search value
        var hasPathSep = searchValue.indexOf(paths.nativeSep) >= 0;
        var cached;
        for (var previousSearch in cache.resultsToSearchCache) {
            // If we narrow down, we might be able to reuse the cached results
            if (strings.startsWith(searchValue, previousSearch)) {
                if (hasPathSep && previousSearch.indexOf(paths.nativeSep) < 0) {
                    continue; // since a path character widens the search for potential more matches, require it in previous search too
                }
                cached = this.preventCancellation(cache.resultsToSearchCache[previousSearch]);
                break;
            }
        }
        if (!cached) {
            return null;
        }
        return new winjs_base_1.PPromise(function (c, e, p) {
            var wasResolved = true;
            cached.then(function (_a) {
                var complete = _a[0], cachedEntries = _a[1];
                var cacheFilterStartTime = Date.now();
                // Pattern match on results
                var results = [];
                var normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();
                for (var i = 0; i < cachedEntries.length; i++) {
                    var entry = cachedEntries[i];
                    // Check if this entry is a match for the search value
                    if (!scorer.matches(entry.relativePath, normalizedSearchValueLowercase)) {
                        continue;
                    }
                    results.push(entry);
                }
                c([complete, results, {
                        cacheWasResolved: wasResolved,
                        cacheFilterStartTime: cacheFilterStartTime,
                        cacheFilterResultCount: cachedEntries.length
                    }]);
            }, e, p);
            wasResolved = false;
        }, function () {
            cached.cancel();
        });
    };
    SearchService.prototype.doSearch = function (engine, batchSize) {
        return new winjs_base_1.PPromise(function (c, e, p) {
            var batch = [];
            engine.search(function (match) {
                if (match) {
                    if (batchSize) {
                        batch.push(match);
                        if (batchSize > 0 && batch.length >= batchSize) {
                            p(batch);
                            batch = [];
                        }
                    }
                    else {
                        p(match);
                    }
                }
            }, function (progress) {
                p(progress);
            }, function (error, stats) {
                if (batch.length) {
                    p(batch);
                }
                if (error) {
                    e(error);
                }
                else {
                    c(stats);
                }
            });
        }, function () {
            engine.cancel();
        });
    };
    SearchService.prototype.clearCache = function (cacheKey) {
        delete this.caches[cacheKey];
        return winjs_base_1.TPromise.as(undefined);
    };
    SearchService.prototype.preventCancellation = function (promise) {
        return new winjs_base_1.PPromise(function (c, e, p) {
            // Allow for piled up cancellations to come through first.
            process.nextTick(function () {
                promise.then(c, e, p);
            });
        }, function () {
            // Do not propagate.
        });
    };
    SearchService.BATCH_SIZE = 512;
    return SearchService;
}());
exports.SearchService = SearchService;
var Cache = (function () {
    function Cache() {
        this.resultsToSearchCache = Object.create(null);
        this.scorerCache = Object.create(null);
    }
    return Cache;
}());
var FileMatchAccessor = (function () {
    function FileMatchAccessor() {
    }
    FileMatchAccessor.getLabel = function (match) {
        return match.basename;
    };
    FileMatchAccessor.getResourcePath = function (match) {
        return match.relativePath;
    };
    return FileMatchAccessor;
}());
