/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var childProcess = require('child_process');
var string_decoder_1 = require('string_decoder');
var errorMessage_1 = require('vs/base/common/errorMessage');
var fs = require('fs');
var paths = require('path');
var scorer = require('vs/base/common/scorer');
var arrays = require('vs/base/common/arrays');
var platform = require('vs/base/common/platform');
var strings = require('vs/base/common/strings');
var types = require('vs/base/common/types');
var glob = require('vs/base/common/glob');
var extfs = require('vs/base/node/extfs');
var flow = require('vs/base/node/flow');
var Traversal;
(function (Traversal) {
    Traversal[Traversal["Node"] = 1] = "Node";
    Traversal[Traversal["MacFind"] = 2] = "MacFind";
    Traversal[Traversal["WindowsDir"] = 3] = "WindowsDir";
    Traversal[Traversal["LinuxFind"] = 4] = "LinuxFind";
})(Traversal || (Traversal = {}));
var FileWalker = (function () {
    function FileWalker(config) {
        this.config = config;
        this.filePattern = config.filePattern;
        this.excludePattern = glob.parse(config.excludePattern, { trimForExclusions: true });
        this.includePattern = config.includePattern && glob.parse(config.includePattern);
        this.maxResults = config.maxResults || null;
        this.maxFilesize = config.maxFilesize || null;
        this.walkedPaths = Object.create(null);
        this.resultCount = 0;
        this.isLimitHit = false;
        this.directoriesWalked = 0;
        this.filesWalked = 0;
        this.traversal = Traversal.Node;
        this.errors = [];
        if (this.filePattern) {
            this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();
        }
    }
    FileWalker.prototype.cancel = function () {
        this.isCanceled = true;
    };
    FileWalker.prototype.walk = function (rootFolders, extraFiles, onResult, done) {
        var _this = this;
        this.fileWalkStartTime = Date.now();
        // Support that the file pattern is a full path to a file that exists
        this.checkFilePatternAbsoluteMatch(function (exists, size) {
            if (_this.isCanceled) {
                return done(null, _this.isLimitHit);
            }
            // Report result from file pattern if matching
            if (exists) {
                _this.resultCount++;
                onResult({
                    relativePath: _this.filePattern,
                    basename: paths.basename(_this.filePattern),
                    size: size
                });
                // Optimization: a match on an absolute path is a good result and we do not
                // continue walking the entire root paths array for other matches because
                // it is very unlikely that another file would match on the full absolute path
                return done(null, _this.isLimitHit);
            }
            // For each extra file
            if (extraFiles) {
                extraFiles.forEach(function (extraFilePath) {
                    var basename = paths.basename(extraFilePath);
                    if (_this.excludePattern(extraFilePath, basename)) {
                        return; // excluded
                    }
                    // File: Check for match on file pattern and include pattern
                    _this.matchFile(onResult, { relativePath: extraFilePath /* no workspace relative path */, basename: basename });
                });
            }
            var traverse = _this.nodeJSTraversal;
            if (!_this.maxFilesize) {
                if (platform.isMacintosh) {
                    _this.traversal = Traversal.MacFind;
                    traverse = _this.findTraversal;
                } /* else if (platform.isWindows) {
                    this.traversal = Traversal.WindowsDir;
                    traverse = this.windowsDirTraversal;
                } */
                else if (platform.isLinux) {
                    _this.traversal = Traversal.LinuxFind;
                    traverse = _this.findTraversal;
                }
            }
            var isNodeTraversal = traverse === _this.nodeJSTraversal;
            if (!isNodeTraversal) {
                _this.cmdForkStartTime = Date.now();
            }
            // For each root folder
            flow.parallel(rootFolders, function (rootFolder, rootFolderDone) {
                traverse.call(_this, rootFolder, onResult, function (err) {
                    if (err) {
                        if (isNodeTraversal) {
                            rootFolderDone(err);
                        }
                        else {
                            // fallback
                            var errorMessage = errorMessage_1.toErrorMessage(err);
                            console.error(errorMessage);
                            _this.errors.push(errorMessage);
                            _this.nodeJSTraversal(rootFolder, onResult, rootFolderDone);
                        }
                    }
                    else {
                        rootFolderDone();
                    }
                });
            }, function (err, result) {
                done(err ? err[0] : null, _this.isLimitHit);
            });
        });
    };
    FileWalker.prototype.findTraversal = function (rootFolder, onResult, cb) {
        var _this = this;
        var isMac = platform.isMacintosh;
        var done = function (err) {
            done = function () { };
            cb(err);
        };
        var leftover = '';
        var first = true;
        var tree = this.initDirectoryTree();
        var cmd = this.spawnFindCmd(rootFolder, this.excludePattern);
        this.collectStdout(cmd, 'utf8', function (err, stdout, last) {
            if (err) {
                done(err);
                return;
            }
            // Mac: uses NFD unicode form on disk, but we want NFC
            var normalized = leftover + (isMac ? strings.normalizeNFC(stdout) : stdout);
            var relativeFiles = normalized.split('\n./');
            if (first && normalized.length >= 2) {
                first = false;
                relativeFiles[0] = relativeFiles[0].trim().substr(2);
            }
            if (last) {
                var n = relativeFiles.length;
                relativeFiles[n - 1] = relativeFiles[n - 1].trim();
                if (!relativeFiles[n - 1]) {
                    relativeFiles.pop();
                }
            }
            else {
                leftover = relativeFiles.pop();
            }
            if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
                done(new Error('Splitting up files failed'));
                return;
            }
            _this.addDirectoryEntries(tree, rootFolder, relativeFiles, onResult);
            if (last) {
                _this.matchDirectoryTree(tree, rootFolder, onResult);
                done();
            }
        });
    };
    // protected windowsDirTraversal(rootFolder: string, onResult: (result: IRawFileMatch) => void, done: (err?: Error) => void): void {
    // 	const cmd = childProcess.spawn('cmd', ['/U', '/c', 'dir', '/s', '/b', '/a-d', rootFolder]);
    // 	this.readStdout(cmd, 'ucs2', (err: Error, stdout?: string) => {
    // 		if (err) {
    // 			done(err);
    // 			return;
    // 		}
    // 		const relativeFiles = stdout.split(`\r\n${rootFolder}\\`);
    // 		relativeFiles[0] = relativeFiles[0].trim().substr(rootFolder.length + 1);
    // 		const n = relativeFiles.length;
    // 		relativeFiles[n - 1] = relativeFiles[n - 1].trim();
    // 		if (!relativeFiles[n - 1]) {
    // 			relativeFiles.pop();
    // 		}
    // 		if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
    // 			done(new Error('Splitting up files failed'));
    // 			return;
    // 		}
    // 		this.matchFiles(rootFolder, relativeFiles, onResult);
    // 		done();
    // 	});
    // }
    /**
     * Public for testing.
     */
    FileWalker.prototype.spawnFindCmd = function (rootFolder, excludePattern) {
        var basenames = glob.getBasenameTerms(excludePattern);
        var paths = glob.getPathTerms(excludePattern);
        var args = ['-L', '.'];
        if (basenames.length || paths.length) {
            args.push('-not', '(', '(');
            for (var _i = 0, basenames_1 = basenames; _i < basenames_1.length; _i++) {
                var basename = basenames_1[_i];
                args.push('-name', basename);
                args.push('-o');
            }
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var path = paths_1[_a];
                args.push('-path', path);
                args.push('-o');
            }
            args.pop();
            args.push(')', '-prune', ')');
        }
        args.push('-type', 'f');
        return childProcess.spawn('find', args, { cwd: rootFolder });
    };
    /**
     * Public for testing.
     */
    FileWalker.prototype.readStdout = function (cmd, encoding, cb) {
        var all = '';
        this.collectStdout(cmd, encoding, function (err, stdout, last) {
            if (err) {
                cb(err);
                return;
            }
            all += stdout;
            if (last) {
                cb(null, all);
            }
        });
    };
    FileWalker.prototype.collectStdout = function (cmd, encoding, cb) {
        var _this = this;
        var done = function (err, stdout, last) {
            if (err || last) {
                done = function () { };
                _this.cmdForkResultTime = Date.now();
            }
            cb(err, stdout, last);
        };
        this.forwardData(cmd.stdout, encoding, done);
        var stderr = this.collectData(cmd.stderr);
        cmd.on('error', function (err) {
            done(err);
        });
        cmd.on('close', function (code) {
            if (code !== 0) {
                done(new Error("find failed with error code " + code + ": " + _this.decodeData(stderr, encoding)));
            }
            else {
                done(null, '', true);
            }
        });
    };
    FileWalker.prototype.forwardData = function (stream, encoding, cb) {
        var decoder = new string_decoder_1.StringDecoder(encoding);
        stream.on('data', function (data) {
            cb(null, decoder.write(data));
        });
        return decoder;
    };
    FileWalker.prototype.collectData = function (stream) {
        var buffers = [];
        stream.on('data', function (data) {
            buffers.push(data);
        });
        return buffers;
    };
    FileWalker.prototype.decodeData = function (buffers, encoding) {
        var decoder = new string_decoder_1.StringDecoder(encoding);
        return buffers.map(function (buffer) { return decoder.write(buffer); }).join('');
    };
    FileWalker.prototype.initDirectoryTree = function () {
        var tree = {
            rootEntries: [],
            pathToEntries: Object.create(null)
        };
        tree.pathToEntries['.'] = tree.rootEntries;
        return tree;
    };
    FileWalker.prototype.addDirectoryEntries = function (_a, base, relativeFiles, onResult) {
        var pathToEntries = _a.pathToEntries;
        this.cmdResultCount += relativeFiles.length;
        // Support relative paths to files from a root resource (ignores excludes)
        if (relativeFiles.indexOf(this.filePattern) !== -1) {
            var basename = paths.basename(this.filePattern);
            this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
        }
        relativeFiles.forEach(function add(relativePath) {
            var basename = paths.basename(relativePath);
            var dirname = paths.dirname(relativePath);
            var entries = pathToEntries[dirname];
            if (!entries) {
                entries = pathToEntries[dirname] = [];
                add(dirname);
            }
            entries.push({
                base: base,
                relativePath: relativePath,
                basename: basename
            });
        });
    };
    FileWalker.prototype.matchDirectoryTree = function (_a, rootFolder, onResult) {
        var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
        var self = this;
        var excludePattern = this.excludePattern;
        var filePattern = this.filePattern;
        function matchDirectory(entries) {
            self.directoriesWalked++;
            var _loop_1 = function(i, n) {
                var entry = entries[i];
                var relativePath = entry.relativePath, basename = entry.basename;
                // Check exclude pattern
                // If the user searches for the exact file name, we adjust the glob matching
                // to ignore filtering by siblings because the user seems to know what she
                // is searching for and we want to include the result in that case anyway
                if (excludePattern(relativePath, basename, function () { return filePattern !== basename ? entries.map(function (entry) { return entry.basename; }) : []; })) {
                    return "continue";
                }
                var sub = pathToEntries[relativePath];
                if (sub) {
                    matchDirectory(sub);
                }
                else {
                    self.filesWalked++;
                    if (relativePath === filePattern) {
                        return "continue"; // ignore file if its path matches with the file pattern because that is already matched above
                    }
                    self.matchFile(onResult, entry);
                }
            };
            for (var i = 0, n = entries.length; i < n; i++) {
                _loop_1(i, n);
            }
            ;
        }
        matchDirectory(rootEntries);
    };
    FileWalker.prototype.nodeJSTraversal = function (rootFolder, onResult, done) {
        var _this = this;
        this.directoriesWalked++;
        extfs.readdir(rootFolder, function (error, files) {
            if (error || _this.isCanceled || _this.isLimitHit) {
                return done();
            }
            // Support relative paths to files from a root resource (ignores excludes)
            return _this.checkFilePatternRelativeMatch(rootFolder, function (match, size) {
                if (_this.isCanceled || _this.isLimitHit) {
                    return done();
                }
                // Report result from file pattern if matching
                if (match) {
                    _this.resultCount++;
                    onResult({
                        base: rootFolder,
                        relativePath: _this.filePattern,
                        basename: paths.basename(_this.filePattern),
                        size: size
                    });
                }
                return _this.doWalk(rootFolder, '', files, onResult, done);
            });
        });
    };
    FileWalker.prototype.getStats = function () {
        return {
            fromCache: false,
            traversal: Traversal[this.traversal],
            errors: this.errors,
            fileWalkStartTime: this.fileWalkStartTime,
            fileWalkResultTime: Date.now(),
            directoriesWalked: this.directoriesWalked,
            filesWalked: this.filesWalked,
            resultCount: this.resultCount,
            cmdForkStartTime: this.cmdForkStartTime,
            cmdForkResultTime: this.cmdForkResultTime,
            cmdResultCount: this.cmdResultCount
        };
    };
    FileWalker.prototype.checkFilePatternAbsoluteMatch = function (clb) {
        if (!this.filePattern || !paths.isAbsolute(this.filePattern)) {
            return clb(false);
        }
        return fs.stat(this.filePattern, function (error, stat) {
            return clb(!error && !stat.isDirectory(), stat && stat.size); // only existing files
        });
    };
    FileWalker.prototype.checkFilePatternRelativeMatch = function (basePath, clb) {
        if (!this.filePattern || paths.isAbsolute(this.filePattern)) {
            return clb(null);
        }
        var absolutePath = paths.join(basePath, this.filePattern);
        return fs.stat(absolutePath, function (error, stat) {
            return clb(!error && !stat.isDirectory() ? absolutePath : null, stat && stat.size); // only existing files
        });
    };
    FileWalker.prototype.doWalk = function (rootFolder, relativeParentPath, files, onResult, done) {
        var _this = this;
        // Execute tasks on each file in parallel to optimize throughput
        flow.parallel(files, function (file, clb) {
            // Check canceled
            if (_this.isCanceled || _this.isLimitHit) {
                return clb(null);
            }
            // If the user searches for the exact file name, we adjust the glob matching
            // to ignore filtering by siblings because the user seems to know what she
            // is searching for and we want to include the result in that case anyway
            var siblings = files;
            if (_this.config.filePattern === file) {
                siblings = [];
            }
            // Check exclude pattern
            var currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(paths.sep) : file;
            if (_this.excludePattern(currentRelativePath, file, function () { return siblings; })) {
                return clb(null);
            }
            // Use lstat to detect links
            var currentAbsolutePath = [rootFolder, currentRelativePath].join(paths.sep);
            fs.lstat(currentAbsolutePath, function (error, lstat) {
                if (error || _this.isCanceled || _this.isLimitHit) {
                    return clb(null);
                }
                // If the path is a link, we must instead use fs.stat() to find out if the
                // link is a directory or not because lstat will always return the stat of
                // the link which is always a file.
                _this.statLinkIfNeeded(currentAbsolutePath, lstat, function (error, stat) {
                    if (error || _this.isCanceled || _this.isLimitHit) {
                        return clb(null);
                    }
                    // Directory: Follow directories
                    if (stat.isDirectory()) {
                        _this.directoriesWalked++;
                        // to really prevent loops with links we need to resolve the real path of them
                        return _this.realPathIfNeeded(currentAbsolutePath, lstat, function (error, realpath) {
                            if (error || _this.isCanceled || _this.isLimitHit) {
                                return clb(null);
                            }
                            if (_this.walkedPaths[realpath]) {
                                return clb(null); // escape when there are cycles (can happen with symlinks)
                            }
                            _this.walkedPaths[realpath] = true; // remember as walked
                            // Continue walking
                            return extfs.readdir(currentAbsolutePath, function (error, children) {
                                if (error || _this.isCanceled || _this.isLimitHit) {
                                    return clb(null);
                                }
                                _this.doWalk(rootFolder, currentRelativePath, children, onResult, clb);
                            });
                        });
                    }
                    else {
                        _this.filesWalked++;
                        if (currentRelativePath === _this.filePattern) {
                            return clb(null); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those
                        }
                        if (_this.maxFilesize && types.isNumber(stat.size) && stat.size > _this.maxFilesize) {
                            return clb(null); // ignore file if max file size is hit
                        }
                        _this.matchFile(onResult, { base: rootFolder, relativePath: currentRelativePath, basename: file, size: stat.size });
                    }
                    // Unwind
                    return clb(null);
                });
            });
        }, function (error) {
            if (error) {
                error = arrays.coalesce(error); // find any error by removing null values first
            }
            return done(error && error.length > 0 ? error[0] : null);
        });
    };
    FileWalker.prototype.matchFile = function (onResult, candidate) {
        if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {
            this.resultCount++;
            if (this.maxResults && this.resultCount > this.maxResults) {
                this.isLimitHit = true;
            }
            if (!this.isLimitHit) {
                onResult(candidate);
            }
        }
    };
    FileWalker.prototype.isFilePatternMatch = function (path) {
        // Check for search pattern
        if (this.filePattern) {
            if (this.filePattern === '*') {
                return true; // support the all-matching wildcard
            }
            return scorer.matches(path, this.normalizedFilePatternLowercase);
        }
        // No patterns means we match all
        return true;
    };
    FileWalker.prototype.statLinkIfNeeded = function (path, lstat, clb) {
        if (lstat.isSymbolicLink()) {
            return fs.stat(path, clb); // stat the target the link points to
        }
        return clb(null, lstat); // not a link, so the stat is already ok for us
    };
    FileWalker.prototype.realPathIfNeeded = function (path, lstat, clb) {
        if (lstat.isSymbolicLink()) {
            return fs.realpath(path, function (error, realpath) {
                if (error) {
                    return clb(error);
                }
                return clb(null, realpath);
            });
        }
        return clb(null, path);
    };
    return FileWalker;
}());
exports.FileWalker = FileWalker;
var Engine = (function () {
    function Engine(config) {
        this.rootFolders = config.rootFolders;
        this.extraFiles = config.extraFiles;
        this.walker = new FileWalker(config);
    }
    Engine.prototype.search = function (onResult, onProgress, done) {
        var _this = this;
        this.walker.walk(this.rootFolders, this.extraFiles, onResult, function (err, isLimitHit) {
            done(err, {
                limitHit: isLimitHit,
                stats: _this.walker.getStats()
            });
        });
    };
    Engine.prototype.cancel = function () {
        this.walker.cancel();
    };
    return Engine;
}());
exports.Engine = Engine;
