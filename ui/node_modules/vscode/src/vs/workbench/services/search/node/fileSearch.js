/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var childProcess = require('child_process');
var string_decoder_1 = require('string_decoder');
var errorMessage_1 = require('vs/base/common/errorMessage');
var fs = require('fs');
var paths = require('path');
var scorer = require('vs/base/common/scorer');
var arrays = require('vs/base/common/arrays');
var platform = require('vs/base/common/platform');
var strings = require('vs/base/common/strings');
var types = require('vs/base/common/types');
var glob = require('vs/base/common/glob');
var extfs = require('vs/base/node/extfs');
var flow = require('vs/base/node/flow');
var Traversal;
(function (Traversal) {
    Traversal[Traversal["Node"] = 1] = "Node";
    Traversal[Traversal["MacFind"] = 2] = "MacFind";
    Traversal[Traversal["WindowsDir"] = 3] = "WindowsDir";
    Traversal[Traversal["LinuxFind"] = 4] = "LinuxFind";
})(Traversal || (Traversal = {}));
var FileWalker = (function () {
    function FileWalker(config) {
        this.config = config;
        this.filePattern = config.filePattern;
        this.excludePattern = glob.parse(config.excludePattern, { trimForExclusions: true });
        this.includePattern = config.includePattern && glob.parse(config.includePattern);
        this.maxResults = config.maxResults || null;
        this.maxFilesize = config.maxFilesize || null;
        this.walkedPaths = Object.create(null);
        this.resultCount = 0;
        this.isLimitHit = false;
        this.directoriesWalked = 0;
        this.filesWalked = 0;
        this.traversal = Traversal.Node;
        this.errors = [];
        if (this.filePattern) {
            this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();
        }
    }
    FileWalker.prototype.cancel = function () {
        this.isCanceled = true;
    };
    FileWalker.prototype.walk = function (rootFolders, extraFiles, onResult, done) {
        var _this = this;
        this.fileWalkStartTime = Date.now();
        // Support that the file pattern is a full path to a file that exists
        this.checkFilePatternAbsoluteMatch(function (exists, size) {
            if (_this.isCanceled) {
                return done(null, _this.isLimitHit);
            }
            // Report result from file pattern if matching
            if (exists) {
                _this.resultCount++;
                onResult({
                    relativePath: _this.filePattern,
                    basename: paths.basename(_this.filePattern),
                    size: size
                });
                // Optimization: a match on an absolute path is a good result and we do not
                // continue walking the entire root paths array for other matches because
                // it is very unlikely that another file would match on the full absolute path
                return done(null, _this.isLimitHit);
            }
            // For each extra file
            if (extraFiles) {
                extraFiles.forEach(function (extraFilePath) {
                    var basename = paths.basename(extraFilePath);
                    if (_this.excludePattern(extraFilePath, basename)) {
                        return; // excluded
                    }
                    // File: Check for match on file pattern and include pattern
                    _this.matchFile(onResult, { relativePath: extraFilePath /* no workspace relative path */, basename: basename });
                });
            }
            var traverse = _this.nodeJSTraversal;
            if (!_this.maxFilesize) {
                if (platform.isMacintosh) {
                    _this.traversal = Traversal.MacFind;
                    traverse = _this.macFindTraversal;
                } /* else if (false && platform.isWindows) {
                    this.traversal = Traversal.WindowsDir;
                    traverse = this.windowsDirTraversal;
                } */
                else if (platform.isLinux) {
                    _this.traversal = Traversal.LinuxFind;
                    traverse = _this.linuxFindTraversal;
                }
            }
            var isNodeTraversal = traverse === _this.nodeJSTraversal;
            if (!isNodeTraversal) {
                _this.cmdForkStartTime = Date.now();
            }
            // For each root folder
            flow.parallel(rootFolders, function (rootFolder, rootFolderDone) {
                traverse.call(_this, rootFolder, onResult, function (err) {
                    if (err) {
                        if (isNodeTraversal) {
                            rootFolderDone(err);
                        }
                        else {
                            // fallback
                            var errorMessage = errorMessage_1.toErrorMessage(err);
                            console.error(errorMessage);
                            _this.errors.push(errorMessage);
                            _this.nodeJSTraversal(rootFolder, onResult, rootFolderDone);
                        }
                    }
                    else {
                        rootFolderDone();
                    }
                });
            }, function (err, result) {
                done(err ? err[0] : null, _this.isLimitHit);
            });
        });
    };
    FileWalker.prototype.macFindTraversal = function (rootFolder, onResult, done) {
        var _this = this;
        var cmd = this.spawnFindCmd(rootFolder, this.excludePattern);
        this.readStdout(cmd, 'utf8', function (err, stdout) {
            if (err) {
                done(err);
                return;
            }
            // Mac: uses NFD unicode form on disk, but we want NFC
            var relativeFiles = strings.normalizeNFC(stdout).split('\n./');
            relativeFiles[0] = relativeFiles[0].trim().substr(2);
            var n = relativeFiles.length;
            relativeFiles[n - 1] = relativeFiles[n - 1].trim();
            if (!relativeFiles[n - 1]) {
                relativeFiles.pop();
            }
            if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
                done(new Error('Splitting up files failed'));
                return;
            }
            _this.matchFiles(rootFolder, relativeFiles, onResult);
            done();
        });
    };
    FileWalker.prototype.windowsDirTraversal = function (rootFolder, onResult, done) {
        var _this = this;
        var cmd = childProcess.spawn('cmd', ['/U', '/c', 'dir', '/s', '/b', '/a-d', rootFolder]);
        this.readStdout(cmd, 'ucs2', function (err, stdout) {
            if (err) {
                done(err);
                return;
            }
            var relativeFiles = stdout.split("\r\n" + rootFolder + "\\");
            relativeFiles[0] = relativeFiles[0].trim().substr(rootFolder.length + 1);
            var n = relativeFiles.length;
            relativeFiles[n - 1] = relativeFiles[n - 1].trim();
            if (!relativeFiles[n - 1]) {
                relativeFiles.pop();
            }
            if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
                done(new Error('Splitting up files failed'));
                return;
            }
            _this.matchFiles(rootFolder, relativeFiles, onResult);
            done();
        });
    };
    FileWalker.prototype.linuxFindTraversal = function (rootFolder, onResult, done) {
        var _this = this;
        var cmd = this.spawnFindCmd(rootFolder, this.excludePattern);
        this.readStdout(cmd, 'utf8', function (err, stdout) {
            if (err) {
                done(err);
                return;
            }
            var relativeFiles = stdout.split('\n./');
            relativeFiles[0] = relativeFiles[0].trim().substr(2);
            var n = relativeFiles.length;
            relativeFiles[n - 1] = relativeFiles[n - 1].trim();
            if (!relativeFiles[n - 1]) {
                relativeFiles.pop();
            }
            if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
                done(new Error('Splitting up files failed'));
                return;
            }
            _this.matchFiles(rootFolder, relativeFiles, onResult);
            done();
        });
    };
    /**
     * Public for testing.
     */
    FileWalker.prototype.spawnFindCmd = function (rootFolder, excludePattern) {
        var basenames = glob.getBasenameTerms(excludePattern);
        var args = ['-L', '.'];
        if (basenames.length) {
            args.push('-not', '(', '(');
            for (var i = 0, n = basenames.length; i < n; i++) {
                if (i) {
                    args.push('-o');
                }
                args.push('-name', FileWalker.escapeGlobSpecials(basenames[i]));
            }
            args.push(')', '-prune', ')');
        }
        args.push('-type', 'f');
        return childProcess.spawn('find', args, { cwd: rootFolder });
    };
    FileWalker.escapeGlobSpecials = function (string) {
        return string.replace(this.GLOB_SPECIALS, this.ESCAPE_CHAR);
    };
    /**
     * Public for testing.
     */
    FileWalker.prototype.readStdout = function (cmd, encoding, cb) {
        var _this = this;
        var done = function (err, stdout) {
            done = function () { };
            _this.cmdForkResultTime = Date.now();
            cb(err, stdout);
        };
        var stdout = this.collectData(cmd.stdout);
        var stderr = this.collectData(cmd.stderr);
        cmd.on('error', function (err) {
            done(err);
        });
        cmd.on('close', function (code) {
            if (code !== 0) {
                done(new Error("find failed with error code " + code + ": " + _this.decodeData(stderr, encoding)));
            }
            else {
                done(null, _this.decodeData(stdout, encoding));
            }
        });
    };
    FileWalker.prototype.collectData = function (stream) {
        var buffers = [];
        stream.on('data', function (data) {
            buffers.push(data);
        });
        return buffers;
    };
    FileWalker.prototype.decodeData = function (buffers, encoding) {
        var decoder = new string_decoder_1.StringDecoder(encoding);
        return buffers.map(function (buffer) { return decoder.write(buffer); }).join('');
    };
    FileWalker.prototype.matchFiles = function (rootFolder, relativeFiles, onResult) {
        this.cmdResultCount = relativeFiles.length;
        // Support relative paths to files from a root resource (ignores excludes)
        if (relativeFiles.indexOf(this.filePattern) !== -1) {
            var basename = paths.basename(this.filePattern);
            this.matchFile(onResult, { base: rootFolder, relativePath: this.filePattern, basename: basename });
        }
        var tree = this.buildDirectoryTree(rootFolder, relativeFiles);
        this.matchDirectoryTree(rootFolder, tree, onResult);
    };
    FileWalker.prototype.buildDirectoryTree = function (base, relativeFilePaths) {
        var tree = {
            rootEntries: [],
            pathToEntries: Object.create(null)
        };
        var pathToEntries = tree.pathToEntries;
        pathToEntries['.'] = tree.rootEntries;
        relativeFilePaths.forEach(function add(relativePath) {
            var basename = paths.basename(relativePath);
            var dirname = paths.dirname(relativePath);
            var entries = pathToEntries[dirname];
            if (!entries) {
                entries = pathToEntries[dirname] = [];
                add(dirname);
            }
            entries.push({
                base: base,
                relativePath: relativePath,
                basename: basename
            });
        });
        return tree;
    };
    FileWalker.prototype.matchDirectoryTree = function (rootFolder, _a, onResult) {
        var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
        var self = this;
        var excludePattern = this.excludePattern;
        var filePattern = this.filePattern;
        function matchDirectory(entries) {
            self.directoriesWalked++;
            var _loop_1 = function(i, n) {
                var entry = entries[i];
                var relativePath = entry.relativePath, basename = entry.basename;
                // Check exclude pattern
                // If the user searches for the exact file name, we adjust the glob matching
                // to ignore filtering by siblings because the user seems to know what she
                // is searching for and we want to include the result in that case anyway
                if (excludePattern(relativePath, basename, function () { return filePattern !== basename ? entries.map(function (entry) { return entry.basename; }) : []; })) {
                    return "continue";
                }
                var sub = pathToEntries[relativePath];
                if (sub) {
                    matchDirectory(sub);
                }
                else {
                    self.filesWalked++;
                    if (relativePath === filePattern) {
                        return "continue"; // ignore file if its path matches with the file pattern because that is already matched above
                    }
                    self.matchFile(onResult, entry);
                }
            };
            for (var i = 0, n = entries.length; i < n; i++) {
                _loop_1(i, n);
            }
            ;
        }
        matchDirectory(rootEntries);
    };
    FileWalker.prototype.nodeJSTraversal = function (rootFolder, onResult, done) {
        var _this = this;
        this.directoriesWalked++;
        extfs.readdir(rootFolder, function (error, files) {
            if (error || _this.isCanceled || _this.isLimitHit) {
                return done();
            }
            // Support relative paths to files from a root resource (ignores excludes)
            return _this.checkFilePatternRelativeMatch(rootFolder, function (match, size) {
                if (_this.isCanceled || _this.isLimitHit) {
                    return done();
                }
                // Report result from file pattern if matching
                if (match) {
                    _this.resultCount++;
                    onResult({
                        base: rootFolder,
                        relativePath: _this.filePattern,
                        basename: paths.basename(_this.filePattern),
                        size: size
                    });
                }
                return _this.doWalk(rootFolder, '', files, onResult, done);
            });
        });
    };
    FileWalker.prototype.getStats = function () {
        return {
            fromCache: false,
            traversal: Traversal[this.traversal],
            errors: this.errors,
            fileWalkStartTime: this.fileWalkStartTime,
            fileWalkResultTime: Date.now(),
            directoriesWalked: this.directoriesWalked,
            filesWalked: this.filesWalked,
            resultCount: this.resultCount,
            cmdForkStartTime: this.cmdForkStartTime,
            cmdForkResultTime: this.cmdForkResultTime,
            cmdResultCount: this.cmdResultCount
        };
    };
    FileWalker.prototype.checkFilePatternAbsoluteMatch = function (clb) {
        if (!this.filePattern || !paths.isAbsolute(this.filePattern)) {
            return clb(false);
        }
        return fs.stat(this.filePattern, function (error, stat) {
            return clb(!error && !stat.isDirectory(), stat && stat.size); // only existing files
        });
    };
    FileWalker.prototype.checkFilePatternRelativeMatch = function (basePath, clb) {
        if (!this.filePattern || paths.isAbsolute(this.filePattern)) {
            return clb(null);
        }
        var absolutePath = paths.join(basePath, this.filePattern);
        return fs.stat(absolutePath, function (error, stat) {
            return clb(!error && !stat.isDirectory() ? absolutePath : null, stat && stat.size); // only existing files
        });
    };
    FileWalker.prototype.doWalk = function (rootFolder, relativeParentPath, files, onResult, done) {
        var _this = this;
        // Execute tasks on each file in parallel to optimize throughput
        flow.parallel(files, function (file, clb) {
            // Check canceled
            if (_this.isCanceled || _this.isLimitHit) {
                return clb(null);
            }
            // If the user searches for the exact file name, we adjust the glob matching
            // to ignore filtering by siblings because the user seems to know what she
            // is searching for and we want to include the result in that case anyway
            var siblings = files;
            if (_this.config.filePattern === file) {
                siblings = [];
            }
            // Check exclude pattern
            var currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(paths.sep) : file;
            if (_this.excludePattern(currentRelativePath, file, function () { return siblings; })) {
                return clb(null);
            }
            // Use lstat to detect links
            var currentAbsolutePath = [rootFolder, currentRelativePath].join(paths.sep);
            fs.lstat(currentAbsolutePath, function (error, lstat) {
                if (error || _this.isCanceled || _this.isLimitHit) {
                    return clb(null);
                }
                // If the path is a link, we must instead use fs.stat() to find out if the
                // link is a directory or not because lstat will always return the stat of
                // the link which is always a file.
                _this.statLinkIfNeeded(currentAbsolutePath, lstat, function (error, stat) {
                    if (error || _this.isCanceled || _this.isLimitHit) {
                        return clb(null);
                    }
                    // Directory: Follow directories
                    if (stat.isDirectory()) {
                        _this.directoriesWalked++;
                        // to really prevent loops with links we need to resolve the real path of them
                        return _this.realPathIfNeeded(currentAbsolutePath, lstat, function (error, realpath) {
                            if (error || _this.isCanceled || _this.isLimitHit) {
                                return clb(null);
                            }
                            if (_this.walkedPaths[realpath]) {
                                return clb(null); // escape when there are cycles (can happen with symlinks)
                            }
                            _this.walkedPaths[realpath] = true; // remember as walked
                            // Continue walking
                            return extfs.readdir(currentAbsolutePath, function (error, children) {
                                if (error || _this.isCanceled || _this.isLimitHit) {
                                    return clb(null);
                                }
                                _this.doWalk(rootFolder, currentRelativePath, children, onResult, clb);
                            });
                        });
                    }
                    else {
                        _this.filesWalked++;
                        if (currentRelativePath === _this.filePattern) {
                            return clb(null); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those
                        }
                        if (_this.maxFilesize && types.isNumber(stat.size) && stat.size > _this.maxFilesize) {
                            return clb(null); // ignore file if max file size is hit
                        }
                        _this.matchFile(onResult, { base: rootFolder, relativePath: currentRelativePath, basename: file, size: stat.size });
                    }
                    // Unwind
                    return clb(null);
                });
            });
        }, function (error) {
            if (error) {
                error = arrays.coalesce(error); // find any error by removing null values first
            }
            return done(error && error.length > 0 ? error[0] : null);
        });
    };
    FileWalker.prototype.matchFile = function (onResult, candidate) {
        if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {
            this.resultCount++;
            if (this.maxResults && this.resultCount > this.maxResults) {
                this.isLimitHit = true;
            }
            if (!this.isLimitHit) {
                onResult(candidate);
            }
        }
    };
    FileWalker.prototype.isFilePatternMatch = function (path) {
        // Check for search pattern
        if (this.filePattern) {
            if (this.filePattern === '*') {
                return true; // support the all-matching wildcard
            }
            return scorer.matches(path, this.normalizedFilePatternLowercase);
        }
        // No patterns means we match all
        return true;
    };
    FileWalker.prototype.statLinkIfNeeded = function (path, lstat, clb) {
        if (lstat.isSymbolicLink()) {
            return fs.stat(path, clb); // stat the target the link points to
        }
        return clb(null, lstat); // not a link, so the stat is already ok for us
    };
    FileWalker.prototype.realPathIfNeeded = function (path, lstat, clb) {
        if (lstat.isSymbolicLink()) {
            return fs.realpath(path, function (error, realpath) {
                if (error) {
                    return clb(error);
                }
                return clb(null, realpath);
            });
        }
        return clb(null, path);
    };
    FileWalker.GLOB_SPECIALS = /[*?\[\]\\]/g;
    FileWalker.ESCAPE_CHAR = '\\$&';
    return FileWalker;
}());
exports.FileWalker = FileWalker;
var Engine = (function () {
    function Engine(config) {
        this.rootFolders = config.rootFolders;
        this.extraFiles = config.extraFiles;
        this.walker = new FileWalker(config);
    }
    Engine.prototype.search = function (onResult, onProgress, done) {
        var _this = this;
        this.walker.walk(this.rootFolders, this.extraFiles, onResult, function (err, isLimitHit) {
            done(err, {
                limitHit: isLimitHit,
                stats: _this.walker.getStats()
            });
        });
    };
    Engine.prototype.cancel = function () {
        this.walker.cancel();
    };
    return Engine;
}());
exports.Engine = Engine;
