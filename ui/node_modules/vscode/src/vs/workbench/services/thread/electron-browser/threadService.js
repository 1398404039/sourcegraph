/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var errorMessage_1 = require('vs/base/common/errorMessage');
var marshalling_1 = require('vs/base/common/marshalling');
var objects = require('vs/base/common/objects');
var strings = require('vs/base/common/strings');
var uri_1 = require('vs/base/common/uri');
var winjs_base_1 = require('vs/base/common/winjs.base');
var ports_1 = require('vs/base/node/ports');
var ipcRemoteCom_1 = require('vs/platform/extensions/common/ipcRemoteCom');
var message_1 = require('vs/platform/message/common/message');
var abstractThreadService_1 = require('vs/workbench/services/thread/common/abstractThreadService');
var lifecycle_1 = require('vs/platform/lifecycle/common/lifecycle');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var windowService_1 = require('vs/workbench/services/window/electron-browser/windowService');
var child_process_1 = require('child_process');
var electron_1 = require('electron');
var environment_1 = require('vs/platform/environment/common/environment');
var actions_1 = require('vs/workbench/electron-browser/actions');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
exports.EXTENSION_LOG_BROADCAST_CHANNEL = 'vscode:extensionLog';
exports.EXTENSION_ATTACH_BROADCAST_CHANNEL = 'vscode:extensionAttach';
exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL = 'vscode:extensionTerminate';
// Enable to see detailed message communication between window and extension host
var logExtensionHostCommunication = false;
var MainThreadService = (function (_super) {
    __extends(MainThreadService, _super);
    function MainThreadService(contextService, messageService, windowService, environmentService, lifecycleService, instantiationService) {
        var _this = this;
        _super.call(this, true);
        this.extensionHostProcessManager = instantiationService.createInstance(ExtensionHostProcessManager);
        var logCommunication = logExtensionHostCommunication || environmentService.logExtensionHostCommunication;
        // Message: Window --> Extension Host
        this.remoteCom = ipcRemoteCom_1.create(function (msg) {
            if (logCommunication) {
                console.log('%c[Window \u2192 Extension]%c[len: ' + strings.pad(msg.length, 5, ' ') + ']', 'color: darkgreen', 'color: grey', msg);
            }
            _this.extensionHostProcessManager.postMessage(msg);
        });
        // Message: Extension Host --> Window
        this.extensionHostProcessManager.startExtensionHostProcess(function (msg) {
            if (logCommunication) {
                console.log('%c[Extension \u2192 Window]%c[len: ' + strings.pad(msg.length, 5, ' ') + ']', 'color: darkgreen', 'color: grey', msg);
            }
            _this.remoteCom.handle(msg);
        });
        this.remoteCom.setManyHandler(this);
        lifecycleService.onShutdown(function () { return _this.dispose(); });
    }
    MainThreadService.prototype.dispose = function () {
        this.extensionHostProcessManager.terminate();
    };
    MainThreadService.prototype._callOnRemote = function (proxyId, path, args) {
        return this.remoteCom.callOnRemote(proxyId, path, args);
    };
    MainThreadService = __decorate([
        __param(0, workspace_1.IWorkspaceContextService),
        __param(1, message_1.IMessageService),
        __param(2, windowService_1.IWindowService),
        __param(3, environment_1.IEnvironmentService),
        __param(4, lifecycle_1.ILifecycleService),
        __param(5, instantiation_1.IInstantiationService)
    ], MainThreadService);
    return MainThreadService;
}(abstractThreadService_1.AbstractThreadService));
exports.MainThreadService = MainThreadService;
var ExtensionHostProcessManager = (function () {
    function ExtensionHostProcessManager(contextService, messageService, windowService, lifecycleService, instantiationService, environmentService) {
        this.contextService = contextService;
        this.messageService = messageService;
        this.windowService = windowService;
        this.instantiationService = instantiationService;
        this.environmentService = environmentService;
        // handle extension host lifecycle a bit special when we know we are developing an extension that runs inside
        this.isExtensionDevelopmentHost = !!environmentService.extensionDevelopmentPath;
        this.isExtensionDevelopmentDebugging = !!environmentService.debugExtensionHost.break;
        this.isExtensionDevelopmentTestFromCli = this.isExtensionDevelopmentHost && !!environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break;
        this.unsentMessages = [];
        this.extensionHostProcessReady = false;
        lifecycleService.onWillShutdown(this._onWillShutdown, this);
    }
    ExtensionHostProcessManager.prototype.startExtensionHostProcess = function (onExtensionHostMessage) {
        var _this = this;
        var opts = {
            env: objects.mixin(objects.clone(process.env), {
                AMD_ENTRYPOINT: 'vs/workbench/node/extensionHostProcess',
                PIPE_LOGGING: 'true',
                VERBOSE_LOGGING: true,
                VSCODE_WINDOW_ID: String(this.windowService.getWindowId())
            })
        };
        // Help in case we fail to start it
        if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.initializeTimer = setTimeout(function () {
                var msg = _this.isExtensionDevelopmentDebugging ? nls.localize('extensionHostProcess.startupFailDebug', "Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.") : nls.localize('extensionHostProcess.startupFail', "Extension host did not start in 10 seconds, that might be a problem.");
                _this.messageService.show(message_1.Severity.Warning, msg);
            }, 10000);
        }
        // Initialize extension host process with hand shakes
        this.initializeExtensionHostProcess = new winjs_base_1.TPromise(function (c, e) {
            // Resolve additional execution args (e.g. debug)
            return _this.resolveDebugPort(_this.environmentService.debugExtensionHost.port, function (port) {
                if (port) {
                    opts.execArgv = ['--nolazy', (_this.isExtensionDevelopmentDebugging ? '--debug-brk=' : '--debug=') + port];
                }
                // Run Extension Host as fork of current process
                _this.extensionHostProcessHandle = child_process_1.fork(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, ['--type=extensionHost'], opts);
                // Notify debugger that we are ready to attach to the process if we run a development extension
                if (_this.isExtensionDevelopmentHost && port) {
                    _this.windowService.broadcast({
                        channel: exports.EXTENSION_ATTACH_BROADCAST_CHANNEL,
                        payload: { port: port }
                    }, _this.environmentService.extensionDevelopmentPath /* target */);
                }
                // Messages from Extension host
                _this.extensionHostProcessHandle.on('message', function (msg) {
                    // 1) Host is ready to receive messages, initialize it
                    if (msg === 'ready') {
                        if (_this.initializeTimer) {
                            window.clearTimeout(_this.initializeTimer);
                        }
                        var initPayload = marshalling_1.stringify({
                            parentPid: process.pid,
                            environment: {
                                appSettingsHome: _this.environmentService.appSettingsHome,
                                disableExtensions: _this.environmentService.disableExtensions,
                                userExtensionsHome: _this.environmentService.extensionsPath,
                                extensionDevelopmentPath: _this.environmentService.extensionDevelopmentPath,
                                extensionTestsPath: _this.environmentService.extensionTestsPath
                            },
                            contextService: {
                                workspace: _this.contextService.getWorkspace()
                            }
                        });
                        _this.extensionHostProcessHandle.send(initPayload);
                    }
                    else if (msg === 'initialized') {
                        _this.unsentMessages.forEach(function (m) { return _this.postMessage(m); });
                        _this.unsentMessages = [];
                        _this.extensionHostProcessReady = true;
                        c(_this.extensionHostProcessHandle);
                    }
                    else if (msg && msg.type === '__$console') {
                        var logEntry = msg;
                        var args = [];
                        try {
                            var parsed_1 = JSON.parse(logEntry.arguments);
                            args.push.apply(args, Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
                        }
                        catch (error) {
                            args.push(logEntry.arguments);
                        }
                        // If the first argument is a string, check for % which indicates that the message
                        // uses substitution for variables. In this case, we cannot just inject our colored
                        // [Extension Host] to the front because it breaks substitution.
                        var consoleArgs = [];
                        if (typeof args[0] === 'string' && args[0].indexOf('%') >= 0) {
                            consoleArgs = [("%c[Extension Host]%c " + args[0]), 'color: blue', 'color: black'].concat(args.slice(1));
                        }
                        else {
                            consoleArgs = ['%c[Extension Host]', 'color: blue'].concat(args);
                        }
                        // Send to local console unless we run tests from cli
                        if (!_this.isExtensionDevelopmentTestFromCli) {
                            console[logEntry.severity].apply(console, consoleArgs);
                        }
                        // Log on main side if running tests from cli
                        if (_this.isExtensionDevelopmentTestFromCli) {
                            electron_1.ipcRenderer.send('vscode:log', logEntry);
                        }
                        else if (!_this.environmentService.isBuilt || _this.isExtensionDevelopmentHost) {
                            _this.windowService.broadcast({
                                channel: exports.EXTENSION_LOG_BROADCAST_CHANNEL,
                                payload: logEntry
                            }, _this.environmentService.extensionDevelopmentPath /* target */);
                        }
                    }
                    else {
                        onExtensionHostMessage(msg);
                    }
                });
                // Lifecycle
                var onExit = function () { return _this.terminate(); };
                process.once('exit', onExit);
                _this.extensionHostProcessHandle.on('error', function (err) {
                    var errorMessage = errorMessage_1.toErrorMessage(err);
                    if (errorMessage === _this.lastExtensionHostError) {
                        return; // prevent error spam
                    }
                    _this.lastExtensionHostError = errorMessage;
                    _this.messageService.show(message_1.Severity.Error, nls.localize('extensionHostProcess.error', "Error from the extension host: {0}", errorMessage));
                });
                _this.extensionHostProcessHandle.on('exit', function (code, signal) {
                    process.removeListener('exit', onExit);
                    if (!_this.terminating) {
                        // Unexpected termination
                        if (!_this.isExtensionDevelopmentHost) {
                            _this.messageService.show(message_1.Severity.Error, {
                                message: nls.localize('extensionHostProcess.crash', "Extension host terminated unexpectedly. Please reload the window to recover."),
                                actions: [_this.instantiationService.createInstance(actions_1.ReloadWindowAction, actions_1.ReloadWindowAction.ID, actions_1.ReloadWindowAction.LABEL)]
                            });
                            console.error('Extension host terminated unexpectedly. Code: ', code, ' Signal: ', signal);
                        }
                        else if (!_this.isExtensionDevelopmentTestFromCli) {
                            _this.windowService.getWindow().close();
                        }
                        else {
                            electron_1.ipcRenderer.send('vscode:exit', code);
                        }
                    }
                });
            });
        }, function () { return _this.terminate(); });
    };
    ExtensionHostProcessManager.prototype.resolveDebugPort = function (extensionHostPort, clb) {
        var _this = this;
        // Check for a free debugging port
        if (typeof extensionHostPort === 'number') {
            return ports_1.findFreePort(extensionHostPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */, function (port) {
                if (!port) {
                    console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');
                    return clb(void 0);
                }
                if (port !== extensionHostPort) {
                    console.warn('%c[Extension Host] %cProvided debugging port ' + extensionHostPort + ' is not free, using ' + port + ' instead.', 'color: blue', 'color: black');
                }
                if (_this.isExtensionDevelopmentDebugging) {
                    console.warn('%c[Extension Host] %cSTOPPED on first line for debugging on port ' + port, 'color: blue', 'color: black');
                }
                else {
                    console.info('%c[Extension Host] %cdebugger listening on port ' + port, 'color: blue', 'color: black');
                }
                return clb(port);
            });
        }
        else {
            return clb(void 0);
        }
    };
    ExtensionHostProcessManager.prototype.postMessage = function (msg) {
        if (this.extensionHostProcessReady) {
            this.extensionHostProcessHandle.send(msg);
        }
        else if (this.initializeExtensionHostProcess) {
            this.initializeExtensionHostProcess.done(function (p) { return p.send(msg); });
        }
        else {
            this.unsentMessages.push(msg);
        }
    };
    ExtensionHostProcessManager.prototype.terminate = function () {
        this.terminating = true;
        if (this.extensionHostProcessHandle) {
            this.extensionHostProcessHandle.send({
                type: '__$terminate'
            });
        }
    };
    ExtensionHostProcessManager.prototype._onWillShutdown = function (event) {
        // If the extension development host was started without debugger attached we need
        // to communicate this back to the main side to terminate the debug session
        if (this.isExtensionDevelopmentHost && !this.isExtensionDevelopmentTestFromCli && !this.isExtensionDevelopmentDebugging) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL,
                payload: true
            }, this.environmentService.extensionDevelopmentPath /* target */);
            event.veto(winjs_base_1.TPromise.timeout(100 /* wait a bit for IPC to get delivered */).then(function () { return false; }));
        }
    };
    ExtensionHostProcessManager = __decorate([
        __param(0, workspace_1.IWorkspaceContextService),
        __param(1, message_1.IMessageService),
        __param(2, windowService_1.IWindowService),
        __param(3, lifecycle_1.ILifecycleService),
        __param(4, instantiation_1.IInstantiationService),
        __param(5, environment_1.IEnvironmentService)
    ], ExtensionHostProcessManager);
    return ExtensionHostProcessManager;
}());
