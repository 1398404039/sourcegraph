/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var errorMessage_1 = require('vs/base/common/errorMessage');
var marshalling_1 = require('vs/base/common/marshalling');
var objects = require('vs/base/common/objects');
var strings = require('vs/base/common/strings');
var uri_1 = require('vs/base/common/uri');
var winjs_base_1 = require('vs/base/common/winjs.base');
var platform_1 = require('vs/base/common/platform');
var ports_1 = require('vs/base/node/ports');
var ipcRemoteCom_1 = require('vs/platform/extensions/common/ipcRemoteCom');
var message_1 = require('vs/platform/message/common/message');
var abstractThreadService_1 = require('vs/workbench/services/thread/common/abstractThreadService');
var lifecycle_1 = require('vs/platform/lifecycle/common/lifecycle');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var windowService_1 = require('vs/workbench/services/window/electron-browser/windowService');
var child_process_1 = require('child_process');
var electron_1 = require('electron');
var environment_1 = require('vs/platform/environment/common/environment');
var actions_1 = require('vs/workbench/electron-browser/actions');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
exports.EXTENSION_LOG_BROADCAST_CHANNEL = 'vscode:extensionLog';
exports.EXTENSION_ATTACH_BROADCAST_CHANNEL = 'vscode:extensionAttach';
exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL = 'vscode:extensionTerminate';
// Enable to see detailed message communication between window and extension host
var logExtensionHostCommunication = false;
var MainThreadService = (function (_super) {
    __extends(MainThreadService, _super);
    function MainThreadService(contextService, messageService, windowService, environmentService, lifecycleService, instantiationService) {
        var _this = this;
        _super.call(this, true);
        this.extensionHostProcessManager = instantiationService.createInstance(ExtensionHostProcessManager);
        var logCommunication = logExtensionHostCommunication || environmentService.logExtensionHostCommunication;
        // Message: Window --> Extension Host
        this.remoteCom = ipcRemoteCom_1.create(function (msg) {
            if (logCommunication) {
                console.log('%c[Window \u2192 Extension]%c[len: ' + strings.pad(msg.length, 5, ' ') + ']', 'color: darkgreen', 'color: grey', msg);
            }
            _this.extensionHostProcessManager.postMessage(msg);
        });
        // Message: Extension Host --> Window
        this.extensionHostProcessManager.startExtensionHostProcess(function (msg) {
            if (logCommunication) {
                console.log('%c[Extension \u2192 Window]%c[len: ' + strings.pad(msg.length, 5, ' ') + ']', 'color: darkgreen', 'color: grey', msg);
            }
            _this.remoteCom.handle(msg);
        });
        this.remoteCom.setManyHandler(this);
        lifecycleService.onShutdown(function () { return _this.dispose(); });
    }
    MainThreadService.prototype.dispose = function () {
        this.extensionHostProcessManager.terminate();
    };
    MainThreadService.prototype._callOnRemote = function (proxyId, path, args) {
        return this.remoteCom.callOnRemote(proxyId, path, args);
    };
    MainThreadService = __decorate([
        __param(0, workspace_1.IWorkspaceContextService),
        __param(1, message_1.IMessageService),
        __param(2, windowService_1.IWindowService),
        __param(3, environment_1.IEnvironmentService),
        __param(4, lifecycle_1.ILifecycleService),
        __param(5, instantiation_1.IInstantiationService)
    ], MainThreadService);
    return MainThreadService;
}(abstractThreadService_1.AbstractThreadService));
exports.MainThreadService = MainThreadService;
var ExtensionHostProcessManager = (function () {
    function ExtensionHostProcessManager(contextService, messageService, windowService, lifecycleService, instantiationService, environmentService) {
        this.contextService = contextService;
        this.messageService = messageService;
        this.windowService = windowService;
        this.instantiationService = instantiationService;
        this.environmentService = environmentService;
        // handle extension host lifecycle a bit special when we know we are developing an extension that runs inside
        this.isExtensionDevelopmentHost = !!environmentService.extensionDevelopmentPath;
        this.isExtensionDevelopmentDebugging = !!environmentService.debugExtensionHost.break;
        this.isExtensionDevelopmentTestFromCli = this.isExtensionDevelopmentHost && !!environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break;
        this.unsentMessages = [];
        this.extensionHostProcessReady = false;
        lifecycleService.onWillShutdown(this._onWillShutdown, this);
    }
    ExtensionHostProcessManager.prototype.startExtensionHostProcess = function (onExtensionHostMessage) {
        var _this = this;
        var opts = {
            env: objects.mixin(objects.clone(process.env), {
                AMD_ENTRYPOINT: 'vs/workbench/node/extensionHostProcess',
                PIPE_LOGGING: 'true',
                VERBOSE_LOGGING: true,
                VSCODE_WINDOW_ID: String(this.windowService.getWindowId())
            }),
            // We only detach the extension host on windows. Linux and Mac orphan by default
            // and detach under Linux and Mac create another process group.
            // We detach because we have noticed that when the renderer exits, its child processes
            // (i.e. extension host) is taken down in a brutal fashion by the OS
            detached: !!platform_1.isWindows,
            onExtensionHostMessage: onExtensionHostMessage
        };
        // Help in case we fail to start it
        if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.initializeTimer = setTimeout(function () {
                var msg = _this.isExtensionDevelopmentDebugging ? nls.localize('extensionHostProcess.startupFailDebug', "Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.") : nls.localize('extensionHostProcess.startupFail', "Extension host did not start in 10 seconds, that might be a problem.");
                _this.messageService.show(message_1.Severity.Warning, msg);
            }, 10000);
        }
        // Initialize extension host process with hand shakes
        this.initializeExtensionHostProcess = this.doInitializeExtensionHostProcess(opts);
    };
    ExtensionHostProcessManager.prototype.doInitializeExtensionHostProcess = function (opts) {
        var _this = this;
        return new winjs_base_1.TPromise(function (c, e) {
            // Resolve additional execution args (e.g. debug)
            _this.resolveDebugPort(_this.environmentService.debugExtensionHost.port).then(function (port) {
                if (port) {
                    opts.execArgv = ['--nolazy', (_this.isExtensionDevelopmentDebugging ? '--debug-brk=' : '--debug=') + port];
                }
                // Run Extension Host as fork of current process
                _this.extensionHostProcessHandle = child_process_1.fork(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, ['--type=extensionHost'], opts);
                // Notify debugger that we are ready to attach to the process if we run a development extension
                if (_this.isExtensionDevelopmentHost && port) {
                    _this.windowService.broadcast({
                        channel: exports.EXTENSION_ATTACH_BROADCAST_CHANNEL,
                        payload: { port: port }
                    }, _this.environmentService.extensionDevelopmentPath /* target */);
                }
                // Messages from Extension host
                _this.extensionHostProcessHandle.on('message', function (msg) {
                    if (_this.onMessaage(msg, opts.onExtensionHostMessage)) {
                        c(_this.extensionHostProcessHandle);
                    }
                });
                // Lifecycle
                var onExit = function () { return _this.terminate(); };
                process.once('exit', onExit);
                _this.extensionHostProcessHandle.on('error', function (err) { return _this.onError(err); });
                _this.extensionHostProcessHandle.on('exit', function (code, signal) { return _this.onExit(code, signal, onExit); });
            });
        }, function () { return _this.terminate(); });
    };
    ExtensionHostProcessManager.prototype.resolveDebugPort = function (extensionHostPort) {
        var _this = this;
        if (typeof extensionHostPort !== 'number') {
            return winjs_base_1.TPromise.wrap(void 0);
        }
        return new winjs_base_1.TPromise(function (c, e) {
            ports_1.findFreePort(extensionHostPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */, function (port) {
                if (!port) {
                    console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');
                    c(void 0);
                }
                if (port !== extensionHostPort) {
                    console.warn('%c[Extension Host] %cProvided debugging port ' + extensionHostPort + ' is not free, using ' + port + ' instead.', 'color: blue', 'color: black');
                }
                if (_this.isExtensionDevelopmentDebugging) {
                    console.warn('%c[Extension Host] %cSTOPPED on first line for debugging on port ' + port, 'color: blue', 'color: black');
                }
                else {
                    console.info('%c[Extension Host] %cdebugger listening on port ' + port, 'color: blue', 'color: black');
                }
                return c(port);
            });
        });
    };
    // @return `true` if ready
    ExtensionHostProcessManager.prototype.onMessaage = function (msg, onExtensionHostMessage) {
        var _this = this;
        // 1) Host is ready to receive messages, initialize it
        if (msg === 'ready') {
            this.initializeExtensionHost();
            return false;
        }
        // 2) Host is initialized
        if (msg === 'initialized') {
            this.unsentMessages.forEach(function (m) { return _this.postMessage(m); });
            this.unsentMessages = [];
            this.extensionHostProcessReady = true;
            return true;
        }
        // Support logging from extension host
        if (msg && msg.type === '__$console') {
            this.logExtensionHostMessage(msg);
            return false;
        }
        // Any other message goes to the callback
        onExtensionHostMessage(msg);
        return false;
    };
    ExtensionHostProcessManager.prototype.initializeExtensionHost = function () {
        if (this.initializeTimer) {
            window.clearTimeout(this.initializeTimer);
        }
        var initPayload = marshalling_1.stringify({
            parentPid: process.pid,
            environment: {
                appSettingsHome: this.environmentService.appSettingsHome,
                disableExtensions: this.environmentService.disableExtensions,
                userExtensionsHome: this.environmentService.extensionsPath,
                extensionDevelopmentPath: this.environmentService.extensionDevelopmentPath,
                extensionTestsPath: this.environmentService.extensionTestsPath
            },
            contextService: {
                workspace: this.contextService.getWorkspace()
            }
        });
        this.extensionHostProcessHandle.send(initPayload);
    };
    ExtensionHostProcessManager.prototype.logExtensionHostMessage = function (logEntry) {
        var args = [];
        try {
            var parsed_1 = JSON.parse(logEntry.arguments);
            args.push.apply(args, Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
        }
        catch (error) {
            args.push(logEntry.arguments);
        }
        // If the first argument is a string, check for % which indicates that the message
        // uses substitution for variables. In this case, we cannot just inject our colored
        // [Extension Host] to the front because it breaks substitution.
        var consoleArgs = [];
        if (typeof args[0] === 'string' && args[0].indexOf('%') >= 0) {
            consoleArgs = [("%c[Extension Host]%c " + args[0]), 'color: blue', 'color: black'].concat(args.slice(1));
        }
        else {
            consoleArgs = ['%c[Extension Host]', 'color: blue'].concat(args);
        }
        // Send to local console unless we run tests from cli
        if (!this.isExtensionDevelopmentTestFromCli) {
            console[logEntry.severity].apply(console, consoleArgs);
        }
        // Log on main side if running tests from cli
        if (this.isExtensionDevelopmentTestFromCli) {
            electron_1.ipcRenderer.send('vscode:log', logEntry);
        }
        else if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_LOG_BROADCAST_CHANNEL,
                payload: logEntry
            }, this.environmentService.extensionDevelopmentPath /* target */);
        }
    };
    ExtensionHostProcessManager.prototype.onError = function (err) {
        var errorMessage = errorMessage_1.toErrorMessage(err);
        if (errorMessage === this.lastExtensionHostError) {
            return; // prevent error spam
        }
        this.lastExtensionHostError = errorMessage;
        this.messageService.show(message_1.Severity.Error, nls.localize('extensionHostProcess.error', "Error from the extension host: {0}", errorMessage));
    };
    ExtensionHostProcessManager.prototype.onExit = function (code, signal, onProcessExit) {
        process.removeListener('exit', onProcessExit);
        if (!this.terminating) {
            // Unexpected termination
            if (!this.isExtensionDevelopmentHost) {
                this.messageService.show(message_1.Severity.Error, {
                    message: nls.localize('extensionHostProcess.crash', "Extension host terminated unexpectedly. Please reload the window to recover."),
                    actions: [this.instantiationService.createInstance(actions_1.ReloadWindowAction, actions_1.ReloadWindowAction.ID, actions_1.ReloadWindowAction.LABEL)]
                });
                console.error('Extension host terminated unexpectedly. Code: ', code, ' Signal: ', signal);
            }
            else if (!this.isExtensionDevelopmentTestFromCli) {
                this.windowService.getWindow().close();
            }
            else {
                electron_1.ipcRenderer.send('vscode:exit', code);
            }
        }
    };
    ExtensionHostProcessManager.prototype.postMessage = function (msg) {
        if (this.extensionHostProcessReady) {
            this.extensionHostProcessHandle.send(msg);
        }
        else if (this.initializeExtensionHostProcess) {
            this.initializeExtensionHostProcess.done(function (p) { return p.send(msg); });
        }
        else {
            this.unsentMessages.push(msg);
        }
    };
    ExtensionHostProcessManager.prototype.terminate = function () {
        this.terminating = true;
        if (this.extensionHostProcessHandle) {
            this.extensionHostProcessHandle.send({
                type: '__$terminate'
            });
        }
    };
    ExtensionHostProcessManager.prototype._onWillShutdown = function (event) {
        // If the extension development host was started without debugger attached we need
        // to communicate this back to the main side to terminate the debug session
        if (this.isExtensionDevelopmentHost && !this.isExtensionDevelopmentTestFromCli && !this.isExtensionDevelopmentDebugging) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL,
                payload: true
            }, this.environmentService.extensionDevelopmentPath /* target */);
            event.veto(winjs_base_1.TPromise.timeout(100 /* wait a bit for IPC to get delivered */).then(function () { return false; }));
        }
    };
    ExtensionHostProcessManager = __decorate([
        __param(0, workspace_1.IWorkspaceContextService),
        __param(1, message_1.IMessageService),
        __param(2, windowService_1.IWindowService),
        __param(3, lifecycle_1.ILifecycleService),
        __param(4, instantiation_1.IInstantiationService),
        __param(5, environment_1.IEnvironmentService)
    ], ExtensionHostProcessManager);
    return ExtensionHostProcessManager;
}());
