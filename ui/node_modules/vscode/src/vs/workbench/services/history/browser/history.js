/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var errors = require('vs/base/common/errors');
var platform = require('vs/base/common/platform');
var nls = require('vs/nls');
var uri_1 = require('vs/base/common/uri');
var product_1 = require('vs/platform/product');
var editor_1 = require('vs/workbench/common/editor');
var textEditor_1 = require('vs/workbench/browser/parts/editor/textEditor');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var selection_1 = require('vs/editor/common/core/selection');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var lifecycle_1 = require('vs/base/common/lifecycle');
var storage_1 = require('vs/platform/storage/common/storage');
var lifecycle_2 = require('vs/platform/lifecycle/common/lifecycle');
var platform_1 = require('vs/platform/platform');
var event_1 = require('vs/base/common/event');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var environment_1 = require('vs/platform/environment/common/environment');
var integrity_1 = require('vs/platform/integrity/common/integrity');
/**
 * Stores the selection & view state of an editor and allows to compare it to other selection states.
 */
var EditorState = (function () {
    function EditorState(_editorInput, _selection) {
        this._editorInput = _editorInput;
        this._selection = _selection;
    }
    Object.defineProperty(EditorState.prototype, "editorInput", {
        get: function () {
            return this._editorInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorState.prototype, "selection", {
        get: function () {
            return this._selection;
        },
        enumerable: true,
        configurable: true
    });
    EditorState.prototype.justifiesNewPushState = function (other) {
        if (!this._editorInput.matches(other._editorInput)) {
            // push different editor inputs
            return true;
        }
        if (!selection_1.Selection.isISelection(this._selection) || !selection_1.Selection.isISelection(other._selection)) {
            // unknown selections
            return true;
        }
        var liftedSelection = selection_1.Selection.liftSelection(this._selection);
        var liftedOtherSelection = selection_1.Selection.liftSelection(other._selection);
        if (Math.abs(liftedSelection.getStartPosition().lineNumber - liftedOtherSelection.getStartPosition().lineNumber) < EditorState.EDITOR_SELECTION_THRESHOLD) {
            // ignore selection changes in the range of EditorState.EDITOR_SELECTION_THRESHOLD lines
            return false;
        }
        return true;
    };
    EditorState.EDITOR_SELECTION_THRESHOLD = 5; // number of lines to move in editor to justify for new state
    return EditorState;
}());
exports.EditorState = EditorState;
var BaseHistoryService = (function () {
    function BaseHistoryService(editorGroupService, editorService, contextService, environmentService, integrityService) {
        var _this = this;
        this.editorGroupService = editorGroupService;
        this.editorService = editorService;
        this.contextService = contextService;
        this.environmentService = environmentService;
        this.toUnbind = [];
        this.activeEditorListeners = [];
        this._isPure = true;
        // Window Title
        window.document.title = this.getWindowTitle(null);
        // Editor Input Changes
        this.toUnbind.push(this.editorGroupService.onEditorsChanged(function () { return _this.onEditorsChanged(); }));
        integrityService.isPure().then(function (r) {
            if (!r.isPure) {
                _this._isPure = false;
                window.document.title = _this.getWindowTitle(null);
            }
        });
    }
    BaseHistoryService.prototype.onEditorsChanged = function () {
        var _this = this;
        // Dispose old listeners
        lifecycle_1.dispose(this.activeEditorListeners);
        this.activeEditorListeners = [];
        var activeEditor = this.editorService.getActiveEditor();
        var activeInput = activeEditor ? activeEditor.input : void 0;
        // Propagate to history
        this.onEditorEvent(activeEditor);
        // Apply listener for dirty and label changes
        if (activeInput instanceof editor_1.EditorInput) {
            this.activeEditorListeners.push(activeInput.onDidChangeDirty(function () {
                _this.updateWindowTitle(activeInput); // Calculate New Window Title when dirty state changes
            }));
            this.activeEditorListeners.push(activeInput.onDidChangeLabel(function () {
                _this.updateWindowTitle(activeInput); // Calculate New Window Title when label changes
            }));
        }
        // Apply listener for selection changes if this is a text editor
        if (activeEditor instanceof textEditor_1.BaseTextEditor) {
            var control = activeEditor.getControl();
            this.activeEditorListeners.push(control.onDidChangeCursorPosition(function (event) {
                _this.handleEditorSelectionChangeEvent(activeEditor);
            }));
        }
    };
    BaseHistoryService.prototype.onEditorEvent = function (editor) {
        var input = editor ? editor.input : null;
        // Calculate New Window Title
        this.updateWindowTitle(input);
        // Delegate to implementors
        this.handleActiveEditorChange(editor);
    };
    BaseHistoryService.prototype.updateWindowTitle = function (input) {
        var windowTitle = null;
        if (input && input.getName()) {
            windowTitle = this.getWindowTitle(input);
        }
        else {
            windowTitle = this.getWindowTitle(null);
        }
        window.document.title = windowTitle;
    };
    BaseHistoryService.prototype.getWindowTitle = function (input) {
        var title = this.doGetWindowTitle(input);
        if (!this._isPure) {
            title += nls.localize('patchedWindowTitle', " [Unsupported]");
        }
        // Extension Development Host gets a special title to identify itself
        if (this.environmentService.extensionDevelopmentPath) {
            return nls.localize('devExtensionWindowTitle', "[Extension Development Host] - {0}", title);
        }
        return title;
    };
    BaseHistoryService.prototype.doGetWindowTitle = function (input) {
        var appName = product_1.default.nameLong;
        var prefix = input && input.getName();
        if (prefix && input) {
            if (input.isDirty() && !platform.isMacintosh /* Mac has its own decoration in window */) {
                prefix = nls.localize('prefixDecoration', "\u25cf {0}", prefix);
            }
        }
        var workspace = this.contextService.getWorkspace();
        if (workspace) {
            var wsName = workspace.name;
            if (prefix) {
                if (platform.isMacintosh) {
                    return nls.localize('prefixWorkspaceTitleMac', "{0} - {1}", prefix, wsName); // Mac: do not append base title
                }
                return nls.localize('prefixWorkspaceTitle', "{0} - {1} - {2}", prefix, wsName, appName);
            }
            if (platform.isMacintosh) {
                return wsName; // Mac: do not append base title
            }
            return nls.localize('workspaceTitle', "{0} - {1}", wsName, appName);
        }
        if (prefix) {
            if (platform.isMacintosh) {
                return prefix; // Mac: do not append base title
            }
            return nls.localize('prefixTitle', "{0} - {1}", prefix, appName);
        }
        return appName;
    };
    BaseHistoryService.prototype.dispose = function () {
        this.toUnbind = lifecycle_1.dispose(this.toUnbind);
    };
    return BaseHistoryService;
}());
exports.BaseHistoryService = BaseHistoryService;
var HistoryService = (function (_super) {
    __extends(HistoryService, _super);
    function HistoryService(editorService, editorGroupService, environmentService, contextService, storageService, lifecycleService, instantiationService, integrityService) {
        _super.call(this, editorGroupService, editorService, contextService, environmentService, integrityService);
        this.storageService = storageService;
        this.lifecycleService = lifecycleService;
        this.instantiationService = instantiationService;
        this.index = -1;
        this.stack = [];
        this.recentlyClosedFiles = [];
        this.loaded = false;
        this.registry = platform_1.Registry.as(editor_1.Extensions.Editors);
        this.registerListeners();
    }
    HistoryService.prototype.registerListeners = function () {
        var _this = this;
        this.toUnbind.push(this.lifecycleService.onShutdown(function () { return _this.save(); }));
        this.toUnbind.push(this.editorGroupService.onEditorOpenFail(function (editor) { return _this.remove(editor); }));
        this.toUnbind.push(this.editorGroupService.getStacksModel().onEditorClosed(function (event) { return _this.onEditorClosed(event); }));
    };
    HistoryService.prototype.onEditorClosed = function (event) {
        // Track closing of pinned editor to support to reopen closed editors
        if (event.pinned) {
            var fileEditor = editor_1.asFileEditorInput(event.editor); // we only support files to reopen
            if (fileEditor) {
                // Remove all inputs matching and add as last recently closed
                this.removeFromRecentlyClosedFiles(event.editor);
                this.recentlyClosedFiles.push({ resource: fileEditor.getResource(), index: event.index });
                // Bounding
                if (this.recentlyClosedFiles.length > HistoryService.MAX_RECENTLY_CLOSED_EDITORS) {
                    this.recentlyClosedFiles.shift();
                }
            }
        }
    };
    HistoryService.prototype.reopenLastClosedEditor = function () {
        this.ensureLoaded();
        var stacks = this.editorGroupService.getStacksModel();
        var lastClosedFile = this.recentlyClosedFiles.pop();
        while (lastClosedFile && this.isFileOpened(lastClosedFile.resource, stacks.activeGroup)) {
            lastClosedFile = this.recentlyClosedFiles.pop(); // pop until we find a file that is not opened
        }
        if (lastClosedFile) {
            this.editorService.openEditor({ resource: lastClosedFile.resource, options: { pinned: true, index: lastClosedFile.index } });
        }
    };
    HistoryService.prototype.forward = function () {
        if (this.stack.length > this.index + 1) {
            this.index++;
            this.navigate();
        }
    };
    HistoryService.prototype.back = function () {
        if (this.index > 0) {
            this.index--;
            this.navigate();
        }
    };
    HistoryService.prototype.clear = function () {
        this.ensureLoaded();
        this.index = -1;
        this.stack.splice(0);
        this.history = [];
        this.recentlyClosedFiles = [];
    };
    HistoryService.prototype.navigate = function () {
        var _this = this;
        var entry = this.stack[this.index];
        var options = entry.options;
        if (options) {
            options.revealIfVisible = true;
        }
        else {
            options = { revealIfVisible: true };
        }
        this.blockStackChanges = true;
        var openEditorPromise;
        if (entry.input instanceof editor_1.EditorInput) {
            openEditorPromise = this.editorService.openEditor(entry.input, options);
        }
        else {
            openEditorPromise = this.editorService.openEditor({ resource: entry.input.resource, options: options });
        }
        openEditorPromise.done(function () {
            _this.blockStackChanges = false;
        }, function (error) {
            _this.blockStackChanges = false;
            errors.onUnexpectedError(error);
        });
    };
    HistoryService.prototype.handleEditorSelectionChangeEvent = function (editor) {
        this.handleEditorEventInStack(editor, true);
    };
    HistoryService.prototype.handleActiveEditorChange = function (editor) {
        this.handleEditorEventInHistory(editor);
        this.handleEditorEventInStack(editor, false);
    };
    HistoryService.prototype.handleEditorEventInHistory = function (editor) {
        var _this = this;
        var input = editor ? editor.input : void 0;
        // Ensure we have at least a name to show
        if (!input || !input.getName()) {
            return;
        }
        this.ensureLoaded();
        var historyInput = this.preferResourceInput(input);
        // Remove any existing entry and add to the beginning
        this.removeFromHistory(input);
        this.history.unshift(historyInput);
        // Respect max entries setting
        if (this.history.length > HistoryService.MAX_HISTORY_ITEMS) {
            this.history.pop();
        }
        // Remove this from the history unless the history input is a resource
        // that can easily be restored even when the input gets disposed
        if (historyInput instanceof editor_1.EditorInput) {
            var onceDispose = event_1.once(historyInput.onDispose);
            onceDispose(function () {
                _this.removeFromHistory(input);
            });
        }
    };
    HistoryService.prototype.remove = function (input) {
        this.removeFromHistory(input);
        this.removeFromStack(input);
        this.removeFromRecentlyClosedFiles(input);
    };
    HistoryService.prototype.removeFromHistory = function (input, index) {
        this.ensureLoaded();
        if (typeof index !== 'number') {
            index = this.indexOf(input);
        }
        if (index >= 0) {
            this.history.splice(index, 1);
        }
    };
    HistoryService.prototype.indexOf = function (input) {
        for (var i = 0; i < this.history.length; i++) {
            var entry = this.history[i];
            if (this.matches(input, entry)) {
                return i;
            }
        }
        return -1;
    };
    HistoryService.prototype.handleEditorEventInStack = function (editor, storeSelection) {
        if (this.blockStackChanges) {
            return; // while we open an editor due to a navigation, we do not want to update our stack
        }
        if (editor instanceof textEditor_1.BaseTextEditor && editor.input) {
            this.handleTextEditorEvent(editor, storeSelection);
            return;
        }
        this.currentFileEditorState = null; // at this time we have no active file editor view state
        if (editor && editor.input) {
            this.handleNonTextEditorEvent(editor);
        }
    };
    HistoryService.prototype.handleTextEditorEvent = function (editor, storeSelection) {
        var stateCandidate = new EditorState(editor.input, editor.getSelection());
        if (!this.currentFileEditorState || this.currentFileEditorState.justifiesNewPushState(stateCandidate)) {
            this.currentFileEditorState = stateCandidate;
            var options = void 0;
            if (storeSelection) {
                var selection = editor.getSelection();
                options = {
                    selection: { startLineNumber: selection.startLineNumber, startColumn: selection.startColumn }
                };
            }
            this.add(editor.input, options);
        }
    };
    HistoryService.prototype.handleNonTextEditorEvent = function (editor) {
        var currentStack = this.stack[this.index];
        if (currentStack && this.matches(editor.input, currentStack.input)) {
            return; // do not push same editor input again
        }
        this.add(editor.input);
    };
    HistoryService.prototype.add = function (input, options) {
        if (!this.blockStackChanges) {
            this.addToStack(input, options);
        }
    };
    HistoryService.prototype.addToStack = function (input, options) {
        var _this = this;
        // Overwrite an entry in the stack if we have a matching input that comes
        // with editor options to indicate that this entry is more specific. Also
        // prevent entries that have the exact same options.
        var replace = false;
        if (this.stack[this.index]) {
            var currentEntry = this.stack[this.index];
            if (this.matches(input, currentEntry.input) && this.sameOptions(currentEntry.options, options)) {
                replace = true;
            }
        }
        var stackInput = this.preferResourceInput(input);
        var entry = { input: stackInput, options: options };
        // If we are not at the end of history, we remove anything after
        if (this.stack.length > this.index + 1) {
            this.stack = this.stack.slice(0, this.index + 1);
        }
        // Replace at current position
        if (replace) {
            this.stack[this.index] = entry;
        }
        else {
            this.index++;
            this.stack.splice(this.index, 0, entry);
            // Check for limit
            if (this.stack.length > HistoryService.MAX_STACK_ITEMS) {
                this.stack.shift(); // remove first and dispose
                if (this.index > 0) {
                    this.index--;
                }
            }
        }
        // Remove this from the stack unless the stack input is a resource
        // that can easily be restored even when the input gets disposed
        if (stackInput instanceof editor_1.EditorInput) {
            var onceDispose = event_1.once(stackInput.onDispose);
            onceDispose(function () {
                _this.removeFromStack(input);
            });
        }
    };
    HistoryService.prototype.preferResourceInput = function (input) {
        var fileInput = editor_1.asFileEditorInput(input);
        if (fileInput) {
            return { resource: fileInput.getResource() };
        }
        return input;
    };
    HistoryService.prototype.sameOptions = function (optionsA, optionsB) {
        if (!optionsA && !optionsB) {
            return true;
        }
        if ((!optionsA && optionsB) || (optionsA && !optionsB)) {
            return false;
        }
        var s1 = optionsA.selection;
        var s2 = optionsB.selection;
        if (!s1 && !s2) {
            return true;
        }
        if ((!s1 && s2) || (s1 && !s2)) {
            return false;
        }
        return s1.startLineNumber === s2.startLineNumber; // we consider the history entry same if we are on the same line
    };
    HistoryService.prototype.removeFromStack = function (input) {
        var _this = this;
        this.stack.forEach(function (e, i) {
            if (_this.matches(input, e.input)) {
                _this.stack.splice(i, 1);
                if (_this.index >= i) {
                    _this.index--; // reduce index if the element is before index
                }
            }
        });
    };
    HistoryService.prototype.removeFromRecentlyClosedFiles = function (input) {
        var _this = this;
        this.recentlyClosedFiles.forEach(function (e, i) {
            if (_this.matchesFile(e.resource, input)) {
                _this.recentlyClosedFiles.splice(i, 1);
            }
        });
    };
    HistoryService.prototype.isFileOpened = function (resource, group) {
        var _this = this;
        if (!group) {
            return false;
        }
        if (!group.contains(resource)) {
            return false; // fast check
        }
        return group.getEditors().some(function (e) { return _this.matchesFile(resource, e); });
    };
    HistoryService.prototype.matches = function (typedInput, input) {
        if (input instanceof editor_1.EditorInput) {
            return input.matches(typedInput);
        }
        return this.matchesFile(input.resource, typedInput);
    };
    HistoryService.prototype.matchesFile = function (resource, input) {
        var fileInput = editor_1.asFileEditorInput(input);
        return fileInput && fileInput.getResource().toString() === resource.toString();
    };
    HistoryService.prototype.getHistory = function () {
        this.ensureLoaded();
        return this.history.slice(0);
    };
    HistoryService.prototype.ensureLoaded = function () {
        if (!this.loaded) {
            this.load();
        }
        this.loaded = true;
    };
    HistoryService.prototype.save = function () {
        if (!this.history) {
            return; // nothing to save because history was not used
        }
        var entries = this.history.map(function (input) {
            if (input instanceof editor_1.EditorInput) {
                return void 0; // only file resource inputs are serializable currently
            }
            return { resource: input.resource.toString() };
        }).filter(function (serialized) { return !!serialized; });
        this.storageService.store(HistoryService.STORAGE_KEY, JSON.stringify(entries), storage_1.StorageScope.WORKSPACE);
    };
    HistoryService.prototype.load = function () {
        var _this = this;
        var entries = [];
        var entriesRaw = this.storageService.get(HistoryService.STORAGE_KEY, storage_1.StorageScope.WORKSPACE);
        if (entriesRaw) {
            entries = JSON.parse(entriesRaw);
        }
        this.history = entries.map(function (entry) {
            var serializedLegacyInput = entry;
            var serializedFileInput = entry;
            // Legacy support (TODO@Ben remove me - migration)
            if (serializedLegacyInput.id) {
                var factory = _this.registry.getEditorInputFactory(serializedLegacyInput.id);
                if (factory && typeof serializedLegacyInput.value === 'string') {
                    var fileInput = editor_1.asFileEditorInput(factory.deserialize(_this.instantiationService, serializedLegacyInput.value));
                    if (fileInput) {
                        return { resource: fileInput.getResource() };
                    }
                    return void 0;
                }
            }
            else if (serializedFileInput.resource) {
                return { resource: uri_1.default.parse(serializedFileInput.resource) };
            }
            return void 0;
        }).filter(function (input) { return !!input; });
    };
    HistoryService.STORAGE_KEY = 'history.entries';
    HistoryService.MAX_HISTORY_ITEMS = 200;
    HistoryService.MAX_STACK_ITEMS = 20;
    HistoryService.MAX_RECENTLY_CLOSED_EDITORS = 20;
    HistoryService = __decorate([
        __param(0, editorService_1.IWorkbenchEditorService),
        __param(1, groupService_1.IEditorGroupService),
        __param(2, environment_1.IEnvironmentService),
        __param(3, workspace_1.IWorkspaceContextService),
        __param(4, storage_1.IStorageService),
        __param(5, lifecycle_2.ILifecycleService),
        __param(6, instantiation_1.IInstantiationService),
        __param(7, integrity_1.IIntegrityService)
    ], HistoryService);
    return HistoryService;
}(BaseHistoryService));
exports.HistoryService = HistoryService;
