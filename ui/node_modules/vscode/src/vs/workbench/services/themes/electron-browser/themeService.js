/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var nls = require('vs/nls');
var Paths = require('vs/base/common/paths');
var Json = require('vs/base/common/json');
var extensions_1 = require('vs/platform/extensions/common/extensions');
var extensionsRegistry_1 = require('vs/platform/extensions/common/extensionsRegistry');
var stylesContributions_1 = require('vs/workbench/services/themes/electron-browser/stylesContributions');
var themes_1 = require('vs/platform/theme/common/themes');
var windowService_1 = require('vs/workbench/services/window/electron-browser/windowService');
var storage_1 = require('vs/platform/storage/common/storage');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var platform_1 = require('vs/platform/platform');
var jsonContributionRegistry_1 = require('vs/platform/jsonschemas/common/jsonContributionRegistry');
var builder_1 = require('vs/base/browser/builder');
var event_1 = require('vs/base/common/event');
var plist = require('fast-plist');
var pfs = require('vs/base/node/pfs');
// implementation
var DEFAULT_THEME_ID = 'vs-dark vscode-theme-defaults-themes-dark_plus-json';
var COLOR_THEME_CHANNEL = 'vscode:changeColorTheme';
var ICON_THEME_CHANNEL = 'vscode:changeIconTheme';
var COLOR_THEME_PREF = 'workbench.theme';
var ICON_THEME_PREF = 'workbench.iconTheme';
var defaultBaseTheme = themes_1.getBaseThemeId(DEFAULT_THEME_ID);
var defaultThemeExtensionId = 'vscode-theme-defaults';
var oldDefaultThemeExtensionId = 'vscode-theme-colorful-defaults';
function validateThemeId(theme) {
    // migrations
    switch (theme) {
        case 'vs': return "vs " + defaultThemeExtensionId + "-themes-light_vs-json";
        case 'vs-dark': return "vs-dark " + defaultThemeExtensionId + "-themes-dark_vs-json";
        case 'hc-black': return "hc-black " + defaultThemeExtensionId + "-themes-hc_black-json";
        case "vs " + oldDefaultThemeExtensionId + "-themes-light_plus-tmTheme": return "vs " + defaultThemeExtensionId + "-themes-light_plus-json";
        case "vs-dark " + oldDefaultThemeExtensionId + "-themes-dark_plus-tmTheme": return "vs-dark " + defaultThemeExtensionId + "-themes-dark_plus-json";
    }
    return theme;
}
var themesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('themes', {
    description: nls.localize('vscode.extension.contributes.themes', 'Contributes textmate color themes.'),
    type: 'array',
    items: {
        type: 'object',
        defaultSnippets: [{ body: { label: '{{label}}', uiTheme: 'vs-dark', path: './themes/{{id}}.tmTheme.' } }],
        properties: {
            label: {
                description: nls.localize('vscode.extension.contributes.themes.label', 'Label of the color theme as shown in the UI.'),
                type: 'string'
            },
            uiTheme: {
                description: nls.localize('vscode.extension.contributes.themes.uiTheme', 'Base theme defining the colors around the editor: \'vs\' is the light color theme, \'vs-dark\' is the dark color theme. \'hc-black\' is the dark high contrast theme.'),
                enum: ['vs', 'vs-dark', 'hc-black']
            },
            path: {
                description: nls.localize('vscode.extension.contributes.themes.path', 'Path of the tmTheme file. The path is relative to the extension folder and is typically \'./themes/themeFile.tmTheme\'.'),
                type: 'string'
            }
        },
        required: ['path', 'uiTheme']
    }
});
var iconThemeExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('iconThemes', {
    description: nls.localize('vscode.extension.contributes.iconThemes', 'Contributes file icon themes.'),
    type: 'array',
    items: {
        type: 'object',
        defaultSnippets: [{ body: { id: '{{id}}', label: '{{label}}', path: './fileicons/{{id}}-icon-theme.json' } }],
        properties: {
            id: {
                description: nls.localize('vscode.extension.contributes.iconThemes.id', 'Id of the icon theme as used in the user settings.'),
                type: 'string'
            },
            label: {
                description: nls.localize('vscode.extension.contributes.iconThemes.label', 'Label of the icon theme as shown in the UI.'),
                type: 'string'
            },
            path: {
                description: nls.localize('vscode.extension.contributes.iconThemes.path', 'Path of the icon theme definition file. The path is relative to the extension folder and is typically \'./icons/awesome-icon-theme.json\'.'),
                type: 'string'
            }
        },
        required: ['path', 'id']
    }
});
var ThemeService = (function () {
    function ThemeService(extensionService, windowService, storageService, telemetryService) {
        var _this = this;
        this.extensionService = extensionService;
        this.windowService = windowService;
        this.storageService = storageService;
        this.telemetryService = telemetryService;
        this.themeExtensionsActivated = {};
        this.knownColorThemes = [];
        this.onColorThemeChange = new event_1.Emitter();
        this.knownIconThemes = [];
        this.currentIconTheme = '';
        themesExtPoint.setHandler(function (extensions) {
            for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
                var ext = extensions_2[_i];
                _this.onThemes(ext.description.extensionFolderPath, ext.description.id, ext.value, ext.collector);
            }
        });
        windowService.onBroadcast(function (e) {
            if (e.channel === COLOR_THEME_CHANNEL && typeof e.payload === 'string') {
                _this.setColorTheme(e.payload, false);
            }
        });
        iconThemeExtPoint.setHandler(function (extensions) {
            for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
                var ext = extensions_3[_i];
                _this.onIconThemes(ext.description.extensionFolderPath, ext.description.id, ext.value, ext.collector);
            }
        });
        windowService.onBroadcast(function (e) {
            if (e.channel === ICON_THEME_CHANNEL && typeof e.payload === 'string') {
                _this.setFileIconTheme(e.payload, false);
            }
        });
    }
    Object.defineProperty(ThemeService.prototype, "onDidColorThemeChange", {
        get: function () {
            return this.onColorThemeChange.event;
        },
        enumerable: true,
        configurable: true
    });
    ThemeService.prototype.initialize = function (container) {
        this.container = container;
        var themeId = this.storageService.get(COLOR_THEME_PREF, storage_1.StorageScope.GLOBAL, null);
        if (!themeId) {
            themeId = DEFAULT_THEME_ID;
            this.storageService.store(COLOR_THEME_PREF, themeId, storage_1.StorageScope.GLOBAL);
        }
        var iconThemeId = this.storageService.get(ICON_THEME_PREF, storage_1.StorageScope.GLOBAL, null);
        return winjs_base_1.Promise.join([
            this.setColorTheme(themeId, false),
            this.setFileIconTheme(iconThemeId, false)
        ]);
    };
    ThemeService.prototype.setColorTheme = function (themeId, broadcastToAllWindows) {
        var _this = this;
        if (!themeId) {
            return winjs_base_1.TPromise.as(false);
        }
        if (themeId === this.currentColorTheme) {
            if (broadcastToAllWindows) {
                this.windowService.broadcast({ channel: COLOR_THEME_CHANNEL, payload: themeId });
            }
            return winjs_base_1.TPromise.as(true);
        }
        themeId = validateThemeId(themeId); // migrate theme ids
        var onApply = function (newTheme) {
            var newThemeId = newTheme.id;
            if (_this.container) {
                if (_this.currentColorTheme) {
                    builder_1.$(_this.container).removeClass(_this.currentColorTheme);
                }
                _this.currentColorTheme = newThemeId;
                builder_1.$(_this.container).addClass(newThemeId);
            }
            _this.storageService.store(COLOR_THEME_PREF, newThemeId, storage_1.StorageScope.GLOBAL);
            if (broadcastToAllWindows) {
                _this.windowService.broadcast({ channel: COLOR_THEME_CHANNEL, payload: newThemeId });
            }
            else {
                _this.sendTelemetry(newTheme);
            }
            _this.onColorThemeChange.fire(newThemeId);
        };
        return this.applyThemeCSS(themeId, DEFAULT_THEME_ID, onApply);
    };
    ThemeService.prototype.getColorTheme = function () {
        return this.currentColorTheme || this.storageService.get(COLOR_THEME_PREF, storage_1.StorageScope.GLOBAL, DEFAULT_THEME_ID);
    };
    ThemeService.prototype.findThemeData = function (themeId, defaultId) {
        return this.getColorThemes().then(function (allThemes) {
            var themes = allThemes.filter(function (t) { return t.id === themeId; });
            if (themes.length > 0) {
                return themes[0];
            }
            if (defaultId) {
                var themes_2 = allThemes.filter(function (t) { return t.id === defaultId; });
                if (themes_2.length > 0) {
                    return themes_2[0];
                }
            }
            return null;
        });
    };
    ThemeService.prototype.applyThemeCSS = function (themeId, defaultId, onApply) {
        return this.findThemeData(themeId, defaultId).then(function (theme) {
            if (theme) {
                return applyTheme(theme, onApply);
            }
            return false;
        });
    };
    ThemeService.prototype.getColorThemes = function () {
        var _this = this;
        return this.extensionService.onReady().then(function (isReady) {
            return _this.knownColorThemes;
        });
    };
    ThemeService.prototype.onThemes = function (extensionFolderPath, extensionId, themes, collector) {
        var _this = this;
        if (!Array.isArray(themes)) {
            collector.error(nls.localize('reqarray', "Extension point `{0}` must be an array.", themesExtPoint.name));
            return;
        }
        themes.forEach(function (theme) {
            if (!theme.path || (typeof theme.path !== 'string')) {
                collector.error(nls.localize('reqpath', "Expected string in `contributes.{0}.path`. Provided value: {1}", themesExtPoint.name, String(theme.path)));
                return;
            }
            var normalizedAbsolutePath = Paths.normalize(Paths.join(extensionFolderPath, theme.path));
            if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
                collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", themesExtPoint.name, normalizedAbsolutePath, extensionFolderPath));
            }
            var themeSelector = toCSSSelector(extensionId + '-' + Paths.normalize(theme.path));
            _this.knownColorThemes.push({
                id: (theme.uiTheme || defaultBaseTheme) + " " + themeSelector,
                label: theme.label || Paths.basename(theme.path),
                description: theme.description,
                path: normalizedAbsolutePath,
                extensionId: extensionId
            });
        });
    };
    ThemeService.prototype.onIconThemes = function (extensionFolderPath, extensionId, iconThemes, collector) {
        var _this = this;
        if (!Array.isArray(iconThemes)) {
            collector.error(nls.localize('reqarray', "Extension point `{0}` must be an array.", themesExtPoint.name));
            return;
        }
        iconThemes.forEach(function (iconTheme) {
            if (!iconTheme.path || (typeof iconTheme.path !== 'string')) {
                collector.error(nls.localize('reqpath', "Expected string in `contributes.{0}.path`. Provided value: {1}", themesExtPoint.name, String(iconTheme.path)));
                return;
            }
            if (!iconTheme.id || (typeof iconTheme.id !== 'string')) {
                collector.error(nls.localize('reqid', "Expected string in `contributes.{0}.id`. Provided value: {1}", themesExtPoint.name, String(iconTheme.path)));
                return;
            }
            var normalizedAbsolutePath = Paths.normalize(Paths.join(extensionFolderPath, iconTheme.path));
            if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
                collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", themesExtPoint.name, normalizedAbsolutePath, extensionFolderPath));
            }
            _this.knownIconThemes.push({
                id: extensionId + '-' + iconTheme.id,
                label: iconTheme.label || Paths.basename(iconTheme.path),
                description: iconTheme.description,
                path: normalizedAbsolutePath,
                extensionId: extensionId
            });
        });
    };
    ThemeService.prototype.sendTelemetry = function (themeData) {
        if (!this.themeExtensionsActivated[themeData.extensionId]) {
            var description = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(themeData.extensionId);
            if (description) {
                this.telemetryService.publicLog('activatePlugin', {
                    id: description.id,
                    name: description.name,
                    isBuiltin: description.isBuiltin,
                    publisherDisplayName: description.publisher,
                    themeId: themeData.id
                });
                this.themeExtensionsActivated[themeData.extensionId] = true;
            }
        }
    };
    ThemeService.prototype.getFileIconThemes = function () {
        var _this = this;
        return this.extensionService.onReady().then(function (isReady) {
            return _this.knownIconThemes;
        });
    };
    ThemeService.prototype.getFileIconTheme = function () {
        return this.currentIconTheme || this.storageService.get(ICON_THEME_PREF, storage_1.StorageScope.GLOBAL, '');
    };
    ThemeService.prototype.setFileIconTheme = function (iconTheme, broadcastToAllWindows) {
        var _this = this;
        iconTheme = iconTheme || '';
        if (iconTheme === this.currentIconTheme) {
            if (broadcastToAllWindows) {
                this.windowService.broadcast({ channel: ICON_THEME_CHANNEL, payload: iconTheme });
            }
            return winjs_base_1.TPromise.as(true);
        }
        var onApply = function (newIconTheme) {
            var newIconThemeId = newIconTheme ? newIconTheme.id : '';
            _this.storageService.store(ICON_THEME_PREF, newIconThemeId, storage_1.StorageScope.GLOBAL);
            if (broadcastToAllWindows) {
                _this.windowService.broadcast({ channel: ICON_THEME_CHANNEL, payload: newIconThemeId });
            }
            else if (newIconTheme) {
                _this.sendTelemetry(newIconTheme);
            }
        };
        this.currentIconTheme = iconTheme;
        return this._updateIconTheme(onApply);
    };
    ThemeService.prototype._updateIconTheme = function (onApply) {
        var _this = this;
        return this.getFileIconThemes().then(function (allIconSets) {
            var iconSetData;
            for (var _i = 0, allIconSets_1 = allIconSets; _i < allIconSets_1.length; _i++) {
                var iconSet = allIconSets_1[_i];
                if (iconSet.id === _this.currentIconTheme) {
                    iconSetData = iconSet;
                    break;
                }
            }
            return _applyIconTheme(iconSetData, onApply);
        });
    };
    ThemeService = __decorate([
        __param(0, extensions_1.IExtensionService),
        __param(1, windowService_1.IWindowService),
        __param(2, storage_1.IStorageService),
        __param(3, telemetry_1.ITelemetryService)
    ], ThemeService);
    return ThemeService;
}());
exports.ThemeService = ThemeService;
function _applyIconTheme(data, onApply) {
    if (!data) {
        _applyRules('', iconThemeRulesClassName);
        onApply(data);
        return winjs_base_1.TPromise.as(true);
    }
    if (data.styleSheetContent) {
        _applyRules(data.styleSheetContent, iconThemeRulesClassName);
        onApply(data);
        return winjs_base_1.TPromise.as(true);
    }
    return _loadIconThemeDocument(data.path).then(function (iconThemeDocument) {
        var styleSheetContent = _processIconThemeDocument(data.id, data.path, iconThemeDocument);
        data.styleSheetContent = styleSheetContent;
        _applyRules(styleSheetContent, iconThemeRulesClassName);
        onApply(data);
        return true;
    }, function (error) {
        return winjs_base_1.TPromise.wrapError(nls.localize('error.cannotloadicontheme', "Unable to load {0}", data.path));
    });
}
function _loadIconThemeDocument(fileSetPath) {
    return pfs.readFile(fileSetPath).then(function (content) {
        var errors = [];
        var contentValue = Json.parse(content.toString(), errors);
        if (errors.length > 0) {
            return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparseicontheme', "Problems parsing file icons file: {0}", errors.map(function (e) { return Json.getParseErrorMessage(e.error); }).join(', '))));
        }
        return winjs_base_1.TPromise.as(contentValue);
    });
}
function _processIconThemeDocument(id, iconThemeDocumentPath, iconThemeDocument) {
    if (!iconThemeDocument.iconDefinitions) {
        return '';
    }
    var selectorByDefinitionId = {};
    function resolvePath(path) {
        return Paths.join(Paths.dirname(iconThemeDocumentPath), path);
    }
    function collectSelectors(associations, baseThemeClassName) {
        function addSelector(selector, defId) {
            if (defId) {
                var list = selectorByDefinitionId[defId];
                if (!list) {
                    list = selectorByDefinitionId[defId] = [];
                }
                list.push(selector);
            }
        }
        if (associations) {
            var qualifier = '.show-file-icons';
            if (baseThemeClassName) {
                qualifier = baseThemeClassName + ' ' + qualifier;
            }
            var expanded = '.monaco-tree-row.expanded'; // workaround for #11453
            addSelector(qualifier + " .folder-icon::before", associations.folder);
            addSelector(qualifier + " " + expanded + " .folder-icon::before", associations.folderExpanded);
            addSelector(qualifier + " .file-icon::before", associations.file);
            var folderNames = associations.folderNames;
            if (folderNames) {
                for (var folderName in folderNames) {
                    addSelector(qualifier + " ." + escapeCSS(folderName.toLowerCase()) + "-name-folder-icon.folder-icon::before", folderNames[folderName]);
                }
            }
            var folderNamesExpanded = associations.folderNamesExpanded;
            if (folderNamesExpanded) {
                for (var folderName in folderNamesExpanded) {
                    addSelector(qualifier + " " + expanded + " ." + escapeCSS(folderName.toLowerCase()) + "-name-folder-icon.folder-icon::before", folderNamesExpanded[folderName]);
                }
            }
            var languageIds = associations.languageIds;
            if (languageIds) {
                for (var languageId in languageIds) {
                    addSelector(qualifier + " ." + escapeCSS(languageId) + "-lang-file-icon.file-icon::before", languageIds[languageId]);
                }
            }
            var fileExtensions = associations.fileExtensions;
            if (fileExtensions) {
                for (var fileExtension in fileExtensions) {
                    var selectors = [];
                    var segments = fileExtension.toLowerCase().split('.');
                    for (var i = 0; i < segments.length; i++) {
                        selectors.push("." + escapeCSS(segments.slice(i).join('.')) + "-ext-file-icon");
                    }
                    addSelector(qualifier + " " + selectors.join('') + ".file-icon::before", fileExtensions[fileExtension]);
                }
            }
            var fileNames = associations.fileNames;
            if (fileNames) {
                for (var fileName in fileNames) {
                    var selectors = [];
                    var segments = fileName.toLowerCase().split('.');
                    if (segments[0]) {
                        selectors.push("." + escapeCSS(segments[0]) + "-name-file-icon");
                    }
                    for (var i = 1; i < segments.length; i++) {
                        selectors.push("." + escapeCSS(segments.slice(i).join('.')) + "-ext-file-icon");
                    }
                    addSelector(qualifier + " " + selectors.join('') + ".file-icon::before", fileNames[fileName]);
                }
            }
        }
    }
    collectSelectors(iconThemeDocument);
    collectSelectors(iconThemeDocument.light, '.vs');
    collectSelectors(iconThemeDocument.highContrast, '.hc_black');
    var cssRules = [];
    var fonts = iconThemeDocument.fonts;
    if (Array.isArray(fonts)) {
        fonts.forEach(function (font) {
            var src = font.src.map(function (l) { return ("url('" + resolvePath(l.path) + "') format('" + l.format + "')"); }).join(', ');
            cssRules.push("@font-face { src: " + src + "; font-family: '" + font.id + "'; font-weigth: " + font.weight + "; font-style: " + font.style + "; }");
        });
        cssRules.push(".show-file-icons .file-icon::before, .show-file-icons .folder-icon::before { font-family: '" + fonts[0].id + "'; font-size: " + (fonts[0].size || '150%') + "}");
    }
    for (var defId in selectorByDefinitionId) {
        var selectors = selectorByDefinitionId[defId];
        var definition = iconThemeDocument.iconDefinitions[defId];
        if (definition) {
            if (definition.iconPath) {
                cssRules.push(selectors.join(', ') + " { content: ' '; background-image: url(\"" + resolvePath(definition.iconPath) + "\"); }");
            }
            if (definition.fontCharacter || definition.fontColor) {
                var body = '';
                if (definition.fontColor) {
                    body += " color: " + definition.fontColor + ";";
                }
                if (definition.fontCharacter) {
                    body += " content: '" + definition.fontCharacter + "';";
                }
                if (definition.fontSize) {
                    body += " font-size: " + definition.fontSize + ";";
                }
                if (definition.fontId) {
                    body += " font-family: " + definition.fontId + ";";
                }
                cssRules.push(selectors.join(', ') + " { " + body + " }");
            }
        }
    }
    return cssRules.join('\n');
}
function escapeCSS(str) {
    return window['CSS'].escape(str);
}
function toCSSSelector(str) {
    str = str.replace(/[^_\-a-zA-Z0-9]/g, '-');
    if (str.charAt(0).match(/[0-9\-]/)) {
        str = '_' + str;
    }
    return str;
}
function applyTheme(theme, onApply) {
    if (theme.styleSheetContent) {
        _applyRules(theme.styleSheetContent, colorThemeRulesClassName);
        onApply(theme);
        return winjs_base_1.TPromise.as(true);
    }
    return _loadThemeDocument(theme.path).then(function (themeDocument) {
        var styleSheetContent = _processThemeObject(theme.id, themeDocument);
        theme.styleSheetContent = styleSheetContent;
        _applyRules(styleSheetContent, colorThemeRulesClassName);
        onApply(theme);
        return true;
    }, function (error) {
        return winjs_base_1.TPromise.wrapError(nls.localize('error.cannotloadtheme', "Unable to load {0}", theme.path));
    });
}
function _loadThemeDocument(themePath) {
    return pfs.readFile(themePath).then(function (content) {
        if (Paths.extname(themePath) === '.json') {
            var errors = [];
            var contentValue_1 = Json.parse(content.toString(), errors);
            if (errors.length > 0) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparsejson', "Problems parsing JSON theme file: {0}", errors.map(function (e) { return Json.getParseErrorMessage(e.error); }).join(', '))));
            }
            if (contentValue_1.include) {
                return _loadThemeDocument(Paths.join(Paths.dirname(themePath), contentValue_1.include)).then(function (includedValue) {
                    contentValue_1.settings = includedValue.settings.concat(contentValue_1.settings);
                    return winjs_base_1.TPromise.as(contentValue_1);
                });
            }
            return winjs_base_1.TPromise.as(contentValue_1);
        }
        try {
            return winjs_base_1.TPromise.as(plist.parse(content.toString()));
        }
        catch (e) {
            return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparse', "Problems parsing plist file: {0}", e.message)));
        }
    });
}
function _processThemeObject(themeId, themeDocument) {
    var cssRules = [];
    var themeSettings = themeDocument.settings;
    if (Array.isArray(themeSettings)) {
        new stylesContributions_1.TokenStylesContribution().contributeStyles(themeId, themeDocument, cssRules);
        new stylesContributions_1.EditorStylesContribution().contributeStyles(themeId, themeDocument, cssRules);
        new stylesContributions_1.SearchViewStylesContribution().contributeStyles(themeId, themeDocument, cssRules);
    }
    return cssRules.join('\n');
}
var colorThemeRulesClassName = 'contributedColorTheme';
var iconThemeRulesClassName = 'contributedIconTheme';
function _applyRules(styleSheetContent, rulesClassName) {
    var themeStyles = document.head.getElementsByClassName(rulesClassName);
    if (themeStyles.length === 0) {
        var elStyle = document.createElement('style');
        elStyle.type = 'text/css';
        elStyle.className = rulesClassName;
        elStyle.innerHTML = styleSheetContent;
        document.head.appendChild(elStyle);
    }
    else {
        themeStyles[0].innerHTML = styleSheetContent;
    }
}
var schemaId = 'vscode://schemas/icon-theme';
var schema = {
    type: 'object',
    definitions: {
        folderExpanded: {
            type: 'string',
            description: nls.localize('schema.folderExpanded', 'The folder icon for expanded folders. The expanded folder icon is optional. If not set, the icon defined for folder will be shown.')
        },
        folder: {
            type: 'string',
            description: nls.localize('schema.folder', 'The folder icon for collapsed folders, and if folderExpanded is not set, also for expanded folders.')
        },
        file: {
            type: 'string',
            description: nls.localize('schema.file', 'The default file icon, shown for all files that don\'t match any extension, filename or language id.')
        },
        folderNames: {
            type: 'object',
            description: nls.localize('schema.folderNames', 'Associates folder names to icons. The object key is is the folder name, not including any path segments. No patterns or wildcards are allowed. Folder name matching is case insensitive.'),
            additionalProperties: {
                type: 'string',
                description: nls.localize('schema.folderName', 'The ID of the icon definition for the association.')
            }
        },
        folderNamesExpanded: {
            type: 'object',
            description: nls.localize('schema.folderNamesExpanded', 'Associates folder names to icons for expanded folders. The object key is is the folder name, not including any path segments. No patterns or wildcards are allowed. Folder name matching is case insensitive.'),
            additionalProperties: {
                type: 'string',
                description: nls.localize('schema.folderNameExpanded', 'The ID of the icon definition for the association.')
            }
        },
        fileExtensions: {
            type: 'object',
            description: nls.localize('schema.fileExtensions', 'Associates file extensions to icons. The object key is is the file extension name. The extension name is the last segment of a file name after the last dot (not including the dot). Extensions are compared case insensitive.'),
            additionalProperties: {
                type: 'string',
                description: nls.localize('schema.fileExtension', 'The ID of the icon definition for the association.')
            }
        },
        fileNames: {
            type: 'object',
            description: nls.localize('schema.fileNames', 'Associates file names to icons. The object key is is the full file name, but not including any path segments. File name can include dots and a possible file extension. No patterns or wildcards are allowed. File name matching is case insensitive.'),
            additionalProperties: {
                type: 'string',
                description: nls.localize('schema.fileName', 'The ID of the icon definition for the association.')
            }
        },
        languageIds: {
            type: 'object',
            description: nls.localize('schema.languageIds', 'Associates languages to icons. The object key is the language id as defined in the language contribution point.'),
            additionalProperties: {
                type: 'string',
                description: nls.localize('schema.languageId', 'The ID of the icon definition for the association.')
            }
        },
        associations: {
            type: 'object',
            properties: {
                folderExpanded: {
                    $ref: '#/definitions/folderExpanded'
                },
                folder: {
                    $ref: '#/definitions/folder'
                },
                file: {
                    $ref: '#/definitions/file'
                },
                folderNames: {
                    $ref: '#/definitions/folderNames'
                },
                folderNamesExpanded: {
                    $ref: '#/definitions/folderNamesExpanded'
                },
                fileExtensions: {
                    $ref: '#/definitions/fileExtensions'
                },
                fileNames: {
                    $ref: '#/definitions/fileNames'
                },
                languageIds: {
                    $ref: '#/definitions/languageIds'
                }
            }
        }
    },
    properties: {
        fonts: {
            type: 'array',
            description: nls.localize('schema.fonts', 'Fonts that are used in the icon definitions.'),
            items: {
                type: 'object',
                properties: {
                    id: {
                        type: 'string',
                        description: nls.localize('schema.id', 'The ID of the font.')
                    },
                    src: {
                        type: 'array',
                        description: nls.localize('schema.src', 'The locations of the font.'),
                        items: {
                            type: 'object',
                            properties: {
                                path: {
                                    type: 'string',
                                    description: nls.localize('schema.font-path', 'The font path, relative to the current icon theme file.'),
                                },
                                format: {
                                    type: 'string',
                                    description: nls.localize('schema.font-format', 'The format of the font.')
                                }
                            },
                            required: [
                                'path',
                                'format'
                            ]
                        }
                    },
                    weight: {
                        type: 'string',
                        description: nls.localize('schema.font-weight', 'The weight of the font.')
                    },
                    style: {
                        type: 'string',
                        description: nls.localize('schema.font-sstyle', 'The style of the font.')
                    },
                    size: {
                        type: 'string',
                        description: nls.localize('schema.font-size', 'The default size of the font.')
                    }
                },
                required: [
                    'id',
                    'src'
                ]
            }
        },
        iconDefinitions: {
            type: 'object',
            description: nls.localize('schema.iconDefinitions', 'Description of all icons that can be used when associating files to icons.'),
            additionalProperties: {
                type: 'object',
                description: nls.localize('schema.iconDefinition', 'An icon definition. The object key is the ID of the definition.'),
                properties: {
                    iconPath: {
                        type: 'string',
                        description: nls.localize('schema.iconPath', 'When using a SVG or PNG: The path to the image. The path is relative to the icon set file.')
                    },
                    fontCharacter: {
                        type: 'string',
                        description: nls.localize('schema.fontCharacter', 'When using a glyph font: The character in the font to use.')
                    },
                    fontColor: {
                        type: 'string',
                        description: nls.localize('schema.fontColor', 'When using a glyph font: The color to use.')
                    },
                    fontSize: {
                        type: 'string',
                        description: nls.localize('schema.fontSize', 'When using a font: The font size in percentage to the text font. If not set, defaults to the size in the font definition.')
                    },
                    fontId: {
                        type: 'string',
                        description: nls.localize('schema.fontId', 'When using a font: The id of the font. If not set, defaults to the first font definition.')
                    }
                }
            }
        },
        folderExpanded: {
            $ref: '#/definitions/folderExpanded'
        },
        folder: {
            $ref: '#/definitions/folder'
        },
        file: {
            $ref: '#/definitions/file'
        },
        folderNames: {
            $ref: '#/definitions/folderNames'
        },
        fileExtensions: {
            $ref: '#/definitions/fileExtensions'
        },
        fileNames: {
            $ref: '#/definitions/fileNames'
        },
        languageIds: {
            $ref: '#/definitions/languageIds'
        },
        light: {
            $ref: '#/definitions/associations',
            description: nls.localize('schema.light', 'Optional associations for file icons in light color themes.')
        },
        highContrast: {
            $ref: '#/definitions/associations',
            description: nls.localize('schema.highContrast', 'Optional associations for file icons in high contrast color themes.')
        }
    }
};
var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
schemaRegistry.registerSchema(schemaId, schema);
