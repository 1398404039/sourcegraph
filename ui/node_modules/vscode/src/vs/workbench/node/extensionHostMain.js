/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var fs = require('fs');
var crypto = require('crypto');
var nls = require('vs/nls');
var pfs = require('vs/base/node/pfs');
var uri_1 = require('vs/base/common/uri');
var winjs_base_1 = require('vs/base/common/winjs.base');
var paths = require('vs/base/common/paths');
var package_1 = require('vs/platform/package');
var extensionsRegistry_1 = require('vs/platform/extensions/common/extensionsRegistry');
var extHost_api_impl_1 = require('vs/workbench/api/node/extHost.api.impl');
var extHostExtensionService_1 = require('vs/workbench/api/node/extHostExtensionService');
var extHostThreadService_1 = require('vs/workbench/services/thread/common/extHostThreadService');
var extHostTelemetry_1 = require('vs/workbench/api/node/extHostTelemetry');
var extensionPoints_1 = require('vs/workbench/node/extensionPoints');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var errors = require('vs/base/common/errors');
var DIRNAME = uri_1.default.parse(require.toUrl('./')).fsPath;
var BASE_PATH = paths.normalize(paths.join(DIRNAME, '../../../..'));
var BUILTIN_EXTENSIONS_PATH = paths.join(BASE_PATH, 'extensions');
var nativeExit = process.exit.bind(process);
process.exit = function () {
    var err = new Error('An extension called process.exit() and this was prevented.');
    console.warn(err.stack);
};
function exit(code) {
    nativeExit(code);
}
exports.exit = exit;
var ExtensionHostMain = (function () {
    function ExtensionHostMain(remoteCom, initData) {
        this._isTerminating = false;
        this._environment = initData.environment;
        this._contextService = new workspace_1.WorkspaceContextService(initData.contextService.workspace);
        var workspaceStoragePath = this._getOrCreateWorkspaceStoragePath();
        var threadService = new extHostThreadService_1.ExtHostThreadService(remoteCom);
        var telemetryService = new extHostTelemetry_1.RemoteTelemetryService('pluginHostTelemetry', threadService);
        this._extensionService = new extHostExtensionService_1.ExtHostExtensionService(threadService, telemetryService, { _serviceBrand: 'optionalArgs', workspaceStoragePath: workspaceStoragePath });
        // Connect to shared process services
        /*
        const channel = sharedProcessClient.getChannel<IExtensionManagementChannel>('extensions');
        const extensionsService = new ExtensionManagementChannelClient(channel);
        if (false && false) {
            // TODO: what to do with the ExtensionManagementChannelClient?
            console.log(extensionsService);
        }
        */
        // Create the ext host API
        extHost_api_impl_1.defineAPI(new extHost_api_impl_1.ExtHostAPIImplementation(threadService, this._extensionService, this._contextService, telemetryService));
    }
    ExtensionHostMain.prototype._getOrCreateWorkspaceStoragePath = function () {
        var workspaceStoragePath;
        var workspace = this._contextService.getWorkspace();
        function rmkDir(directory) {
            try {
                fs.mkdirSync(directory);
                return true;
            }
            catch (err) {
                if (err.code === 'ENOENT') {
                    if (rmkDir(paths.dirname(directory))) {
                        fs.mkdirSync(directory);
                        return true;
                    }
                }
                else {
                    return fs.statSync(directory).isDirectory();
                }
            }
        }
        if (workspace) {
            var hash = crypto.createHash('md5');
            hash.update(workspace.resource.fsPath);
            if (workspace.uid) {
                hash.update(workspace.uid.toString());
            }
            workspaceStoragePath = paths.join(this._environment.appSettingsHome, 'workspaceStorage', hash.digest('hex'));
            if (!fs.existsSync(workspaceStoragePath)) {
                try {
                    if (rmkDir(workspaceStoragePath)) {
                        fs.writeFileSync(paths.join(workspaceStoragePath, 'meta.json'), JSON.stringify({
                            workspacePath: workspace.resource.fsPath,
                            uid: workspace.uid ? workspace.uid : null
                        }, null, 4));
                    }
                    else {
                        workspaceStoragePath = undefined;
                    }
                }
                catch (err) {
                    workspaceStoragePath = undefined;
                }
            }
        }
        return workspaceStoragePath;
    };
    ExtensionHostMain.prototype.start = function () {
        return this.readExtensions();
    };
    ExtensionHostMain.prototype.terminate = function () {
        var _this = this;
        if (this._isTerminating) {
            // we are already shutting down...
            return;
        }
        this._isTerminating = true;
        errors.setUnexpectedErrorHandler(function (err) {
            // TODO: write to log once we have one
        });
        var allPromises = [];
        try {
            var allExtensions = extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions();
            var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
            var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
            allPromises = activatedExtensions.map(function (extensionId) {
                return _this._extensionService.deactivate(extensionId);
            });
        }
        catch (err) {
        }
        var extensionsDeactivated = winjs_base_1.TPromise.join(allPromises).then(function () { return void 0; });
        // Give extensions 1 second to wrap up any async dispose, then exit
        setTimeout(function () {
            winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(4000), extensionsDeactivated]).then(function () { return exit(); }, function () { return exit(); });
        }, 1000);
    };
    ExtensionHostMain.prototype.readExtensions = function () {
        var _this = this;
        var collector = new extensionPoints_1.MessagesCollector();
        return ExtensionHostMain.scanExtensions(collector, BUILTIN_EXTENSIONS_PATH, !this._environment.disableExtensions ? this._environment.userExtensionsHome : void 0, !this._environment.disableExtensions ? this._environment.extensionDevelopmentPath : void 0, package_1.default.version)
            .then(null, function (err) {
            collector.error('', err);
            return [];
        })
            .then(function (extensions) {
            // Register & Signal done
            extensionsRegistry_1.ExtensionsRegistry.registerExtensions(extensions);
            _this._extensionService.registrationDone(collector.getMessages());
        })
            .then(function () { return _this.handleEagerExtensions(); })
            .then(function () { return _this.handleExtensionTests(); });
    };
    ExtensionHostMain.scanExtensions = function (collector, builtinExtensionsPath, userInstallPath, extensionDevelopmentPath, version) {
        var builtinExtensions = extensionPoints_1.ExtensionScanner.scanExtensions(version, collector, builtinExtensionsPath, true);
        var userExtensions = !userInstallPath ? winjs_base_1.TPromise.as([]) : extensionPoints_1.ExtensionScanner.scanExtensions(version, collector, userInstallPath, false);
        var developedExtensions = !extensionDevelopmentPath ? winjs_base_1.TPromise.as([]) : extensionPoints_1.ExtensionScanner.scanOneOrMultipleExtensions(version, collector, extensionDevelopmentPath, false);
        return winjs_base_1.TPromise.join([builtinExtensions, userExtensions, developedExtensions]).then(function (_) {
            var builtinExtensions = _[0];
            var userExtensions = _[1];
            var developedExtensions = _[2];
            var result = {};
            builtinExtensions.forEach(function (builtinExtension) {
                result[builtinExtension.id] = builtinExtension;
            });
            userExtensions.forEach(function (userExtension) {
                if (result.hasOwnProperty(userExtension.id)) {
                    collector.warn(userExtension.extensionFolderPath, nls.localize('overwritingExtension', "Overwriting extension {0} with {1}.", result[userExtension.id].extensionFolderPath, userExtension.extensionFolderPath));
                }
                result[userExtension.id] = userExtension;
            });
            developedExtensions.forEach(function (developedExtension) {
                collector.info('', nls.localize('extensionUnderDevelopment', "Loading development extension at {0}", developedExtension.extensionFolderPath));
                if (result.hasOwnProperty(developedExtension.id)) {
                    collector.warn(developedExtension.extensionFolderPath, nls.localize('overwritingExtension', "Overwriting extension {0} with {1}.", result[developedExtension.id].extensionFolderPath, developedExtension.extensionFolderPath));
                }
                result[developedExtension.id] = developedExtension;
            });
            return Object.keys(result).map(function (name) { return result[name]; });
        });
    };
    // Handle "eager" activation extensions
    ExtensionHostMain.prototype.handleEagerExtensions = function () {
        this._extensionService.activateByEvent('*').then(null, function (err) {
            console.error(err);
        });
        return this.handleWorkspaceContainsEagerExtensions();
    };
    ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
        var _this = this;
        var workspace = this._contextService.getWorkspace();
        if (!workspace || !workspace.resource) {
            return winjs_base_1.TPromise.as(null);
        }
        var folderPath = workspace.resource.fsPath;
        var desiredFilesMap = {};
        extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions().forEach(function (desc) {
            var activationEvents = desc.activationEvents;
            if (!activationEvents) {
                return;
            }
            for (var i = 0; i < activationEvents.length; i++) {
                if (/^workspaceContains:/.test(activationEvents[i])) {
                    var fileName = activationEvents[i].substr('workspaceContains:'.length);
                    desiredFilesMap[fileName] = true;
                }
            }
        });
        return winjs_base_1.TPromise.join(Object.keys(desiredFilesMap).map(function (fileName) { return pfs.existsWithResult(paths.join(folderPath, fileName), fileName); })).then(function (fileNames) {
            fileNames.forEach(function (existingFileName) {
                if (!existingFileName) {
                    return;
                }
                var activationEvent = 'workspaceContains:' + existingFileName;
                _this._extensionService.activateByEvent(activationEvent).then(null, function (err) {
                    console.error(err);
                });
            });
        });
    };
    ExtensionHostMain.prototype.handleExtensionTests = function () {
        var _this = this;
        if (!this._environment.extensionTestsPath || !this._environment.extensionDevelopmentPath) {
            return winjs_base_1.TPromise.as(null);
        }
        // Require the test runner via node require from the provided path
        var testRunner;
        var requireError;
        try {
            testRunner = require.__$__nodeRequire(this._environment.extensionTestsPath);
        }
        catch (error) {
            requireError = error;
        }
        // Execute the runner if it follows our spec
        if (testRunner && typeof testRunner.run === 'function') {
            return new winjs_base_1.TPromise(function (c, e) {
                testRunner.run(_this._environment.extensionTestsPath, function (error, failures) {
                    if (error) {
                        e(error.toString());
                    }
                    else {
                        c(null);
                    }
                    // after tests have run, we shutdown the host
                    _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                });
            });
        }
        else {
            this.gracefulExit(1 /* ERROR */);
        }
        return winjs_base_1.TPromise.wrapError(requireError ? requireError.toString() : nls.localize('extensionTestError', "Path {0} does not point to a valid extension test runner.", this._environment.extensionTestsPath));
    };
    ExtensionHostMain.prototype.gracefulExit = function (code) {
        // to give the PH process a chance to flush any outstanding console
        // messages to the main process, we delay the exit() by some time
        setTimeout(function () { return exit(code); }, 500);
    };
    return ExtensionHostMain;
}());
exports.ExtensionHostMain = ExtensionHostMain;
