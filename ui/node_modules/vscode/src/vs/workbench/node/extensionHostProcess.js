/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require("vs/base/common/errors");
var winjs_base_1 = require("vs/base/common/winjs.base");
var extensionHostMain_1 = require("vs/workbench/node/extensionHostMain");
var ipcRemoteCom_1 = require("vs/platform/extensions/common/ipcRemoteCom");
var marshalling = require("vs/base/common/marshalling");
var processes_1 = require("vs/base/node/processes");
/**
 * Flag set when in shutdown phase to avoid communicating to the main process.
 */
var isTerminating = false;
// This calls exit directly in case the initialization is not finished and we need to exit
// Otherwise, if initialization completed we go to extensionHostMain.terminate()
var onTerminate = function () {
    extensionHostMain_1.exit();
};
// Utility to not flood the process.send() with messages if it is busy catching up
var queuedSender = processes_1.createQueuedSender(process);
function connectToRenderer() {
    return new winjs_base_1.TPromise(function (c, e) {
        var stats = [];
        // Listen init data message
        process.once('message', function (raw) {
            var msg = marshalling.parse(raw);
            var remoteCom = ipcRemoteCom_1.create(function (data) {
                // Needed to avoid EPIPE errors in process.send below when a channel is closed
                if (isTerminating === true) {
                    return;
                }
                queuedSender.send(data);
                stats.push(data.length);
            });
            // Listen to all other messages
            process.on('message', function (msg) {
                if (msg.type === '__$terminate') {
                    isTerminating = true;
                    onTerminate();
                    return;
                }
                remoteCom.handle(msg);
            });
            // Print a console message when rejection isn't handled within N seconds. For details:
            // see https://nodejs.org/api/process.html#process_event_unhandledrejection
            // and https://nodejs.org/api/process.html#process_event_rejectionhandled
            var unhandledPromises = [];
            process.on('unhandledRejection', function (reason, promise) {
                unhandledPromises.push(promise);
                setTimeout(function () {
                    var idx = unhandledPromises.indexOf(promise);
                    if (idx >= 0) {
                        unhandledPromises.splice(idx, 1);
                        console.warn('rejected promise not handled within 1 second');
                        errors_1.onUnexpectedError(reason);
                    }
                }, 1000);
            });
            process.on('rejectionHandled', function (promise) {
                var idx = unhandledPromises.indexOf(promise);
                if (idx >= 0) {
                    unhandledPromises.splice(idx, 1);
                }
            });
            // Print a console message when an exception isn't handled.
            process.on('uncaughtException', function (err) {
                errors_1.onUnexpectedError(err);
            });
            // Kill oneself if one's parent dies. Much drama.
            setInterval(function () {
                try {
                    process.kill(msg.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
                }
                catch (e) {
                    onTerminate();
                }
            }, 5000);
            // Check stats
            setInterval(function () {
                if (stats.length >= 250) {
                    var total = stats.reduce(function (prev, current) { return prev + current; }, 0);
                    console.warn("MANY messages are being SEND FROM the extension host!");
                    console.warn("SEND during 1sec: message_count=" + stats.length + ", total_len=" + total);
                }
                stats.length = 0;
            }, 1000);
            // Send heartbeat
            setInterval(function () {
                queuedSender.send('__$heartbeat');
            }, 250);
            // Tell the outside that we are initialized
            queuedSender.send('initialized');
            c({ remoteCom: remoteCom, initData: msg });
        });
        // Tell the outside that we are ready to receive messages
        queuedSender.send('ready');
    });
}
connectToRenderer().then(function (renderer) {
    var extensionHostMain = new extensionHostMain_1.ExtensionHostMain(renderer.remoteCom, renderer.initData);
    onTerminate = function () { return extensionHostMain.terminate(); };
    return extensionHostMain.start();
}).done(null, function (err) { return console.error(err); });
