/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var platform = require('vs/base/common/platform');
var winjs_base_1 = require('vs/base/common/winjs.base');
var pfs_1 = require('vs/base/node/pfs');
var DOM = require('vs/base/browser/dom');
var DND = require('vs/base/browser/dnd');
var builder_1 = require('vs/base/browser/builder');
var partService_1 = require('vs/workbench/services/part/common/partService');
var editor_1 = require('vs/workbench/common/editor');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var electron_1 = require('electron');
var dialog = electron_1.remote.dialog;
var ElectronWindow = (function () {
    function ElectronWindow(win, shellContainer, editorService, editorGroupService, partService) {
        this.editorService = editorService;
        this.editorGroupService = editorGroupService;
        this.partService = partService;
        this.win = win;
        this.windowId = win.id;
        this.registerListeners();
    }
    ElectronWindow.prototype.registerListeners = function () {
        var _this = this;
        // React to editor input changes (Mac only)
        if (platform.platform === platform.Platform.Mac) {
            this.editorGroupService.onEditorsChanged(function () {
                var fileInput = editor_1.asFileEditorInput(_this.editorService.getActiveEditorInput(), true);
                var representedFilename = '';
                if (fileInput) {
                    representedFilename = fileInput.getResource().fsPath;
                }
                electron_1.ipcRenderer.send('vscode:setRepresentedFilename', _this.windowId, representedFilename);
            });
        }
        var draggedExternalResources;
        var dropOverlay;
        function cleanUp() {
            draggedExternalResources = void 0;
            if (dropOverlay) {
                dropOverlay.destroy();
                dropOverlay = void 0;
            }
        }
        // Detect resources dropped into Code from outside
        window.document.body.addEventListener(DOM.EventType.DRAG_OVER, function (e) {
            DOM.EventHelper.stop(e);
            if (!draggedExternalResources) {
                draggedExternalResources = DND.extractResources(e, true /* external only */);
                // Find out if folders are dragged and show the appropiate feedback then
                _this.includesFolder(draggedExternalResources).done(function (includesFolder) {
                    if (includesFolder) {
                        dropOverlay = builder_1.$(window.document.getElementById(_this.partService.getWorkbenchElementId()))
                            .div({ id: 'monaco-workbench-drop-overlay' })
                            .on(DOM.EventType.DROP, function (e) {
                            DOM.EventHelper.stop(e, true);
                            _this.focus(); // make sure this window has focus so that the open call reaches the right window!
                            electron_1.ipcRenderer.send('vscode:windowOpen', draggedExternalResources.map(function (r) { return r.fsPath; })); // handled from browser process
                            cleanUp();
                        })
                            .on([DOM.EventType.DRAG_LEAVE, DOM.EventType.DRAG_END], function () {
                            cleanUp();
                        }).once(DOM.EventType.MOUSE_OVER, function () {
                            // Under some circumstances we have seen reports where the drop overlay is not being
                            // cleaned up and as such the editor area remains under the overlay so that you cannot
                            // type into the editor anymore. This seems related to using VMs and DND via host and
                            // guest OS, though some users also saw it without VMs.
                            // To protect against this issue we always destroy the overlay as soon as we detect a
                            // mouse event over it. The delay is used to guarantee we are not interfering with the
                            // actual DROP event that can also trigger a mouse over event.
                            // See also: https://github.com/Microsoft/vscode/issues/10970
                            setTimeout(function () {
                                cleanUp();
                            }, 300);
                        });
                    }
                });
            }
        });
        // Clear our map and overlay on any finish of DND outside the overlay
        [DOM.EventType.DROP, DOM.EventType.DRAG_END].forEach(function (event) {
            window.document.body.addEventListener(event, function (e) {
                if (!dropOverlay || e.target !== dropOverlay.getHTMLElement()) {
                    cleanUp(); // only run cleanUp() if we are not over the overlay (because we are being called in capture phase)
                }
            }, true /* use capture because components within may preventDefault() when they accept the drop */);
        });
        // prevent opening a real URL inside the shell
        window.document.body.addEventListener(DOM.EventType.DROP, function (e) {
            DOM.EventHelper.stop(e);
        });
        // Handle window.open() calls
        window.open = function (url, target, features, replace) {
            electron_1.shell.openExternal(url);
            return null;
        };
        // Patch focus to also focus the entire window
        var originalFocus = window.focus;
        var $this = this;
        window.focus = function () {
            originalFocus.call(this, arguments);
            $this.focus();
        };
    };
    ElectronWindow.prototype.includesFolder = function (resources) {
        return winjs_base_1.TPromise.join(resources.map(function (resource) {
            return pfs_1.stat(resource.fsPath).then(function (stats) { return stats.isDirectory() ? true : false; }, function (error) { return false; });
        })).then(function (res) { return res.some(function (res) { return !!res; }); });
    };
    ElectronWindow.prototype.openNew = function () {
        electron_1.ipcRenderer.send('vscode:openNewWindow'); // handled from browser process
    };
    ElectronWindow.prototype.close = function () {
        this.win.close();
    };
    ElectronWindow.prototype.reload = function () {
        electron_1.ipcRenderer.send('vscode:reloadWindow', this.windowId);
    };
    ElectronWindow.prototype.showMessageBox = function (options) {
        return dialog.showMessageBox(this.win, options);
    };
    ElectronWindow.prototype.showSaveDialog = function (options, callback) {
        if (callback) {
            return dialog.showSaveDialog(this.win, options, callback);
        }
        return dialog.showSaveDialog(this.win, options); // https://github.com/electron/electron/issues/4936
    };
    ElectronWindow.prototype.setFullScreen = function (fullscreen) {
        electron_1.ipcRenderer.send('vscode:setFullScreen', this.windowId, fullscreen); // handled from browser process
    };
    ElectronWindow.prototype.openDevTools = function () {
        electron_1.ipcRenderer.send('vscode:openDevTools', this.windowId); // handled from browser process
    };
    ElectronWindow.prototype.setMenuBarVisibility = function (visible) {
        electron_1.ipcRenderer.send('vscode:setMenuBarVisibility', this.windowId, visible); // handled from browser process
    };
    ElectronWindow.prototype.focus = function () {
        electron_1.ipcRenderer.send('vscode:focusWindow', this.windowId); // handled from browser process
    };
    ElectronWindow.prototype.flashFrame = function () {
        electron_1.ipcRenderer.send('vscode:flashFrame', this.windowId); // handled from browser process
    };
    ElectronWindow = __decorate([
        __param(2, editorService_1.IWorkbenchEditorService),
        __param(3, groupService_1.IEditorGroupService),
        __param(4, partService_1.IPartService)
    ], ElectronWindow);
    return ElectronWindow;
}());
exports.ElectronWindow = ElectronWindow;
