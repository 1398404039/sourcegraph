/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var platform = require("vs/base/common/platform");
var winjs_base_1 = require("vs/base/common/winjs.base");
var pfs_1 = require("vs/base/node/pfs");
var DOM = require("vs/base/browser/dom");
var dnd_1 = require("vs/base/browser/dnd");
var builder_1 = require("vs/base/browser/builder");
var partService_1 = require("vs/workbench/services/part/common/partService");
var editor_1 = require("vs/workbench/common/editor");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var windows_1 = require("vs/platform/windows/common/windows");
var titleService_1 = require("vs/workbench/services/title/common/titleService");
var electron_1 = require("electron");
var dialog = electron_1.remote.dialog;
var ElectronWindow = (function () {
    function ElectronWindow(win, shellContainer, editorService, editorGroupService, partService, windowsService, windowService, titleService) {
        this.editorService = editorService;
        this.editorGroupService = editorGroupService;
        this.partService = partService;
        this.windowsService = windowsService;
        this.windowService = windowService;
        this.titleService = titleService;
        this.win = win;
        this.windowId = win.id;
        this.registerListeners();
    }
    ElectronWindow.prototype.registerListeners = function () {
        var _this = this;
        // React to editor input changes (Mac only)
        if (platform.platform === platform.Platform.Mac) {
            this.editorGroupService.onEditorsChanged(function () {
                var fileInput = editor_1.asFileEditorInput(_this.editorService.getActiveEditorInput(), true);
                var fileName = fileInput ? fileInput.getResource().fsPath : '';
                _this.titleService.setRepresentedFilename(fileName);
            });
        }
        var draggedExternalResources;
        var dropOverlay;
        function cleanUp() {
            draggedExternalResources = void 0;
            if (dropOverlay) {
                dropOverlay.destroy();
                dropOverlay = void 0;
            }
        }
        // Detect resources dropped into Code from outside
        window.document.body.addEventListener(DOM.EventType.DRAG_OVER, function (e) {
            DOM.EventHelper.stop(e);
            if (!draggedExternalResources) {
                draggedExternalResources = dnd_1.extractResources(e, true /* external only */).map(function (d) { return d.resource; });
                // Find out if folders are dragged and show the appropiate feedback then
                _this.includesFolder(draggedExternalResources).done(function (includesFolder) {
                    if (includesFolder) {
                        dropOverlay = builder_1.$(window.document.getElementById(_this.partService.getWorkbenchElementId()))
                            .div({ id: 'monaco-workbench-drop-overlay' })
                            .on(DOM.EventType.DROP, function (e) {
                            DOM.EventHelper.stop(e, true);
                            _this.focus(); // make sure this window has focus so that the open call reaches the right window!
                            _this.windowsService.windowOpen(draggedExternalResources.map(function (r) { return r.fsPath; }));
                            cleanUp();
                        })
                            .on([DOM.EventType.DRAG_LEAVE, DOM.EventType.DRAG_END], function () {
                            cleanUp();
                        }).once(DOM.EventType.MOUSE_OVER, function () {
                            // Under some circumstances we have seen reports where the drop overlay is not being
                            // cleaned up and as such the editor area remains under the overlay so that you cannot
                            // type into the editor anymore. This seems related to using VMs and DND via host and
                            // guest OS, though some users also saw it without VMs.
                            // To protect against this issue we always destroy the overlay as soon as we detect a
                            // mouse event over it. The delay is used to guarantee we are not interfering with the
                            // actual DROP event that can also trigger a mouse over event.
                            // See also: https://github.com/Microsoft/vscode/issues/10970
                            setTimeout(function () {
                                cleanUp();
                            }, 300);
                        });
                    }
                });
            }
        });
        // Clear our map and overlay on any finish of DND outside the overlay
        [DOM.EventType.DROP, DOM.EventType.DRAG_END].forEach(function (event) {
            window.document.body.addEventListener(event, function (e) {
                if (!dropOverlay || e.target !== dropOverlay.getHTMLElement()) {
                    cleanUp(); // only run cleanUp() if we are not over the overlay (because we are being called in capture phase)
                }
            }, true /* use capture because components within may preventDefault() when they accept the drop */);
        });
        // prevent opening a real URL inside the shell
        window.document.body.addEventListener(DOM.EventType.DROP, function (e) {
            DOM.EventHelper.stop(e);
        });
        // Handle window.open() calls
        var $this = this;
        window.open = function (url, target, features, replace) {
            $this.windowsService.openExternal(url);
            return null;
        };
    };
    ElectronWindow.prototype.includesFolder = function (resources) {
        return winjs_base_1.TPromise.join(resources.map(function (resource) {
            return pfs_1.stat(resource.fsPath).then(function (stats) { return stats.isDirectory() ? true : false; }, function (error) { return false; });
        })).then(function (res) { return res.some(function (res) { return !!res; }); });
    };
    ElectronWindow.prototype.close = function () {
        this.win.close();
    };
    ElectronWindow.prototype.showMessageBox = function (options) {
        return dialog.showMessageBox(this.win, options);
    };
    ElectronWindow.prototype.showSaveDialog = function (options, callback) {
        if (callback) {
            return dialog.showSaveDialog(this.win, options, callback);
        }
        return dialog.showSaveDialog(this.win, options); // https://github.com/electron/electron/issues/4936
    };
    ElectronWindow.prototype.focus = function () {
        return this.windowService.focusWindow();
    };
    return ElectronWindow;
}());
ElectronWindow = __decorate([
    __param(2, editorService_1.IWorkbenchEditorService),
    __param(3, groupService_1.IEditorGroupService),
    __param(4, partService_1.IPartService),
    __param(5, windows_1.IWindowsService),
    __param(6, windows_1.IWindowService),
    __param(7, titleService_1.ITitleService)
], ElectronWindow);
exports.ElectronWindow = ElectronWindow;
