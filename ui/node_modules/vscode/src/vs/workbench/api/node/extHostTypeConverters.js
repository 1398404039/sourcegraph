/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var severity_1 = require('vs/base/common/severity');
var arrays_1 = require('vs/base/common/arrays');
var diff_1 = require('vs/base/common/diff/diff');
var types = require('./extHostTypes');
var editor_1 = require('vs/platform/editor/common/editor');
var uri_1 = require('vs/base/common/uri');
var textfiles_1 = require('vs/workbench/services/textfile/common/textfiles');
function toSelection(selection) {
    var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
    var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
    var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
    return new types.Selection(start, end);
}
exports.toSelection = toSelection;
function fromSelection(selection) {
    var anchor = selection.anchor, active = selection.active;
    return {
        selectionStartLineNumber: anchor.line + 1,
        selectionStartColumn: anchor.character + 1,
        positionLineNumber: active.line + 1,
        positionColumn: active.character + 1
    };
}
exports.fromSelection = fromSelection;
function fromRange(range) {
    var start = range.start, end = range.end;
    return {
        startLineNumber: start.line + 1,
        startColumn: start.character + 1,
        endLineNumber: end.line + 1,
        endColumn: end.character + 1
    };
}
exports.fromRange = fromRange;
function toRange(range) {
    var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
    return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
}
exports.toRange = toRange;
function toPosition(position) {
    return new types.Position(position.lineNumber - 1, position.column - 1);
}
exports.toPosition = toPosition;
function fromPosition(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
}
exports.fromPosition = fromPosition;
function fromDiagnosticSeverity(value) {
    switch (value) {
        case types.DiagnosticSeverity.Error:
            return severity_1.default.Error;
        case types.DiagnosticSeverity.Warning:
            return severity_1.default.Warning;
        case types.DiagnosticSeverity.Information:
            return severity_1.default.Info;
        case types.DiagnosticSeverity.Hint:
            return severity_1.default.Ignore;
    }
    return severity_1.default.Error;
}
exports.fromDiagnosticSeverity = fromDiagnosticSeverity;
function toDiagnosticSeverty(value) {
    switch (value) {
        case severity_1.default.Info:
            return types.DiagnosticSeverity.Information;
        case severity_1.default.Warning:
            return types.DiagnosticSeverity.Warning;
        case severity_1.default.Error:
            return types.DiagnosticSeverity.Error;
        case severity_1.default.Ignore:
            return types.DiagnosticSeverity.Hint;
    }
    return types.DiagnosticSeverity.Error;
}
exports.toDiagnosticSeverty = toDiagnosticSeverty;
function fromViewColumn(column) {
    var editorColumn = editor_1.Position.LEFT;
    if (typeof column !== 'number') {
    }
    else if (column === types.ViewColumn.Two) {
        editorColumn = editor_1.Position.CENTER;
    }
    else if (column === types.ViewColumn.Three) {
        editorColumn = editor_1.Position.RIGHT;
    }
    return editorColumn;
}
exports.fromViewColumn = fromViewColumn;
function toViewColumn(position) {
    if (typeof position !== 'number') {
        return;
    }
    if (position === editor_1.Position.LEFT) {
        return types.ViewColumn.One;
    }
    else if (position === editor_1.Position.CENTER) {
        return types.ViewColumn.Two;
    }
    else if (position === editor_1.Position.RIGHT) {
        return types.ViewColumn.Three;
    }
}
exports.toViewColumn = toViewColumn;
function isDecorationOptions(something) {
    return (typeof something.range !== 'undefined');
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return ranges.map(function (r) {
            return {
                range: fromRange(r.range),
                hoverMessage: r.hoverMessage,
                renderOptions: r.renderOptions
            };
        });
    }
    else {
        return ranges.map(function (r) {
            return {
                range: fromRange(r)
            };
        });
    }
}
exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
exports.TextEdit = {
    minimalEditOperations: function (edits, document, beforeDocumentVersion) {
        // document has changed in the meantime and we shouldn't do
        // offset math as it's likely to be all wrong
        if (document.version !== beforeDocumentVersion) {
            return edits.map(exports.TextEdit.from);
        }
        var result = [];
        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
            var edit = edits_1[_i];
            var original = document.getText(edit.range);
            var modified = edit.newText;
            var changes = diff_1.stringDiff(original, modified);
            if (changes.length <= 1) {
                result.push(exports.TextEdit.from(edit));
                continue;
            }
            var editOffset = document.offsetAt(edit.range.start);
            for (var j = 0; j < changes.length; j++) {
                var _a = changes[j], originalStart = _a.originalStart, originalLength = _a.originalLength, modifiedStart = _a.modifiedStart, modifiedLength = _a.modifiedLength;
                var start = fromPosition(document.positionAt(editOffset + originalStart));
                var end = fromPosition(document.positionAt(editOffset + originalStart + originalLength));
                result.push({
                    text: modified.substr(modifiedStart, modifiedLength),
                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                });
            }
        }
        return result;
    },
    from: function (edit) {
        return {
            text: edit.newText,
            range: fromRange(edit.range)
        };
    },
    to: function (edit) {
        return new types.TextEdit(toRange(edit.range), edit.text);
    }
};
var SymbolInformation;
(function (SymbolInformation) {
    function fromOutlineEntry(entry) {
        return new types.SymbolInformation(entry.name, entry.kind, toRange(entry.location.range), entry.location.uri, entry.containerName);
    }
    SymbolInformation.fromOutlineEntry = fromOutlineEntry;
    function toOutlineEntry(symbol) {
        return {
            name: symbol.name,
            kind: symbol.kind,
            containerName: symbol.containerName,
            location: {
                uri: symbol.location.uri,
                range: fromRange(symbol.location.range)
            }
        };
    }
    SymbolInformation.toOutlineEntry = toOutlineEntry;
})(SymbolInformation = exports.SymbolInformation || (exports.SymbolInformation = {}));
function fromSymbolInformation(info) {
    return {
        name: info.name,
        type: types.SymbolKind[info.kind || types.SymbolKind.Property].toLowerCase(),
        containerName: info.containerName,
        range: info.location && fromRange(info.location.range),
        resource: info.location && info.location.uri,
    };
}
exports.fromSymbolInformation = fromSymbolInformation;
function toSymbolInformation(bearing) {
    return new types.SymbolInformation(bearing.name, types.SymbolKind[bearing.type.charAt(0).toUpperCase() + bearing.type.substr(1)], bearing.containerName, new types.Location(bearing.resource, toRange(bearing.range)));
}
exports.toSymbolInformation = toSymbolInformation;
exports.location = {
    from: function (value) {
        return {
            range: fromRange(value.range),
            uri: value.uri
        };
    },
    to: function (value) {
        return new types.Location(value.uri, toRange(value.range));
    }
};
function fromHover(hover) {
    return {
        range: fromRange(hover.range),
        contents: hover.contents
    };
}
exports.fromHover = fromHover;
function toHover(info) {
    return new types.Hover(info.contents, toRange(info.range));
}
exports.toHover = toHover;
function toDocumentHighlight(occurrence) {
    return new types.DocumentHighlight(toRange(occurrence.range), occurrence.kind);
}
exports.toDocumentHighlight = toDocumentHighlight;
exports.CompletionItemKind = {
    from: function (kind) {
        switch (kind) {
            case types.CompletionItemKind.Method: return 'method';
            case types.CompletionItemKind.Function: return 'function';
            case types.CompletionItemKind.Constructor: return 'constructor';
            case types.CompletionItemKind.Field: return 'field';
            case types.CompletionItemKind.Variable: return 'variable';
            case types.CompletionItemKind.Class: return 'class';
            case types.CompletionItemKind.Interface: return 'interface';
            case types.CompletionItemKind.Module: return 'module';
            case types.CompletionItemKind.Property: return 'property';
            case types.CompletionItemKind.Unit: return 'unit';
            case types.CompletionItemKind.Value: return 'value';
            case types.CompletionItemKind.Enum: return 'enum';
            case types.CompletionItemKind.Keyword: return 'keyword';
            case types.CompletionItemKind.Snippet: return 'snippet';
            case types.CompletionItemKind.Text: return 'text';
            case types.CompletionItemKind.Color: return 'color';
            case types.CompletionItemKind.File: return 'file';
            case types.CompletionItemKind.Reference: return 'reference';
        }
        return 'property';
    },
    to: function (type) {
        if (!type) {
            return types.CompletionItemKind.Property;
        }
        else {
            return types.CompletionItemKind[type.charAt(0).toUpperCase() + type.substr(1)];
        }
    }
};
exports.Suggest = {
    from: function (item, disposables) {
        var suggestion = {
            label: item.label || '<missing label>',
            insertText: item.insertText || item.label,
            type: exports.CompletionItemKind.from(item.kind),
            detail: item.detail,
            documentation: item.documentation,
            sortText: item.sortText,
            filterText: item.filterText,
            command: Command.from(item.command, disposables),
            additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(exports.TextEdit.from)
        };
        return suggestion;
    },
    to: function (container, position, suggestion) {
        var result = new types.CompletionItem(suggestion.label);
        result.insertText = suggestion.insertText;
        result.kind = exports.CompletionItemKind.to(suggestion.type);
        result.detail = suggestion.detail;
        result.documentation = suggestion.documentation;
        result.sortText = suggestion.sortText;
        result.filterText = suggestion.filterText;
        var overwriteBefore = (typeof suggestion.overwriteBefore === 'number') ? suggestion.overwriteBefore : container.currentWord.length;
        var startPosition = new types.Position(position.line, Math.max(0, position.character - overwriteBefore));
        var endPosition = position;
        if (typeof suggestion.overwriteAfter === 'number') {
            endPosition = new types.Position(position.line, position.character + suggestion.overwriteAfter);
        }
        result.textEdit = types.TextEdit.replace(new types.Range(startPosition, endPosition), suggestion.insertText);
        return result;
    }
};
var SignatureHelp;
(function (SignatureHelp) {
    function from(signatureHelp) {
        return signatureHelp;
    }
    SignatureHelp.from = from;
    function to(hints) {
        return hints;
    }
    SignatureHelp.to = to;
})(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
var DocumentLink;
(function (DocumentLink) {
    function from(link) {
        return {
            range: fromRange(link.range),
            url: link.target && link.target.toString()
        };
    }
    DocumentLink.from = from;
    function to(link) {
        return new types.DocumentLink(toRange(link.range), link.url && uri_1.default.parse(link.url));
    }
    DocumentLink.to = to;
})(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
var Command;
(function (Command) {
    var _delegateId = '_internal_delegate_command';
    var _cache = Object.create(null);
    var _idPool = 1;
    function initialize(commands) {
        return commands.registerCommand(_delegateId, function (id) {
            var command = _cache[id];
            if (!command) {
                // handle already disposed delegations graceful
                return;
            }
            return commands.executeCommand.apply(commands, [command.command].concat(command.arguments));
        });
    }
    Command.initialize = initialize;
    function from(command, disposables) {
        if (!command) {
            return;
        }
        var result = {
            id: command.command,
            title: command.title
        };
        if (!arrays_1.isFalsyOrEmpty(command.arguments)) {
            // redirect to delegate command and store actual command
            var id_1 = "delegate/" + _idPool++ + "/for/" + command.command;
            result.id = _delegateId;
            result.arguments = [id_1];
            _cache[id_1] = command;
            disposables.push({
                dispose: function () {
                    delete _cache[id_1];
                }
            });
        }
        return result;
    }
    Command.from = from;
    function to(command) {
        var result;
        if (command.id === _delegateId) {
            var key = command.arguments[0];
            result = _cache[key];
        }
        if (!result) {
            result = {
                command: command.id,
                title: command.title
            };
        }
        return result;
    }
    Command.to = to;
})(Command = exports.Command || (exports.Command = {}));
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    function to(reason) {
        switch (reason) {
            case textfiles_1.SaveReason.AUTO:
                return types.TextDocumentSaveReason.AfterDelay;
            case textfiles_1.SaveReason.EXPLICIT:
                return types.TextDocumentSaveReason.Manual;
            case textfiles_1.SaveReason.FOCUS_CHANGE:
            case textfiles_1.SaveReason.WINDOW_CHANGE:
                return types.TextDocumentSaveReason.FocusOut;
        }
    }
    TextDocumentSaveReason.to = to;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
