/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var types_1 = require('vs/base/common/types');
var winjs_base_1 = require('vs/base/common/winjs.base');
var extHostTypes = require('vs/workbench/api/node/extHostTypes');
var extHostTypeConverter = require('vs/workbench/api/node/extHostTypeConverters');
var objects_1 = require('vs/base/common/objects');
var extHost_protocol_1 = require('./extHost.protocol');
var ExtHostCommands = (function (_super) {
    __extends(ExtHostCommands, _super);
    function ExtHostCommands(threadService, extHostEditors) {
        _super.call(this);
        this._commands = Object.create(null);
        this._extHostEditors = extHostEditors;
        this._proxy = threadService.get(extHost_protocol_1.MainContext.MainThreadCommands);
    }
    ExtHostCommands.prototype.registerCommand = function (id, callback, thisArg, description) {
        var _this = this;
        if (!id.trim().length) {
            throw new Error('invalid id');
        }
        if (this._commands[id]) {
            throw new Error('command with id already exists');
        }
        this._commands[id] = { callback: callback, thisArg: thisArg, description: description };
        this._proxy.$registerCommand(id);
        return new extHostTypes.Disposable(function () {
            if (delete _this._commands[id]) {
                _this._proxy.$unregisterCommand(id);
            }
        });
    };
    ExtHostCommands.prototype.executeCommand = function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this._commands[id]) {
            // we stay inside the extension host and support
            // to pass any kind of parameters around
            return this.$executeContributedCommand.apply(this, [id].concat(args));
        }
        else {
            // automagically convert some argument types
            args = objects_1.cloneAndChange(args, function (value) {
                if (value instanceof extHostTypes.Position) {
                    return extHostTypeConverter.fromPosition(value);
                }
                if (value instanceof extHostTypes.Range) {
                    return extHostTypeConverter.fromRange(value);
                }
                if (value instanceof extHostTypes.Location) {
                    return extHostTypeConverter.location.from(value);
                }
                if (!Array.isArray(value)) {
                    return value;
                }
            });
            return this._proxy.$executeCommand(id, args);
        }
    };
    ExtHostCommands.prototype.$executeContributedCommand = function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var command = this._commands[id];
        if (!command) {
            return Promise.reject("Contributed command '" + id + "' does not exist.");
        }
        var callback = command.callback, thisArg = command.thisArg, description = command.description;
        if (description) {
            for (var i = 0; i < description.args.length; i++) {
                try {
                    types_1.validateConstraint(args[i], description.args[i].constraint);
                }
                catch (err) {
                    return Promise.reject("Running the contributed command:'" + id + "' failed. Illegal argument '" + description.args[i].name + "' - " + description.args[i].description);
                }
            }
        }
        try {
            var result = callback.apply(thisArg, args);
            return Promise.resolve(result);
        }
        catch (err) {
            // console.log(err);
            // try {
            // 	console.log(toErrorMessage(err));
            // } catch (err) {
            // 	//
            // }
            return Promise.reject("Running the contributed command:'" + id + "' failed.");
        }
    };
    ExtHostCommands.prototype.getCommands = function (filterUnderscoreCommands) {
        if (filterUnderscoreCommands === void 0) { filterUnderscoreCommands = false; }
        return this._proxy.$getCommands().then(function (result) {
            if (filterUnderscoreCommands) {
                result = result.filter(function (command) { return command[0] !== '_'; });
            }
            return result;
        });
    };
    ExtHostCommands.prototype.$getContributedCommandHandlerDescriptions = function () {
        var result = Object.create(null);
        for (var id in this._commands) {
            var description = this._commands[id].description;
            if (description) {
                result[id] = description;
            }
        }
        return winjs_base_1.TPromise.as(result);
    };
    return ExtHostCommands;
}(extHost_protocol_1.ExtHostCommandsShape));
exports.ExtHostCommands = ExtHostCommands;
