/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lifecycle_1 = require('vs/base/common/lifecycle');
var paths = require('vs/base/common/paths');
var severity_1 = require('vs/base/common/severity');
var winjs_base_1 = require('vs/base/common/winjs.base');
var abstractExtensionService_1 = require('vs/platform/extensions/common/abstractExtensionService');
var extensionsRegistry_1 = require('vs/platform/extensions/common/extensionsRegistry');
var extHostStorage_1 = require('vs/workbench/api/node/extHostStorage');
var extHost_protocol_1 = require('./extHost.protocol');
var hasOwnProperty = Object.hasOwnProperty;
var ExtHostExtension = (function (_super) {
    __extends(ExtHostExtension, _super);
    function ExtHostExtension(activationFailed, module, exports, subscriptions) {
        _super.call(this, activationFailed);
        this.module = module;
        this.exports = exports;
        this.subscriptions = subscriptions;
    }
    return ExtHostExtension;
}(abstractExtensionService_1.ActivatedExtension));
exports.ExtHostExtension = ExtHostExtension;
var ExtHostEmptyExtension = (function (_super) {
    __extends(ExtHostEmptyExtension, _super);
    function ExtHostEmptyExtension() {
        _super.call(this, false, { activate: undefined, deactivate: undefined }, undefined, []);
    }
    return ExtHostEmptyExtension;
}(ExtHostExtension));
exports.ExtHostEmptyExtension = ExtHostEmptyExtension;
var ExtensionMemento = (function () {
    function ExtensionMemento(id, global, storage) {
        var _this = this;
        this._id = id;
        this._shared = global;
        this._storage = storage;
        this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(function (value) {
            _this._value = value;
            return _this;
        });
    }
    Object.defineProperty(ExtensionMemento.prototype, "whenReady", {
        get: function () {
            return this._init;
        },
        enumerable: true,
        configurable: true
    });
    ExtensionMemento.prototype.get = function (key, defaultValue) {
        var value = this._value[key];
        if (typeof value === 'undefined') {
            value = defaultValue;
        }
        return value;
    };
    ExtensionMemento.prototype.update = function (key, value) {
        this._value[key] = value;
        return this._storage
            .setValue(this._shared, this._id, this._value)
            .then(function () { return true; });
    };
    return ExtensionMemento;
}());
var ExtHostExtensionService = (function (_super) {
    __extends(ExtHostExtensionService, _super);
    /**
     * This class is constructed manually because it is a service, so it doesn't use any ctor injection
     */
    function ExtHostExtensionService(threadService, telemetryService, args) {
        _super.call(this, false);
        this._threadService = threadService;
        this._storage = new extHostStorage_1.ExtHostStorage(threadService);
        this._proxy = this._threadService.get(extHost_protocol_1.MainContext.MainProcessExtensionService);
        this._telemetryService = telemetryService;
        this._workspaceStoragePath = args.workspaceStoragePath;
    }
    ExtHostExtensionService.prototype.$localShowMessage = function (severity, msg) {
        switch (severity) {
            case severity_1.default.Error:
                console.error(msg);
                break;
            case severity_1.default.Warning:
                console.warn(msg);
                break;
            default:
                console.log(msg);
        }
    };
    ExtHostExtensionService.prototype.get = function (extensionId) {
        if (!hasOwnProperty.call(this._activatedExtensions, extensionId)) {
            throw new Error('Extension `' + extensionId + '` is not known or not activated');
        }
        return this._activatedExtensions[extensionId].exports;
    };
    ExtHostExtensionService.prototype.deactivate = function (extensionId) {
        var extension = this._activatedExtensions[extensionId];
        if (!extension) {
            return;
        }
        // call deactivate if available
        try {
            if (typeof extension.module.deactivate === 'function') {
                extension.module.deactivate();
            }
        }
        catch (err) {
        }
        // clean up subscriptions
        try {
            lifecycle_1.dispose(extension.subscriptions);
        }
        catch (err) {
        }
    };
    ExtHostExtensionService.prototype.registrationDone = function (messages) {
        var _this = this;
        this._proxy.$onExtensionHostReady(extensionsRegistry_1.ExtensionsRegistry.getAllExtensionDescriptions(), messages).then(function () {
            // Wait for the main process to acknowledge its receival of the extensions descriptions
            // before allowing extensions to be activated
            _this._triggerOnReady();
        });
    };
    // -- overwriting AbstractExtensionService
    ExtHostExtensionService.prototype._showMessage = function (severity, msg) {
        this._proxy.$localShowMessage(severity, msg);
        this.$localShowMessage(severity, msg);
    };
    ExtHostExtensionService.prototype._createFailedExtension = function () {
        return new ExtHostExtension(true, { activate: undefined, deactivate: undefined }, undefined, []);
    };
    ExtHostExtensionService.prototype._loadExtensionContext = function (extensionDescription) {
        var globalState = new ExtensionMemento(extensionDescription.id, true, this._storage);
        var workspaceState = new ExtensionMemento(extensionDescription.id, false, this._storage);
        var storagePath = this._workspaceStoragePath ? paths.normalize(paths.join(this._workspaceStoragePath, extensionDescription.id)) : undefined;
        return winjs_base_1.TPromise.join([globalState.whenReady, workspaceState.whenReady]).then(function () {
            return Object.freeze({
                globalState: globalState,
                workspaceState: workspaceState,
                subscriptions: [],
                get extensionPath() { return extensionDescription.extensionFolderPath; },
                storagePath: storagePath,
                asAbsolutePath: function (relativePath) { return paths.normalize(paths.join(extensionDescription.extensionFolderPath, relativePath), true); }
            });
        });
    };
    ExtHostExtensionService.prototype._actualActivateExtension = function (extensionDescription) {
        var _this = this;
        return this._doActualActivateExtension(extensionDescription).then(function (activatedExtension) {
            _this._proxy.$onExtensionActivated(extensionDescription.id);
            return activatedExtension;
        }, function (err) {
            _this._proxy.$onExtensionActivationFailed(extensionDescription.id);
            throw err;
        });
    };
    ExtHostExtensionService.prototype._doActualActivateExtension = function (extensionDescription) {
        var _this = this;
        var event = getTelemetryActivationEvent(extensionDescription);
        this._telemetryService.publicLog('activatePlugin', event);
        if (!extensionDescription.main) {
            // Treat the extension as being empty => NOT AN ERROR CASE
            return winjs_base_1.TPromise.as(new ExtHostEmptyExtension());
        }
        return loadCommonJSModule(extensionDescription.main).then(function (extensionModule) {
            return _this._loadExtensionContext(extensionDescription).then(function (context) {
                return ExtHostExtensionService._callActivate(extensionModule, context);
            });
        });
    };
    ExtHostExtensionService._callActivate = function (extensionModule, context) {
        // Make sure the extension's surface is not undefined
        extensionModule = extensionModule || {
            activate: undefined,
            deactivate: undefined
        };
        return this._callActivateOptional(extensionModule, context).then(function (extensionExports) {
            return new ExtHostExtension(false, extensionModule, extensionExports, context.subscriptions);
        });
    };
    ExtHostExtensionService._callActivateOptional = function (extensionModule, context) {
        if (typeof extensionModule.activate === 'function') {
            try {
                return winjs_base_1.TPromise.as(extensionModule.activate.apply(global, [context]));
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        }
        else {
            // No activate found => the module is the extension's exports
            return winjs_base_1.TPromise.as(extensionModule);
        }
    };
    // -- called by main thread
    ExtHostExtensionService.prototype.$activateExtension = function (extensionDescription) {
        return this._activateExtension(extensionDescription);
    };
    return ExtHostExtensionService;
}(abstractExtensionService_1.AbstractExtensionService));
exports.ExtHostExtensionService = ExtHostExtensionService;
function loadCommonJSModule(modulePath) {
    var r = null;
    try {
        r = require.__$__nodeRequire(modulePath);
    }
    catch (e) {
        return winjs_base_1.TPromise.wrapError(e);
    }
    return winjs_base_1.TPromise.as(r);
}
function getTelemetryActivationEvent(extensionDescription) {
    var event = {
        id: extensionDescription.id,
        name: extensionDescription.name,
        publisherDisplayName: extensionDescription.publisher,
        activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
        isBuiltin: extensionDescription.isBuiltin
    };
    for (var contribution in extensionDescription.contributes) {
        var contributionDetails = extensionDescription.contributes[contribution];
        if (!contributionDetails) {
            continue;
        }
        switch (contribution) {
            case 'debuggers':
                var types = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['type'] : c['type']; }, '');
                event['contribution.debuggers'] = types;
                break;
            case 'grammars':
                var grammers = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['language'] : c['language']; }, '');
                event['contribution.grammars'] = grammers;
                break;
            case 'languages':
                var languages = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['id'] : c['id']; }, '');
                event['contribution.languages'] = languages;
                break;
            case 'tmSnippets':
                var tmSnippets = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['languageId'] : c['languageId']; }, '');
                event['contribution.tmSnippets'] = tmSnippets;
                break;
            default:
                event[("contribution." + contribution)] = true;
        }
    }
    return event;
}
