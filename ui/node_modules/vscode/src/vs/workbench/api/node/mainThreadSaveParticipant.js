/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var async_1 = require('vs/base/common/async');
var codeEditorService_1 = require('vs/editor/common/services/codeEditorService');
var threadService_1 = require('vs/workbench/services/thread/common/threadService');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var range_1 = require('vs/editor/common/core/range');
var selection_1 = require('vs/editor/common/core/selection');
var trimTrailingWhitespaceCommand_1 = require('vs/editor/common/commands/trimTrailingWhitespaceCommand');
var format_1 = require('vs/editor/contrib/format/common/format');
var formatCommand_1 = require('vs/editor/contrib/format/common/formatCommand');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var textFileEditorModel_1 = require('vs/workbench/parts/files/common/editors/textFileEditorModel');
var extHost_protocol_1 = require('./extHost.protocol');
var files_1 = require('vs/workbench/parts/files/common/files');
var TrimWhitespaceParticipant = (function () {
    function TrimWhitespaceParticipant(configurationService, codeEditorService) {
        this.configurationService = configurationService;
        this.codeEditorService = codeEditorService;
        // Nothing
    }
    TrimWhitespaceParticipant.prototype.participate = function (model, env) {
        if (this.configurationService.lookup('files.trimTrailingWhitespace').value) {
            this.doTrimTrailingWhitespace(model.textEditorModel, env.reason === files_1.SaveReason.AUTO);
        }
    };
    TrimWhitespaceParticipant.prototype.doTrimTrailingWhitespace = function (model, isAutoSaved) {
        var prevSelection = [new selection_1.Selection(1, 1, 1, 1)];
        var cursors = [];
        // Find `prevSelection` in any case do ensure a good undo stack when pushing the edit
        // Collect active cursors in `cursors` only if `isAutoSaved` to avoid having the cursors jump
        if (model.isAttachedToEditor()) {
            var allEditors = this.codeEditorService.listCodeEditors();
            for (var i = 0, len = allEditors.length; i < len; i++) {
                var editor = allEditors[i];
                var editorModel = editor.getModel();
                if (!editorModel) {
                    continue; // empty editor
                }
                if (model === editorModel) {
                    prevSelection = editor.getSelections();
                    if (isAutoSaved) {
                        cursors.push.apply(cursors, prevSelection.map(function (s) {
                            return {
                                lineNumber: s.positionLineNumber,
                                column: s.positionColumn
                            };
                        }));
                    }
                }
            }
        }
        var ops = trimTrailingWhitespaceCommand_1.trimTrailingWhitespace(model, cursors);
        if (!ops.length) {
            return; // Nothing to do
        }
        model.pushEditOperations(prevSelection, ops, function (edits) { return prevSelection; });
    };
    TrimWhitespaceParticipant = __decorate([
        __param(0, configuration_1.IConfigurationService),
        __param(1, codeEditorService_1.ICodeEditorService)
    ], TrimWhitespaceParticipant);
    return TrimWhitespaceParticipant;
}());
var FormatOnSaveParticipant = (function () {
    function FormatOnSaveParticipant(_editorService, _configurationService) {
        this._editorService = _editorService;
        this._configurationService = _configurationService;
        // Nothing
    }
    FormatOnSaveParticipant.prototype.participate = function (editorModel, env) {
        var _this = this;
        if (env.reason === files_1.SaveReason.AUTO
            || !this._configurationService.lookup('editor.formatOnSave').value) {
            return;
        }
        var model = editorModel.textEditorModel;
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            setTimeout(resolve, 750);
            format_1.getDocumentRangeFormattingEdits(model, model.getFullModelRange(), { tabSize: tabSize, insertSpaces: insertSpaces }).then(resolve, reject);
        }).then(function (edits) {
            if (edits) {
                var editor = _this._findEditor(model);
                if (editor) {
                    _this._editsWithEditor(editor, edits);
                }
                else {
                    _this._editWithModel(model, edits);
                }
            }
        });
    };
    FormatOnSaveParticipant.prototype._editsWithEditor = function (editor, edits) {
        editor.executeCommand('files.formatOnSave', new formatCommand_1.EditOperationsCommand(edits, editor.getSelection()));
    };
    FormatOnSaveParticipant.prototype._editWithModel = function (model, edits) {
        var range = edits[0].range;
        var initialSelection = new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        model.pushEditOperations([initialSelection], edits.map(FormatOnSaveParticipant._asIdentEdit), function (undoEdits) {
            for (var _i = 0, undoEdits_1 = undoEdits; _i < undoEdits_1.length; _i++) {
                var range_2 = undoEdits_1[_i].range;
                if (range_1.Range.areIntersectingOrTouching(range_2, initialSelection)) {
                    return [new selection_1.Selection(range_2.startLineNumber, range_2.startColumn, range_2.endLineNumber, range_2.endColumn)];
                }
            }
        });
    };
    FormatOnSaveParticipant._asIdentEdit = function (_a) {
        var text = _a.text, range = _a.range;
        return {
            text: text,
            range: range_1.Range.lift(range),
            identifier: undefined,
            forceMoveMarkers: true
        };
    };
    FormatOnSaveParticipant.prototype._findEditor = function (model) {
        if (!model.isAttachedToEditor()) {
            return;
        }
        var candidate;
        for (var _i = 0, _a = this._editorService.listCodeEditors(); _i < _a.length; _i++) {
            var editor = _a[_i];
            if (editor.getModel() === model) {
                if (editor.isFocused()) {
                    return editor;
                }
                else {
                    candidate = editor;
                }
            }
        }
        return candidate;
    };
    FormatOnSaveParticipant = __decorate([
        __param(0, codeEditorService_1.ICodeEditorService),
        __param(1, configuration_1.IConfigurationService)
    ], FormatOnSaveParticipant);
    return FormatOnSaveParticipant;
}());
var ExtHostSaveParticipant = (function () {
    function ExtHostSaveParticipant(threadService) {
        this._proxy = threadService.get(extHost_protocol_1.ExtHostContext.ExtHostDocumentSaveParticipant);
    }
    ExtHostSaveParticipant.prototype.participate = function (editorModel, env) {
        return this._proxy.$participateInSave(editorModel.getResource(), env.reason);
    };
    ExtHostSaveParticipant = __decorate([
        __param(0, threadService_1.IThreadService)
    ], ExtHostSaveParticipant);
    return ExtHostSaveParticipant;
}());
// The save participant can change a model before its saved to support various scenarios like trimming trailing whitespace
var SaveParticipant = (function () {
    function SaveParticipant(instantiationService, threadService) {
        this._saveParticipants = [
            instantiationService.createInstance(TrimWhitespaceParticipant),
            instantiationService.createInstance(FormatOnSaveParticipant),
            instantiationService.createInstance(ExtHostSaveParticipant)
        ];
        // Hook into model
        textFileEditorModel_1.TextFileEditorModel.setSaveParticipant(this);
    }
    SaveParticipant.prototype.participate = function (model, env) {
        var promiseFactory = this._saveParticipants.map(function (p) { return function () {
            return winjs_base_1.TPromise.as(p.participate(model, env)).then(undefined, function (err) {
                // console.error(err);
            });
        }; });
        return async_1.sequence(promiseFactory);
    };
    SaveParticipant = __decorate([
        __param(0, instantiation_1.IInstantiationService),
        __param(1, threadService_1.IThreadService)
    ], SaveParticipant);
    return SaveParticipant;
}());
exports.SaveParticipant = SaveParticipant;
