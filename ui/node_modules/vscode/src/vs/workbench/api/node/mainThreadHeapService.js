/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var threadService_1 = require("vs/workbench/services/thread/common/threadService");
var extHost_protocol_1 = require("./extHost.protocol");
var gc_signals_1 = require("gc-signals");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var extensions_1 = require("vs/platform/instantiation/common/extensions");
exports.IHeapService = instantiation_1.createDecorator('heapService');
var MainThreadHeapService = (function () {
    function MainThreadHeapService(threadService) {
        var _this = this;
        this._activeSignals = new WeakMap();
        this._activeIds = new Set();
        var proxy = threadService.get(extHost_protocol_1.ExtHostContext.ExtHostHeapService);
        this._consumeHandle = setInterval(function () {
            var ids = gc_signals_1.consumeSignals();
            if (ids.length > 0) {
                // local book-keeping
                for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                    var id = ids_1[_i];
                    _this._activeIds.delete(id);
                }
                // send to ext host
                proxy.$onGarbageCollection(ids);
            }
        }, 15 * 1000);
    }
    MainThreadHeapService.prototype.dispose = function () {
        clearInterval(this._consumeHandle);
    };
    MainThreadHeapService.prototype.trackRecursive = function (obj) {
        var _this = this;
        if (winjs_base_1.TPromise.is(obj)) {
            return obj.then(function (result) { return _this.trackRecursive(result); });
        }
        else {
            return this._doTrackRecursive(obj);
        }
    };
    MainThreadHeapService.prototype._doTrackRecursive = function (obj) {
        var stack = [obj];
        while (stack.length > 0) {
            // remove first element
            var obj_1 = stack.shift();
            if (!obj_1 || typeof obj_1 !== 'object') {
                continue;
            }
            for (var key in obj_1) {
                if (!Object.prototype.hasOwnProperty.call(obj_1, key)) {
                    continue;
                }
                var value = obj_1[key];
                // recurse -> object/array
                if (typeof value === 'object') {
                    stack.push(value);
                }
                else if (key === extHost_protocol_1.ObjectIdentifier.name) {
                    // track new $ident-objects
                    if (typeof value === 'number' && !this._activeIds.has(value)) {
                        this._activeIds.add(value);
                        this._activeSignals.set(obj_1, new gc_signals_1.GCSignal(value));
                    }
                }
            }
        }
        return obj;
    };
    return MainThreadHeapService;
}());
MainThreadHeapService = __decorate([
    __param(0, threadService_1.IThreadService)
], MainThreadHeapService);
exports.MainThreadHeapService = MainThreadHeapService;
extensions_1.registerSingleton(exports.IHeapService, MainThreadHeapService);
