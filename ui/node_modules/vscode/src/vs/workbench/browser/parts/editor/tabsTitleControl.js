/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require("./media/tabstitle.css");
var nls = require("vs/nls");
var errors = require("vs/base/common/errors");
var DOM = require("vs/base/browser/dom");
var platform_1 = require("vs/base/common/platform");
var mime_1 = require("vs/base/common/mime");
var editor_1 = require("vs/workbench/common/editor");
var keyboardEvent_1 = require("vs/base/browser/keyboardEvent");
var labels_1 = require("vs/workbench/browser/labels");
var actionbar_1 = require("vs/base/browser/ui/actionbar/actionbar");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var untitledEditorService_1 = require("vs/workbench/services/untitled/common/untitledEditorService");
var message_1 = require("vs/platform/message/common/message");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var actions_1 = require("vs/platform/actions/common/actions");
var windows_1 = require("vs/platform/windows/common/windows");
var titleControl_1 = require("vs/workbench/browser/parts/editor/titleControl");
var quickOpenService_1 = require("vs/workbench/services/quickopen/common/quickOpenService");
var lifecycle_1 = require("vs/base/common/lifecycle");
var scrollableElement_1 = require("vs/base/browser/ui/scrollbar/scrollableElement");
var scrollable_1 = require("vs/base/common/scrollable");
var dnd_1 = require("vs/base/browser/dnd");
var map_1 = require("vs/base/common/map");
var paths = require("vs/base/common/paths");
var TabsTitleControl = (function (_super) {
    __extends(TabsTitleControl, _super);
    function TabsTitleControl(contextMenuService, instantiationService, configurationService, editorService, editorGroupService, untitledEditorService, contextKeyService, keybindingService, telemetryService, messageService, menuService, quickOpenService, windowService) {
        var _this = _super.call(this, contextMenuService, instantiationService, configurationService, editorService, editorGroupService, contextKeyService, keybindingService, telemetryService, messageService, menuService, quickOpenService) || this;
        _this.untitledEditorService = untitledEditorService;
        _this.windowService = windowService;
        _this.tabDisposeables = [];
        _this.tabDisposeables = [];
        _this.editorLabels = [];
        return _this;
    }
    TabsTitleControl.prototype.setContext = function (group) {
        _super.prototype.setContext.call(this, group);
        this.editorActionsToolbar.context = { group: group };
    };
    TabsTitleControl.prototype.create = function (parent) {
        var _this = this;
        _super.prototype.create.call(this, parent);
        this.titleContainer = parent;
        // Tabs Container
        this.tabsContainer = document.createElement('div');
        this.tabsContainer.setAttribute('role', 'tablist');
        DOM.addClass(this.tabsContainer, 'tabs-container');
        // Forward scrolling inside the container to our custom scrollbar
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.SCROLL, function (e) {
            if (DOM.hasClass(_this.tabsContainer, 'scroll')) {
                _this.scrollbar.updateState({
                    scrollLeft: _this.tabsContainer.scrollLeft // during DND the  container gets scrolled so we need to update the custom scrollbar
                });
            }
        }));
        // New file when double clicking on tabs container (but not tabs)
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DBLCLICK, function (e) {
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                DOM.EventHelper.stop(e);
                var group = _this.context;
                if (group) {
                    _this.editorService.openEditor(_this.untitledEditorService.createOrGet(), { pinned: true, index: group.count /* always at the end */ }).done(null, errors.onUnexpectedError); // untitled are always pinned
                }
            }
        }));
        // Custom Scrollbar
        this.scrollbar = new scrollableElement_1.ScrollableElement(this.tabsContainer, {
            horizontal: scrollable_1.ScrollbarVisibility.Auto,
            vertical: scrollable_1.ScrollbarVisibility.Hidden,
            scrollYToX: true,
            useShadows: false,
            canUseTranslate3d: true,
            horizontalScrollbarSize: 3
        });
        this.scrollbar.onScroll(function (e) {
            _this.tabsContainer.scrollLeft = e.scrollLeft;
        });
        this.titleContainer.appendChild(this.scrollbar.getDomNode());
        // Drag over
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_OVER, function (e) {
            DOM.addClass(_this.tabsContainer, 'scroll'); // enable support to scroll while dragging
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                DOM.addClass(_this.tabsContainer, 'dropfeedback');
            }
        }));
        // Drag leave
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_LEAVE, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
        }));
        // Drag end
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_END, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
        }));
        // Drop onto tabs container
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DROP, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                var group = _this.context;
                if (group) {
                    var targetPosition = _this.stacks.positionOfGroup(group);
                    var targetIndex = group.count;
                    _this.onDrop(e, group, targetPosition, targetIndex);
                }
            }
        }));
        // Editor Actions Container
        var editorActionsContainer = document.createElement('div');
        DOM.addClass(editorActionsContainer, 'editor-actions');
        this.titleContainer.appendChild(editorActionsContainer);
        // Editor Actions Toolbar
        this.createEditorActionsToolBar(editorActionsContainer);
    };
    TabsTitleControl.prototype.allowDragging = function (element) {
        return (element.className === 'tabs-container');
    };
    TabsTitleControl.prototype.doUpdate = function () {
        var _this = this;
        if (!this.context) {
            return;
        }
        var group = this.context;
        // Tabs container activity state
        var isActive = this.stacks.isActive(group);
        if (isActive) {
            DOM.addClass(this.titleContainer, 'active');
        }
        else {
            DOM.removeClass(this.titleContainer, 'active');
        }
        // Compute labels and protect against duplicates
        var editorsOfGroup = this.context.getEditors();
        var labels = this.getUniqueTabLabels(editorsOfGroup);
        // Tab label and styles
        editorsOfGroup.forEach(function (editor, index) {
            var tabContainer = _this.tabsContainer.children[index];
            if (tabContainer instanceof HTMLElement) {
                var isPinned = group.isPinned(editor);
                var isActive_1 = group.isActive(editor);
                var isDirty = editor.isDirty();
                var label = labels[index];
                var name_1 = label.name;
                var description = label.hasAmbiguousName && label.description ? label.description : '';
                var verboseDescription = label.verboseDescription || '';
                // Container
                tabContainer.setAttribute('aria-label', "tab, " + name_1);
                tabContainer.title = verboseDescription;
                // Label
                var tabLabel = _this.editorLabels[index];
                tabLabel.setLabel({ name: name_1, description: description, resource: editor_1.getResource(editor) }, { extraClasses: ['tab-label'], italic: !isPinned });
                // Active state
                if (isActive_1) {
                    DOM.addClass(tabContainer, 'active');
                    tabContainer.setAttribute('aria-selected', 'true');
                    _this.activeTab = tabContainer;
                }
                else {
                    DOM.removeClass(tabContainer, 'active');
                    tabContainer.setAttribute('aria-selected', 'false');
                }
                // Dirty State
                if (isDirty) {
                    DOM.addClass(tabContainer, 'dirty');
                }
                else {
                    DOM.removeClass(tabContainer, 'dirty');
                }
            }
        });
        // Update Editor Actions Toolbar
        this.updateEditorActionsToolbar();
        // Ensure the active tab is always revealed
        this.layout();
    };
    TabsTitleControl.prototype.getUniqueTabLabels = function (editors) {
        var labels = [];
        var mapLabelToDuplicates = new map_1.LinkedMap();
        var mapLabelAndDescriptionToDuplicates = new map_1.LinkedMap();
        // Build labels and descriptions for each editor
        editors.forEach(function (editor) {
            var description = editor.getDescription();
            if (description && description.indexOf(paths.nativeSep) >= 0) {
                description = paths.basename(description); // optimize for editors that show paths and build a shorter description to keep tab width small
            }
            var item = {
                editor: editor,
                name: editor.getName(),
                description: description,
                verboseDescription: editor.getDescription(true)
            };
            labels.push(item);
            mapLabelToDuplicates.getOrSet(item.name, []).push(item);
            if (item.description) {
                mapLabelAndDescriptionToDuplicates.getOrSet(item.name + item.description, []).push(item);
            }
        });
        // Mark label duplicates
        var labelDuplicates = mapLabelToDuplicates.values();
        labelDuplicates.forEach(function (duplicates) {
            if (duplicates.length > 1) {
                duplicates.forEach(function (duplicate) {
                    duplicate.hasAmbiguousName = true;
                });
            }
        });
        // React to duplicates for combination of label and description
        var descriptionDuplicates = mapLabelAndDescriptionToDuplicates.values();
        descriptionDuplicates.forEach(function (duplicates) {
            if (duplicates.length > 1) {
                duplicates.forEach(function (duplicate) {
                    duplicate.description = duplicate.editor.getDescription(); // fallback to full description if the short description still has duplicates
                });
            }
        });
        return labels;
    };
    TabsTitleControl.prototype.doRefresh = function () {
        var group = this.context;
        var editor = group && group.activeEditor;
        if (!editor) {
            this.clearTabs();
            this.clearEditorActionsToolbar();
            return; // return early if we are being closed
        }
        // Refresh Tabs
        this.refreshTabs(group);
        // Update Tabs
        this.doUpdate();
    };
    TabsTitleControl.prototype.clearTabs = function () {
        DOM.clearNode(this.tabsContainer);
        this.tabDisposeables = lifecycle_1.dispose(this.tabDisposeables);
        this.editorLabels = lifecycle_1.dispose(this.editorLabels);
    };
    TabsTitleControl.prototype.refreshTabs = function (group) {
        var _this = this;
        // Empty container first
        this.clearTabs();
        var tabContainers = [];
        // Add a tab for each opened editor
        this.context.getEditors().forEach(function (editor) {
            // Tab Container
            var tabContainer = document.createElement('div');
            tabContainer.draggable = true;
            tabContainer.tabIndex = 0;
            tabContainer.setAttribute('role', 'presentation'); // cannot use role "tab" here due to https://github.com/Microsoft/vscode/issues/8659
            DOM.addClass(tabContainer, 'tab monaco-editor-background');
            tabContainers.push(tabContainer);
            if (!_this.showTabCloseButton) {
                DOM.addClass(tabContainer, 'no-close-button');
            }
            else {
                DOM.removeClass(tabContainer, 'no-close-button');
            }
            // Tab Editor Label
            var editorLabel = _this.instantiationService.createInstance(labels_1.EditorLabel, tabContainer, void 0);
            _this.editorLabels.push(editorLabel);
            // Tab Close
            var tabCloseContainer = document.createElement('div');
            DOM.addClass(tabCloseContainer, 'tab-close');
            tabContainer.appendChild(tabCloseContainer);
            var bar = new actionbar_1.ActionBar(tabCloseContainer, { context: { editor: editor, group: group }, ariaLabel: nls.localize('araLabelTabActions', "Tab actions") });
            bar.push(_this.closeEditorAction, { icon: true, label: false, keybinding: _this.getKeybindingLabel(_this.closeEditorAction) });
            _this.tabDisposeables.push(bar);
            // Eventing
            _this.hookTabListeners(tabContainer, { editor: editor, group: group });
        });
        // Add to tabs container
        tabContainers.forEach(function (tab) { return _this.tabsContainer.appendChild(tab); });
    };
    TabsTitleControl.prototype.layout = function () {
        if (!this.activeTab) {
            return;
        }
        var visibleContainerWidth = this.tabsContainer.offsetWidth;
        var totalContainerWidth = this.tabsContainer.scrollWidth;
        // Update scrollbar
        this.scrollbar.updateState({
            width: visibleContainerWidth,
            scrollWidth: totalContainerWidth
        });
        // Always reveal the active one
        var containerScrollPosX = this.tabsContainer.scrollLeft;
        var activeTabPosX = this.activeTab.offsetLeft;
        var activeTabWidth = this.activeTab.offsetWidth;
        var activeTabFits = activeTabWidth <= visibleContainerWidth;
        // Tab is overflowing to the right: Scroll minimally until the element is fully visible to the right
        // Note: only try to do this if we actually have enough width to give to show the tab fully!
        if (activeTabFits && containerScrollPosX + visibleContainerWidth < activeTabPosX + activeTabWidth) {
            this.scrollbar.updateState({
                scrollLeft: containerScrollPosX + ((activeTabPosX + activeTabWidth) /* right corner of tab */ - (containerScrollPosX + visibleContainerWidth) /* right corner of view port */)
            });
        }
        else if (containerScrollPosX > activeTabPosX || !activeTabFits) {
            this.scrollbar.updateState({
                scrollLeft: this.activeTab.offsetLeft
            });
        }
    };
    TabsTitleControl.prototype.hookTabListeners = function (tab, identifier) {
        var _this = this;
        var editor = identifier.editor, group = identifier.group;
        var position = this.stacks.positionOfGroup(group);
        // Open on Click
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.MOUSE_DOWN, function (e) {
            tab.blur();
            if (e.button === 0 /* Left Button */ && !DOM.findParentWithClass(e.target || e.srcElement, 'monaco-action-bar', 'tab')) {
                setTimeout(function () { return _this.editorService.openEditor(editor, null, position).done(null, errors.onUnexpectedError); }); // timeout to keep focus in editor after mouse up
            }
        }));
        // Close on mouse middle click
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.MOUSE_UP, function (e) {
            DOM.EventHelper.stop(e);
            tab.blur();
            if (e.button === 1 /* Middle Button */) {
                _this.editorService.closeEditor(position, editor).done(null, errors.onUnexpectedError);
            }
        }));
        // Context menu on Shift+F10
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.KEY_DOWN, function (e) {
            var event = new keyboardEvent_1.StandardKeyboardEvent(e);
            if (event.shiftKey && event.keyCode === 68 /* F10 */) {
                DOM.EventHelper.stop(e);
                _this.onContextMenu(identifier, e, tab);
            }
        }));
        // Keyboard accessibility
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.KEY_UP, function (e) {
            var event = new keyboardEvent_1.StandardKeyboardEvent(e);
            var handled = false;
            // Run action on Enter/Space
            if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                handled = true;
                _this.editorService.openEditor(editor, null, position).done(null, errors.onUnexpectedError);
            }
            else if ([15 /* LeftArrow */, 17 /* RightArrow */, 16 /* UpArrow */, 18 /* DownArrow */, 14 /* Home */, 13 /* End */].some(function (kb) { return event.equals(kb); })) {
                var index = group.indexOf(editor);
                var targetIndex = void 0;
                if (event.equals(15 /* LeftArrow */) || event.equals(16 /* UpArrow */)) {
                    targetIndex = index - 1;
                }
                else if (event.equals(17 /* RightArrow */) || event.equals(18 /* DownArrow */)) {
                    targetIndex = index + 1;
                }
                else if (event.equals(14 /* Home */)) {
                    targetIndex = 0;
                }
                else {
                    targetIndex = group.count - 1;
                }
                var target = group.getEditor(targetIndex);
                if (target) {
                    handled = true;
                    _this.editorService.openEditor(target, { preserveFocus: true }, position).done(null, errors.onUnexpectedError);
                    _this.tabsContainer.childNodes[targetIndex].focus();
                }
            }
            if (handled) {
                DOM.EventHelper.stop(e, true);
            }
            // moving in the tabs container can have an impact on scrolling position, so we need to update the custom scrollbar
            _this.scrollbar.updateState({
                scrollLeft: _this.tabsContainer.scrollLeft
            });
        }));
        // Pin on double click
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DBLCLICK, function (e) {
            DOM.EventHelper.stop(e);
            _this.editorGroupService.pinEditor(group, editor);
        }));
        // Context menu
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.CONTEXT_MENU, function (e) { return _this.onContextMenu(identifier, e, tab); }));
        // Drag start
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_START, function (e) {
            _this.onEditorDragStart({ editor: editor, group: group });
            e.dataTransfer.effectAllowed = 'copyMove';
            // Insert transfer accordingly
            var fileInput = editor_1.asFileEditorInput(editor, true);
            if (fileInput) {
                var resource = fileInput.getResource().toString();
                e.dataTransfer.setData('URL', resource); // enables cross window DND of tabs
                e.dataTransfer.setData('DownloadURL', [mime_1.MIME_BINARY, editor.getName(), resource].join(':')); // enables support to drag a tab as file to desktop
            }
        }));
        // We need to keep track of DRAG_ENTER and DRAG_LEAVE events because a tab is not just a div without children,
        // it contains a label and a close button. HTML gives us DRAG_ENTER and DRAG_LEAVE events when hovering over
        // these children and this can cause flicker of the drop feedback. The workaround is to count the events and only
        // remove the drop feedback when the counter is 0 (see https://github.com/Microsoft/vscode/issues/14470)
        var counter = 0;
        // Drag over
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_ENTER, function (e) {
            counter++;
            DOM.addClass(tab, 'dropfeedback');
        }));
        // Drag leave
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_LEAVE, function (e) {
            counter--;
            if (counter === 0) {
                DOM.removeClass(tab, 'dropfeedback');
            }
        }));
        // Drag end
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_END, function (e) {
            counter = 0;
            DOM.removeClass(tab, 'dropfeedback');
            _this.onEditorDragEnd();
        }));
        // Drop
        this.tabDisposeables.push(DOM.addDisposableListener(tab, DOM.EventType.DROP, function (e) {
            counter = 0;
            DOM.removeClass(tab, 'dropfeedback');
            var targetPosition = _this.stacks.positionOfGroup(group);
            var targetIndex = group.indexOf(editor);
            _this.onDrop(e, group, targetPosition, targetIndex);
        }));
    };
    TabsTitleControl.prototype.onDrop = function (e, group, targetPosition, targetIndex) {
        DOM.removeClass(this.tabsContainer, 'dropfeedback');
        DOM.removeClass(this.tabsContainer, 'scroll');
        // Local DND
        var draggedEditor = TabsTitleControl.getDraggedEditor();
        if (draggedEditor) {
            DOM.EventHelper.stop(e, true);
            // Move editor to target position and index
            if (this.isMoveOperation(e, draggedEditor.group, group)) {
                this.editorGroupService.moveEditor(draggedEditor.editor, draggedEditor.group, group, targetIndex);
            }
            else {
                this.editorService.openEditor(draggedEditor.editor, { pinned: true, index: targetIndex }, targetPosition).done(null, errors.onUnexpectedError);
            }
            this.onEditorDragEnd();
        }
        else {
            this.handleExternalDrop(e, targetPosition, targetIndex);
        }
    };
    TabsTitleControl.prototype.handleExternalDrop = function (e, targetPosition, targetIndex) {
        var _this = this;
        var resources = dnd_1.extractResources(e).filter(function (d) { return d.resource.scheme === 'file' || d.resource.scheme === 'untitled'; });
        // Handle resources
        if (resources.length) {
            DOM.EventHelper.stop(e, true);
            // Add external ones to recently open list
            var externalResources = resources.filter(function (d) { return d.isExternal; }).map(function (d) { return d.resource; });
            if (externalResources.length) {
                this.windowService.addToRecentlyOpen(externalResources.map(function (resource) {
                    return {
                        path: resource.fsPath,
                        isFile: true
                    };
                }));
            }
            // Open in Editor
            this.editorService.openEditors(resources.map(function (d) {
                return {
                    input: { resource: d.resource, options: { pinned: true, index: targetIndex } },
                    position: targetPosition
                };
            })).then(function () {
                _this.editorGroupService.focusGroup(targetPosition);
                return _this.windowService.focusWindow();
            }).done(null, errors.onUnexpectedError);
        }
    };
    TabsTitleControl.prototype.isMoveOperation = function (e, source, target) {
        var isCopy = (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
        return !isCopy || source.id === target.id;
    };
    return TabsTitleControl;
}(titleControl_1.TitleControl));
TabsTitleControl = __decorate([
    __param(0, contextView_1.IContextMenuService),
    __param(1, instantiation_1.IInstantiationService),
    __param(2, configuration_1.IConfigurationService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, groupService_1.IEditorGroupService),
    __param(5, untitledEditorService_1.IUntitledEditorService),
    __param(6, contextkey_1.IContextKeyService),
    __param(7, keybinding_1.IKeybindingService),
    __param(8, telemetry_1.ITelemetryService),
    __param(9, message_1.IMessageService),
    __param(10, actions_1.IMenuService),
    __param(11, quickOpenService_1.IQuickOpenService),
    __param(12, windows_1.IWindowService)
], TabsTitleControl);
exports.TabsTitleControl = TabsTitleControl;
