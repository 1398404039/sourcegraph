/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require('./media/sidebyside.css');
var arrays = require('vs/base/common/arrays');
var event_1 = require('vs/base/common/event');
var mouseEvent_1 = require('vs/base/browser/mouseEvent');
var types = require('vs/base/common/types');
var builder_1 = require('vs/base/browser/builder');
var sash_1 = require('vs/base/browser/ui/sash/sash');
var progressbar_1 = require('vs/base/browser/ui/progressbar/progressbar');
var DOM = require('vs/base/browser/dom');
var errors = require('vs/base/common/errors');
var async_1 = require('vs/base/common/async');
var platform_1 = require('vs/base/common/platform');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var editor_1 = require('vs/platform/editor/common/editor');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var textEditor_1 = require('vs/workbench/browser/parts/editor/textEditor');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var serviceCollection_1 = require('vs/platform/instantiation/common/serviceCollection');
var contextkey_1 = require('vs/platform/contextkey/common/contextkey');
var extensions_1 = require('vs/platform/extensions/common/extensions');
var lifecycle_1 = require('vs/base/common/lifecycle');
var tabsTitleControl_1 = require('vs/workbench/browser/parts/editor/tabsTitleControl');
var titleControl_1 = require('vs/workbench/browser/parts/editor/titleControl');
var noTabsTitleControl_1 = require('vs/workbench/browser/parts/editor/noTabsTitleControl');
var editor_2 = require('vs/workbench/common/editor');
var dnd_1 = require('vs/base/browser/dnd');
(function (Rochade) {
    Rochade[Rochade["NONE"] = 0] = "NONE";
    Rochade[Rochade["CENTER_TO_LEFT"] = 1] = "CENTER_TO_LEFT";
    Rochade[Rochade["RIGHT_TO_CENTER"] = 2] = "RIGHT_TO_CENTER";
    Rochade[Rochade["CENTER_AND_RIGHT_TO_LEFT"] = 3] = "CENTER_AND_RIGHT_TO_LEFT";
})(exports.Rochade || (exports.Rochade = {}));
var Rochade = exports.Rochade;
(function (ProgressState) {
    ProgressState[ProgressState["INFINITE"] = 0] = "INFINITE";
    ProgressState[ProgressState["DONE"] = 1] = "DONE";
    ProgressState[ProgressState["STOP"] = 2] = "STOP";
})(exports.ProgressState || (exports.ProgressState = {}));
var ProgressState = exports.ProgressState;
/**
 * Helper class to manage multiple side by side editors for the editor part.
 */
var SideBySideEditorControl = (function () {
    function SideBySideEditorControl(parent, editorService, editorGroupService, telemetryService, configurationService, contextKeyService, extensionService, instantiationService) {
        var _this = this;
        this.editorService = editorService;
        this.editorGroupService = editorGroupService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        this.contextKeyService = contextKeyService;
        this.extensionService = extensionService;
        this.instantiationService = instantiationService;
        this.stacks = editorGroupService.getStacksModel();
        this.toDispose = [];
        this.parent = parent;
        this.dimension = new builder_1.Dimension(0, 0);
        this.silos = [];
        this.siloWidths = [];
        this.visibleEditors = [];
        this.visibleEditorFocusTrackers = [];
        this._onGroupFocusChanged = new event_1.Emitter();
        this.onStacksChangeScheduler = new async_1.RunOnceScheduler(function () { return _this.handleStacksChanged(); }, 0);
        this.toDispose.push(this.onStacksChangeScheduler);
        this.stacksChangedBuffer = [];
        this.create(this.parent);
        this.registerListeners();
    }
    SideBySideEditorControl.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.stacks.onModelChanged(function (e) { return _this.onStacksChanged(e); }));
        this.toDispose.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config); }));
        this.extensionService.onReady().then(function () { return _this.onExtensionsReady(); });
    };
    SideBySideEditorControl.prototype.onConfigurationUpdated = function (config) {
        var _this = this;
        var _a = this.getConfig(), showTabs = _a.showTabs, showIcons = _a.showIcons;
        editor_1.POSITIONS.forEach(function (position) {
            var titleControl = _this.getTitleAreaControl(position);
            // TItle Container
            var titleContainer = builder_1.$(titleControl.getContainer());
            if (showTabs) {
                titleContainer.addClass('tabs');
            }
            else {
                titleContainer.removeClass('tabs');
            }
            var showingIcons = titleContainer.hasClass('show-file-icons');
            if (showIcons) {
                titleContainer.addClass('show-file-icons');
            }
            else {
                titleContainer.removeClass('show-file-icons');
            }
            // Title Control
            if (titleControl) {
                var usingTabs = (titleControl instanceof tabsTitleControl_1.TabsTitleControl);
                // Recreate title when tabs change
                if (usingTabs !== showTabs) {
                    titleControl.dispose();
                    titleContainer.empty();
                    _this.createTitleControl(_this.stacks.groupAt(position), _this.silos[position], titleContainer, _this.getInstantiationService(position));
                }
                else if (showingIcons !== showIcons) {
                    titleControl.refresh(true);
                }
            }
        });
    };
    SideBySideEditorControl.prototype.onExtensionsReady = function () {
        var _this = this;
        // Up to date title areas
        editor_1.POSITIONS.forEach(function (position) { return _this.getTitleAreaControl(position).update(); });
    };
    SideBySideEditorControl.prototype.onStacksChanged = function (e) {
        this.stacksChangedBuffer.push(e);
        this.onStacksChangeScheduler.schedule();
    };
    SideBySideEditorControl.prototype.handleStacksChanged = function () {
        var _this = this;
        // Read and reset buffer of events
        var buffer = this.stacksChangedBuffer;
        this.stacksChangedBuffer = [];
        // Up to date context for all title controls
        editor_1.POSITIONS.forEach(function (position) {
            var titleAreaControl = _this.getTitleAreaControl(position);
            var context = _this.stacks.groupAt(position);
            titleAreaControl.setContext(context);
            if (!context && titleAreaControl.hasContext()) {
                titleAreaControl.refresh(); // clear out the control if the context is no longer present and there was a context
            }
        });
        // Refresh / update if group is visible and has a position
        buffer.forEach(function (e) {
            var position = _this.stacks.positionOfGroup(e.group);
            if (position >= 0) {
                if (e.structural) {
                    _this.getTitleAreaControl(position).refresh();
                }
                else {
                    _this.getTitleAreaControl(position).update();
                }
            }
        });
    };
    Object.defineProperty(SideBySideEditorControl.prototype, "onGroupFocusChanged", {
        get: function () {
            return this._onGroupFocusChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    SideBySideEditorControl.prototype.show = function (editor, position, preserveActive, widthRatios) {
        var visibleEditorCount = this.getVisibleEditorCount();
        // Store into editor bucket
        this.visibleEditors[position] = editor;
        // Store as active unless preserveActive is set
        if (!preserveActive || !this.lastActiveEditor) {
            this.doSetActive(editor, position);
        }
        // Track focus
        this.trackFocus(editor, position);
        // Find target container and build into
        var target = this.silos[position].child();
        editor.getContainer().build(target);
        // Adjust layout according to provided ratios (used when restoring multiple editors at once)
        if (widthRatios && (widthRatios.length === 2 || widthRatios.length === 3)) {
            var hasLayoutInfo = this.dimension && this.dimension.width;
            // We received width ratios but were not layouted yet. So we keep these ratios for when we layout()
            if (!hasLayoutInfo) {
                this.siloInitialRatios = widthRatios;
            }
            // Adjust layout: -> [!][!]
            if (widthRatios.length === 2) {
                if (hasLayoutInfo) {
                    this.siloWidths[position] = this.dimension.width * widthRatios[position];
                }
            }
            else if (widthRatios.length === 3) {
                if (hasLayoutInfo) {
                    this.siloWidths[position] = this.dimension.width * widthRatios[position];
                }
                if (this.rightSash.isHidden()) {
                    this.rightSash.show();
                    this.rightSash.layout();
                }
            }
            if (this.leftSash.isHidden()) {
                this.leftSash.show();
                this.leftSash.layout();
            }
            if (hasLayoutInfo) {
                this.layoutContainers();
            }
        }
        else if (visibleEditorCount === 0 && this.dimension) {
            this.siloWidths[position] = this.dimension.width;
            this.layoutContainers();
        }
        else if (position === editor_1.Position.CENTER && this.leftSash.isHidden() && this.rightSash.isHidden() && this.dimension) {
            this.siloWidths[editor_1.Position.LEFT] = this.dimension.width / 2;
            this.siloWidths[editor_1.Position.CENTER] = this.dimension.width - this.siloWidths[editor_1.Position.LEFT];
            this.leftSash.show();
            this.leftSash.layout();
            this.layoutContainers();
        }
        else if (position === editor_1.Position.RIGHT && this.rightSash.isHidden() && this.dimension) {
            this.siloWidths[editor_1.Position.LEFT] = this.dimension.width / 3;
            this.siloWidths[editor_1.Position.CENTER] = this.dimension.width / 3;
            this.siloWidths[editor_1.Position.RIGHT] = this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - this.siloWidths[editor_1.Position.CENTER];
            this.leftSash.layout();
            this.rightSash.show();
            this.rightSash.layout();
            this.layoutContainers();
        }
        // Show editor container
        editor.getContainer().show();
        // Styles
        this.updateParentStyle();
    };
    SideBySideEditorControl.prototype.getVisibleEditorCount = function () {
        return this.visibleEditors.filter(function (v) { return !!v; }).length;
    };
    SideBySideEditorControl.prototype.trackFocus = function (editor, position) {
        var _this = this;
        // In case there is a previous tracker on the position, dispose it first
        if (this.visibleEditorFocusTrackers[position]) {
            this.visibleEditorFocusTrackers[position].dispose();
        }
        // Track focus on editor container
        this.visibleEditorFocusTrackers[position] = DOM.trackFocus(editor.getContainer().getHTMLElement());
        this.visibleEditorFocusTrackers[position].addFocusListener(function () {
            _this.onFocusGained(editor);
        });
    };
    SideBySideEditorControl.prototype.onFocusGained = function (editor) {
        this.setActive(editor);
    };
    SideBySideEditorControl.prototype.setActive = function (editor) {
        var _this = this;
        // Update active editor and position
        if (this.lastActiveEditor !== editor) {
            this.doSetActive(editor, this.visibleEditors.indexOf(editor));
            // Automatically maximize this position if it has min editor width
            if (this.siloWidths[this.lastActivePosition] === SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                // Log this fact in telemetry
                if (this.telemetryService) {
                    this.telemetryService.publicLog('workbenchEditorMaximized');
                }
                var remainingWidth_1 = this.dimension.width;
                // Minimize all other positions to min width
                editor_1.POSITIONS.forEach(function (p) {
                    if (_this.lastActivePosition !== p && !!_this.visibleEditors[p]) {
                        _this.siloWidths[p] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
                        remainingWidth_1 -= _this.siloWidths[p];
                    }
                });
                // Grow focussed position if there is more width to spend
                if (remainingWidth_1 > SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                    this.siloWidths[this.lastActivePosition] = remainingWidth_1;
                    if (!this.leftSash.isHidden()) {
                        this.leftSash.layout();
                    }
                    if (!this.rightSash.isHidden()) {
                        this.rightSash.layout();
                    }
                    this.layoutContainers();
                }
            }
            // Re-emit to outside
            this._onGroupFocusChanged.fire();
        }
    };
    SideBySideEditorControl.prototype.focusNextNonMinimized = function () {
        var _this = this;
        // If the current focussed editor is minimized, try to focus the next largest editor
        if (!types.isUndefinedOrNull(this.lastActivePosition) && this.siloWidths[this.lastActivePosition] === SideBySideEditorControl.MIN_EDITOR_WIDTH) {
            var candidate_1 = null;
            var currentWidth_1 = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            editor_1.POSITIONS.forEach(function (position) {
                // Skip current active position and check if the editor is larger than min width
                if (position !== _this.lastActivePosition) {
                    if (_this.visibleEditors[position] && _this.siloWidths[position] > currentWidth_1) {
                        candidate_1 = position;
                        currentWidth_1 = _this.siloWidths[position];
                    }
                }
            });
            // Focus editor if a candidate has been found
            if (!types.isUndefinedOrNull(candidate_1)) {
                this.editorGroupService.focusGroup(candidate_1);
            }
        }
    };
    SideBySideEditorControl.prototype.hide = function (editor, position, layoutAndRochade) {
        var result = Rochade.NONE;
        var visibleEditorCount = this.getVisibleEditorCount();
        var hasCenter = !!this.visibleEditors[editor_1.Position.CENTER];
        var hasRight = !!this.visibleEditors[editor_1.Position.RIGHT];
        // If editor is not showing for position, return
        if (editor !== this.visibleEditors[position]) {
            return result;
        }
        // Clear Position
        this.clearPosition(position);
        // Take editor container offdom and hide
        editor.getContainer().offDOM().hide();
        // Adjust layout and rochade if instructed to do so
        if (layoutAndRochade) {
            // Adjust layout: [x] ->
            if (visibleEditorCount === 1) {
                this.siloWidths[position] = 0;
                this.leftSash.hide();
                this.rightSash.hide();
                this.layoutContainers();
            }
            else if (hasCenter && !hasRight) {
                this.siloWidths[editor_1.Position.LEFT] = this.dimension.width;
                this.siloWidths[editor_1.Position.CENTER] = 0;
                this.leftSash.hide();
                this.rightSash.hide();
                // Move CENTER to LEFT ([x]|[] -> [])
                if (position === editor_1.Position.LEFT) {
                    this.rochade(editor_1.Position.CENTER, editor_1.Position.LEFT);
                    result = Rochade.CENTER_TO_LEFT;
                }
                this.layoutContainers();
            }
            else if (hasCenter && hasRight) {
                this.siloWidths[editor_1.Position.LEFT] = this.dimension.width / 2;
                this.siloWidths[editor_1.Position.CENTER] = this.dimension.width - this.siloWidths[editor_1.Position.LEFT];
                this.siloWidths[editor_1.Position.RIGHT] = 0;
                this.leftSash.layout();
                this.rightSash.hide();
                // Move RIGHT to CENTER ([]|[x]|[] -> [ ]|[ ])
                if (position === editor_1.Position.CENTER) {
                    this.rochade(editor_1.Position.RIGHT, editor_1.Position.CENTER);
                    result = Rochade.RIGHT_TO_CENTER;
                }
                else if (position === editor_1.Position.LEFT) {
                    this.rochade(editor_1.Position.CENTER, editor_1.Position.LEFT);
                    this.rochade(editor_1.Position.RIGHT, editor_1.Position.CENTER);
                    result = Rochade.CENTER_AND_RIGHT_TO_LEFT;
                }
                this.layoutContainers();
            }
        }
        // Automatically pick the next editor as active if any
        if (this.lastActiveEditor === editor) {
            // Clear old
            this.doSetActive(null, null);
            // Find new active position by taking the next one close to the closed one to the left
            if (layoutAndRochade) {
                var newActivePosition = void 0;
                switch (position) {
                    case editor_1.Position.LEFT:
                        newActivePosition = hasCenter ? editor_1.Position.LEFT : null;
                        break;
                    case editor_1.Position.CENTER:
                        newActivePosition = editor_1.Position.LEFT;
                        break;
                    case editor_1.Position.RIGHT:
                        newActivePosition = editor_1.Position.CENTER;
                        break;
                }
                if (!types.isUndefinedOrNull(newActivePosition)) {
                    this.doSetActive(this.visibleEditors[newActivePosition], newActivePosition);
                }
            }
        }
        // Styles
        this.updateParentStyle();
        return result;
    };
    SideBySideEditorControl.prototype.updateParentStyle = function () {
        var editorCount = this.getVisibleEditorCount();
        if (editorCount > 1) {
            this.parent.addClass('multiple-editors');
        }
        else {
            this.parent.removeClass('multiple-editors');
        }
    };
    SideBySideEditorControl.prototype.doSetActive = function (editor, newActive) {
        this.lastActivePosition = newActive;
        this.lastActiveEditor = editor;
    };
    SideBySideEditorControl.prototype.clearPosition = function (position) {
        // Unregister Listeners
        if (this.visibleEditorFocusTrackers[position]) {
            this.visibleEditorFocusTrackers[position].dispose();
            this.visibleEditorFocusTrackers[position] = null;
        }
        // Clear from active editors
        this.visibleEditors[position] = null;
    };
    SideBySideEditorControl.prototype.rochade = function (from, to) {
        // Move container to new position
        var containerFrom = this.silos[from].child();
        containerFrom.appendTo(this.silos[to]);
        var containerTo = this.silos[to].child();
        containerTo.appendTo(this.silos[from]);
        // Inform editor
        var editor = this.visibleEditors[from];
        editor.changePosition(to);
        // Change data structures
        var listeners = this.visibleEditorFocusTrackers[from];
        this.visibleEditorFocusTrackers[to] = listeners;
        this.visibleEditorFocusTrackers[from] = null;
        this.visibleEditors[to] = editor;
        this.visibleEditors[from] = null;
        // Update last active position
        if (this.lastActivePosition === from) {
            this.doSetActive(this.lastActiveEditor, to);
        }
    };
    SideBySideEditorControl.prototype.move = function (from, to) {
        // Distance 1: Swap Editors
        if (Math.abs(from - to) === 1) {
            // Move containers to new position
            var containerFrom = this.silos[from].child();
            containerFrom.appendTo(this.silos[to]);
            var containerTo = this.silos[to].child();
            containerTo.appendTo(this.silos[from]);
            // Inform Editors
            this.visibleEditors[from].changePosition(to);
            this.visibleEditors[to].changePosition(from);
            // Update last active position accordingly
            if (this.lastActivePosition === from) {
                this.doSetActive(this.lastActiveEditor, to);
            }
            else if (this.lastActivePosition === to) {
                this.doSetActive(this.lastActiveEditor, from);
            }
        }
        else {
            // Find new positions
            var newLeftPosition = void 0;
            var newCenterPosition = void 0;
            var newRightPosition = void 0;
            if (from === editor_1.Position.LEFT) {
                newLeftPosition = editor_1.Position.RIGHT;
                newCenterPosition = editor_1.Position.LEFT;
                newRightPosition = editor_1.Position.CENTER;
            }
            else {
                newLeftPosition = editor_1.Position.CENTER;
                newCenterPosition = editor_1.Position.RIGHT;
                newRightPosition = editor_1.Position.LEFT;
            }
            // Move containers to new position
            var containerPos1 = this.silos[editor_1.Position.LEFT].child();
            containerPos1.appendTo(this.silos[newLeftPosition]);
            var containerPos2 = this.silos[editor_1.Position.CENTER].child();
            containerPos2.appendTo(this.silos[newCenterPosition]);
            var containerPos3 = this.silos[editor_1.Position.RIGHT].child();
            containerPos3.appendTo(this.silos[newRightPosition]);
            // Inform Editors
            this.visibleEditors[editor_1.Position.LEFT].changePosition(newLeftPosition);
            this.visibleEditors[editor_1.Position.CENTER].changePosition(newCenterPosition);
            this.visibleEditors[editor_1.Position.RIGHT].changePosition(newRightPosition);
            // Update last active position accordingly
            if (this.lastActivePosition === editor_1.Position.LEFT) {
                this.doSetActive(this.lastActiveEditor, newLeftPosition);
            }
            else if (this.lastActivePosition === editor_1.Position.CENTER) {
                this.doSetActive(this.lastActiveEditor, newCenterPosition);
            }
            else if (this.lastActivePosition === editor_1.Position.RIGHT) {
                this.doSetActive(this.lastActiveEditor, newRightPosition);
            }
        }
        // Change data structures
        arrays.move(this.visibleEditors, from, to);
        arrays.move(this.visibleEditorFocusTrackers, from, to);
        arrays.move(this.siloWidths, from, to);
        // Layout
        if (!this.leftSash.isHidden()) {
            this.leftSash.layout();
        }
        if (!this.rightSash.isHidden()) {
            this.rightSash.layout();
        }
        this.layoutContainers();
    };
    SideBySideEditorControl.prototype.arrangeGroups = function (arrangement) {
        var _this = this;
        if (!this.dimension) {
            return; // too early
        }
        var availableWidth = this.dimension.width;
        var visibleEditors = this.getVisibleEditorCount();
        if (visibleEditors <= 1) {
            return; // need more editors
        }
        // Minimize Others
        if (arrangement === groupService_1.GroupArrangement.MINIMIZE_OTHERS) {
            editor_1.POSITIONS.forEach(function (position) {
                if (_this.visibleEditors[position]) {
                    if (position !== _this.lastActivePosition) {
                        _this.siloWidths[position] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
                        availableWidth -= SideBySideEditorControl.MIN_EDITOR_WIDTH;
                    }
                }
            });
            this.siloWidths[this.lastActivePosition] = availableWidth;
        }
        else if (arrangement === groupService_1.GroupArrangement.EVEN_WIDTH) {
            editor_1.POSITIONS.forEach(function (position) {
                if (_this.visibleEditors[position]) {
                    _this.siloWidths[position] = availableWidth / visibleEditors;
                }
            });
        }
        this.layoutControl(this.dimension);
    };
    SideBySideEditorControl.prototype.getWidthRatios = function () {
        var _this = this;
        var ratio = [];
        if (this.dimension) {
            var fullWidth_1 = this.dimension.width;
            editor_1.POSITIONS.forEach(function (position) {
                if (_this.visibleEditors[position]) {
                    ratio.push(_this.siloWidths[position] / fullWidth_1);
                }
            });
        }
        return ratio;
    };
    SideBySideEditorControl.prototype.getActiveEditor = function () {
        return this.lastActiveEditor;
    };
    SideBySideEditorControl.prototype.getActivePosition = function () {
        return this.lastActivePosition;
    };
    SideBySideEditorControl.prototype.create = function (parent) {
        var _this = this;
        // Allow to drop into container to open
        this.enableDropTarget(parent.getHTMLElement());
        // Left Silo
        this.silos[editor_1.Position.LEFT] = builder_1.$(parent).div({ class: 'one-editor-silo editor-left monaco-editor-background' });
        // Left Sash
        this.leftSash = new sash_1.Sash(parent.getHTMLElement(), this, { baseSize: 5 });
        this.toDispose.push(this.leftSash.addListener2('start', function () { return _this.onLeftSashDragStart(); }));
        this.toDispose.push(this.leftSash.addListener2('change', function (e) { return _this.onLeftSashDrag(e); }));
        this.toDispose.push(this.leftSash.addListener2('end', function () { return _this.onLeftSashDragEnd(); }));
        this.toDispose.push(this.leftSash.addListener2('reset', function () { return _this.onLeftSashReset(); }));
        this.leftSash.hide();
        // Center Silo
        this.silos[editor_1.Position.CENTER] = builder_1.$(parent).div({ class: 'one-editor-silo editor-center monaco-editor-background' });
        // Right Sash
        this.rightSash = new sash_1.Sash(parent.getHTMLElement(), this, { baseSize: 5 });
        this.toDispose.push(this.rightSash.addListener2('start', function () { return _this.onRightSashDragStart(); }));
        this.toDispose.push(this.rightSash.addListener2('change', function (e) { return _this.onRightSashDrag(e); }));
        this.toDispose.push(this.rightSash.addListener2('end', function () { return _this.onRightSashDragEnd(); }));
        this.toDispose.push(this.rightSash.addListener2('reset', function () { return _this.onRightSashReset(); }));
        this.rightSash.hide();
        // Right Silo
        this.silos[editor_1.Position.RIGHT] = builder_1.$(parent).div({ class: 'one-editor-silo editor-right monaco-editor-background' });
        // For each position
        var _a = this.getConfig(), showTabs = _a.showTabs, showIcons = _a.showIcons;
        editor_1.POSITIONS.forEach(function (position) {
            var silo = _this.silos[position];
            // Containers (they contain everything and can move between silos)
            var container = builder_1.$(silo).div({ 'class': 'container' });
            // InstantiationServices
            var instantiationService = _this.instantiationService.createChild(new serviceCollection_1.ServiceCollection([contextkey_1.IContextKeyService, _this.contextKeyService.createScoped(container.getHTMLElement())]));
            container.setProperty(SideBySideEditorControl.INSTANTIATION_SERVICE_KEY, instantiationService); // associate with container
            // Title containers
            var titleContainer = builder_1.$(container).div({ 'class': 'title' });
            if (showTabs) {
                titleContainer.addClass('tabs');
            }
            if (showIcons) {
                titleContainer.addClass('show-file-icons');
            }
            _this.hookTitleDragListener(titleContainer);
            // Title Control
            _this.createTitleControl(_this.stacks.groupAt(position), silo, titleContainer, instantiationService);
            // Progress Bar
            var progressBar = new progressbar_1.ProgressBar(builder_1.$(container));
            progressBar.getContainer().hide();
            container.setProperty(SideBySideEditorControl.PROGRESS_BAR_CONTROL_KEY, progressBar); // associate with container
        });
    };
    SideBySideEditorControl.prototype.enableDropTarget = function (node) {
        var _this = this;
        var $this = this;
        var overlayId = 'monaco-workbench-editor-drop-overlay';
        var splitToPropertyKey = 'splitToPosition';
        var stacks = this.editorGroupService.getStacksModel();
        var overlay;
        var draggedResources;
        function cleanUp() {
            draggedResources = void 0;
            if (overlay) {
                overlay.destroy();
                overlay = void 0;
            }
            DOM.removeClass(node, 'dragged-over');
        }
        function optionsFromDraggedEditor(identifier) {
            // When moving an editor, try to preserve as much view state as possible by checking
            // for th editor to be a text editor and creating the options accordingly if so
            var options = editor_2.EditorOptions.create({ pinned: true });
            var activeEditor = $this.editorService.getActiveEditor();
            if (activeEditor instanceof textEditor_1.BaseTextEditor && activeEditor.position === stacks.positionOfGroup(identifier.group) && identifier.editor.matches(activeEditor.input)) {
                options = editor_2.TextEditorOptions.create({ pinned: true });
                options.fromEditor(activeEditor.getControl());
            }
            return options;
        }
        function onDrop(e, position, splitTo) {
            var droppedResources = draggedResources;
            DOM.removeClass(node, 'dropfeedback');
            cleanUp();
            var editorService = $this.editorService;
            var groupService = $this.editorGroupService;
            var splitEditor = (typeof splitTo === 'number'); // TODO@Ben ugly split code should benefit from empty group support once available!
            var freeGroup = (stacks.groups.length === 1) ? editor_1.Position.CENTER : editor_1.Position.RIGHT;
            // Check for transfer from title control
            var draggedEditor = titleControl_1.TitleControl.getDraggedEditor();
            if (draggedEditor) {
                var isCopy = (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
                // Copy editor to new location
                if (isCopy) {
                    if (splitEditor) {
                        editorService.openEditor(draggedEditor.editor, optionsFromDraggedEditor(draggedEditor), freeGroup).then(function () {
                            if (splitTo !== freeGroup) {
                                groupService.moveGroup(freeGroup, splitTo);
                            }
                        }).done(null, errors.onUnexpectedError);
                    }
                    else {
                        editorService.openEditor(draggedEditor.editor, optionsFromDraggedEditor(draggedEditor), position).done(null, errors.onUnexpectedError);
                    }
                }
                else {
                    var sourcePosition = stacks.positionOfGroup(draggedEditor.group);
                    if (splitEditor) {
                        if (draggedEditor.group.count === 1) {
                            groupService.moveGroup(sourcePosition, splitTo);
                        }
                        else {
                            editorService.openEditor(draggedEditor.editor, optionsFromDraggedEditor(draggedEditor), freeGroup).then(function () {
                                if (splitTo !== freeGroup) {
                                    groupService.moveGroup(freeGroup, splitTo);
                                }
                                groupService.moveEditor(draggedEditor.editor, stacks.positionOfGroup(draggedEditor.group), splitTo);
                            }).done(null, errors.onUnexpectedError);
                        }
                    }
                    else {
                        groupService.moveEditor(draggedEditor.editor, sourcePosition, position);
                    }
                }
            }
            else {
                if (droppedResources.length) {
                    window.focus(); // make sure this window has focus so that the open call reaches the right window!
                    // Open all
                    editorService.openEditors(droppedResources.map(function (resource) { return { input: { resource: resource, options: { pinned: true } }, position: splitEditor ? freeGroup : position }; }))
                        .then(function () {
                        if (splitEditor && splitTo !== freeGroup) {
                            groupService.moveGroup(freeGroup, splitTo);
                        }
                        groupService.focusGroup(splitEditor ? splitTo : position);
                    })
                        .done(null, errors.onUnexpectedError);
                }
            }
        }
        function positionOverlay(e, groups, position) {
            var target = e.target;
            var posXOnOverlay = e.offsetX;
            var overlayIsSplit = typeof overlay.getProperty(splitToPropertyKey) === 'number';
            var overlayWidth = target.clientWidth;
            var splitThreshold = overlayIsSplit ? overlayWidth / 5 : overlayWidth / 10;
            var isCopy = (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
            var draggedEditor = titleControl_1.TitleControl.getDraggedEditor();
            var isOverSplitLeft = posXOnOverlay < splitThreshold;
            var isOverSplitRight = posXOnOverlay + splitThreshold > overlayWidth;
            var splitTarget;
            // No splitting if we reached maximum group count
            if (groups === editor_1.POSITIONS.length) {
                splitTarget = null;
            }
            else if (!isCopy && draggedEditor && draggedEditor.group.count === 1) {
                var positionOfDraggedEditor = stacks.positionOfGroup(draggedEditor.group);
                switch (positionOfDraggedEditor) {
                    case editor_1.Position.LEFT:
                        if (position === editor_1.Position.CENTER && isOverSplitRight) {
                            splitTarget = editor_1.Position.CENTER; // allow to move single editor from LEFT to CENTER
                        }
                        break;
                    case editor_1.Position.CENTER:
                        if (position === editor_1.Position.LEFT && isOverSplitLeft) {
                            splitTarget = editor_1.Position.LEFT; // allow to move single editor from CENTER to LEFT
                        }
                        break;
                    default:
                        splitTarget = null; // splitting not allowed
                }
            }
            else {
                if (isOverSplitRight) {
                    splitTarget = (position === editor_1.Position.LEFT) ? editor_1.Position.CENTER : editor_1.Position.RIGHT;
                }
                else if (isOverSplitLeft) {
                    splitTarget = (position === editor_1.Position.LEFT) ? editor_1.Position.LEFT : editor_1.Position.CENTER;
                }
            }
            // Apply split target
            var canSplit = (typeof splitTarget === 'number');
            if (canSplit) {
                overlay.setProperty(splitToPropertyKey, splitTarget);
            }
            else {
                overlay.removeProperty(splitToPropertyKey);
            }
            // Update overlay styles
            if (canSplit && isOverSplitRight) {
                overlay.style({
                    left: '50%',
                    width: '50%',
                });
            }
            else if (canSplit && isOverSplitLeft) {
                overlay.style({
                    width: '50%'
                });
            }
            else {
                overlay.style({
                    left: '0',
                    width: '100%'
                });
            }
            // Make sure the overlay is visible
            overlay.style({ opacity: 1 });
            // Indicate a drag over is happening
            DOM.addClass(node, 'dragged-over');
        }
        function createOverlay(target) {
            if (!overlay) {
                var showTabs_1 = $this.getConfig().showTabs;
                var containers_1 = $this.visibleEditors.filter(function (e) { return !!e; }).map(function (e) { return e.getContainer(); });
                containers_1.forEach(function (container, index) {
                    if (container && DOM.isAncestor(target, container.getHTMLElement())) {
                        overlay = builder_1.$('div').style({
                            top: showTabs_1 ? SideBySideEditorControl.EDITOR_TITLE_HEIGHT + 'px' : 0,
                            height: showTabs_1 ? "calc(100% - " + SideBySideEditorControl.EDITOR_TITLE_HEIGHT + "px" : '100%'
                        }).id(overlayId);
                        overlay.appendTo(container);
                        overlay.on(DOM.EventType.DROP, function (e) {
                            DOM.EventHelper.stop(e, true);
                            onDrop(e, index, overlay.getProperty(splitToPropertyKey));
                        });
                        overlay.on(DOM.EventType.DRAG_OVER, function (e) {
                            positionOverlay(e, containers_1.length, index);
                        });
                        overlay.on([DOM.EventType.DRAG_LEAVE, DOM.EventType.DRAG_END], function () {
                            cleanUp();
                        });
                        // Under some circumstances we have seen reports where the drop overlay is not being
                        // cleaned up and as such the editor area remains under the overlay so that you cannot
                        // type into the editor anymore. This seems related to using VMs and DND via host and
                        // guest OS, though some users also saw it without VMs.
                        // To protect against this issue we always destroy the overlay as soon as we detect a
                        // mouse event over it. The delay is used to guarantee we are not interfering with the
                        // actual DROP event that can also trigger a mouse over event.
                        overlay.once(DOM.EventType.MOUSE_OVER, function () {
                            setTimeout(function () {
                                cleanUp();
                            }, 300);
                        });
                    }
                });
            }
        }
        // const a dropped file open inside Code (only if dropped over editor area)
        this.toDispose.push(DOM.addDisposableListener(node, DOM.EventType.DROP, function (e) {
            if (e.target === node) {
                DOM.EventHelper.stop(e, true);
                onDrop(e, editor_1.Position.LEFT);
            }
            else {
                DOM.removeClass(node, 'dropfeedback');
            }
        }));
        // Drag over
        this.toDispose.push(DOM.addDisposableListener(node, DOM.EventType.DRAG_OVER, function (e) {
            // Upon first drag, detect the dragged resources and only take valid ones
            if (!draggedResources) {
                draggedResources = dnd_1.extractResources(e).filter(function (r) { return r.scheme === 'file' || r.scheme === 'untitled'; });
            }
            if (!draggedResources.length && !titleControl_1.TitleControl.getDraggedEditor()) {
                return; // do not show drop feedback if we drag invalid resources or no tab around
            }
            if (e.target === node) {
                DOM.addClass(node, 'dropfeedback');
            }
            var target = e.target;
            if (target) {
                if (overlay && target.id !== overlayId) {
                    cleanUp(); // somehow we managed to move the mouse quickly out of the current overlay, so destroy it
                }
                createOverlay(target);
                if (overlay) {
                    DOM.removeClass(node, 'dropfeedback'); // if we show an overlay, we can remove the drop feedback from the editor background
                }
            }
        }));
        // Drag leave
        this.toDispose.push(DOM.addDisposableListener(node, DOM.EventType.DRAG_LEAVE, function (e) {
            DOM.removeClass(node, 'dropfeedback');
        }));
        // Drag end (also install globally to be safe)
        [node, window].forEach(function (container) {
            _this.toDispose.push(DOM.addDisposableListener(container, DOM.EventType.DRAG_END, function (e) {
                DOM.removeClass(node, 'dropfeedback');
                cleanUp();
            }));
        });
    };
    SideBySideEditorControl.prototype.createTitleControl = function (context, silo, container, instantiationService) {
        var showTabs = this.getConfig().showTabs;
        var titleAreaControl = instantiationService.createInstance(showTabs ? tabsTitleControl_1.TabsTitleControl : noTabsTitleControl_1.NoTabsTitleControl);
        titleAreaControl.create(container.getHTMLElement());
        titleAreaControl.setContext(context);
        titleAreaControl.refresh(true /* instant */);
        silo.child().setProperty(SideBySideEditorControl.TITLE_AREA_CONTROL_KEY, titleAreaControl); // associate with container
    };
    SideBySideEditorControl.prototype.getConfig = function (config) {
        if (config === void 0) { config = this.configurationService.getConfiguration(); }
        if (config.workbench && config.workbench.editor) {
            return { showTabs: config.workbench.editor.showTabs, showIcons: config.workbench.editor.showIcons };
        }
        return Object.create(null);
    };
    SideBySideEditorControl.prototype.findPosition = function (element) {
        var parent = element.parentElement;
        while (parent) {
            for (var i = 0; i < editor_1.POSITIONS.length; i++) {
                var position = editor_1.POSITIONS[i];
                if (this.silos[position].getHTMLElement() === parent) {
                    return position;
                }
            }
            parent = parent.parentElement;
        }
        return null;
    };
    SideBySideEditorControl.prototype.hookTitleDragListener = function (titleContainer) {
        var _this = this;
        var wasDragged = false;
        // Allow to reorder positions by dragging the title
        titleContainer.on(DOM.EventType.MOUSE_DOWN, function (e) {
            var position = _this.findPosition(titleContainer.getHTMLElement());
            var titleAreaControl = _this.getTitleAreaControl(position);
            if (!titleAreaControl.allowDragging(e.target || e.srcElement)) {
                return; // return early if we are not in the drag zone of the title widget
            }
            // Reset flag
            wasDragged = false;
            titleAreaControl.setDragged(false);
            // Return early if there is only one editor active or the user clicked into the toolbar
            if (_this.getVisibleEditorCount() <= 1) {
                return;
            }
            // Only allow for first mouse button click!
            if (e.button !== 0) {
                return;
            }
            DOM.EventHelper.stop(e);
            // Overlay the editor area with a div to be able to capture all mouse events
            var overlayDiv = builder_1.$('div').style({
                top: SideBySideEditorControl.EDITOR_TITLE_HEIGHT + 'px',
                height: '100%'
            }).id('monaco-workbench-editor-move-overlay');
            overlayDiv.appendTo(_this.parent);
            // Update flag
            _this.dragging = true;
            var visibleEditorCount = _this.getVisibleEditorCount();
            var mouseDownEvent = new mouseEvent_1.StandardMouseEvent(e);
            var startX = mouseDownEvent.posx;
            var oldNewLeft = null;
            _this.silos[position].addClass('drag');
            _this.parent.addClass('drag');
            var $window = builder_1.$(window);
            $window.on(DOM.EventType.MOUSE_MOVE, function (e) {
                DOM.EventHelper.stop(e, false);
                var mouseMoveEvent = new mouseEvent_1.StandardMouseEvent(e);
                var diffX = mouseMoveEvent.posx - startX;
                var newLeft = null;
                if (Math.abs(diffX) > 5) {
                    wasDragged = true;
                }
                switch (position) {
                    // [ ! ]|[ ]: Moves only to the right but not outside of dimension width to the right
                    case editor_1.Position.LEFT: {
                        newLeft = Math.max(-1 /* 1px border accomodation */, Math.min(diffX, _this.dimension.width - _this.siloWidths[editor_1.Position.LEFT]));
                        break;
                    }
                    case editor_1.Position.CENTER: {
                        // [ ]|[ ! ]: Moves only to the left but not outside of dimension width to the left
                        if (visibleEditorCount === 2) {
                            newLeft = Math.min(_this.siloWidths[editor_1.Position.LEFT], Math.max(-1 /* 1px border accomodation */, _this.siloWidths[editor_1.Position.LEFT] + diffX));
                        }
                        else {
                            newLeft = Math.min(_this.dimension.width - _this.siloWidths[editor_1.Position.CENTER], Math.max(-1 /* 1px border accomodation */, _this.siloWidths[editor_1.Position.LEFT] + diffX));
                        }
                        break;
                    }
                    // [ ]|[ ]|[ ! ]: Moves to the right but not outside of dimension width on the left side
                    case editor_1.Position.RIGHT: {
                        newLeft = Math.min(_this.siloWidths[editor_1.Position.LEFT] + _this.siloWidths[editor_1.Position.CENTER], Math.max(-1 /* 1px border accomodation */, _this.siloWidths[editor_1.Position.LEFT] + _this.siloWidths[editor_1.Position.CENTER] + diffX));
                        break;
                    }
                }
                // Return early if position did not change
                if (oldNewLeft === newLeft) {
                    return;
                }
                oldNewLeft = newLeft;
                // Live drag Feedback
                var moveTo = _this.findMoveTarget(position, diffX);
                switch (position) {
                    case editor_1.Position.LEFT: {
                        if (moveTo === editor_1.Position.LEFT || moveTo === null) {
                            _this.silos[editor_1.Position.CENTER].style({ left: _this.siloWidths[editor_1.Position.LEFT] + 'px', right: 'auto', borderLeftWidth: '1px' });
                            _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: 0 });
                        }
                        else if (moveTo === editor_1.Position.CENTER) {
                            _this.silos[editor_1.Position.CENTER].style({ left: 0, right: 'auto', borderLeftWidth: 0 });
                            _this.silos[editor_1.Position.CENTER].addClass('draggedunder');
                            _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: 0 });
                        }
                        else if (moveTo === editor_1.Position.RIGHT) {
                            _this.silos[editor_1.Position.CENTER].style({ left: 0, right: 'auto' });
                            _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: _this.siloWidths[editor_1.Position.LEFT] + 'px' });
                            _this.silos[editor_1.Position.RIGHT].addClass('draggedunder');
                        }
                        break;
                    }
                    case editor_1.Position.CENTER: {
                        if (moveTo === editor_1.Position.LEFT) {
                            _this.silos[editor_1.Position.LEFT].style({ left: _this.siloWidths[editor_1.Position.CENTER] + 'px', right: 'auto' });
                            _this.silos[editor_1.Position.LEFT].addClass('draggedunder');
                        }
                        else if (moveTo === editor_1.Position.CENTER || moveTo === null) {
                            _this.silos[editor_1.Position.LEFT].style({ left: 0, right: 'auto' });
                            _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: 0 });
                        }
                        else if (moveTo === editor_1.Position.RIGHT) {
                            _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: _this.siloWidths[editor_1.Position.CENTER] + 'px' });
                            _this.silos[editor_1.Position.RIGHT].addClass('draggedunder');
                            _this.silos[editor_1.Position.LEFT].style({ left: 0, right: 'auto' });
                        }
                        break;
                    }
                    case editor_1.Position.RIGHT: {
                        if (moveTo === editor_1.Position.LEFT) {
                            _this.silos[editor_1.Position.LEFT].style({ left: _this.siloWidths[editor_1.Position.RIGHT] + 'px', right: 'auto' });
                            _this.silos[editor_1.Position.LEFT].addClass('draggedunder');
                        }
                        else if (moveTo === editor_1.Position.CENTER) {
                            _this.silos[editor_1.Position.LEFT].style({ left: 0, right: 'auto' });
                            _this.silos[editor_1.Position.CENTER].style({ left: (_this.siloWidths[editor_1.Position.LEFT] + _this.siloWidths[editor_1.Position.RIGHT]) + 'px', right: 'auto' });
                            _this.silos[editor_1.Position.CENTER].addClass('draggedunder');
                        }
                        else if (moveTo === editor_1.Position.RIGHT || moveTo === null) {
                            _this.silos[editor_1.Position.LEFT].style({ left: 0, right: 'auto' });
                            _this.silos[editor_1.Position.CENTER].style({ left: _this.siloWidths[editor_1.Position.LEFT] + 'px', right: 'auto' });
                        }
                        break;
                    }
                }
                // Move the editor to provide feedback to the user and add class
                if (newLeft !== null) {
                    _this.silos[position].style({ left: newLeft + 'px' });
                    _this.silos[position].addClass('dragging');
                    _this.parent.addClass('dragging');
                }
            }).once(DOM.EventType.MOUSE_UP, function (e) {
                DOM.EventHelper.stop(e, false);
                // Destroy overlay
                overlayDiv.destroy();
                // Update flag
                _this.dragging = false;
                if (wasDragged) {
                    titleAreaControl.setDragged(true);
                }
                // Restore styles
                _this.parent.removeClass('drag');
                _this.silos[position].removeClass('drag');
                _this.parent.removeClass('dragging');
                _this.silos[position].removeClass('dragging');
                editor_1.POSITIONS.forEach(function (p) { return _this.silos[p].removeClass('draggedunder'); });
                _this.silos[editor_1.Position.LEFT].style({ left: 0, right: 'auto' });
                _this.silos[editor_1.Position.CENTER].style({ left: 'auto', right: 'auto', borderLeftWidth: '1px' });
                _this.silos[editor_1.Position.RIGHT].style({ left: 'auto', right: 0, borderLeftWidth: '1px' });
                // Find move target
                var mouseUpEvent = new mouseEvent_1.StandardMouseEvent(e);
                var diffX = mouseUpEvent.posx - startX;
                var moveTo = _this.findMoveTarget(position, diffX);
                // Move to valid position if any
                if (moveTo !== null) {
                    _this.editorGroupService.moveGroup(position, moveTo);
                }
                else {
                    _this.layoutContainers();
                }
                // If not dragging, make editor group active unless already active
                if (!wasDragged && position !== _this.getActivePosition()) {
                    _this.editorGroupService.focusGroup(position);
                }
                $window.off('mousemove');
            });
        });
    };
    SideBySideEditorControl.prototype.findMoveTarget = function (position, diffX) {
        var visibleEditorCount = this.getVisibleEditorCount();
        switch (position) {
            case editor_1.Position.LEFT: {
                // [ ! ]|[] -> []|[ ! ]
                if (visibleEditorCount === 2 && (diffX >= this.siloWidths[editor_1.Position.LEFT] / 2 || diffX >= this.siloWidths[editor_1.Position.CENTER] / 2)) {
                    return editor_1.Position.CENTER;
                }
                // [ ! ]|[]|[] -> []|[]|[ ! ]
                if (visibleEditorCount === 3 && (diffX >= this.siloWidths[editor_1.Position.LEFT] / 2 + this.siloWidths[editor_1.Position.CENTER] || diffX >= this.siloWidths[editor_1.Position.RIGHT] / 2 + this.siloWidths[editor_1.Position.CENTER])) {
                    return editor_1.Position.RIGHT;
                }
                // [ ! ]|[]|[] -> []|[ ! ]|[]
                if (visibleEditorCount === 3 && (diffX >= this.siloWidths[editor_1.Position.LEFT] / 2 || diffX >= this.siloWidths[editor_1.Position.CENTER] / 2)) {
                    return editor_1.Position.CENTER;
                }
                break;
            }
            case editor_1.Position.CENTER: {
                if (visibleEditorCount === 2 && diffX > 0) {
                    return null; // Return early since CENTER cannot be moved to the RIGHT unless there is a RIGHT position
                }
                // []|[ ! ] -> [ ! ]|[]
                if (visibleEditorCount === 2 && (Math.abs(diffX) >= this.siloWidths[editor_1.Position.CENTER] / 2 || Math.abs(diffX) >= this.siloWidths[editor_1.Position.LEFT] / 2)) {
                    return editor_1.Position.LEFT;
                }
                // []|[ ! ]|[] -> [ ! ]|[]|[]
                if (visibleEditorCount === 3 && ((diffX < 0 && Math.abs(diffX) >= this.siloWidths[editor_1.Position.CENTER] / 2) || (diffX < 0 && Math.abs(diffX) >= this.siloWidths[editor_1.Position.LEFT] / 2))) {
                    return editor_1.Position.LEFT;
                }
                // []|[ ! ]|[] -> []|[]|[ ! ]
                if (visibleEditorCount === 3 && ((diffX > 0 && Math.abs(diffX) >= this.siloWidths[editor_1.Position.CENTER] / 2) || (diffX > 0 && Math.abs(diffX) >= this.siloWidths[editor_1.Position.RIGHT] / 2))) {
                    return editor_1.Position.RIGHT;
                }
                break;
            }
            case editor_1.Position.RIGHT: {
                if (diffX > 0) {
                    return null; // Return early since RIGHT cannot be moved more to the RIGHT
                }
                // []|[]|[ ! ] -> [ ! ]|[]|[]
                if (Math.abs(diffX) >= this.siloWidths[editor_1.Position.RIGHT] / 2 + this.siloWidths[editor_1.Position.CENTER] || Math.abs(diffX) >= this.siloWidths[editor_1.Position.LEFT] / 2 + this.siloWidths[editor_1.Position.CENTER]) {
                    return editor_1.Position.LEFT;
                }
                // []|[]|[ ! ] -> []|[ ! ]|[]
                if (Math.abs(diffX) >= this.siloWidths[editor_1.Position.RIGHT] / 2 || Math.abs(diffX) >= this.siloWidths[editor_1.Position.CENTER] / 2) {
                    return editor_1.Position.CENTER;
                }
                break;
            }
        }
        return null;
    };
    SideBySideEditorControl.prototype.centerSash = function (a, b) {
        var sumWidth = this.siloWidths[a] + this.siloWidths[b];
        var meanWidth = sumWidth / 2;
        this.siloWidths[a] = meanWidth;
        this.siloWidths[b] = sumWidth - meanWidth;
        this.layoutContainers();
    };
    SideBySideEditorControl.prototype.onLeftSashDragStart = function () {
        this.startLeftContainerWidth = this.siloWidths[editor_1.Position.LEFT];
    };
    SideBySideEditorControl.prototype.onLeftSashDrag = function (e) {
        var oldLeftContainerWidth = this.siloWidths[editor_1.Position.LEFT];
        var newLeftContainerWidth = this.startLeftContainerWidth + e.currentX - e.startX;
        // Side-by-Side
        if (this.rightSash.isHidden()) {
            // []|[      ] : left side can not get smaller than MIN_EDITOR_WIDTH
            if (newLeftContainerWidth < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (this.dimension.width - newLeftContainerWidth < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = this.dimension.width - SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (newLeftContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (this.dimension.width - newLeftContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = this.dimension.width - SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            this.siloWidths[editor_1.Position.LEFT] = newLeftContainerWidth;
            this.siloWidths[editor_1.Position.CENTER] = this.dimension.width - newLeftContainerWidth;
        }
        else {
            // [!]|[      ]|[  ] : left side can not get smaller than MIN_EDITOR_WIDTH
            if (newLeftContainerWidth < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (this.dimension.width - newLeftContainerWidth - this.siloWidths[editor_1.Position.RIGHT] < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                // [      ]|[ ]|[!] : right side can not get smaller than MIN_EDITOR_WIDTH
                if (this.dimension.width - newLeftContainerWidth - this.siloWidths[editor_1.Position.CENTER] < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                    newLeftContainerWidth = this.dimension.width - (2 * SideBySideEditorControl.MIN_EDITOR_WIDTH);
                    this.siloWidths[editor_1.Position.CENTER] = this.siloWidths[editor_1.Position.RIGHT] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
                }
                else if (this.dimension.width - newLeftContainerWidth - this.siloWidths[editor_1.Position.CENTER] - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                    this.siloWidths[editor_1.Position.RIGHT] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
                }
                else {
                    this.siloWidths[editor_1.Position.RIGHT] = this.siloWidths[editor_1.Position.RIGHT] - (newLeftContainerWidth - oldLeftContainerWidth);
                }
                this.rightSash.layout();
            }
            else if (newLeftContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (this.dimension.width - this.siloWidths[editor_1.Position.RIGHT] - newLeftContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newLeftContainerWidth = this.dimension.width - this.siloWidths[editor_1.Position.RIGHT] - SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            this.siloWidths[editor_1.Position.LEFT] = newLeftContainerWidth;
            this.siloWidths[editor_1.Position.CENTER] = this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - this.siloWidths[editor_1.Position.RIGHT];
        }
        // Pass on to containers
        this.layoutContainers();
    };
    SideBySideEditorControl.prototype.onLeftSashDragEnd = function () {
        this.leftSash.layout();
        this.rightSash.layout(); // Moving left sash might have also moved right sash, so layout() both
        this.focusNextNonMinimized();
    };
    SideBySideEditorControl.prototype.onLeftSashReset = function () {
        this.centerSash(editor_1.Position.LEFT, editor_1.Position.CENTER);
        this.leftSash.layout();
    };
    SideBySideEditorControl.prototype.onRightSashDragStart = function () {
        this.startRightContainerWidth = this.siloWidths[editor_1.Position.RIGHT];
    };
    SideBySideEditorControl.prototype.onRightSashDrag = function (e) {
        var oldRightContainerWidth = this.siloWidths[editor_1.Position.RIGHT];
        var newRightContainerWidth = this.startRightContainerWidth - e.currentX + e.startX;
        // [  ]|[      ]|[!] : right side can not get smaller than MIN_EDITOR_WIDTH
        if (newRightContainerWidth < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
            newRightContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
        }
        else if (this.dimension.width - newRightContainerWidth - this.siloWidths[editor_1.Position.LEFT] < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
            // [!]|[ ]|[    ] : left side can not get smaller than MIN_EDITOR_WIDTH
            if (this.dimension.width - newRightContainerWidth - this.siloWidths[editor_1.Position.CENTER] < SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                newRightContainerWidth = this.dimension.width - (2 * SideBySideEditorControl.MIN_EDITOR_WIDTH);
                this.siloWidths[editor_1.Position.LEFT] = this.siloWidths[editor_1.Position.CENTER] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else if (this.dimension.width - newRightContainerWidth - this.siloWidths[editor_1.Position.CENTER] - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                this.siloWidths[editor_1.Position.LEFT] = SideBySideEditorControl.MIN_EDITOR_WIDTH;
            }
            else {
                this.siloWidths[editor_1.Position.LEFT] = this.siloWidths[editor_1.Position.LEFT] - (newRightContainerWidth - oldRightContainerWidth);
            }
            this.leftSash.layout();
        }
        else if (newRightContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
            newRightContainerWidth = SideBySideEditorControl.MIN_EDITOR_WIDTH;
        }
        else if (this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - newRightContainerWidth - SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD <= SideBySideEditorControl.MIN_EDITOR_WIDTH) {
            newRightContainerWidth = this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - SideBySideEditorControl.MIN_EDITOR_WIDTH;
        }
        this.siloWidths[editor_1.Position.RIGHT] = newRightContainerWidth;
        this.siloWidths[editor_1.Position.CENTER] = this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - this.siloWidths[editor_1.Position.RIGHT];
        this.layoutContainers();
    };
    SideBySideEditorControl.prototype.onRightSashDragEnd = function () {
        this.leftSash.layout(); // Moving right sash might have also moved left sash, so layout() both
        this.rightSash.layout();
        this.focusNextNonMinimized();
    };
    SideBySideEditorControl.prototype.onRightSashReset = function () {
        this.centerSash(editor_1.Position.CENTER, editor_1.Position.RIGHT);
        this.rightSash.layout();
    };
    SideBySideEditorControl.prototype.getVerticalSashTop = function (sash) {
        return 0;
    };
    SideBySideEditorControl.prototype.getVerticalSashLeft = function (sash) {
        return sash === this.leftSash ? this.siloWidths[editor_1.Position.LEFT] : this.siloWidths[editor_1.Position.CENTER] + this.siloWidths[editor_1.Position.LEFT];
    };
    SideBySideEditorControl.prototype.getVerticalSashHeight = function (sash) {
        return this.dimension.height;
    };
    SideBySideEditorControl.prototype.isDragging = function () {
        return this.dragging;
    };
    SideBySideEditorControl.prototype.layout = function (arg) {
        if (arg instanceof builder_1.Dimension) {
            this.layoutControl(arg);
        }
        else {
            this.layoutEditor(arg);
        }
    };
    SideBySideEditorControl.prototype.layoutControl = function (dimension) {
        var _this = this;
        var oldDimension = this.dimension;
        this.dimension = dimension;
        // Use the current dimension in case an editor was opened before we had any dimension
        if (!oldDimension || !oldDimension.width || !oldDimension.height) {
            oldDimension = dimension;
        }
        // Apply to visible editors
        var totalWidth = 0;
        // Set preferred dimensions based on ratio to previous dimenions
        editor_1.POSITIONS.forEach(function (position) {
            if (_this.visibleEditors[position]) {
                // Keep minimized editors in tact by not letting them grow if we have width to give
                if (_this.siloWidths[position] !== SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                    var sashWidthRatio = void 0;
                    // We have some stored initial ratios when the editor was restored on startup
                    // Use those ratios over anything else but only once.
                    if (_this.siloInitialRatios && types.isNumber(_this.siloInitialRatios[position])) {
                        sashWidthRatio = _this.siloInitialRatios[position];
                        delete _this.siloInitialRatios[position]; // dont use again
                    }
                    else {
                        sashWidthRatio = _this.siloWidths[position] / oldDimension.width;
                    }
                    _this.siloWidths[position] = Math.max(Math.round(_this.dimension.width * sashWidthRatio), SideBySideEditorControl.MIN_EDITOR_WIDTH);
                }
                totalWidth += _this.siloWidths[position];
            }
        });
        // Compensate for overflow either through rounding error or min editor width
        if (totalWidth > 0) {
            var overflow_1 = totalWidth - this.dimension.width;
            // We have width to give
            if (overflow_1 < 0) {
                // Find the first position from left to right that is not minimized
                // to give width. This ensures that minimized editors are left like
                // that if the user chose this layout.
                var positionToGive_1 = null;
                editor_1.POSITIONS.forEach(function (position) {
                    if (_this.visibleEditors[position] && positionToGive_1 === null && _this.siloWidths[position] !== SideBySideEditorControl.MIN_EDITOR_WIDTH) {
                        positionToGive_1 = position;
                    }
                });
                if (positionToGive_1 === null) {
                    positionToGive_1 = editor_1.Position.LEFT; // maybe all are minimized, so give LEFT the extra width
                }
                this.siloWidths[positionToGive_1] -= overflow_1;
            }
            else if (overflow_1 > 0) {
                editor_1.POSITIONS.forEach(function (position) {
                    var maxCompensation = _this.siloWidths[position] - SideBySideEditorControl.MIN_EDITOR_WIDTH;
                    if (maxCompensation >= overflow_1) {
                        _this.siloWidths[position] -= overflow_1;
                        overflow_1 = 0;
                    }
                    else if (maxCompensation > 0) {
                        var compensation = overflow_1 - maxCompensation;
                        _this.siloWidths[position] -= compensation;
                        overflow_1 -= compensation;
                    }
                });
            }
        }
        // Sash positioning
        this.leftSash.layout();
        this.rightSash.layout();
        // Pass on to Editor Containers
        this.layoutContainers();
    };
    SideBySideEditorControl.prototype.layoutContainers = function () {
        var _this = this;
        // Layout containers
        editor_1.POSITIONS.forEach(function (position) {
            _this.silos[position].size(_this.siloWidths[position], _this.dimension.height);
        });
        // Position center depending on visibility of right hand editor
        if (this.visibleEditors[editor_1.Position.RIGHT]) {
            this.silos[editor_1.Position.CENTER].position(null, this.siloWidths[editor_1.Position.RIGHT]);
        }
        else {
            this.silos[editor_1.Position.CENTER].position(null, this.dimension.width - this.siloWidths[editor_1.Position.LEFT] - this.siloWidths[editor_1.Position.CENTER]);
        }
        // Visibility
        editor_1.POSITIONS.forEach(function (position) {
            if (_this.visibleEditors[position] && _this.silos[position].isHidden()) {
                _this.silos[position].show();
            }
            else if (!_this.visibleEditors[position] && !_this.silos[position].isHidden()) {
                _this.silos[position].hide();
            }
        });
        // Layout visible editors
        editor_1.POSITIONS.forEach(function (position) {
            _this.layoutEditor(position);
        });
        // Layout title controls
        editor_1.POSITIONS.forEach(function (position) {
            _this.getTitleAreaControl(position).layout();
        });
    };
    SideBySideEditorControl.prototype.layoutEditor = function (position) {
        var editorWidth = this.siloWidths[position];
        if (editorWidth && this.visibleEditors[position]) {
            this.visibleEditors[position].layout(new builder_1.Dimension(editorWidth, this.dimension.height - SideBySideEditorControl.EDITOR_TITLE_HEIGHT));
        }
    };
    SideBySideEditorControl.prototype.getInstantiationService = function (position) {
        return this.getFromContainer(position, SideBySideEditorControl.INSTANTIATION_SERVICE_KEY);
    };
    SideBySideEditorControl.prototype.getProgressBar = function (position) {
        return this.getFromContainer(position, SideBySideEditorControl.PROGRESS_BAR_CONTROL_KEY);
    };
    SideBySideEditorControl.prototype.getTitleAreaControl = function (position) {
        return this.getFromContainer(position, SideBySideEditorControl.TITLE_AREA_CONTROL_KEY);
    };
    SideBySideEditorControl.prototype.getFromContainer = function (position, key) {
        var silo = this.silos[position];
        return silo ? silo.child().getProperty(key) : void 0;
    };
    SideBySideEditorControl.prototype.updateTitle = function (identifier) {
        this.onStacksChanged({ editor: identifier.editor, group: identifier.group });
    };
    SideBySideEditorControl.prototype.updateProgress = function (position, state) {
        var progressbar = this.getProgressBar(position);
        if (!progressbar) {
            return;
        }
        switch (state) {
            case ProgressState.INFINITE:
                progressbar.infinite().getContainer().show();
                break;
            case ProgressState.DONE:
                progressbar.done().getContainer().hide();
                break;
            case ProgressState.STOP:
                progressbar.stop().getContainer().hide();
                break;
        }
    };
    SideBySideEditorControl.prototype.dispose = function () {
        var _this = this;
        lifecycle_1.dispose(this.toDispose);
        // Positions
        editor_1.POSITIONS.forEach(function (position) {
            _this.clearPosition(position);
        });
        // Controls
        editor_1.POSITIONS.forEach(function (position) {
            _this.getTitleAreaControl(position).dispose();
            _this.getProgressBar(position).dispose();
        });
        // Sash
        this.leftSash.dispose();
        this.rightSash.dispose();
        // Destroy Container
        this.silos.forEach(function (silo) {
            silo.destroy();
        });
        this.lastActiveEditor = null;
        this.lastActivePosition = null;
        this.visibleEditors = null;
        this._onGroupFocusChanged.dispose();
    };
    SideBySideEditorControl.TITLE_AREA_CONTROL_KEY = '__titleAreaControl';
    SideBySideEditorControl.PROGRESS_BAR_CONTROL_KEY = '__progressBar';
    SideBySideEditorControl.INSTANTIATION_SERVICE_KEY = '__instantiationService';
    SideBySideEditorControl.MIN_EDITOR_WIDTH = 170;
    SideBySideEditorControl.EDITOR_TITLE_HEIGHT = 35;
    SideBySideEditorControl.SNAP_TO_MINIMIZED_THRESHOLD = 50;
    SideBySideEditorControl = __decorate([
        __param(1, editorService_1.IWorkbenchEditorService),
        __param(2, groupService_1.IEditorGroupService),
        __param(3, telemetry_1.ITelemetryService),
        __param(4, configuration_1.IConfigurationService),
        __param(5, contextkey_1.IContextKeyService),
        __param(6, extensions_1.IExtensionService),
        __param(7, instantiation_1.IInstantiationService)
    ], SideBySideEditorControl);
    return SideBySideEditorControl;
}());
exports.SideBySideEditorControl = SideBySideEditorControl;
