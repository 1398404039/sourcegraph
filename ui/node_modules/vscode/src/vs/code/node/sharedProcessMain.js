/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var fs = require('fs');
var platform = require('vs/base/common/platform');
var product_1 = require('vs/platform/product');
var package_1 = require('vs/platform/package');
var ipc_net_1 = require('vs/base/parts/ipc/node/ipc.net');
var winjs_base_1 = require('vs/base/common/winjs.base');
var serviceCollection_1 = require('vs/platform/instantiation/common/serviceCollection');
var descriptors_1 = require('vs/platform/instantiation/common/descriptors');
var instantiationService_1 = require('vs/platform/instantiation/common/instantiationService');
var environment_1 = require('vs/platform/environment/common/environment');
var environmentService_1 = require('vs/platform/environment/node/environmentService');
var event_1 = require('vs/platform/event/common/event');
var eventService_1 = require('vs/platform/event/common/eventService');
var extensionManagementIpc_1 = require('vs/platform/extensionManagement/common/extensionManagementIpc');
var extensionManagement_1 = require('vs/platform/extensionManagement/common/extensionManagement');
var extensionManagementService_1 = require('vs/platform/extensionManagement/node/extensionManagementService');
var extensionGalleryService_1 = require('vs/platform/extensionManagement/node/extensionGalleryService');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var configurationService_1 = require('vs/platform/configuration/node/configurationService');
var request_1 = require('vs/platform/request/common/request');
var requestService_1 = require('vs/platform/request/node/requestService');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var commonProperties_1 = require('vs/platform/telemetry/node/commonProperties');
var telemetryIpc_1 = require('vs/platform/telemetry/common/telemetryIpc');
var telemetryService_1 = require('vs/platform/telemetry/common/telemetryService');
var appInsightsAppender_1 = require('vs/platform/telemetry/node/appInsightsAppender');
var message_1 = require('vs/platform/message/common/message');
var messageIpc_1 = require('vs/platform/message/common/messageIpc');
var windowsIpc_1 = require('vs/code/common/windowsIpc');
var windows_1 = require('vs/code/common/windows');
function quit(err) {
    if (err) {
        console.error(err.stack || err);
    }
    process.exit(err ? 1 : 0);
}
/**
 * Plan B is to kill oneself if one's parent dies. Much drama.
 */
function setupPlanB(parentPid) {
    setInterval(function () {
        try {
            process.kill(parentPid, 0); // throws an exception if the main process doesn't exist anymore.
        }
        catch (e) {
            process.exit();
        }
    }, 5000);
}
var eventPrefix = 'monacoworkbench';
function main(server, initData) {
    var services = new serviceCollection_1.ServiceCollection();
    services.set(event_1.IEventService, new descriptors_1.SyncDescriptor(eventService_1.EventService));
    services.set(environment_1.IEnvironmentService, new descriptors_1.SyncDescriptor(environmentService_1.EnvironmentService, initData.args, process.execPath));
    services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));
    services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));
    var windowEventService = new windowsIpc_1.WindowEventChannelClient(server.getChannel('windowEvent', {
        routeCall: function (command, arg) {
            return 'main';
        }
    }));
    services.set(windows_1.IWindowEventService, windowEventService);
    var activeWindowManager = new windows_1.ActiveWindowManager(windowEventService);
    services.set(message_1.IChoiceService, new messageIpc_1.ChoiceChannelClient(server.getChannel('choice', {
        routeCall: function () { return activeWindowManager.activeClientId; }
    })));
    var instantiationService = new instantiationService_1.InstantiationService(services);
    instantiationService.invokeFunction(function (accessor) {
        var appenders = [];
        if (product_1.default.aiConfig && product_1.default.aiConfig.key) {
            appenders.push(new appInsightsAppender_1.AppInsightsAppender(eventPrefix, null, product_1.default.aiConfig.key));
        }
        if (product_1.default.aiConfig && product_1.default.aiConfig.asimovKey) {
            appenders.push(new appInsightsAppender_1.AppInsightsAppender(eventPrefix, null, product_1.default.aiConfig.asimovKey));
        }
        // It is important to dispose the AI adapter properly because
        // only then they flush remaining data.
        process.once('exit', function () { return appenders.forEach(function (a) { return a.dispose(); }); });
        var appender = telemetry_1.combinedAppender.apply(void 0, appenders);
        server.registerChannel('telemetryAppender', new telemetryIpc_1.TelemetryAppenderChannel(appender));
        var services = new serviceCollection_1.ServiceCollection();
        var _a = accessor.get(environment_1.IEnvironmentService), appRoot = _a.appRoot, extensionsPath = _a.extensionsPath, extensionDevelopmentPath = _a.extensionDevelopmentPath, isBuilt = _a.isBuilt;
        if (isBuilt && !extensionDevelopmentPath && product_1.default.enableTelemetry) {
            var config = {
                appender: appender,
                commonProperties: commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version),
                piiPaths: [appRoot, extensionsPath]
            };
            services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, config));
        }
        else {
            services.set(telemetry_1.ITelemetryService, telemetry_1.NullTelemetryService);
        }
        services.set(extensionManagement_1.IExtensionManagementService, new descriptors_1.SyncDescriptor(extensionManagementService_1.ExtensionManagementService));
        services.set(extensionManagement_1.IExtensionGalleryService, new descriptors_1.SyncDescriptor(extensionGalleryService_1.ExtensionGalleryService));
        var instantiationService2 = instantiationService.createChild(services);
        instantiationService2.invokeFunction(function (accessor) {
            var extensionManagementService = accessor.get(extensionManagement_1.IExtensionManagementService);
            var channel = new extensionManagementIpc_1.ExtensionManagementChannel(extensionManagementService);
            server.registerChannel('extensions', channel);
            // clean up deprecated extensions
            extensionManagementService.removeDeprecatedExtensions();
        });
    });
}
function setupIPC(hook) {
    function setup(retry) {
        return ipc_net_1.serve(hook).then(null, function (err) {
            if (!retry || platform.isWindows || err.code !== 'EADDRINUSE') {
                return winjs_base_1.TPromise.wrapError(err);
            }
            // should retry, not windows and eaddrinuse
            return ipc_net_1.connect(hook, '').then(function (client) {
                // we could connect to a running instance. this is not good, abort
                client.dispose();
                return winjs_base_1.TPromise.wrapError(new Error('There is an instance already running.'));
            }, function (err) {
                // it happens on Linux and OS X that the pipe is left behind
                // let's delete it, since we can't connect to it
                // and the retry the whole thing
                try {
                    fs.unlinkSync(hook);
                }
                catch (e) {
                    return winjs_base_1.TPromise.wrapError(new Error('Error deleting the shared ipc hook.'));
                }
                return setup(false);
            });
        });
    }
    return setup(true);
}
function handshake() {
    return new winjs_base_1.TPromise(function (c, e) {
        process.once('message', c);
        process.once('error', e);
        process.send('hello');
    });
}
setupIPC(process.env['VSCODE_SHARED_IPC_HOOK'])
    .then(function (server) { return handshake()
    .then(function (data) { return main(server, data); })
    .then(function () { return setupPlanB(process.env['VSCODE_PID']); })
    .done(null, quit); });
