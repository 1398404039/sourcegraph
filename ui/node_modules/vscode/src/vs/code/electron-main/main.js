/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var nls = require('vs/nls');
var electron_1 = require('electron');
var objects_1 = require('vs/base/common/objects');
var platform = require('vs/base/common/platform');
var argv_1 = require('vs/platform/environment/node/argv');
var pfs_1 = require('vs/base/node/pfs');
var env_1 = require('vs/code/electron-main/env');
var windows_1 = require('vs/code/electron-main/windows');
var windows_2 = require('vs/code/common/windows');
var windowsIpc_1 = require('vs/code/common/windowsIpc');
var lifecycle_1 = require('vs/code/electron-main/lifecycle');
var menus_1 = require('vs/code/electron-main/menus');
var update_manager_1 = require('vs/code/electron-main/update-manager');
var ipc_electron_1 = require('vs/base/parts/ipc/common/ipc.electron');
var ipc_net_1 = require('vs/base/parts/ipc/node/ipc.net');
var winjs_base_1 = require('vs/base/common/winjs.base');
var gitIpc_1 = require('vs/workbench/parts/git/common/gitIpc');
var askpassService_1 = require('vs/workbench/parts/git/electron-main/askpassService');
var sharedProcess_1 = require('vs/code/node/sharedProcess');
var launch_1 = require('./launch');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var instantiationService_1 = require('vs/platform/instantiation/common/instantiationService');
var serviceCollection_1 = require('vs/platform/instantiation/common/serviceCollection');
var descriptors_1 = require('vs/platform/instantiation/common/descriptors');
var log_1 = require('vs/code/electron-main/log');
var storage_1 = require('vs/code/electron-main/storage');
var environment_1 = require('vs/platform/environment/common/environment');
var environmentService_1 = require('vs/platform/environment/node/environmentService');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var configurationService_1 = require('vs/platform/configuration/node/configurationService');
var request_1 = require('vs/platform/request/common/request');
var requestService_1 = require('vs/platform/request/node/requestService');
var uuid_1 = require('vs/base/common/uuid');
var labels_1 = require('vs/base/common/labels');
var url_1 = require('vs/platform/url/common/url');
var urlIpc_1 = require('vs/platform/url/common/urlIpc');
var urlService_1 = require('vs/platform/url/electron-main/urlService');
var fs = require('original-fs');
var cp = require('child_process');
var path = require('path');
function quit(accessor, arg) {
    var logService = accessor.get(log_1.ILogService);
    var exitCode = 0;
    if (typeof arg === 'string') {
        logService.log(arg);
    }
    else {
        exitCode = 1; // signal error to the outside
        if (arg.stack) {
            console.error(arg.stack);
        }
        else {
            console.error('Startup error: ' + arg.toString());
        }
    }
    process.exit(exitCode); // in main, process.exit === app.exit
}
function main(accessor, mainIpcServer, userEnv) {
    var instantiationService = accessor.get(instantiation_1.IInstantiationService);
    var logService = accessor.get(log_1.ILogService);
    var envService = accessor.get(env_1.IEnvService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    var windowsService = accessor.get(windows_1.IWindowsService);
    var windowEventService = accessor.get(windows_2.IWindowEventService);
    var lifecycleService = accessor.get(lifecycle_1.ILifecycleService);
    var updateService = accessor.get(update_manager_1.IUpdateService);
    var configurationService = accessor.get(configuration_1.IConfigurationService);
    var windowEventChannel = new windowsIpc_1.WindowEventChannel(windowEventService);
    // We handle uncaught exceptions here to prevent electron from opening a dialog to the user
    process.on('uncaughtException', function (err) {
        if (err) {
            // take only the message and stack property
            var friendlyError = {
                message: err.message,
                stack: err.stack
            };
            // handle on client side
            windowsService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));
        }
        console.error('[uncaught exception in main]: ' + err);
        if (err.stack) {
            console.error(err.stack);
        }
    });
    logService.log('Starting VS Code in verbose mode');
    logService.log("from: " + envService.appRoot);
    logService.log('args:', envService.cliArgs);
    // Setup Windows mutex
    var windowsMutex = null;
    try {
        var Mutex_1 = require.__$__nodeRequire('windows-mutex').Mutex;
        windowsMutex = new Mutex_1(envService.product.win32MutexName);
    }
    catch (e) {
    }
    // Register Main IPC services
    var launchService = instantiationService.createInstance(launch_1.LaunchService);
    var launchChannel = new launch_1.LaunchChannel(launchService);
    mainIpcServer.registerChannel('launch', launchChannel);
    var askpassService = new askpassService_1.GitAskpassService();
    var askpassChannel = new gitIpc_1.AskpassChannel(askpassService);
    mainIpcServer.registerChannel('askpass', askpassChannel);
    // Create Electron IPC Server
    var electronIpcServer = new ipc_electron_1.Server(electron_1.ipcMain);
    // Register Electron IPC services
    var urlService = accessor.get(url_1.IURLService);
    var urlChannel = instantiationService.createInstance(urlIpc_1.URLChannel, urlService);
    electronIpcServer.registerChannel('url', urlChannel);
    // Spawn shared process
    var initData = { args: environmentService.args };
    var options = {
        allowOutput: !envService.isBuilt || envService.cliArgs.verbose,
        debugPort: envService.isBuilt ? null : 5871
    };
    var sharedProcessDisposable;
    sharedProcess_1.spawnSharedProcess(initData, options).done(function (disposable) {
        sharedProcessDisposable = disposable;
        var sharedProcessConnect = ipc_net_1.connect(environmentService.sharedIPCHandle, 'main');
        sharedProcessConnect.done(function (client) {
            client.registerChannel('windowEvent', windowEventChannel);
        });
    });
    // Make sure we associate the program with the app user model id
    // This will help Windows to associate the running program with
    // any shortcut that is pinned to the taskbar and prevent showing
    // two icons in the taskbar for the same app.
    if (platform.isWindows && envService.product.win32AppUserModelId) {
        electron_1.app.setAppUserModelId(envService.product.win32AppUserModelId);
    }
    function dispose() {
        if (mainIpcServer) {
            mainIpcServer.dispose();
            mainIpcServer = null;
        }
        if (sharedProcessDisposable) {
            sharedProcessDisposable.dispose();
        }
        if (windowsMutex) {
            windowsMutex.release();
        }
        configurationService.dispose();
    }
    // Dispose on app quit
    electron_1.app.on('will-quit', function () {
        logService.log('App#will-quit: disposing resources');
        dispose();
    });
    // Dispose on vscode:exit
    electron_1.ipcMain.on('vscode:exit', function (event, code) {
        logService.log('IPC#vscode:exit', code);
        dispose();
        process.exit(code); // in main, process.exit === app.exit
    });
    // Lifecycle
    lifecycleService.ready();
    // Propagate to clients
    windowsService.ready(userEnv);
    // Install Menu
    var menu = instantiationService.createInstance(menus_1.VSCodeMenu);
    menu.ready();
    // Install JumpList on Windows
    if (platform.isWindows) {
        var jumpList = [];
        // Tasks
        jumpList.push({
            type: 'tasks',
            items: [
                {
                    type: 'task',
                    title: nls.localize('newWindow', "New Window"),
                    description: nls.localize('newWindowDesc', "Opens a new window"),
                    program: process.execPath,
                    args: '-n',
                    iconPath: process.execPath,
                    iconIndex: 0
                }
            ]
        });
        // Recent Folders
        var folders = windowsService.getRecentPathsList().folders;
        if (folders.length > 0) {
            jumpList.push({
                type: 'custom',
                name: 'Recent Folders',
                items: windowsService.getRecentPathsList().folders.slice(0, 7 /* limit number of entries here */).map(function (folder) {
                    return {
                        type: 'task',
                        title: labels_1.getPathLabel(folder),
                        description: nls.localize('folderDesc', "{0} {1}", path.basename(folder), labels_1.getPathLabel(path.dirname(folder))),
                        program: process.execPath,
                        args: folder,
                        iconPath: 'explorer.exe',
                        iconIndex: 0
                    };
                })
            });
        }
        // Recent
        jumpList.push({
            type: 'recent' // this enables to show files in the "recent" category
        });
        try {
            electron_1.app.setJumpList(jumpList);
        }
        catch (error) {
            logService.log('#setJumpList', error); // since setJumpList is relatively new API, make sure to guard for errors
        }
    }
    // Setup auto update
    updateService.initialize();
    // Open our first window
    if (envService.cliArgs['new-window'] && envService.cliArgs.paths.length === 0) {
        windowsService.open({ cli: envService.cliArgs, forceNewWindow: true, forceEmpty: true }); // new window if "-n" was used without paths
    }
    else if (global.macOpenFiles && global.macOpenFiles.length && (!envService.cliArgs.paths || !envService.cliArgs.paths.length)) {
        windowsService.open({ cli: envService.cliArgs, pathsToOpen: global.macOpenFiles }); // mac: open-file event received on startup
    }
    else {
        windowsService.open({ cli: envService.cliArgs, forceNewWindow: envService.cliArgs['new-window'], diffMode: envService.cliArgs.diff }); // default: read paths from cli
    }
}
function setupIPC(accessor) {
    var logService = accessor.get(log_1.ILogService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    var envService = accessor.get(env_1.IEnvService);
    function setup(retry) {
        return ipc_net_1.serve(environmentService.mainIPCHandle).then(function (server) {
            if (platform.isMacintosh) {
                electron_1.app.dock.show(); // dock might be hidden at this case due to a retry
            }
            return server;
        }, function (err) {
            if (err.code !== 'EADDRINUSE') {
                return winjs_base_1.TPromise.wrapError(err);
            }
            // Since we are the second instance, we do not want to show the dock
            if (platform.isMacintosh) {
                electron_1.app.dock.hide();
            }
            // there's a running instance, let's connect to it
            return ipc_net_1.connect(environmentService.mainIPCHandle, 'main').then(function (client) {
                // Tests from CLI require to be the only instance currently (TODO@Ben support multiple instances and output)
                if (environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break) {
                    var msg = 'Running extension tests from the command line is currently only supported if no other instance of Code is running.';
                    console.error(msg);
                    client.dispose();
                    return winjs_base_1.TPromise.wrapError(msg);
                }
                logService.log('Sending env to running instance...');
                var channel = client.getChannel('launch');
                var service = new launch_1.LaunchChannelClient(channel);
                return service.start(envService.cliArgs, process.env)
                    .then(function () { return client.dispose(); })
                    .then(function () { return winjs_base_1.TPromise.wrapError('Sent env to running instance. Terminating...'); });
            }, function (err) {
                if (!retry || platform.isWindows || err.code !== 'ECONNREFUSED') {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                // it happens on Linux and OS X that the pipe is left behind
                // let's delete it, since we can't connect to it
                // and the retry the whole thing
                try {
                    fs.unlinkSync(environmentService.mainIPCHandle);
                }
                catch (e) {
                    logService.log('Fatal error deleting obsolete instance handle', e);
                    return winjs_base_1.TPromise.wrapError(e);
                }
                return setup(false);
            });
        });
    }
    return setup(true);
}
function getUnixShellEnvironment() {
    var promise = new winjs_base_1.TPromise(function (c, e) {
        var runAsNode = process.env['ELECTRON_RUN_AS_NODE'];
        var noAttach = process.env['ELECTRON_NO_ATTACH_CONSOLE'];
        var mark = uuid_1.generateUuid().replace(/-/g, '').substr(0, 12);
        var regex = new RegExp(mark + '(.*)' + mark);
        var env = objects_1.assign({}, process.env, {
            ELECTRON_RUN_AS_NODE: '1',
            ELECTRON_NO_ATTACH_CONSOLE: '1'
        });
        var command = "'" + process.execPath + "' -p '\"" + mark + "\" + JSON.stringify(process.env) + \"" + mark + "\"'";
        var child = cp.spawn(process.env.SHELL, ['-ilc', command], {
            detached: true,
            stdio: ['ignore', 'pipe', process.stderr],
            env: env
        });
        var buffers = [];
        child.on('error', function () { return c({}); });
        child.stdout.on('data', function (b) { return buffers.push(b); });
        child.on('close', function (code, signal) {
            if (code !== 0) {
                return e(new Error('Failed to get environment'));
            }
            var raw = Buffer.concat(buffers).toString('utf8');
            var match = regex.exec(raw);
            var rawStripped = match ? match[1] : '{}';
            try {
                var env_2 = JSON.parse(rawStripped);
                if (runAsNode) {
                    env_2['ELECTRON_RUN_AS_NODE'] = runAsNode;
                }
                else {
                    delete env_2['ELECTRON_RUN_AS_NODE'];
                }
                if (noAttach) {
                    env_2['ELECTRON_NO_ATTACH_CONSOLE'] = noAttach;
                }
                else {
                    delete env_2['ELECTRON_NO_ATTACH_CONSOLE'];
                }
                c(env_2);
            }
            catch (err) {
                e(err);
            }
        });
    });
    // swallow errors
    return promise.then(null, function () { return ({}); });
}
/**
 * We eed to get the environment from a user's shell.
 * This should only be done when Code itself is not launched
 * from within a shell.
 */
function getShellEnvironment() {
    if (process.env['VSCODE_CLI'] === '1') {
        return winjs_base_1.TPromise.as({});
    }
    if (platform.isWindows) {
        return winjs_base_1.TPromise.as({});
    }
    return getUnixShellEnvironment();
}
/**
 * Returns the user environment necessary for all Code processes.
 * Such environment needs to be propagated to the renderer/shared
 * processes.
 */
function getEnvironment(accessor) {
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    return getShellEnvironment().then(function (shellEnv) {
        var instanceEnv = {
            VSCODE_PID: String(process.pid),
            VSCODE_IPC_HOOK: environmentService.mainIPCHandle,
            VSCODE_SHARED_IPC_HOOK: environmentService.sharedIPCHandle,
            VSCODE_NLS_CONFIG: process.env['VSCODE_NLS_CONFIG']
        };
        return objects_1.assign({}, shellEnv, instanceEnv);
    });
}
function createPaths(environmentService) {
    var paths = [environmentService.appSettingsHome, environmentService.userHome, environmentService.extensionsPath];
    return winjs_base_1.TPromise.join(paths.map(function (p) { return pfs_1.mkdirp(p); }));
}
function start() {
    var args;
    try {
        args = argv_1.parseMainProcessArgv(process.argv);
    }
    catch (err) {
        console.error(err.message);
        process.exit(1);
        return;
    }
    // TODO: isolate
    var services = new serviceCollection_1.ServiceCollection();
    services.set(environment_1.IEnvironmentService, new descriptors_1.SyncDescriptor(environmentService_1.EnvironmentService, args, process.execPath));
    services.set(env_1.IEnvService, new descriptors_1.SyncDescriptor(env_1.EnvService));
    services.set(log_1.ILogService, new descriptors_1.SyncDescriptor(log_1.MainLogService));
    services.set(windows_1.IWindowsService, new descriptors_1.SyncDescriptor(windows_1.WindowsManager));
    services.set(windows_2.IWindowEventService, new descriptors_1.SyncDescriptor(windows_1.WindowEventService));
    services.set(lifecycle_1.ILifecycleService, new descriptors_1.SyncDescriptor(lifecycle_1.LifecycleService));
    services.set(storage_1.IStorageService, new descriptors_1.SyncDescriptor(storage_1.StorageService));
    services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));
    services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));
    services.set(update_manager_1.IUpdateService, new descriptors_1.SyncDescriptor(update_manager_1.UpdateManager));
    services.set(url_1.IURLService, new descriptors_1.SyncDescriptor(urlService_1.URLService, args['open-url']));
    var instantiationService = new instantiationService_1.InstantiationService(services);
    // On some platforms we need to manually read from the global environment variables
    // and assign them to the process environment (e.g. when doubleclick app on Mac)
    return instantiationService.invokeFunction(function (accessor) {
        return getEnvironment(accessor).then(function (env) {
            objects_1.assign(process.env, env);
            return instantiationService.invokeFunction(function (a) { return createPaths(a.get(environment_1.IEnvironmentService)); })
                .then(function () { return instantiationService.invokeFunction(setupIPC); })
                .then(function (mainIpcServer) { return instantiationService.invokeFunction(main, mainIpcServer, env); });
        });
    })
        .done(null, function (err) { return instantiationService.invokeFunction(quit, err); });
}
start();
