/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var platform = require('vs/base/common/platform');
var arrays = require('vs/base/common/arrays');
var env_1 = require('vs/code/electron-main/env');
var electron_1 = require('electron');
var windows_1 = require('vs/code/electron-main/windows');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var storage_1 = require('vs/code/electron-main/storage');
var files_1 = require('vs/platform/files/common/files');
var update_manager_1 = require('vs/code/electron-main/update-manager');
var keybinding_1 = require('vs/base/common/keybinding');
var product_1 = require('vs/platform/product');
var VSCodeMenu = (function () {
    function VSCodeMenu(storageService, updateService, configurationService, windowsService, envService) {
        this.storageService = storageService;
        this.updateService = updateService;
        this.configurationService = configurationService;
        this.windowsService = windowsService;
        this.envService = envService;
        this.actionIdKeybindingRequests = [];
        this.mapResolvedKeybindingToActionId = Object.create(null);
        this.mapLastKnownKeybindingToActionId = this.storageService.getItem(VSCodeMenu.lastKnownKeybindingsMapStorageKey) || Object.create(null);
        var config = configurationService.getConfiguration();
        this.currentAutoSaveSetting = config && config.files && config.files.autoSave;
    }
    VSCodeMenu.prototype.ready = function () {
        this.registerListeners();
        this.install();
    };
    VSCodeMenu.prototype.registerListeners = function () {
        var _this = this;
        // Keep flag when app quits
        electron_1.app.on('will-quit', function () {
            _this.isQuitting = true;
        });
        // Listen to "open" & "close" event from window service
        this.windowsService.onOpen(function (paths) { return _this.onOpen(paths); });
        this.windowsService.onClose(function (_) { return _this.onClose(_this.windowsService.getWindowCount()); });
        // Resolve keybindings when any first workbench is loaded
        this.windowsService.onReady(function (win) { return _this.resolveKeybindings(win); });
        // Listen to resolved keybindings
        electron_1.ipcMain.on('vscode:keybindingsResolved', function (event, rawKeybindings) {
            var keybindings = [];
            try {
                keybindings = JSON.parse(rawKeybindings);
            }
            catch (error) {
            }
            // Fill hash map of resolved keybindings
            var needsMenuUpdate = false;
            keybindings.forEach(function (keybinding) {
                var accelerator = new keybinding_1.Keybinding(keybinding.binding)._toElectronAccelerator();
                if (accelerator) {
                    _this.mapResolvedKeybindingToActionId[keybinding.id] = accelerator;
                    if (_this.mapLastKnownKeybindingToActionId[keybinding.id] !== accelerator) {
                        needsMenuUpdate = true; // we only need to update when something changed!
                    }
                }
            });
            // A keybinding might have been unassigned, so we have to account for that too
            if (Object.keys(_this.mapLastKnownKeybindingToActionId).length !== Object.keys(_this.mapResolvedKeybindingToActionId).length) {
                needsMenuUpdate = true;
            }
            if (needsMenuUpdate) {
                _this.storageService.setItem(VSCodeMenu.lastKnownKeybindingsMapStorageKey, _this.mapResolvedKeybindingToActionId); // keep to restore instantly after restart
                _this.mapLastKnownKeybindingToActionId = _this.mapResolvedKeybindingToActionId; // update our last known map
                _this.updateMenu();
            }
        });
        // Update when auto save config changes
        this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config); });
        // Listen to update service
        this.updateService.on('change', function () { return _this.updateMenu(); });
    };
    VSCodeMenu.prototype.onConfigurationUpdated = function (config) {
        var newAutoSaveSetting = config && config.files && config.files.autoSave;
        if (newAutoSaveSetting !== this.currentAutoSaveSetting) {
            this.currentAutoSaveSetting = newAutoSaveSetting;
            this.updateMenu();
        }
    };
    VSCodeMenu.prototype.resolveKeybindings = function (win) {
        if (this.keybindingsResolved) {
            return; // only resolve once
        }
        this.keybindingsResolved = true;
        // Resolve keybindings when workbench window is up
        if (this.actionIdKeybindingRequests.length) {
            win.send('vscode:resolveKeybindings', JSON.stringify(this.actionIdKeybindingRequests));
        }
    };
    VSCodeMenu.prototype.updateMenu = function () {
        var _this = this;
        // Due to limitations in Electron, it is not possible to update menu items dynamically. The suggested
        // workaround from Electron is to set the application menu again.
        // See also https://github.com/electron/electron/issues/846
        //
        // Run delayed to prevent updating menu while it is open
        if (!this.isQuitting) {
            setTimeout(function () {
                if (!_this.isQuitting) {
                    _this.install();
                }
            }, 10 /* delay this because there is an issue with updating a menu when it is open */);
        }
    };
    VSCodeMenu.prototype.onOpen = function (path) {
        this.updateMenu();
    };
    VSCodeMenu.prototype.onClose = function (remainingWindowCount) {
        if (remainingWindowCount === 0 && platform.isMacintosh) {
            this.updateMenu();
        }
    };
    VSCodeMenu.prototype.install = function () {
        var _this = this;
        // Menus
        var menubar = new electron_1.Menu();
        // Mac: Application
        var macApplicationMenuItem;
        if (platform.isMacintosh) {
            var applicationMenu = new electron_1.Menu();
            macApplicationMenuItem = new electron_1.MenuItem({ label: this.envService.product.nameShort, submenu: applicationMenu });
            this.setMacApplicationMenu(applicationMenu);
        }
        // File
        var fileMenu = new electron_1.Menu();
        var fileMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mFile', comment: ['&& denotes a mnemonic'] }, "&&File")), submenu: fileMenu });
        this.setFileMenu(fileMenu);
        // Edit
        var editMenu = new electron_1.Menu();
        var editMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mEdit', comment: ['&& denotes a mnemonic'] }, "&&Edit")), submenu: editMenu });
        this.setEditMenu(editMenu);
        // View
        var viewMenu = new electron_1.Menu();
        var viewMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mView', comment: ['&& denotes a mnemonic'] }, "&&View")), submenu: viewMenu });
        this.setViewMenu(viewMenu);
        // Goto
        var gotoMenu = new electron_1.Menu();
        var gotoMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mGoto', comment: ['&& denotes a mnemonic'] }, "&&Go")), submenu: gotoMenu });
        this.setGotoMenu(gotoMenu);
        // Mac: Window
        var macWindowMenuItem;
        if (platform.isMacintosh) {
            var windowMenu = new electron_1.Menu();
            macWindowMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize('mWindow', "Window")), submenu: windowMenu, role: 'window' });
            this.setMacWindowMenu(windowMenu);
        }
        // Help
        var helpMenu = new electron_1.Menu();
        var helpMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mHelp', comment: ['&& denotes a mnemonic'] }, "&&Help")), submenu: helpMenu, role: 'help' });
        this.setHelpMenu(helpMenu);
        // Menu Structure
        if (macApplicationMenuItem) {
            menubar.append(macApplicationMenuItem);
        }
        menubar.append(fileMenuItem);
        menubar.append(editMenuItem);
        menubar.append(viewMenuItem);
        menubar.append(gotoMenuItem);
        if (macWindowMenuItem) {
            menubar.append(macWindowMenuItem);
        }
        menubar.append(helpMenuItem);
        electron_1.Menu.setApplicationMenu(menubar);
        // Dock Menu
        if (platform.isMacintosh && !this.appMenuInstalled) {
            this.appMenuInstalled = true;
            var dockMenu = new electron_1.Menu();
            dockMenu.append(new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miNewWindow', comment: ['&& denotes a mnemonic'] }, "&&New Window")), click: function () { return _this.windowsService.openNewWindow(); } }));
            electron_1.app.dock.setMenu(dockMenu);
        }
    };
    VSCodeMenu.prototype.setMacApplicationMenu = function (macApplicationMenu) {
        var _this = this;
        var about = new electron_1.MenuItem({ label: nls.localize('mAbout', "About {0}", this.envService.product.nameLong), role: 'about' });
        var checkForUpdates = this.getUpdateMenuItems();
        var preferences = this.getPreferencesMenu();
        var hide = new electron_1.MenuItem({ label: nls.localize('mHide', "Hide {0}", this.envService.product.nameLong), role: 'hide', accelerator: 'Command+H' });
        var hideOthers = new electron_1.MenuItem({ label: nls.localize('mHideOthers', "Hide Others"), role: 'hideothers', accelerator: 'Command+Alt+H' });
        var showAll = new electron_1.MenuItem({ label: nls.localize('mShowAll', "Show All"), role: 'unhide' });
        var quit = new electron_1.MenuItem({ label: nls.localize('miQuit', "Quit {0}", this.envService.product.nameLong), click: function () { return _this.quit(); }, accelerator: 'Command+Q' });
        var actions = [about];
        actions.push.apply(actions, checkForUpdates);
        actions.push.apply(actions, [
            __separator__(),
            preferences,
            __separator__(),
            hide,
            hideOthers,
            showAll,
            __separator__(),
            quit
        ]);
        actions.forEach(function (i) { return macApplicationMenu.append(i); });
    };
    VSCodeMenu.prototype.setFileMenu = function (fileMenu) {
        var _this = this;
        var hasNoWindows = (this.windowsService.getWindowCount() === 0);
        var newFile;
        if (hasNoWindows) {
            newFile = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miNewFile', comment: ['&& denotes a mnemonic'] }, "&&New File")), accelerator: this.getAccelerator('workbench.action.files.newUntitledFile'), click: function () { return _this.windowsService.openNewWindow(); } });
        }
        else {
            newFile = this.createMenuItem(nls.localize({ key: 'miNewFile', comment: ['&& denotes a mnemonic'] }, "&&New File"), 'workbench.action.files.newUntitledFile');
        }
        var open = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miOpen', comment: ['&& denotes a mnemonic'] }, "&&Open...")), accelerator: this.getAccelerator('workbench.action.files.openFileFolder'), click: function () { return _this.windowsService.openFileFolderPicker(); } });
        var openFolder = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miOpenFolder', comment: ['&& denotes a mnemonic'] }, "Open &&Folder...")), accelerator: this.getAccelerator('workbench.action.files.openFolder'), click: function () { return _this.windowsService.openFolderPicker(); } });
        var openFile;
        if (hasNoWindows) {
            openFile = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miOpenFile', comment: ['&& denotes a mnemonic'] }, "&&Open File...")), accelerator: this.getAccelerator('workbench.action.files.openFile'), click: function () { return _this.windowsService.openFilePicker(); } });
        }
        else {
            openFile = this.createMenuItem(nls.localize({ key: 'miOpenFile', comment: ['&& denotes a mnemonic'] }, "&&Open File..."), 'workbench.action.files.openFile');
        }
        var openRecentMenu = new electron_1.Menu();
        this.setOpenRecentMenu(openRecentMenu);
        var openRecent = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miOpenRecent', comment: ['&& denotes a mnemonic'] }, "Open &&Recent")), submenu: openRecentMenu, enabled: openRecentMenu.items.length > 0 });
        var saveFile = this.createMenuItem(nls.localize({ key: 'miSave', comment: ['&& denotes a mnemonic'] }, "&&Save"), 'workbench.action.files.save', this.windowsService.getWindowCount() > 0);
        var saveFileAs = this.createMenuItem(nls.localize({ key: 'miSaveAs', comment: ['&& denotes a mnemonic'] }, "Save &&As..."), 'workbench.action.files.saveAs', this.windowsService.getWindowCount() > 0);
        var saveAllFiles = this.createMenuItem(nls.localize({ key: 'miSaveAll', comment: ['&& denotes a mnemonic'] }, "Save A&&ll"), 'workbench.action.files.saveAll', this.windowsService.getWindowCount() > 0);
        var autoSaveEnabled = [files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE].some(function (s) { return _this.currentAutoSaveSetting === s; });
        var autoSave = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize('miAutoSave', "Auto Save")), type: 'checkbox', checked: autoSaveEnabled, enabled: this.windowsService.getWindowCount() > 0, click: function () { return _this.windowsService.sendToFocused('vscode.toggleAutoSave'); } });
        var preferences = this.getPreferencesMenu();
        var newWindow = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miNewWindow', comment: ['&& denotes a mnemonic'] }, "&&New Window")), accelerator: this.getAccelerator('workbench.action.newWindow'), click: function () { return _this.windowsService.openNewWindow(); } });
        var revertFile = this.createMenuItem(nls.localize({ key: 'miRevert', comment: ['&& denotes a mnemonic'] }, "Revert F&&ile"), 'workbench.action.files.revert', this.windowsService.getWindowCount() > 0);
        var closeWindow = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miCloseWindow', comment: ['&& denotes a mnemonic'] }, "Close &&Window")), accelerator: this.getAccelerator('workbench.action.closeWindow'), click: function () { return _this.windowsService.getLastActiveWindow().win.close(); }, enabled: this.windowsService.getWindowCount() > 0 });
        var closeFolder = this.createMenuItem(nls.localize({ key: 'miCloseFolder', comment: ['&& denotes a mnemonic'] }, "Close &&Folder"), 'workbench.action.closeFolder');
        var closeEditor = this.createMenuItem(nls.localize({ key: 'miCloseEditor', comment: ['&& denotes a mnemonic'] }, "Close &&Editor"), 'workbench.action.closeActiveEditor');
        var exit = this.createMenuItem(nls.localize({ key: 'miExit', comment: ['&& denotes a mnemonic'] }, "E&&xit"), function () { return _this.quit(); });
        arrays.coalesce([
            newFile,
            newWindow,
            __separator__(),
            platform.isMacintosh ? open : null,
            !platform.isMacintosh ? openFile : null,
            !platform.isMacintosh ? openFolder : null,
            openRecent,
            __separator__(),
            saveFile,
            saveFileAs,
            saveAllFiles,
            __separator__(),
            autoSave,
            __separator__(),
            !platform.isMacintosh ? preferences : null,
            !platform.isMacintosh ? __separator__() : null,
            revertFile,
            closeEditor,
            closeFolder,
            !platform.isMacintosh ? closeWindow : null,
            !platform.isMacintosh ? __separator__() : null,
            !platform.isMacintosh ? exit : null
        ]).forEach(function (item) { return fileMenu.append(item); });
    };
    VSCodeMenu.prototype.getPreferencesMenu = function () {
        var userSettings = this.createMenuItem(nls.localize({ key: 'miOpenSettings', comment: ['&& denotes a mnemonic'] }, "&&User Settings"), 'workbench.action.openGlobalSettings');
        var workspaceSettings = this.createMenuItem(nls.localize({ key: 'miOpenWorkspaceSettings', comment: ['&& denotes a mnemonic'] }, "&&Workspace Settings"), 'workbench.action.openWorkspaceSettings');
        var kebindingSettings = this.createMenuItem(nls.localize({ key: 'miOpenKeymap', comment: ['&& denotes a mnemonic'] }, "&&Keyboard Shortcuts"), 'workbench.action.openGlobalKeybindings');
        var snippetsSettings = this.createMenuItem(nls.localize({ key: 'miOpenSnippets', comment: ['&& denotes a mnemonic'] }, "User &&Snippets"), 'workbench.action.openSnippets');
        var colorThemeSelection = this.createMenuItem(nls.localize({ key: 'miSelectColorTheme', comment: ['&& denotes a mnemonic'] }, "&&Color Theme"), 'workbench.action.selectTheme');
        var iconThemeSelection = this.createMenuItem(nls.localize({ key: 'miSelectIconTheme', comment: ['&& denotes a mnemonic'] }, "File &&Icon Theme"), 'workbench.action.selectIconTheme');
        var preferencesMenu = new electron_1.Menu();
        preferencesMenu.append(userSettings);
        preferencesMenu.append(workspaceSettings);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(kebindingSettings);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(snippetsSettings);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(colorThemeSelection);
        preferencesMenu.append(iconThemeSelection);
        return new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miPreferences', comment: ['&& denotes a mnemonic'] }, "&&Preferences")), submenu: preferencesMenu });
    };
    VSCodeMenu.prototype.quit = function () {
        var _this = this;
        // If the user selected to exit from an extension development host window, do not quit, but just
        // close the window unless this is the last window that is opened.
        var vscodeWindow = this.windowsService.getFocusedWindow();
        if (vscodeWindow && vscodeWindow.isPluginDevelopmentHost && this.windowsService.getWindowCount() > 1) {
            vscodeWindow.win.close();
        }
        else {
            setTimeout(function () {
                _this.isQuitting = true;
                electron_1.app.quit();
            }, 10 /* delay this because there is an issue with quitting while the menu is open */);
        }
    };
    VSCodeMenu.prototype.setOpenRecentMenu = function (openRecentMenu) {
        var _this = this;
        openRecentMenu.append(this.createMenuItem(nls.localize({ key: 'miReopenClosedEditor', comment: ['&& denotes a mnemonic'] }, "&&Reopen Closed Editor"), 'workbench.action.reopenClosedEditor'));
        var _a = this.windowsService.getRecentPathsList(), folders = _a.folders, files = _a.files;
        // Folders
        if (folders.length > 0) {
            openRecentMenu.append(__separator__());
            for (var i = 0; i < VSCodeMenu.MAX_MENU_RECENT_ENTRIES && i < folders.length; i++) {
                openRecentMenu.append(this.createOpenRecentMenuItem(folders[i]));
            }
        }
        // Files
        if (files.length > 0) {
            openRecentMenu.append(__separator__());
            for (var i = 0; i < VSCodeMenu.MAX_MENU_RECENT_ENTRIES && i < files.length; i++) {
                openRecentMenu.append(this.createOpenRecentMenuItem(files[i]));
            }
        }
        if (folders.length || files.length) {
            openRecentMenu.append(__separator__());
            openRecentMenu.append(new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miClearItems', comment: ['&& denotes a mnemonic'] }, "&&Clear Items")), click: function () { _this.windowsService.clearRecentPathsList(); _this.updateMenu(); } }));
        }
    };
    VSCodeMenu.prototype.createOpenRecentMenuItem = function (path) {
        var _this = this;
        return new electron_1.MenuItem({
            label: unMnemonicLabel(path), click: function (menuItem, win, event) {
                var openInNewWindow = event && ((!platform.isMacintosh && event.ctrlKey) || (platform.isMacintosh && event.metaKey));
                var success = !!_this.windowsService.open({ cli: _this.envService.cliArgs, pathsToOpen: [path], forceNewWindow: openInNewWindow });
                if (!success) {
                    _this.windowsService.removeFromRecentPathsList(path);
                    _this.updateMenu();
                }
            }
        });
    };
    VSCodeMenu.prototype.createRoleMenuItem = function (label, actionId, role) {
        var options = {
            label: mnemonicLabel(label),
            accelerator: this.getAccelerator(actionId),
            role: role,
            enabled: true
        };
        return new electron_1.MenuItem(options);
    };
    VSCodeMenu.prototype.setEditMenu = function (winLinuxEditMenu) {
        var undo;
        var redo;
        var cut;
        var copy;
        var paste;
        var selectAll;
        if (platform.isMacintosh) {
            undo = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"), 'undo', function (devTools) { return devTools.undo(); });
            redo = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"), 'redo', function (devTools) { return devTools.redo(); });
            cut = this.createRoleMenuItem(nls.localize({ key: 'miCut', comment: ['&& denotes a mnemonic'] }, "&&Cut"), 'editor.action.clipboardCutAction', 'cut');
            copy = this.createRoleMenuItem(nls.localize({ key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "C&&opy"), 'editor.action.clipboardCopyAction', 'copy');
            paste = this.createRoleMenuItem(nls.localize({ key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"), 'editor.action.clipboardPasteAction', 'paste');
            selectAll = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"), 'editor.action.selectAll', function (devTools) { return devTools.selectAll(); });
        }
        else {
            undo = this.createMenuItem(nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"), 'undo');
            redo = this.createMenuItem(nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"), 'redo');
            cut = this.createMenuItem(nls.localize({ key: 'miCut', comment: ['&& denotes a mnemonic'] }, "&&Cut"), 'editor.action.clipboardCutAction');
            copy = this.createMenuItem(nls.localize({ key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "C&&opy"), 'editor.action.clipboardCopyAction');
            paste = this.createMenuItem(nls.localize({ key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"), 'editor.action.clipboardPasteAction');
            selectAll = this.createMenuItem(nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"), 'editor.action.selectAll');
        }
        var find = this.createMenuItem(nls.localize({ key: 'miFind', comment: ['&& denotes a mnemonic'] }, "&&Find"), 'actions.find');
        var replace = this.createMenuItem(nls.localize({ key: 'miReplace', comment: ['&& denotes a mnemonic'] }, "&&Replace"), 'editor.action.startFindReplaceAction');
        var findInFiles = this.createMenuItem(nls.localize({ key: 'miFindInFiles', comment: ['&& denotes a mnemonic'] }, "Find &&in Files"), 'workbench.view.search');
        var replaceInFiles = this.createMenuItem(nls.localize({ key: 'miReplaceInFiles', comment: ['&& denotes a mnemonic'] }, "Replace &&in Files"), 'workbench.action.replaceInFiles');
        [
            undo,
            redo,
            __separator__(),
            cut,
            copy,
            paste,
            selectAll,
            __separator__(),
            find,
            replace,
            __separator__(),
            findInFiles,
            replaceInFiles
        ].forEach(function (item) { return winLinuxEditMenu.append(item); });
    };
    VSCodeMenu.prototype.setViewMenu = function (viewMenu) {
        var _this = this;
        var explorer = this.createMenuItem(nls.localize({ key: 'miViewExplorer', comment: ['&& denotes a mnemonic'] }, "&&Explorer"), 'workbench.view.explorer');
        var search = this.createMenuItem(nls.localize({ key: 'miViewSearch', comment: ['&& denotes a mnemonic'] }, "&&Search"), 'workbench.view.search');
        var git = this.createMenuItem(nls.localize({ key: 'miViewGit', comment: ['&& denotes a mnemonic'] }, "&&Git"), 'workbench.view.git');
        var debug = this.createMenuItem(nls.localize({ key: 'miViewDebug', comment: ['&& denotes a mnemonic'] }, "&&Debug"), 'workbench.view.debug');
        var extensions = this.createMenuItem(nls.localize({ key: 'miViewExtensions', comment: ['&& denotes a mnemonic'] }, "E&&xtensions"), 'workbench.view.extensions');
        var output = this.createMenuItem(nls.localize({ key: 'miToggleOutput', comment: ['&& denotes a mnemonic'] }, "&&Output"), 'workbench.action.output.toggleOutput');
        var debugConsole = this.createMenuItem(nls.localize({ key: 'miToggleDebugConsole', comment: ['&& denotes a mnemonic'] }, "De&&bug Console"), 'workbench.debug.action.toggleRepl');
        var integratedTerminal = this.createMenuItem(nls.localize({ key: 'miToggleIntegratedTerminal', comment: ['&& denotes a mnemonic'] }, "&&Integrated Terminal"), 'workbench.action.terminal.toggleTerminal');
        var problems = this.createMenuItem(nls.localize({ key: 'miMarker', comment: ['&& denotes a mnemonic'] }, "&&Problems"), 'workbench.actions.view.problems');
        var commands = this.createMenuItem(nls.localize({ key: 'miCommandPalette', comment: ['&& denotes a mnemonic'] }, "&&Command Palette..."), 'workbench.action.showCommands');
        var fullscreen = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miToggleFullScreen', comment: ['&& denotes a mnemonic'] }, "Toggle &&Full Screen")), accelerator: this.getAccelerator('workbench.action.toggleFullScreen'), click: function () { return _this.windowsService.getLastActiveWindow().toggleFullScreen(); }, enabled: this.windowsService.getWindowCount() > 0 });
        var toggleMenuBar = this.createMenuItem(nls.localize({ key: 'miToggleMenuBar', comment: ['&& denotes a mnemonic'] }, "Toggle Menu &&Bar"), 'workbench.action.toggleMenuBar');
        var splitEditor = this.createMenuItem(nls.localize({ key: 'miSplitEditor', comment: ['&& denotes a mnemonic'] }, "Split &&Editor"), 'workbench.action.splitEditor');
        var toggleSidebar = this.createMenuItem(nls.localize({ key: 'miToggleSidebar', comment: ['&& denotes a mnemonic'] }, "&&Toggle Side Bar"), 'workbench.action.toggleSidebarVisibility');
        var moveSidebar = this.createMenuItem(nls.localize({ key: 'miMoveSidebar', comment: ['&& denotes a mnemonic'] }, "&&Move Side Bar"), 'workbench.action.toggleSidebarPosition');
        var togglePanel = this.createMenuItem(nls.localize({ key: 'miTogglePanel', comment: ['&& denotes a mnemonic'] }, "Toggle &&Panel"), 'workbench.action.togglePanel');
        var toggleStatusbar = this.createMenuItem(nls.localize({ key: 'miToggleStatusbar', comment: ['&& denotes a mnemonic'] }, "&&Toggle Status Bar"), 'workbench.action.toggleStatusbarVisibility');
        var toggleWordWrap = this.createMenuItem(nls.localize({ key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] }, "Toggle &&Word Wrap"), 'editor.action.toggleWordWrap');
        var toggleRenderWhitespace = this.createMenuItem(nls.localize({ key: 'miToggleRenderWhitespace', comment: ['&& denotes a mnemonic'] }, "Toggle &&Render Whitespace"), 'editor.action.toggleRenderWhitespace');
        var toggleRenderControlCharacters = this.createMenuItem(nls.localize({ key: 'miToggleRenderControlCharacters', comment: ['&& denotes a mnemonic'] }, "Toggle &&Control Characters"), 'editor.action.toggleRenderControlCharacter');
        var zoomIn = this.createMenuItem(nls.localize({ key: 'miZoomIn', comment: ['&& denotes a mnemonic'] }, "&&Zoom In"), 'workbench.action.zoomIn');
        var zoomOut = this.createMenuItem(nls.localize({ key: 'miZoomOut', comment: ['&& denotes a mnemonic'] }, "Zoom O&&ut"), 'workbench.action.zoomOut');
        var resetZoom = this.createMenuItem(nls.localize({ key: 'miZoomReset', comment: ['&& denotes a mnemonic'] }, "&&Reset Zoom"), 'workbench.action.zoomReset');
        arrays.coalesce([
            commands,
            __separator__(),
            explorer,
            search,
            git,
            debug,
            extensions,
            __separator__(),
            output,
            problems,
            debugConsole,
            integratedTerminal,
            __separator__(),
            fullscreen,
            platform.isWindows || platform.isLinux ? toggleMenuBar : void 0,
            __separator__(),
            splitEditor,
            moveSidebar,
            toggleSidebar,
            togglePanel,
            toggleStatusbar,
            __separator__(),
            toggleWordWrap,
            toggleRenderWhitespace,
            toggleRenderControlCharacters,
            __separator__(),
            zoomIn,
            zoomOut,
            resetZoom
        ]).forEach(function (item) { return viewMenu.append(item); });
    };
    VSCodeMenu.prototype.setGotoMenu = function (gotoMenu) {
        var back = this.createMenuItem(nls.localize({ key: 'miBack', comment: ['&& denotes a mnemonic'] }, "&&Back"), 'workbench.action.navigateBack');
        var forward = this.createMenuItem(nls.localize({ key: 'miForward', comment: ['&& denotes a mnemonic'] }, "&&Forward"), 'workbench.action.navigateForward');
        var switchEditorMenu = new electron_1.Menu();
        var nextEditor = this.createMenuItem(nls.localize({ key: 'miNextEditor', comment: ['&& denotes a mnemonic'] }, "&&Next Editor"), 'workbench.action.nextEditor');
        var previousEditor = this.createMenuItem(nls.localize({ key: 'miPreviousEditor', comment: ['&& denotes a mnemonic'] }, "&&Previous Editor"), 'workbench.action.previousEditor');
        var nextEditorInGroup = this.createMenuItem(nls.localize({ key: 'miNextEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Used Editor in Group"), 'workbench.action.openNextRecentlyUsedEditorInGroup');
        var previousEditorInGroup = this.createMenuItem(nls.localize({ key: 'miPreviousEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Used Editor in Group"), 'workbench.action.openPreviousRecentlyUsedEditorInGroup');
        [
            nextEditor,
            previousEditor,
            __separator__(),
            nextEditorInGroup,
            previousEditorInGroup
        ].forEach(function (item) { return switchEditorMenu.append(item); });
        var switchEditor = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miSwitchEditor', comment: ['&& denotes a mnemonic'] }, "Switch &&Editor")), submenu: switchEditorMenu, enabled: true });
        var switchGroupMenu = new electron_1.Menu();
        var focusFirstGroup = this.createMenuItem(nls.localize({ key: 'miFocusFirstGroup', comment: ['&& denotes a mnemonic'] }, "&&Left Group"), 'workbench.action.focusFirstEditorGroup');
        var focusSecondGroup = this.createMenuItem(nls.localize({ key: 'miFocusSecondGroup', comment: ['&& denotes a mnemonic'] }, "&&Center Group"), 'workbench.action.focusSecondEditorGroup');
        var focusThirdGroup = this.createMenuItem(nls.localize({ key: 'miFocusThirdGroup', comment: ['&& denotes a mnemonic'] }, "&&Right Group"), 'workbench.action.focusThirdEditorGroup');
        var nextGroup = this.createMenuItem(nls.localize({ key: 'miNextGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Group"), 'workbench.action.focusNextGroup');
        var previousGroup = this.createMenuItem(nls.localize({ key: 'miPreviousGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Group"), 'workbench.action.focusPreviousGroup');
        [
            focusFirstGroup,
            focusSecondGroup,
            focusThirdGroup,
            __separator__(),
            nextGroup,
            previousGroup
        ].forEach(function (item) { return switchGroupMenu.append(item); });
        var switchGroup = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miSwitchGroup', comment: ['&& denotes a mnemonic'] }, "Switch &&Group")), submenu: switchGroupMenu, enabled: true });
        var gotoFile = this.createMenuItem(nls.localize({ key: 'miGotoFile', comment: ['&& denotes a mnemonic'] }, "Go to &&File..."), 'workbench.action.quickOpen');
        var gotoSymbolInFile = this.createMenuItem(nls.localize({ key: 'miGotoSymbolInFile', comment: ['&& denotes a mnemonic'] }, "Go to &&Symbol in File..."), 'workbench.action.gotoSymbol');
        var gotoSymbolInWorkspace = this.createMenuItem(nls.localize({ key: 'miGotoSymbolInWorkspace', comment: ['&& denotes a mnemonic'] }, "Go to Symbol in &&Workspace..."), 'workbench.action.showAllSymbols');
        var gotoDefinition = this.createMenuItem(nls.localize({ key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Definition"), 'editor.action.goToDeclaration');
        var gotoLine = this.createMenuItem(nls.localize({ key: 'miGotoLine', comment: ['&& denotes a mnemonic'] }, "Go to &&Line..."), 'workbench.action.gotoLine');
        [
            back,
            forward,
            __separator__(),
            switchEditor,
            switchGroup,
            __separator__(),
            gotoFile,
            gotoSymbolInFile,
            gotoSymbolInWorkspace,
            gotoDefinition,
            gotoLine
        ].forEach(function (item) { return gotoMenu.append(item); });
    };
    VSCodeMenu.prototype.setMacWindowMenu = function (macWindowMenu) {
        var minimize = new electron_1.MenuItem({ label: nls.localize('mMinimize', "Minimize"), role: 'minimize', accelerator: 'Command+M', enabled: this.windowsService.getWindowCount() > 0 });
        var close = new electron_1.MenuItem({ label: nls.localize('mClose', "Close"), role: 'close', accelerator: 'Command+W', enabled: this.windowsService.getWindowCount() > 0 });
        var bringAllToFront = new electron_1.MenuItem({ label: nls.localize('mBringToFront', "Bring All to Front"), role: 'front', enabled: this.windowsService.getWindowCount() > 0 });
        [
            minimize,
            close,
            __separator__(),
            bringAllToFront
        ].forEach(function (item) { return macWindowMenu.append(item); });
    };
    VSCodeMenu.prototype.toggleDevTools = function () {
        var w = this.windowsService.getFocusedWindow();
        if (w && w.win) {
            w.win.webContents.toggleDevTools();
        }
    };
    VSCodeMenu.prototype.setHelpMenu = function (helpMenu) {
        var _this = this;
        var toggleDevToolsItem = new electron_1.MenuItem({
            label: mnemonicLabel(nls.localize({ key: 'miToggleDevTools', comment: ['&& denotes a mnemonic'] }, "&&Toggle Developer Tools")),
            accelerator: this.getAccelerator('workbench.action.toggleDevTools'),
            click: function () { return _this.toggleDevTools(); },
            enabled: (this.windowsService.getWindowCount() > 0)
        });
        var showAccessibilityOptions = new electron_1.MenuItem({
            label: mnemonicLabel(nls.localize({ key: 'miAccessibilityOptions', comment: ['&& denotes a mnemonic'] }, "Accessibility &&Options")),
            accelerator: null,
            click: function () {
                _this.windowsService.openAccessibilityOptions();
            }
        });
        var reportIssuesItem = null;
        if (this.envService.product.reportIssueUrl) {
            var label = nls.localize({ key: 'miReportIssues', comment: ['&& denotes a mnemonic'] }, "Report &&Issues");
            if (this.windowsService.getWindowCount() > 0) {
                reportIssuesItem = this.createMenuItem(label, 'workbench.action.reportIssues');
            }
            else {
                reportIssuesItem = new electron_1.MenuItem({ label: mnemonicLabel(label), click: function () { return _this.openUrl(product_1.default.reportIssueUrl, 'openReportIssues'); } });
            }
        }
        arrays.coalesce([
            this.envService.product.documentationUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miDocumentation', comment: ['&& denotes a mnemonic'] }, "&&Documentation")), click: function () { return _this.openUrl(_this.envService.product.documentationUrl, 'openDocumentationUrl'); } }) : null,
            this.envService.product.releaseNotesUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miReleaseNotes', comment: ['&& denotes a mnemonic'] }, "&&Release Notes")), click: function () { return _this.windowsService.sendToFocused('vscode:runAction', 'update.showCurrentReleaseNotes'); } }) : null,
            (this.envService.product.documentationUrl || this.envService.product.releaseNotesUrl) ? __separator__() : null,
            this.envService.product.twitterUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miTwitter', comment: ['&& denotes a mnemonic'] }, "&&Join us on Twitter")), click: function () { return _this.openUrl(_this.envService.product.twitterUrl, 'openTwitterUrl'); } }) : null,
            this.envService.product.requestFeatureUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miUserVoice', comment: ['&& denotes a mnemonic'] }, "&&Search Feature Requests")), click: function () { return _this.openUrl(_this.envService.product.requestFeatureUrl, 'openUserVoiceUrl'); } }) : null,
            reportIssuesItem,
            (this.envService.product.twitterUrl || this.envService.product.requestFeatureUrl || this.envService.product.reportIssueUrl) ? __separator__() : null,
            this.envService.product.licenseUrl ? new electron_1.MenuItem({
                label: mnemonicLabel(nls.localize({ key: 'miLicense', comment: ['&& denotes a mnemonic'] }, "&&View License")), click: function () {
                    if (platform.language) {
                        var queryArgChar = _this.envService.product.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                        _this.openUrl("" + _this.envService.product.licenseUrl + queryArgChar + "lang=" + platform.language, 'openLicenseUrl');
                    }
                    else {
                        _this.openUrl(_this.envService.product.licenseUrl, 'openLicenseUrl');
                    }
                }
            }) : null,
            this.envService.product.privacyStatementUrl ? new electron_1.MenuItem({
                label: mnemonicLabel(nls.localize({ key: 'miPrivacyStatement', comment: ['&& denotes a mnemonic'] }, "&&Privacy Statement")), click: function () {
                    if (platform.language) {
                        var queryArgChar = _this.envService.product.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                        _this.openUrl("" + _this.envService.product.privacyStatementUrl + queryArgChar + "lang=" + platform.language, 'openPrivacyStatement');
                    }
                    else {
                        _this.openUrl(_this.envService.product.privacyStatementUrl, 'openPrivacyStatement');
                    }
                }
            }) : null,
            (this.envService.product.licenseUrl || this.envService.product.privacyStatementUrl) ? __separator__() : null,
            toggleDevToolsItem,
            platform.isWindows && product_1.default.quality !== 'stable' ? showAccessibilityOptions : null
        ]).forEach(function (item) { return helpMenu.append(item); });
        if (!platform.isMacintosh) {
            var updateMenuItems = this.getUpdateMenuItems();
            if (updateMenuItems.length) {
                helpMenu.append(__separator__());
                updateMenuItems.forEach(function (i) { return helpMenu.append(i); });
            }
            helpMenu.append(__separator__());
            helpMenu.append(new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miAbout', comment: ['&& denotes a mnemonic'] }, "&&About")), click: function () { return _this.openAboutDialog(); } }));
        }
    };
    VSCodeMenu.prototype.getUpdateMenuItems = function () {
        var _this = this;
        switch (this.updateService.state) {
            case update_manager_1.State.Uninitialized:
                return [];
            case update_manager_1.State.UpdateDownloaded:
                var update_1 = this.updateService.availableUpdate;
                return [new electron_1.MenuItem({
                        label: nls.localize('miRestartToUpdate', "Restart To Update..."), click: function () {
                            _this.reportMenuActionTelemetry('RestartToUpdate');
                            update_1.quitAndUpdate();
                        }
                    })];
            case update_manager_1.State.CheckingForUpdate:
                return [new electron_1.MenuItem({ label: nls.localize('miCheckingForUpdates', "Checking For Updates..."), enabled: false })];
            case update_manager_1.State.UpdateAvailable:
                if (platform.isLinux) {
                    var update_2 = this.updateService.availableUpdate;
                    return [new electron_1.MenuItem({
                            label: nls.localize('miDownloadUpdate', "Download Available Update"), click: function () {
                                update_2.quitAndUpdate();
                            }
                        })];
                }
                var updateAvailableLabel = platform.isWindows
                    ? nls.localize('miDownloadingUpdate', "Downloading Update...")
                    : nls.localize('miInstallingUpdate', "Installing Update...");
                return [new electron_1.MenuItem({ label: updateAvailableLabel, enabled: false })];
            default:
                var result = [new electron_1.MenuItem({
                        label: nls.localize('miCheckForUpdates', "Check For Updates..."), click: function () { return setTimeout(function () {
                            _this.reportMenuActionTelemetry('CheckForUpdate');
                            _this.updateService.checkForUpdates(true);
                        }, 0); }
                    })];
                return result;
        }
    };
    VSCodeMenu.prototype.createMenuItem = function (arg1, arg2, arg3) {
        var _this = this;
        var label = mnemonicLabel(arg1);
        var click = (typeof arg2 === 'function') ? arg2 : function () { return _this.windowsService.sendToFocused('vscode:runAction', arg2); };
        var enabled = typeof arg3 === 'boolean' ? arg3 : this.windowsService.getWindowCount() > 0;
        var actionId;
        if (typeof arg2 === 'string') {
            actionId = arg2;
        }
        var options = {
            label: label,
            accelerator: this.getAccelerator(actionId),
            click: click,
            enabled: enabled
        };
        return new electron_1.MenuItem(options);
    };
    VSCodeMenu.prototype.createDevToolsAwareMenuItem = function (label, actionId, devToolsFocusedFn) {
        var _this = this;
        return new electron_1.MenuItem({
            label: mnemonicLabel(label),
            accelerator: this.getAccelerator(actionId),
            enabled: this.windowsService.getWindowCount() > 0,
            click: function () {
                var windowInFocus = _this.windowsService.getFocusedWindow();
                if (!windowInFocus) {
                    return;
                }
                if (windowInFocus.win.webContents.isDevToolsFocused()) {
                    devToolsFocusedFn(windowInFocus.win.webContents.devToolsWebContents);
                }
                else {
                    _this.windowsService.sendToFocused('vscode:runAction', actionId);
                }
            }
        });
    };
    VSCodeMenu.prototype.getAccelerator = function (actionId) {
        if (actionId) {
            var resolvedKeybinding = this.mapResolvedKeybindingToActionId[actionId];
            if (resolvedKeybinding) {
                return resolvedKeybinding; // keybinding is fully resolved
            }
            if (!this.keybindingsResolved) {
                this.actionIdKeybindingRequests.push(actionId); // keybinding needs to be resolved
            }
            var lastKnownKeybinding = this.mapLastKnownKeybindingToActionId[actionId];
            return lastKnownKeybinding; // return the last known keybining (chance of mismatch is very low unless it changed)
        }
        return void (0);
    };
    VSCodeMenu.prototype.openAboutDialog = function () {
        var lastActiveWindow = this.windowsService.getFocusedWindow() || this.windowsService.getLastActiveWindow();
        electron_1.dialog.showMessageBox(lastActiveWindow && lastActiveWindow.win, {
            title: this.envService.product.nameLong,
            type: 'info',
            message: this.envService.product.nameLong,
            detail: nls.localize('aboutDetail', "\nVersion {0}\nCommit {1}\nDate {2}\nShell {3}\nRenderer {4}\nNode {5}", electron_1.app.getVersion(), this.envService.product.commit || 'Unknown', this.envService.product.date || 'Unknown', process.versions['electron'], process.versions['chrome'], process.versions['node']),
            buttons: [nls.localize('okButton', "OK")],
            noLink: true
        }, function (result) { return null; });
        this.reportMenuActionTelemetry('showAboutDialog');
    };
    VSCodeMenu.prototype.openUrl = function (url, id) {
        electron_1.shell.openExternal(url);
        this.reportMenuActionTelemetry(id);
    };
    VSCodeMenu.prototype.reportMenuActionTelemetry = function (id) {
        this.windowsService.sendToFocused('vscode:telemetry', { eventName: 'workbenchActionExecuted', data: { id: id, from: 'menu' } });
    };
    VSCodeMenu.lastKnownKeybindingsMapStorageKey = 'lastKnownKeybindings';
    VSCodeMenu.MAX_MENU_RECENT_ENTRIES = 10;
    VSCodeMenu = __decorate([
        __param(0, storage_1.IStorageService),
        __param(1, update_manager_1.IUpdateService),
        __param(2, configuration_1.IConfigurationService),
        __param(3, windows_1.IWindowsService),
        __param(4, env_1.IEnvService)
    ], VSCodeMenu);
    return VSCodeMenu;
}());
exports.VSCodeMenu = VSCodeMenu;
function __separator__() {
    return new electron_1.MenuItem({ type: 'separator' });
}
function mnemonicLabel(label) {
    if (platform.isMacintosh) {
        return label.replace(/\(&&\w\)|&&/g, ''); // no mnemonic support on mac
    }
    return label.replace(/&&/g, '&');
}
function unMnemonicLabel(label) {
    if (platform.isMacintosh) {
        return label; // no mnemonic support on mac
    }
    return label.replace(/&/g, '&&');
}
