/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * A simple map to store value by a key object. Key can be any object that has toString() function to get
 * string value of the key.
 */
var LinkedMap = (function () {
    function LinkedMap() {
        this.map = Object.create(null);
        this._size = 0;
    }
    Object.defineProperty(LinkedMap.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    LinkedMap.prototype.get = function (k) {
        var value = this.peek(k);
        return value ? value : null;
    };
    LinkedMap.prototype.getOrSet = function (k, t) {
        var res = this.get(k);
        if (res) {
            return res;
        }
        this.set(k, t);
        return t;
    };
    LinkedMap.prototype.keys = function () {
        var keys = [];
        for (var key in this.map) {
            keys.push(this.map[key].key);
        }
        return keys;
    };
    LinkedMap.prototype.values = function () {
        var values = [];
        for (var key in this.map) {
            values.push(this.map[key].value);
        }
        return values;
    };
    LinkedMap.prototype.entries = function () {
        var entries = [];
        for (var key in this.map) {
            entries.push(this.map[key]);
        }
        return entries;
    };
    LinkedMap.prototype.set = function (k, t) {
        if (this.get(k)) {
            return false; // already present!
        }
        this.push(k, t);
        return true;
    };
    LinkedMap.prototype.delete = function (k) {
        var value = this.get(k);
        if (value) {
            this.pop(k);
            return value;
        }
        return null;
    };
    LinkedMap.prototype.has = function (k) {
        return !!this.get(k);
    };
    LinkedMap.prototype.clear = function () {
        this.map = Object.create(null);
        this._size = 0;
    };
    LinkedMap.prototype.push = function (key, value) {
        var entry = { key: key, value: value };
        this.map[key.toString()] = entry;
        this._size++;
    };
    LinkedMap.prototype.pop = function (k) {
        delete this.map[k.toString()];
        this._size--;
    };
    LinkedMap.prototype.peek = function (k) {
        var entry = this.map[k.toString()];
        return entry ? entry.value : null;
    };
    return LinkedMap;
}());
exports.LinkedMap = LinkedMap;
/**
 * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,
 * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,
 * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).
 */
var BoundedLinkedMap = (function () {
    function BoundedLinkedMap(limit, ratio) {
        if (limit === void 0) { limit = Number.MAX_VALUE; }
        if (ratio === void 0) { ratio = 1; }
        this.limit = limit;
        this.map = Object.create(null);
        this._size = 0;
        this.ratio = limit * ratio;
    }
    Object.defineProperty(BoundedLinkedMap.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    BoundedLinkedMap.prototype.set = function (key, value) {
        if (this.map[key]) {
            return false; // already present!
        }
        var entry = { key: key, value: value };
        this.push(entry);
        if (this._size > this.limit) {
            this.trim();
        }
        return true;
    };
    BoundedLinkedMap.prototype.get = function (key) {
        var entry = this.map[key];
        return entry ? entry.value : null;
    };
    BoundedLinkedMap.prototype.getOrSet = function (k, t) {
        var res = this.get(k);
        if (res) {
            return res;
        }
        this.set(k, t);
        return t;
    };
    BoundedLinkedMap.prototype.delete = function (key) {
        var entry = this.map[key];
        if (entry) {
            this.map[key] = void 0;
            this._size--;
            if (entry.next) {
                entry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]
            }
            else {
                this.head = entry.prev; // [A]-[x] = [A]
            }
            if (entry.prev) {
                entry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]
            }
            else {
                this.tail = entry.next; // [x]-[A] = [A]
            }
            return entry.value;
        }
        return null;
    };
    BoundedLinkedMap.prototype.has = function (key) {
        return !!this.map[key];
    };
    BoundedLinkedMap.prototype.clear = function () {
        this.map = Object.create(null);
        this._size = 0;
        this.head = null;
        this.tail = null;
    };
    BoundedLinkedMap.prototype.push = function (entry) {
        if (this.head) {
            // [A]-[B] = [A]-[B]->[X]
            entry.prev = this.head;
            this.head.next = entry;
        }
        if (!this.tail) {
            this.tail = entry;
        }
        this.head = entry;
        this.map[entry.key] = entry;
        this._size++;
    };
    BoundedLinkedMap.prototype.trim = function () {
        if (this.tail) {
            // Remove all elements until ratio is reached
            if (this.ratio < this.limit) {
                var index = 0;
                var current = this.tail;
                while (current.next) {
                    // Remove the entry
                    this.map[current.key] = void 0;
                    this._size--;
                    // if we reached the element that overflows our ratio condition
                    // make its next element the new tail of the Map and adjust the size
                    if (index === this.ratio) {
                        this.tail = current.next;
                        this.tail.prev = null;
                        break;
                    }
                    // Move on
                    current = current.next;
                    index++;
                }
            }
            else {
                this.map[this.tail.key] = void 0;
                this._size--;
                // [x]-[B] = [B]
                this.tail = this.tail.next;
                this.tail.prev = null;
            }
        }
    };
    return BoundedLinkedMap;
}());
exports.BoundedLinkedMap = BoundedLinkedMap;
/**
 * A subclass of Map<T> that makes an entry the MRU entry as soon
 * as it is being accessed. In combination with the limit for the
 * maximum number of elements in the cache, it helps to remove those
 * entries from the cache that are LRU.
 */
var LRUCache = (function (_super) {
    __extends(LRUCache, _super);
    function LRUCache(limit) {
        return _super.call(this, limit) || this;
    }
    LRUCache.prototype.get = function (key) {
        // Upon access of an entry, make it the head of
        // the linked map so that it is the MRU element
        var entry = this.map[key];
        if (entry) {
            this.delete(key);
            this.push(entry);
            return entry.value;
        }
        return null;
    };
    return LRUCache;
}(BoundedLinkedMap));
exports.LRUCache = LRUCache;
/**
 * A trie map that allows for fast look up when keys are substrings
 * to the actual search keys (dir/subdir-problem).
 */
var TrieMap = (function () {
    function TrieMap(splitter) {
        this._root = { children: Object.create(null) };
        this._splitter = splitter;
    }
    TrieMap.prototype.insert = function (path, element) {
        var parts = this._splitter(path);
        var i = 0;
        // find insertion node
        var node = this._root;
        for (; i < parts.length; i++) {
            var child = node.children[parts[i]];
            if (child) {
                node = child;
                continue;
            }
            break;
        }
        // create new nodes
        var newNode;
        for (; i < parts.length; i++) {
            newNode = { children: Object.create(null) };
            node.children[parts[i]] = newNode;
            node = newNode;
        }
        node.element = element;
    };
    TrieMap.prototype.lookUp = function (path) {
        var parts = this._splitter(path);
        var children = this._root.children;
        var node;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            node = children[part];
            if (!node) {
                return;
            }
            children = node.children;
        }
        return node.element;
    };
    TrieMap.prototype.findSubstr = function (path) {
        var parts = this._splitter(path);
        var lastNode;
        var children = this._root.children;
        for (var _i = 0, parts_2 = parts; _i < parts_2.length; _i++) {
            var part = parts_2[_i];
            var node = children[part];
            if (!node) {
                break;
            }
            if (node.element) {
                lastNode = node;
            }
            children = node.children;
        }
        // return the last matching node
        // that had an element
        if (lastNode) {
            return lastNode.element;
        }
    };
    TrieMap.prototype.findSuperstr = function (path) {
        var parts = this._splitter(path);
        var children = this._root.children;
        var node;
        for (var _i = 0, parts_3 = parts; _i < parts_3.length; _i++) {
            var part = parts_3[_i];
            node = children[part];
            if (!node) {
                return;
            }
            children = node.children;
        }
        var result = new TrieMap(this._splitter);
        result._root = node;
        return result;
    };
    return TrieMap;
}());
TrieMap.PathSplitter = function (s) { return s.split(/[\\/]/).filter(function (s) { return !!s; }); };
exports.TrieMap = TrieMap;
