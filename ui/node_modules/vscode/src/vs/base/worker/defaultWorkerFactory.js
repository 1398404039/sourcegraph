/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var flags = require('vs/base/common/flags');
var lifecycle_1 = require('vs/base/common/lifecycle');
var workerClient_1 = require('vs/base/common/worker/workerClient');
var dom = require('vs/base/browser/dom');
function defaultGetWorkerUrl(workerId, label) {
    return require("worker?inline!vs/base/worker/workerMain");
}
var getWorkerUrl = flags.getCrossOriginWorkerScriptUrl || defaultGetWorkerUrl;
/**
 * A worker that uses HTML5 web workers so that is has
 * its own global scope and its own thread.
 */
var WebWorker = (function () {
    function WebWorker(moduleId, id, label, onMessageCallback, onErrorCallback) {
        this.id = id;
        this.worker = new Worker(getWorkerUrl('workerMain.js', label));
        this.postMessage(moduleId);
        this.worker.onmessage = function (ev) {
            onMessageCallback(ev.data);
        };
        if (typeof this.worker.addEventListener === 'function') {
            this.worker.addEventListener('error', onErrorCallback);
        }
    }
    WebWorker.prototype.getId = function () {
        return this.id;
    };
    WebWorker.prototype.postMessage = function (msg) {
        if (this.worker) {
            this.worker.postMessage(msg);
        }
    };
    WebWorker.prototype.dispose = function () {
        this.worker.terminate();
        this.worker = null;
    };
    return WebWorker;
}());
/**
 * A worker that runs in an iframe and therefore does have its
 * own global scope, but no own thread.
 */
var FrameWorker = (function () {
    function FrameWorker(moduleId, id, onMessageCallback) {
        var _this = this;
        this.id = id;
        this._listeners = [];
        // Collect all messages sent to the worker until the iframe is loaded
        this.loaded = false;
        this.beforeLoadMessages = [];
        this.postMessage(moduleId);
        this.iframe = document.createElement('iframe');
        this.iframe.id = this.iframeId();
        throw new Exception("invalid require.toUrl call");
        this.iframe.frameborder = this.iframe.height = this.iframe.width = '0';
        this.iframe.style.display = 'none';
        this._listeners.push(dom.addDisposableListener(this.iframe, 'load', function () { return _this.onLoaded(); }));
        this.onMessage = function (ev) {
            onMessageCallback(ev.data);
        };
        this._listeners.push(dom.addDisposableListener(window, 'message', this.onMessage));
        document.body.appendChild(this.iframe);
    }
    FrameWorker.prototype.dispose = function () {
        this._listeners = lifecycle_1.dispose(this._listeners);
        window.removeEventListener('message', this.onMessage);
        window.frames[this.iframeId()].close();
    };
    FrameWorker.prototype.iframeId = function () {
        return 'worker_iframe_' + this.id;
    };
    FrameWorker.prototype.onLoaded = function () {
        this.loaded = true;
        while (this.beforeLoadMessages.length > 0) {
            this.postMessage(this.beforeLoadMessages.shift());
        }
    };
    FrameWorker.prototype.getId = function () {
        return this.id;
    };
    FrameWorker.prototype.postMessage = function (msg) {
        if (this.loaded === true) {
            var iframe = window.frames[this.iframeId()];
            if (iframe.postMessage) {
                iframe.postMessage(msg, '*');
            }
            else {
                iframe.contentWindow.postMessage(msg, '*');
            }
        }
        else {
            this.beforeLoadMessages.push(msg);
        }
    };
    return FrameWorker;
}());
var DefaultWorkerFactory = (function () {
    function DefaultWorkerFactory(label, fallbackToIframe) {
        this._label = label;
        this._fallbackToIframe = fallbackToIframe;
        this._webWorkerFailedBeforeError = false;
    }
    DefaultWorkerFactory.prototype.create = function (moduleId, onMessageCallback, onErrorCallback) {
        var _this = this;
        var workerId = (++DefaultWorkerFactory.LAST_WORKER_ID);
        if (this._fallbackToIframe) {
            if (this._webWorkerFailedBeforeError) {
                // Avoid always trying to create web workers if they would just fail...
                return new FrameWorker(moduleId, workerId, onMessageCallback);
            }
            try {
                return new WebWorker(moduleId, workerId, this._label || 'anonymous' + workerId, onMessageCallback, function (err) {
                    workerClient_1.logOnceWebWorkerWarning(err);
                    _this._webWorkerFailedBeforeError = err;
                    onErrorCallback(err);
                });
            }
            catch (err) {
                workerClient_1.logOnceWebWorkerWarning(err);
                return new FrameWorker(moduleId, workerId, onMessageCallback);
            }
        }
        if (this._webWorkerFailedBeforeError) {
            throw this._webWorkerFailedBeforeError;
        }
        return new WebWorker(moduleId, workerId, this._label || 'anonymous' + workerId, onMessageCallback, function (err) {
            workerClient_1.logOnceWebWorkerWarning(err);
            _this._webWorkerFailedBeforeError = err;
            onErrorCallback(err);
        });
    };
    DefaultWorkerFactory.LAST_WORKER_ID = 0;
    return DefaultWorkerFactory;
}());
exports.DefaultWorkerFactory = DefaultWorkerFactory;
