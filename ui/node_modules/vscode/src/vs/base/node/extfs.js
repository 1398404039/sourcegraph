/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var uuid = require('vs/base/common/uuid');
var strings = require('vs/base/common/strings');
var platform = require('vs/base/common/platform');
var flow = require('vs/base/node/flow');
var fs = require('fs');
var paths = require('path');
var loop = flow.loop;
function readdir(path, callback) {
    // Mac: uses NFD unicode form on disk, but we want NFC
    // See also https://github.com/nodejs/node/issues/2165
    if (platform.isMacintosh) {
        return readdirNormalize(path, function (error, children) {
            if (error) {
                return callback(error, null);
            }
            return callback(null, children.map(function (c) { return strings.normalizeNFC(c); }));
        });
    }
    return readdirNormalize(path, callback);
}
exports.readdir = readdir;
function readdirNormalize(path, callback) {
    fs.readdir(path, function (error, children) {
        if (error) {
            return callback(error, null);
        }
        // Bug in node: In some environments we get "." and ".." as entries from the call to readdir().
        // For example Sharepoint via WebDav on Windows includes them. We never want those
        // entries in the result set though because they are not valid children of the folder
        // for our concerns.
        // See https://github.com/nodejs/node/issues/4002
        return callback(null, children.filter(function (c) { return c !== '.' && c !== '..'; }));
    });
}
function mkdirp(path, mode, callback) {
    fs.exists(path, function (exists) {
        if (exists) {
            return isDirectory(path, function (err, itIs) {
                if (err) {
                    return callback(err);
                }
                if (!itIs) {
                    return callback(new Error('"' + path + '" is not a directory.'));
                }
                callback(null);
            });
        }
        mkdirp(paths.dirname(path), mode, function (err) {
            if (err) {
                callback(err);
                return;
            }
            if (mode) {
                fs.mkdir(path, mode, function (error) {
                    if (error) {
                        return callback(error);
                    }
                    fs.chmod(path, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                });
            }
            else {
                fs.mkdir(path, null, callback);
            }
        });
    });
}
exports.mkdirp = mkdirp;
function isDirectory(path, callback) {
    fs.stat(path, function (error, stat) {
        if (error) {
            return callback(error);
        }
        callback(null, stat.isDirectory());
    });
}
function copy(source, target, callback, copiedSources) {
    if (!copiedSources) {
        copiedSources = Object.create(null);
    }
    fs.stat(source, function (error, stat) {
        if (error) {
            return callback(error);
        }
        if (!stat.isDirectory()) {
            return pipeFs(source, target, stat.mode & 511, callback);
        }
        if (copiedSources[source]) {
            return callback(null); // escape when there are cycles (can happen with symlinks)
        }
        else {
            copiedSources[source] = true; // remember as copied
        }
        mkdirp(target, stat.mode & 511, function (err) {
            readdir(source, function (err, files) {
                loop(files, function (file, clb) {
                    copy(paths.join(source, file), paths.join(target, file), clb, copiedSources);
                }, callback);
            });
        });
    });
}
exports.copy = copy;
function pipeFs(source, target, mode, callback) {
    var callbackHandled = false;
    var readStream = fs.createReadStream(source);
    var writeStream = fs.createWriteStream(target, { mode: mode });
    var onError = function (error) {
        if (!callbackHandled) {
            callbackHandled = true;
            callback(error);
        }
    };
    readStream.on('error', onError);
    writeStream.on('error', onError);
    readStream.on('end', function () {
        writeStream.end(function () {
            if (!callbackHandled) {
                callbackHandled = true;
                fs.chmod(target, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
            }
        });
    });
    // In node 0.8 there is no easy way to find out when the pipe operation has finished. As such, we use the end property = false
    // so that we are in charge of calling end() on the write stream and we will be notified when the write stream is really done.
    // We can do this because file streams have an end() method that allows to pass in a callback.
    // In node 0.10 there is an event 'finish' emitted from the write stream that can be used. See
    // https://groups.google.com/forum/?fromgroups=#!topic/nodejs/YWQ1sRoXOdI
    readStream.pipe(writeStream, { end: false });
}
// Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
// after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
// will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
// However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
function del(path, tmpFolder, callback, done) {
    fs.exists(path, function (exists) {
        if (!exists) {
            return callback(null);
        }
        fs.stat(path, function (err, stat) {
            if (err || !stat) {
                return callback(err);
            }
            // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
            // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
            if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                return rmRecursive(path, callback);
            }
            var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
            fs.rename(path, pathInTemp, function (error) {
                if (error) {
                    return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                }
                // Return early since the move succeeded
                callback(null);
                // do the heavy deletion outside the callers callback
                rmRecursive(pathInTemp, function (error) {
                    if (error) {
                        console.error(error);
                    }
                    if (done) {
                        done(error);
                    }
                });
            });
        });
    });
}
exports.del = del;
function rmRecursive(path, callback) {
    if (path === '\\' || path === '/') {
        return callback(new Error('Will not delete root!'));
    }
    fs.exists(path, function (exists) {
        if (!exists) {
            callback(null);
        }
        else {
            fs.lstat(path, function (err, stat) {
                if (err || !stat) {
                    callback(err);
                }
                else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                    var mode = stat.mode;
                    if (!(mode & 128)) {
                        fs.chmod(path, mode | 128, function (err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                fs.unlink(path, callback);
                            }
                        });
                    }
                    else {
                        fs.unlink(path, callback);
                    }
                }
                else {
                    readdir(path, function (err, children) {
                        if (err || !children) {
                            callback(err);
                        }
                        else if (children.length === 0) {
                            fs.rmdir(path, callback);
                        }
                        else {
                            var firstError_1 = null;
                            var childrenLeft_1 = children.length;
                            children.forEach(function (child) {
                                rmRecursive(paths.join(path, child), function (err) {
                                    childrenLeft_1--;
                                    if (err) {
                                        firstError_1 = firstError_1 || err;
                                    }
                                    if (childrenLeft_1 === 0) {
                                        if (firstError_1) {
                                            callback(firstError_1);
                                        }
                                        else {
                                            fs.rmdir(path, callback);
                                        }
                                    }
                                });
                            });
                        }
                    });
                }
            });
        }
    });
}
function mv(source, target, callback) {
    if (source === target) {
        return callback(null);
    }
    function updateMtime(err) {
        if (err) {
            return callback(err);
        }
        fs.stat(target, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (stat.isDirectory()) {
                return callback(null);
            }
            fs.open(target, 'a', null, function (err, fd) {
                if (err) {
                    return callback(err);
                }
                fs.futimes(fd, stat.atime, new Date(), function (err) {
                    if (err) {
                        return callback(err);
                    }
                    fs.close(fd, callback);
                });
            });
        });
    }
    // Try native rename()
    fs.rename(source, target, function (err) {
        if (!err) {
            return updateMtime(null);
        }
        // In two cases we fallback to classic copy and delete:
        //
        // 1.) The EXDEV error indicates that source and target are on different devices
        // In this case, fallback to using a copy() operation as there is no way to
        // rename() between different devices.
        //
        // 2.) The user tries to rename a file/folder that ends with a dot. This is not
        // really possible to move then, at least on UNC devices.
        if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
            return copy(source, target, function (err) {
                if (err) {
                    return callback(err);
                }
                rmRecursive(source, updateMtime);
            });
        }
        return callback(err);
    });
}
exports.mv = mv;
// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk
// We do this in cases where we want to make sure the data is really on disk and
// not in some cache.
//
// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194
var canFlush = true;
function writeFileAndFlush(path, data, options, callback) {
    if (!canFlush) {
        return fs.writeFile(path, data, options, callback);
    }
    if (!options) {
        options = { encoding: 'utf8', mode: 438, flag: 'w' };
    }
    else if (typeof options === 'string') {
        options = { encoding: options, mode: 438, flag: 'w' };
    }
    // Open the file with same flags and mode as fs.writeFile()
    fs.open(path, options.flag, options.mode, function (openError, fd) {
        if (openError) {
            return callback(openError);
        }
        // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
        fs.writeFile(fd, data, options.encoding, function (writeError) {
            if (writeError) {
                return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!
            }
            // Flush contents (not metadata) of the file to disk
            fs.fdatasync(fd, function (syncError) {
                // In some exotic setups it is well possible that node fails to sync
                // In that case we disable flushing and warn to the console
                if (syncError) {
                    console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                    canFlush = false;
                }
                return fs.close(fd, function (closeError) { return callback(closeError); });
            });
        });
    });
}
exports.writeFileAndFlush = writeFileAndFlush;
