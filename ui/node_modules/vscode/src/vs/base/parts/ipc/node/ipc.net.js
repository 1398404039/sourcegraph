/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var net_1 = require('net');
var winjs_base_1 = require('vs/base/common/winjs.base');
var event_1 = require('vs/base/common/event');
var event_2 = require('vs/base/node/event');
var ipc_1 = require('vs/base/parts/ipc/common/ipc');
function bufferIndexOf(buffer, value, start) {
    if (start === void 0) { start = 0; }
    while (start < buffer.length && buffer[start] !== value) {
        start++;
    }
    return start;
}
var Protocol = (function () {
    function Protocol(socket) {
        this.socket = socket;
        var buffer = null;
        var emitter = new event_1.Emitter();
        var onRawData = event_2.fromEventEmitter(socket, 'data', function (data) { return data; });
        onRawData(function (data) {
            var lastIndex = 0;
            var index = 0;
            while ((index = bufferIndexOf(data, 0, lastIndex)) < data.length) {
                var dataToParse = data.slice(lastIndex, index);
                if (buffer) {
                    emitter.fire(JSON.parse(Buffer.concat([buffer, dataToParse]).toString('utf8')));
                    buffer = null;
                }
                else {
                    emitter.fire(JSON.parse(dataToParse.toString('utf8')));
                }
                lastIndex = index + 1;
            }
            if (index - lastIndex > 0) {
                var dataToBuffer = data.slice(lastIndex, index);
                if (buffer) {
                    buffer = Buffer.concat([buffer, dataToBuffer]);
                }
                else {
                    buffer = dataToBuffer;
                }
            }
        });
        this._onMessage = emitter.event;
    }
    Object.defineProperty(Protocol.prototype, "onMessage", {
        get: function () { return this._onMessage; },
        enumerable: true,
        configurable: true
    });
    Protocol.prototype.send = function (message) {
        try {
            this.socket.write(JSON.stringify(message));
            this.socket.write(Protocol.Boundary);
        }
        catch (e) {
        }
    };
    Protocol.Boundary = new Buffer([0]);
    return Protocol;
}());
var RoutingChannelClient = (function () {
    function RoutingChannelClient() {
        this.onClientAdded = new event_1.Emitter();
        this.ipcClients = Object.create(null);
    }
    RoutingChannelClient.prototype.add = function (id, client) {
        this.ipcClients[id] = client;
        this.onClientAdded.fire();
    };
    RoutingChannelClient.prototype.remove = function (id) {
        delete this.ipcClients[id];
    };
    RoutingChannelClient.prototype.getClient = function (clientId) {
        var _this = this;
        var getClientFn = function (clientId, c) {
            var client = _this.ipcClients[clientId];
            if (client) {
                c(client);
                return true;
            }
            return false;
        };
        return new winjs_base_1.TPromise(function (c, e) {
            if (!getClientFn(clientId, c)) {
                var disposable_1 = _this.onClientAdded.event(function () {
                    if (getClientFn(clientId, c)) {
                        disposable_1.dispose();
                    }
                });
            }
        });
    };
    RoutingChannelClient.prototype.getChannel = function (channelName, router) {
        var _this = this;
        var call = function (command, arg) {
            var id = router.routeCall(command, arg);
            if (!id) {
                return winjs_base_1.TPromise.wrapError('Client id should be provided');
            }
            return _this.getClient(id).then(function (client) { return client.getChannel(channelName).call(command, arg); });
        };
        return { call: call };
    };
    RoutingChannelClient.prototype.dispose = function () {
        this.ipcClients = null;
        this.onClientAdded.dispose();
    };
    return RoutingChannelClient;
}());
// TODO@joao: move multi channel implementation down to ipc
var Server = (function () {
    function Server(server) {
        var _this = this;
        this.server = server;
        this.channels = Object.create(null);
        this.router = new RoutingChannelClient();
        this.server.on('connection', function (socket) {
            var protocol = new Protocol(socket);
            var onFirstMessage = event_1.once(protocol.onMessage);
            onFirstMessage(function (id) {
                var channelServer = new ipc_1.ChannelServer(protocol);
                Object.keys(_this.channels)
                    .forEach(function (name) { return channelServer.registerChannel(name, _this.channels[name]); });
                var channelClient = new ipc_1.ChannelClient(protocol);
                _this.router.add(id, channelClient);
                socket.once('close', function () {
                    channelClient.dispose();
                    _this.router.remove(id);
                    channelServer.dispose();
                });
            });
        });
    }
    Server.prototype.getChannel = function (channelName, router) {
        return this.router.getChannel(channelName, router);
    };
    Server.prototype.registerChannel = function (channelName, channel) {
        this.channels[channelName] = channel;
    };
    Server.prototype.dispose = function () {
        this.router.dispose();
        this.router = null;
        this.channels = null;
        this.server.close();
        this.server = null;
    };
    return Server;
}());
exports.Server = Server;
var Client = (function () {
    function Client(socket, id) {
        var _this = this;
        this.socket = socket;
        this._onClose = new event_1.Emitter();
        var protocol = new Protocol(socket);
        protocol.send(id);
        this.channelClient = new ipc_1.ChannelClient(protocol);
        this.channelServer = new ipc_1.ChannelServer(protocol);
        socket.once('close', function () { return _this._onClose.fire(); });
    }
    Object.defineProperty(Client.prototype, "onClose", {
        get: function () { return this._onClose.event; },
        enumerable: true,
        configurable: true
    });
    Client.prototype.getChannel = function (channelName) {
        return this.channelClient.getChannel(channelName);
    };
    Client.prototype.registerChannel = function (channelName, channel) {
        this.channelServer.registerChannel(channelName, channel);
    };
    Client.prototype.dispose = function () {
        this.socket.end();
        this.socket = null;
        this.channelClient = null;
        this.channelServer.dispose();
        this.channelServer = null;
    };
    return Client;
}());
exports.Client = Client;
function serve(hook) {
    return new winjs_base_1.TPromise(function (c, e) {
        var server = net_1.createServer();
        server.on('error', e);
        server.listen(hook, function () {
            server.removeListener('error', e);
            c(new Server(server));
        });
    });
}
exports.serve = serve;
function connect(hook, clientId) {
    return new winjs_base_1.TPromise(function (c, e) {
        var socket = net_1.createConnection(hook, function () {
            socket.removeListener('error', e);
            c(new Client(socket, clientId));
        });
        socket.once('error', e);
    });
}
exports.connect = connect;
