/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var winjs_base_1 = require('vs/base/common/winjs.base');
var extensionsRegistry_1 = require('vs/platform/extensions/common/extensionsRegistry');
var modesRegistry_1 = require('vs/editor/common/modes/modesRegistry');
var standaloneServices_1 = require('vs/editor/browser/standalone/standaloneServices');
var modes = require('vs/editor/common/modes');
var range_1 = require('vs/editor/common/core/range');
var async_1 = require('vs/base/common/async');
var monarchCompile_1 = require('vs/editor/common/modes/monarch/monarchCompile');
var monarchLexer_1 = require('vs/editor/common/modes/monarch/monarchLexer');
var languageConfigurationRegistry_1 = require('vs/editor/common/modes/languageConfigurationRegistry');
var modeServiceImpl_1 = require('vs/editor/common/services/modeServiceImpl');
/**
 * Register information about a new language.
 */
function register(language) {
    modesRegistry_1.ModesRegistry.registerLanguage(language);
}
exports.register = register;
/**
 * Get the information of all the registered languages.
 */
function getLanguages() {
    var result = [];
    result = result.concat(modesRegistry_1.ModesRegistry.getLanguages());
    return result;
}
exports.getLanguages = getLanguages;
/**
 * An event emitted when a language is first time needed (e.g. a model has it set).
 */
function onLanguage(languageId, callback) {
    var isDisposed = false;
    extensionsRegistry_1.ExtensionsRegistry.registerOneTimeActivationEventListener('onLanguage:' + languageId, function () {
        if (!isDisposed) {
            callback();
        }
    });
    return {
        dispose: function () { isDisposed = true; }
    };
}
exports.onLanguage = onLanguage;
/**
 * Set the editing configuration for a language.
 */
function setLanguageConfiguration(languageId, configuration) {
    return languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(languageId, configuration);
}
exports.setLanguageConfiguration = setLanguageConfiguration;
/**
 * Set the tokens provider for a language (manual implementation).
 */
function setTokensProvider(languageId, provider) {
    var adapter = new modeServiceImpl_1.TokenizationSupport2Adapter(languageId, provider);
    return modes.TokenizationRegistry.register(languageId, adapter);
}
exports.setTokensProvider = setTokensProvider;
/**
 * Set the tokens provider for a language (monarch implementation).
 */
function setMonarchTokensProvider(languageId, languageDef) {
    var lexer = monarchCompile_1.compile(languageId, languageDef);
    var adapter = monarchLexer_1.createTokenizationSupport(standaloneServices_1.StaticServices.modeService.get(), languageId, lexer);
    return modes.TokenizationRegistry.register(languageId, adapter);
}
exports.setMonarchTokensProvider = setMonarchTokensProvider;
/**
 * Register a reference provider (used by e.g. reference search).
 */
function registerReferenceProvider(languageId, provider) {
    return modes.ReferenceProviderRegistry.register(languageId, provider);
}
exports.registerReferenceProvider = registerReferenceProvider;
/**
 * Register a rename provider (used by e.g. rename symbol).
 */
function registerRenameProvider(languageId, provider) {
    return modes.RenameProviderRegistry.register(languageId, provider);
}
exports.registerRenameProvider = registerRenameProvider;
/**
 * Register a signature help provider (used by e.g. paremeter hints).
 */
function registerSignatureHelpProvider(languageId, provider) {
    return modes.SignatureHelpProviderRegistry.register(languageId, provider);
}
exports.registerSignatureHelpProvider = registerSignatureHelpProvider;
/**
 * Register a hover provider (used by e.g. editor hover).
 */
function registerHoverProvider(languageId, provider) {
    return modes.HoverProviderRegistry.register(languageId, {
        provideHover: function (model, position, token) {
            var word = model.getWordAtPosition(position);
            return async_1.toThenable(provider.provideHover(model, position, token)).then(function (value) {
                if (!value) {
                    return;
                }
                if (!value.range && word) {
                    value.range = new range_1.Range(position.lineNumber, word.startColumn, position.column, word.endColumn);
                }
                if (!value.range) {
                    value.range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                }
                return value;
            });
        }
    });
}
exports.registerHoverProvider = registerHoverProvider;
/**
 * Register a document symbol provider (used by e.g. outline).
 */
function registerDocumentSymbolProvider(languageId, provider) {
    return modes.DocumentSymbolProviderRegistry.register(languageId, provider);
}
exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
/**
 * Register a document highlight provider (used by e.g. highlight occurences).
 */
function registerDocumentHighlightProvider(languageId, provider) {
    return modes.DocumentHighlightProviderRegistry.register(languageId, provider);
}
exports.registerDocumentHighlightProvider = registerDocumentHighlightProvider;
/**
 * Register a definition provider (used by e.g. go to definition).
 */
function registerDefinitionProvider(languageId, provider) {
    return modes.DefinitionProviderRegistry.register(languageId, provider);
}
exports.registerDefinitionProvider = registerDefinitionProvider;
/**
 * Register a code lens provider (used by e.g. inline code lenses).
 */
function registerCodeLensProvider(languageId, provider) {
    return modes.CodeLensProviderRegistry.register(languageId, provider);
}
exports.registerCodeLensProvider = registerCodeLensProvider;
/**
 * Register a code action provider (used by e.g. quick fix).
 */
function registerCodeActionProvider(languageId, provider) {
    return modes.CodeActionProviderRegistry.register(languageId, {
        provideCodeActions: function (model, range, token) {
            var markers = standaloneServices_1.StaticServices.markerService.get().read({ resource: model.uri }).filter(function (m) {
                return range_1.Range.areIntersectingOrTouching(m, range);
            });
            return provider.provideCodeActions(model, range, { markers: markers }, token);
        }
    });
}
exports.registerCodeActionProvider = registerCodeActionProvider;
/**
 * Register a formatter that can handle only entire models.
 */
function registerDocumentFormattingEditProvider(languageId, provider) {
    return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerDocumentFormattingEditProvider = registerDocumentFormattingEditProvider;
/**
 * Register a formatter that can handle a range inside a model.
 */
function registerDocumentRangeFormattingEditProvider(languageId, provider) {
    return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerDocumentRangeFormattingEditProvider = registerDocumentRangeFormattingEditProvider;
/**
 * Register a formatter than can do formatting as the user types.
 */
function registerOnTypeFormattingEditProvider(languageId, provider) {
    return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerOnTypeFormattingEditProvider = registerOnTypeFormattingEditProvider;
/**
 * Register a link provider that can find links in text.
 */
function registerLinkProvider(languageId, provider) {
    return modes.LinkProviderRegistry.register(languageId, provider);
}
exports.registerLinkProvider = registerLinkProvider;
/**
 * Register a completion item provider (use by e.g. suggestions).
 */
function registerCompletionItemProvider(languageId, provider) {
    var adapter = new SuggestAdapter(provider);
    return modes.SuggestRegistry.register(languageId, {
        triggerCharacters: provider.triggerCharacters,
        provideCompletionItems: function (model, position, token) {
            return adapter.provideCompletionItems(model, position, token);
        },
        resolveCompletionItem: function (model, position, suggestion, token) {
            return adapter.resolveCompletionItem(model, position, suggestion, token);
        }
    });
}
exports.registerCompletionItemProvider = registerCompletionItemProvider;
/**
 * Completion item kinds.
 */
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
})(exports.CompletionItemKind || (exports.CompletionItemKind = {}));
var CompletionItemKind = exports.CompletionItemKind;
function convertKind(kind) {
    switch (kind) {
        case CompletionItemKind.Method: return 'method';
        case CompletionItemKind.Function: return 'function';
        case CompletionItemKind.Constructor: return 'constructor';
        case CompletionItemKind.Field: return 'field';
        case CompletionItemKind.Variable: return 'variable';
        case CompletionItemKind.Class: return 'class';
        case CompletionItemKind.Interface: return 'interface';
        case CompletionItemKind.Module: return 'module';
        case CompletionItemKind.Property: return 'property';
        case CompletionItemKind.Unit: return 'unit';
        case CompletionItemKind.Value: return 'value';
        case CompletionItemKind.Enum: return 'enum';
        case CompletionItemKind.Keyword: return 'keyword';
        case CompletionItemKind.Snippet: return 'snippet';
        case CompletionItemKind.Text: return 'text';
        case CompletionItemKind.Color: return 'color';
        case CompletionItemKind.File: return 'file';
        case CompletionItemKind.Reference: return 'reference';
    }
    return 'property';
}
var SuggestAdapter = (function () {
    function SuggestAdapter(provider) {
        this._provider = provider;
    }
    SuggestAdapter.from = function (item) {
        return {
            _actual: item,
            label: item.label,
            insertText: item.insertText || item.label,
            type: convertKind(item.kind),
            detail: item.detail,
            documentation: item.documentation,
            sortText: item.sortText,
            filterText: item.filterText
        };
    };
    SuggestAdapter.prototype.provideCompletionItems = function (model, position, token) {
        return async_1.toThenable(this._provider.provideCompletionItems(model, position, token)).then(function (value) {
            var result = {
                suggestions: [],
                currentWord: '',
            };
            // default text edit start
            var wordStartPos = position.clone();
            var word = model.getWordUntilPosition(position);
            if (word) {
                wordStartPos.column = word.startColumn;
            }
            var list;
            if (Array.isArray(value)) {
                list = {
                    items: value,
                    isIncomplete: false
                };
            }
            else if (typeof value === 'object' && Array.isArray(value.items)) {
                list = value;
                result.incomplete = list.isIncomplete;
            }
            else if (!value) {
                // undefined and null are valid results
                return;
            }
            else {
                // warn about everything else
                console.warn('INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:', value);
            }
            for (var i = 0; i < list.items.length; i++) {
                var item = list.items[i];
                var suggestion = SuggestAdapter.from(item);
                if (item.textEdit) {
                    var editRange = item.textEdit.range;
                    var isSingleLine = (editRange.startLineNumber === editRange.endLineNumber);
                    // invalid text edit
                    if (!isSingleLine || editRange.startLineNumber !== position.lineNumber) {
                        console.warn('INVALID text edit, must be single line and on the same line');
                        continue;
                    }
                    // insert the text of the edit and create a dedicated
                    // suggestion-container with overwrite[Before|After]
                    suggestion.insertText = item.textEdit.text;
                    suggestion.overwriteBefore = position.column - editRange.startColumn;
                    suggestion.overwriteAfter = editRange.endColumn - position.column;
                }
                else {
                    suggestion.overwriteBefore = position.column - wordStartPos.column;
                    suggestion.overwriteAfter = 0;
                }
                result.suggestions.push(suggestion);
            }
            return result;
        });
    };
    SuggestAdapter.prototype.resolveCompletionItem = function (model, position, suggestion, token) {
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return winjs_base_1.TPromise.as(suggestion);
        }
        var item = suggestion._actual;
        if (!item) {
            return winjs_base_1.TPromise.as(suggestion);
        }
        return async_1.toThenable(this._provider.resolveCompletionItem(item, token)).then(function (resolvedItem) {
            return SuggestAdapter.from(resolvedItem);
        });
    };
    return SuggestAdapter;
}());
