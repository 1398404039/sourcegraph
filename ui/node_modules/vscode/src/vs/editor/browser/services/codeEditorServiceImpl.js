/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var objects = require('vs/base/common/objects');
var marshalling_1 = require('vs/base/common/marshalling');
var strings = require('vs/base/common/strings');
var uri_1 = require('vs/base/common/uri');
var dom = require('vs/base/browser/dom');
var editorCommon_1 = require('vs/editor/common/editorCommon');
var abstractCodeEditorService_1 = require('vs/editor/common/services/abstractCodeEditorService');
var lifecycle_1 = require('vs/base/common/lifecycle');
var CodeEditorServiceImpl = (function (_super) {
    __extends(CodeEditorServiceImpl, _super);
    function CodeEditorServiceImpl(styleSheet) {
        if (styleSheet === void 0) { styleSheet = dom.createStyleSheet(); }
        _super.call(this);
        this._styleSheet = styleSheet;
        this._decorationOptionProviders = Object.create(null);
    }
    CodeEditorServiceImpl.prototype.registerDecorationType = function (key, options, parentTypeKey) {
        var provider = this._decorationOptionProviders[key];
        if (!provider) {
            if (!parentTypeKey) {
                provider = new DecorationTypeOptionsProvider(this._styleSheet, key, options);
            }
            else {
                provider = new DecorationSubTypeOptionsProvider(this._styleSheet, key, parentTypeKey, options);
            }
            this._decorationOptionProviders[key] = provider;
        }
        provider.refCount++;
    };
    CodeEditorServiceImpl.prototype.removeDecorationType = function (key) {
        var provider = this._decorationOptionProviders[key];
        if (provider) {
            provider.refCount--;
            if (provider.refCount <= 0) {
                delete this._decorationOptionProviders[key];
                provider.dispose();
                this.listCodeEditors().forEach(function (ed) { return ed.removeDecorations(key); });
            }
        }
    };
    CodeEditorServiceImpl.prototype.resolveDecorationOptions = function (decorationTypeKey, writable) {
        var provider = this._decorationOptionProviders[decorationTypeKey];
        if (!provider) {
            throw new Error('Unknown decoration type key: ' + decorationTypeKey);
        }
        return provider.getOptions(this, writable);
    };
    return CodeEditorServiceImpl;
}(abstractCodeEditorService_1.AbstractCodeEditorService));
exports.CodeEditorServiceImpl = CodeEditorServiceImpl;
var DecorationSubTypeOptionsProvider = (function () {
    function DecorationSubTypeOptionsProvider(styleSheet, key, parentTypeKey, options) {
        this._parentTypeKey = parentTypeKey;
        this.refCount = 0;
        var themedOpts = getThemedRenderOptions(options);
        this._beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, 3 /* BeforeContentClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
        });
        this._afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, 4 /* AfterContentClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
        });
        if (this._beforeContentClassName || this._afterContentClassName) {
            this._disposable = lifecycle_1.toDisposable(function () {
                dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
            });
        }
    }
    DecorationSubTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
        var options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
        if (this._beforeContentClassName) {
            options.beforeContentClassName = this._beforeContentClassName;
        }
        if (this._afterContentClassName) {
            options.afterContentClassName = this._afterContentClassName;
        }
        return options;
    };
    DecorationSubTypeOptionsProvider.prototype.dispose = function () {
        if (this._disposable) {
            this._disposable.dispose();
            delete this._disposable;
        }
    };
    return DecorationSubTypeOptionsProvider;
}());
var DecorationTypeOptionsProvider = (function () {
    function DecorationTypeOptionsProvider(styleSheet, key, options) {
        this.refCount = 0;
        var themedOpts = getThemedRenderOptions(options);
        this.className = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 0 /* ClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.light),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.dark)
        });
        this.inlineClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 1 /* InlineClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.light),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.dark)
        });
        this.beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 3 /* BeforeContentClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
        });
        this.afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 4 /* AfterContentClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
        });
        this.glyphMarginClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 2 /* GlyphMarginClassName */, {
            light: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.light),
            dark: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.dark)
        });
        this.isWholeLine = Boolean(options.isWholeLine);
        if (typeof themedOpts.light.overviewRulerColor !== 'undefined'
            || typeof themedOpts.dark.overviewRulerColor !== 'undefined') {
            this.overviewRuler = {
                color: themedOpts.light.overviewRulerColor || themedOpts.dark.overviewRulerColor,
                darkColor: themedOpts.dark.overviewRulerColor || themedOpts.light.overviewRulerColor,
                position: options.overviewRulerLane || editorCommon_1.OverviewRulerLane.Center
            };
        }
        this._disposable = lifecycle_1.toDisposable(function () {
            dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
        });
    }
    DecorationTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
        if (!writable) {
            return this;
        }
        return {
            inlineClassName: this.inlineClassName,
            beforeContentClassName: this.beforeContentClassName,
            afterContentClassName: this.afterContentClassName,
            className: this.className,
            glyphMarginClassName: this.glyphMarginClassName,
            isWholeLine: this.isWholeLine,
            overviewRuler: this.overviewRuler,
            stickiness: this.stickiness
        };
    };
    DecorationTypeOptionsProvider.prototype.dispose = function () {
        if (this._disposable) {
            this._disposable.dispose();
            delete this._disposable;
        }
    };
    return DecorationTypeOptionsProvider;
}());
var DecorationRenderHelper = (function () {
    function DecorationRenderHelper() {
    }
    /**
     * Build the CSS for decorations styled via `className`.
     */
    DecorationRenderHelper.getCSSTextForModelDecorationClassName = function (opts) {
        var cssTextArr = [];
        DecorationRenderHelper.collectCSSText(opts, ['backgroundColor', 'outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
        DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled via `inlineClassName`.
     */
    DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName = function (opts) {
        var cssTextArr = [];
        DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'cursor', 'color', 'letterSpacing'], cssTextArr);
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled before or after content.
     */
    DecorationRenderHelper.getCSSTextForModelDecorationContentClassName = function (opts) {
        var cssTextArr = [];
        if (typeof opts !== 'undefined') {
            DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
            if (typeof opts.contentIconPath === 'string') {
                cssTextArr.push(strings.format(this._CSS_MAP.contentIconPath, uri_1.default.file(opts.contentIconPath).toString()));
            }
            else if (opts.contentIconPath instanceof uri_1.default) {
                cssTextArr.push(strings.format(this._CSS_MAP.contentIconPath, opts.contentIconPath.toString(true).replace(/'/g, '%27')));
            }
            if (typeof opts.contentText !== 'undefined') {
                var escaped = opts.contentText.replace(/\"/g, '\\\"');
                cssTextArr.push(strings.format(this._CSS_MAP.contentText, escaped));
            }
            DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'color', 'backgroundColor', 'margin'], cssTextArr);
            if (DecorationRenderHelper.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
                cssTextArr.push('display:inline-block;');
            }
        }
        return cssTextArr.join('');
    };
    /**
     * Build the CSS for decorations styled via `glpyhMarginClassName`.
     */
    DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName = function (opts) {
        var cssTextArr = [];
        if (typeof opts.gutterIconPath !== 'undefined') {
            if (typeof opts.gutterIconPath === 'string') {
                cssTextArr.push(strings.format(this._CSS_MAP.gutterIconPath, uri_1.default.file(opts.gutterIconPath).toString()));
            }
            else {
                cssTextArr.push(strings.format(this._CSS_MAP.gutterIconPath, opts.gutterIconPath.toString(true).replace(/'/g, '%27')));
            }
            if (typeof opts.gutterIconSize !== 'undefined') {
                cssTextArr.push(strings.format(this._CSS_MAP.gutterIconSize, opts.gutterIconSize));
            }
        }
        return cssTextArr.join('');
    };
    DecorationRenderHelper.collectBorderSettingsCSSText = function (opts, cssTextArr) {
        if (DecorationRenderHelper.collectCSSText(opts, DecorationRenderHelper.border_rules, cssTextArr)) {
            cssTextArr.push(strings.format('box-sizing: border-box;'));
            return true;
        }
        return false;
    };
    DecorationRenderHelper.collectCSSText = function (opts, properties, cssTextArr) {
        var lenBefore = cssTextArr.length;
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            if (typeof opts[property] !== 'undefined') {
                cssTextArr.push(strings.format(this._CSS_MAP[property], opts[property]));
            }
        }
        return cssTextArr.length !== lenBefore;
    };
    /**
     * Create CSS rules for `cssTexts` with the generated class names from `ruleType`
     */
    DecorationRenderHelper.createCSSRules = function (styleSheet, key, parentKey, ruleType, cssTexts) {
        function createCSSSelector(themeType, cssText) {
            var selector = CSSNameHelper.getSelector(themeType, key, parentKey, ruleType);
            dom.createCSSRule(selector, cssText, styleSheet);
        }
        var hasContent = false;
        if (cssTexts.light.length > 0) {
            createCSSSelector(0 /* Light */, cssTexts.light);
            hasContent = true;
        }
        if (cssTexts.dark.length > 0) {
            createCSSSelector(1 /* Dark */, cssTexts.dark);
            createCSSSelector(2 /* HighContrastBlack */, cssTexts.dark);
            hasContent = true;
        }
        if (hasContent) {
            var className = CSSNameHelper.getClassName(key, ruleType);
            if (parentKey) {
                className = className + ' ' + CSSNameHelper.getClassName(parentKey, ruleType);
            }
            return className;
        }
        return void 0;
    };
    DecorationRenderHelper._CSS_MAP = {
        color: 'color:{0} !important;',
        backgroundColor: 'background-color:{0};',
        outline: 'outline:{0};',
        outlineColor: 'outline-color:{0};',
        outlineStyle: 'outline-style:{0};',
        outlineWidth: 'outline-width:{0};',
        border: 'border:{0};',
        borderColor: 'border-color:{0};',
        borderRadius: 'border-radius:{0};',
        borderSpacing: 'border-spacing:{0};',
        borderStyle: 'border-style:{0};',
        borderWidth: 'border-width:{0};',
        textDecoration: 'text-decoration:{0};',
        cursor: 'cursor:{0};',
        letterSpacing: 'letter-spacing:{0};',
        gutterIconPath: 'background:url(\'{0}\') center center no-repeat;',
        gutterIconSize: 'background-size:{0};',
        contentText: 'content:\'{0}\';',
        contentIconPath: 'content:url(\'{0}\');',
        margin: 'margin:{0};',
        width: 'width:{0};',
        height: 'height:{0};'
    };
    DecorationRenderHelper.border_rules = ['border', 'borderColor', 'borderColor', 'borderSpacing', 'borderStyle', 'borderWidth'];
    return DecorationRenderHelper;
}());
var ThemeType;
(function (ThemeType) {
    ThemeType[ThemeType["Light"] = 0] = "Light";
    ThemeType[ThemeType["Dark"] = 1] = "Dark";
    ThemeType[ThemeType["HighContrastBlack"] = 2] = "HighContrastBlack";
})(ThemeType || (ThemeType = {}));
var ModelDecorationCSSRuleType;
(function (ModelDecorationCSSRuleType) {
    ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["ClassName"] = 0] = "ClassName";
    ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["InlineClassName"] = 1] = "InlineClassName";
    ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["GlyphMarginClassName"] = 2] = "GlyphMarginClassName";
    ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["BeforeContentClassName"] = 3] = "BeforeContentClassName";
    ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["AfterContentClassName"] = 4] = "AfterContentClassName";
})(ModelDecorationCSSRuleType || (ModelDecorationCSSRuleType = {}));
var CSSNameHelper = (function () {
    function CSSNameHelper() {
    }
    CSSNameHelper._getSelectorPrefixOf = function (theme) {
        if (theme === 0 /* Light */) {
            return '.monaco-editor.vs';
        }
        if (theme === 1 /* Dark */) {
            return '.monaco-editor.vs-dark';
        }
        return '.monaco-editor.hc-black';
    };
    CSSNameHelper.getClassName = function (key, type) {
        return 'ced-' + key + '-' + type;
    };
    CSSNameHelper.getSelector = function (themeType, key, parentKey, ruleType) {
        var selector = this._getSelectorPrefixOf(themeType) + ' .' + this.getClassName(key, ruleType);
        if (parentKey) {
            selector = selector + '.' + this.getClassName(parentKey, ruleType);
        }
        if (ruleType === 3 /* BeforeContentClassName */) {
            selector += '::before';
        }
        else if (ruleType === 4 /* AfterContentClassName */) {
            selector += '::after';
        }
        return selector;
    };
    CSSNameHelper.getDeletionSubstring = function (key) {
        return '.ced-' + key + '-';
    };
    return CSSNameHelper;
}());
function getThemedRenderOptions(opts) {
    // TODO@alex,joh - not really how/what deep clone is being used
    // for here but it will break the URI
    // var light = <T> objects.deepClone(opts);
    var light = marshalling_1.parse(marshalling_1.stringify(opts));
    objects.mixin(light, opts.light);
    // var dark = <T> objects.deepClone(opts);
    var dark = marshalling_1.parse(marshalling_1.stringify(opts));
    objects.mixin(dark, opts.dark);
    return {
        light: light,
        dark: dark
    };
}
