/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var position_1 = require('vs/editor/common/core/position');
var range_1 = require('vs/editor/common/core/range');
var editorCommon_1 = require('vs/editor/common/editorCommon');
var editorBrowser_1 = require('vs/editor/browser/editorBrowser');
var dom = require('vs/base/browser/dom');
var browser = require('vs/base/browser/browser');
var MouseTarget = (function () {
    function MouseTarget(element, type, mouseColumn, position, range, detail) {
        if (mouseColumn === void 0) { mouseColumn = 0; }
        if (position === void 0) { position = null; }
        if (range === void 0) { range = null; }
        if (detail === void 0) { detail = null; }
        this.element = element;
        this.type = type;
        this.mouseColumn = mouseColumn;
        this.position = position;
        if (!range && position) {
            range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        this.range = range;
        this.detail = detail;
    }
    MouseTarget.prototype._typeToString = function () {
        if (this.type === editorCommon_1.MouseTargetType.TEXTAREA) {
            return 'TEXTAREA';
        }
        if (this.type === editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN) {
            return 'GUTTER_GLYPH_MARGIN';
        }
        if (this.type === editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS) {
            return 'GUTTER_LINE_NUMBERS';
        }
        if (this.type === editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return 'GUTTER_LINE_DECORATIONS';
        }
        if (this.type === editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE) {
            return 'GUTTER_VIEW_ZONE';
        }
        if (this.type === editorCommon_1.MouseTargetType.CONTENT_TEXT) {
            return 'CONTENT_TEXT';
        }
        if (this.type === editorCommon_1.MouseTargetType.CONTENT_EMPTY) {
            return 'CONTENT_EMPTY';
        }
        if (this.type === editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE) {
            return 'CONTENT_VIEW_ZONE';
        }
        if (this.type === editorCommon_1.MouseTargetType.CONTENT_WIDGET) {
            return 'CONTENT_WIDGET';
        }
        if (this.type === editorCommon_1.MouseTargetType.OVERVIEW_RULER) {
            return 'OVERVIEW_RULER';
        }
        if (this.type === editorCommon_1.MouseTargetType.SCROLLBAR) {
            return 'SCROLLBAR';
        }
        if (this.type === editorCommon_1.MouseTargetType.OVERLAY_WIDGET) {
            return 'OVERLAY_WIDGET';
        }
        return 'UNKNOWN';
    };
    MouseTarget.prototype.toString = function () {
        return this._typeToString() + ': ' + this.position + ' - ' + this.range + ' - ' + this.detail;
    };
    return MouseTarget;
}());
// e.g. of paths:
// - overflow-guard/monaco-scrollable-element editor-scrollable vs/lines-content/view-lines/view-line
// - overflow-guard/monaco-scrollable-element editor-scrollable vs/lines-content/view-lines/view-line/token comment js
// etc.
var REGEX = (function () {
    function nodeWithClass(className) {
        return '[^/]*' + className + '[^/]*';
    }
    function anyNode() {
        return '[^/]+';
    }
    var ANCHOR = '^' + editorBrowser_1.ClassNames.OVERFLOW_GUARD + '\\/';
    function createRegExp() {
        var pieces = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pieces[_i - 0] = arguments[_i];
        }
        var forceEndMatch = false;
        if (pieces[pieces.length - 1] === '$') {
            forceEndMatch = true;
            pieces.pop();
        }
        return new RegExp(ANCHOR + pieces.join('\\/') + (forceEndMatch ? '$' : ''));
    }
    return {
        IS_TEXTAREA_COVER: createRegExp(nodeWithClass(editorBrowser_1.ClassNames.TEXTAREA_COVER), '$'),
        IS_TEXTAREA: createRegExp(editorBrowser_1.ClassNames.TEXTAREA, '$'),
        IS_VIEW_LINES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_LINES, '$'),
        IS_CURSORS_LAYER: createRegExp(anyNode(), anyNode(), nodeWithClass(editorBrowser_1.ClassNames.VIEW_CURSORS_LAYER), '$'),
        IS_CHILD_OF_VIEW_LINES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_LINES),
        IS_CHILD_OF_SCROLLABLE_ELEMENT: createRegExp(nodeWithClass(editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT)),
        IS_CHILD_OF_CONTENT_WIDGETS: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.CONTENT_WIDGETS),
        IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS: new RegExp('^' + editorBrowser_1.ClassNames.OVERFLOWING_CONTENT_WIDGETS + '\\/'),
        IS_CHILD_OF_OVERLAY_WIDGETS: createRegExp(editorBrowser_1.ClassNames.OVERLAY_WIDGETS),
        IS_CHILD_OF_VIEW_OVERLAYS: createRegExp(editorBrowser_1.ClassNames.MARGIN_VIEW_OVERLAYS),
        IS_CHILD_OF_VIEW_ZONES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_ZONES),
    };
})();
var MouseTargetFactory = (function () {
    function MouseTargetFactory(context, viewHelper) {
        this._context = context;
        this._viewHelper = viewHelper;
    }
    MouseTargetFactory.prototype.getClassNamePathTo = function (child, stopAt) {
        var path = [], className;
        while (child && child !== document.body) {
            if (child === stopAt) {
                break;
            }
            if (child.nodeType === child.ELEMENT_NODE) {
                className = child.className;
                if (className) {
                    path.unshift(className);
                }
            }
            child = child.parentNode;
        }
        return path.join('/');
    };
    MouseTargetFactory.prototype.mouseTargetIsWidget = function (e) {
        var t = e.target;
        var path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
        // Is it a content widget?
        if (REGEX.IS_CHILD_OF_CONTENT_WIDGETS.test(path) || REGEX.IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS.test(path)) {
            return true;
        }
        // Is it an overlay widget?
        if (REGEX.IS_CHILD_OF_OVERLAY_WIDGETS.test(path)) {
            return true;
        }
        return false;
    };
    MouseTargetFactory.prototype.createMouseTarget = function (layoutInfo, lastViewCursorsRenderData, e, testEventTarget) {
        try {
            var r = this._unsafeCreateMouseTarget(layoutInfo, lastViewCursorsRenderData, e, testEventTarget);
            return r;
        }
        catch (e) {
            return this.createMouseTargetFromUnknownTarget(e.target);
        }
    };
    MouseTargetFactory.prototype._unsafeCreateMouseTarget = function (layoutInfo, lastViewCursorsRenderData, e, testEventTarget) {
        var mouseVerticalOffset = Math.max(0, this._viewHelper.getScrollTop() + (e.posy - e.editorPos.top));
        var mouseContentHorizontalOffset = this._viewHelper.getScrollLeft() + (e.posx - e.editorPos.left) - layoutInfo.contentLeft;
        var mouseColumn = this._getMouseColumn(mouseContentHorizontalOffset);
        var t = e.target;
        // Edge has a bug when hit-testing the exact position of a cursor,
        // instead of returning the correct dom node, it returns the
        // first or last rendered view line dom node, therefore help it out
        // and first check if we are on top of a cursor
        for (var i = 0, len = lastViewCursorsRenderData.length; i < len; i++) {
            var d = lastViewCursorsRenderData[i];
            if (d.contentLeft <= mouseContentHorizontalOffset
                && mouseContentHorizontalOffset <= d.contentLeft + d.width
                && d.contentTop <= mouseVerticalOffset
                && mouseVerticalOffset <= d.contentTop + d.height) {
                return this.createMouseTargetFromViewCursor(t, d.position.lineNumber, d.position.column, mouseColumn);
            }
        }
        var path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
        // Is it a content widget?
        if (REGEX.IS_CHILD_OF_CONTENT_WIDGETS.test(path) || REGEX.IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS.test(path)) {
            return this.createMouseTargetFromContentWidgetsChild(t, mouseColumn);
        }
        // Is it an overlay widget?
        if (REGEX.IS_CHILD_OF_OVERLAY_WIDGETS.test(path)) {
            return this.createMouseTargetFromOverlayWidgetsChild(t, mouseColumn);
        }
        // Is it a cursor ?
        var lineNumberAttribute = t.hasAttribute && t.hasAttribute('lineNumber') ? t.getAttribute('lineNumber') : null;
        var columnAttribute = t.hasAttribute && t.hasAttribute('column') ? t.getAttribute('column') : null;
        if (lineNumberAttribute && columnAttribute) {
            return this.createMouseTargetFromViewCursor(t, parseInt(lineNumberAttribute, 10), parseInt(columnAttribute, 10), mouseColumn);
        }
        // Is it the textarea cover?
        if (REGEX.IS_TEXTAREA_COVER.test(path)) {
            if (this._context.configuration.editor.viewInfo.glyphMargin) {
                return this.createMouseTargetFromGlyphMargin(t, mouseVerticalOffset, mouseColumn);
            }
            else if (this._context.configuration.editor.viewInfo.renderLineNumbers) {
                return this.createMouseTargetFromLineNumbers(t, mouseVerticalOffset, mouseColumn);
            }
            else {
                return this.createMouseTargetFromLinesDecorationsChild(t, mouseVerticalOffset, mouseColumn);
            }
        }
        // Is it the textarea?
        if (REGEX.IS_TEXTAREA.test(path)) {
            return new MouseTarget(t, editorCommon_1.MouseTargetType.TEXTAREA);
        }
        // Is it a view zone?
        if (REGEX.IS_CHILD_OF_VIEW_ZONES.test(path)) {
            // Check if it is at a view zone
            var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
            if (viewZoneData) {
                return new MouseTarget(t, editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
            }
            return this.createMouseTargetFromUnknownTarget(t);
        }
        // Is it the view lines container?
        if (REGEX.IS_VIEW_LINES.test(path)) {
            // Sometimes, IE returns this target when right clicking on top of text
            // -> See Bug #12990: [F12] Context menu shows incorrect position while doing a resize
            // Check if it is below any lines and any view zones
            if (this._viewHelper.isAfterLines(mouseVerticalOffset)) {
                return this.createMouseTargetFromViewLines(t, mouseVerticalOffset, mouseColumn);
            }
            // Check if it is at a view zone
            var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
            if (viewZoneData) {
                return new MouseTarget(t, editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
            }
            // Check if it hits a position
            var hitTestResult = this._doHitTest(e, mouseVerticalOffset);
            if (hitTestResult.position) {
                return this.createMouseTargetFromHitTestPosition(t, hitTestResult.position.lineNumber, hitTestResult.position.column, mouseContentHorizontalOffset, mouseColumn);
            }
            // Fall back to view lines
            return this.createMouseTargetFromViewLines(t, mouseVerticalOffset, mouseColumn);
        }
        // Is it a child of the view lines container?
        if (!testEventTarget || REGEX.IS_CHILD_OF_VIEW_LINES.test(path)) {
            var hitTestResult = this._doHitTest(e, mouseVerticalOffset);
            if (hitTestResult.position) {
                return this.createMouseTargetFromHitTestPosition(t, hitTestResult.position.lineNumber, hitTestResult.position.column, mouseContentHorizontalOffset, mouseColumn);
            }
            else if (hitTestResult.hitTarget) {
                t = hitTestResult.hitTarget;
                path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
                // TODO@Alex: try again with this different target, but guard against recursion.
                // Is it a cursor ?
                var lineNumberAttribute_1 = t.hasAttribute && t.hasAttribute('lineNumber') ? t.getAttribute('lineNumber') : null;
                var columnAttribute_1 = t.hasAttribute && t.hasAttribute('column') ? t.getAttribute('column') : null;
                if (lineNumberAttribute_1 && columnAttribute_1) {
                    return this.createMouseTargetFromViewCursor(t, parseInt(lineNumberAttribute_1, 10), parseInt(columnAttribute_1, 10), mouseColumn);
                }
            }
            else {
                // Hit testing completely failed...
                var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
                var maxColumn = this._context.model.getLineMaxColumn(possibleLineNumber);
                return new MouseTarget(t, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, new position_1.Position(possibleLineNumber, maxColumn));
            }
        }
        // Is it the cursors layer?
        if (REGEX.IS_CURSORS_LAYER.test(path)) {
            return new MouseTarget(t, editorCommon_1.MouseTargetType.UNKNOWN);
        }
        // Is it a child of the scrollable element?
        if (REGEX.IS_CHILD_OF_SCROLLABLE_ELEMENT.test(path)) {
            return this.createMouseTargetFromScrollbar(t, mouseVerticalOffset, mouseColumn);
        }
        if (REGEX.IS_CHILD_OF_VIEW_OVERLAYS.test(path)) {
            var offset = Math.abs(e.posx - e.editorPos.left);
            if (offset <= layoutInfo.glyphMarginWidth) {
                // On the glyph margin
                return this.createMouseTargetFromGlyphMargin(t, mouseVerticalOffset, mouseColumn);
            }
            offset -= layoutInfo.glyphMarginWidth;
            if (offset <= layoutInfo.lineNumbersWidth) {
                // On the line numbers
                return this.createMouseTargetFromLineNumbers(t, mouseVerticalOffset, mouseColumn);
            }
            offset -= layoutInfo.lineNumbersWidth;
            // On the line decorations
            return this.createMouseTargetFromLinesDecorationsChild(t, mouseVerticalOffset, mouseColumn);
        }
        if (/OverviewRuler/i.test(path)) {
            return this.createMouseTargetFromScrollbar(t, mouseVerticalOffset, mouseColumn);
        }
        return this.createMouseTargetFromUnknownTarget(t);
    };
    MouseTargetFactory.prototype._isChild = function (testChild, testAncestor, stopAt) {
        while (testChild && testChild !== document.body) {
            if (testChild === testAncestor) {
                return true;
            }
            if (testChild === stopAt) {
                return false;
            }
            testChild = testChild.parentNode;
        }
        return false;
    };
    MouseTargetFactory.prototype._findAttribute = function (element, attr, stopAt) {
        while (element && element !== document.body) {
            if (element.hasAttribute && element.hasAttribute(attr)) {
                return element.getAttribute(attr);
            }
            if (element === stopAt) {
                return null;
            }
            element = element.parentNode;
        }
        return null;
    };
    /**
     * Most probably WebKit browsers and Edge
     */
    MouseTargetFactory.prototype._doHitTestWithCaretRangeFromPoint = function (e, mouseVerticalOffset) {
        // In Chrome, especially on Linux it is possible to click between lines,
        // so try to adjust the `hity` below so that it lands in the center of a line
        var lineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
        var lineVerticalOffset = this._viewHelper.getVerticalOffsetForLineNumber(lineNumber);
        var centeredVerticalOffset = lineVerticalOffset + Math.floor(this._context.configuration.editor.lineHeight / 2);
        var adjustedPosy = e.posy + (centeredVerticalOffset - mouseVerticalOffset);
        if (adjustedPosy <= e.editorPos.top) {
            adjustedPosy = e.editorPos.top + 1;
        }
        if (adjustedPosy >= e.editorPos.top + this._context.configuration.editor.layoutInfo.height) {
            adjustedPosy = e.editorPos.top + this._context.configuration.editor.layoutInfo.height - 1;
        }
        var r = this._actualDoHitTestWithCaretRangeFromPoint(e.viewportx, adjustedPosy - dom.StandardWindow.scrollY);
        if (r.position) {
            return r;
        }
        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)
        return this._actualDoHitTestWithCaretRangeFromPoint(e.viewportx, e.viewporty);
    };
    MouseTargetFactory.prototype._actualDoHitTestWithCaretRangeFromPoint = function (hitx, hity) {
        var range = document.caretRangeFromPoint(hitx, hity);
        if (!range || !range.startContainer) {
            return {
                position: null,
                hitTarget: null
            };
        }
        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span
        var startContainer = range.startContainer;
        var hitTarget;
        if (startContainer.nodeType === startContainer.TEXT_NODE) {
            // startContainer is expected to be the token text
            var parent1 = startContainer.parentNode; // expected to be the token span
            var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
            var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
            var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
            if (parent3ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                var p = this._viewHelper.getPositionFromDOMInfo(parent1, range.startOffset);
                return {
                    position: p,
                    hitTarget: null
                };
            }
            else {
                hitTarget = startContainer.parentNode;
            }
        }
        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {
            // startContainer is expected to be the token span
            var parent1 = startContainer.parentNode; // expected to be the view line container span
            var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div
            var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
            if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                var p = this._viewHelper.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);
                return {
                    position: p,
                    hitTarget: null
                };
            }
            else {
                hitTarget = startContainer;
            }
        }
        return {
            position: null,
            hitTarget: hitTarget
        };
    };
    /**
     * Most probably Gecko
     */
    MouseTargetFactory.prototype._doHitTestWithCaretPositionFromPoint = function (e) {
        var hitResult = document.caretPositionFromPoint(e.viewportx, e.viewporty);
        var range = document.createRange();
        range.setStart(hitResult.offsetNode, hitResult.offset);
        range.collapse(true);
        var resultPosition = this._viewHelper.getPositionFromDOMInfo(range.startContainer.parentNode, range.startOffset);
        range.detach();
        return {
            position: resultPosition,
            hitTarget: null
        };
    };
    /**
     * Most probably IE
     */
    MouseTargetFactory.prototype._doHitTestWithMoveToPoint = function (e) {
        var resultPosition = null;
        var resultHitTarget = null;
        var textRange = document.body.createTextRange();
        try {
            textRange.moveToPoint(e.viewportx, e.viewporty);
        }
        catch (err) {
            return {
                position: null,
                hitTarget: null
            };
        }
        textRange.collapse(true);
        // Now, let's do our best to figure out what we hit :)
        var parentElement = textRange ? textRange.parentElement() : null;
        var parent1 = parentElement ? parentElement.parentNode : null;
        var parent2 = parent1 ? parent1.parentNode : null;
        var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';
        if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
            var rangeToContainEntireSpan = textRange.duplicate();
            rangeToContainEntireSpan.moveToElementText(parentElement);
            rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);
            resultPosition = this._viewHelper.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            rangeToContainEntireSpan.moveToElementText(this._viewHelper.viewDomNode);
        }
        else {
            // Looks like we've hit the hover or something foreign
            resultHitTarget = parentElement;
        }
        // Move range out of the span node, IE doesn't like having many ranges in
        // the same spot and will act badly for lines containing dashes ('-')
        textRange.moveToElementText(this._viewHelper.viewDomNode);
        return {
            position: resultPosition,
            hitTarget: resultHitTarget
        };
    };
    MouseTargetFactory.prototype._doHitTest = function (e, mouseVerticalOffset) {
        // State of the art (18.10.2012):
        // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)
        // Gecko:
        //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352
        //    - however, they do give out rangeParent/rangeOffset properties on mouse events
        // Webkit:
        //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint
        // IE:
        //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx
        // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy
        //    - when hit testing the cursor it returns the first or the last line in the viewport
        //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes
        //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line
        // Thank you browsers for making this so 'easy' :)
        if (document.caretRangeFromPoint) {
            return this._doHitTestWithCaretRangeFromPoint(e, mouseVerticalOffset);
        }
        else if (document.caretPositionFromPoint) {
            return this._doHitTestWithCaretPositionFromPoint(e);
        }
        else if (document.body.createTextRange) {
            return this._doHitTestWithMoveToPoint(e);
        }
        return {
            position: null,
            hitTarget: null
        };
    };
    MouseTargetFactory.prototype._getZoneAtCoord = function (mouseVerticalOffset) {
        // The target is either a view zone or the empty space after the last view-line
        var viewZoneWhitespace = this._viewHelper.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
        if (viewZoneWhitespace) {
            var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = this._context.model.getLineCount(), positionBefore = null, position = void 0, positionAfter = null;
            if (viewZoneWhitespace.afterLineNumber !== lineCount) {
                // There are more lines after this view zone
                positionAfter = new position_1.Position(viewZoneWhitespace.afterLineNumber + 1, 1);
            }
            if (viewZoneWhitespace.afterLineNumber > 0) {
                // There are more lines above this view zone
                positionBefore = new position_1.Position(viewZoneWhitespace.afterLineNumber, this._context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));
            }
            if (positionAfter === null) {
                position = positionBefore;
            }
            else if (positionBefore === null) {
                position = positionAfter;
            }
            else if (mouseVerticalOffset < viewZoneMiddle) {
                position = positionBefore;
            }
            else {
                position = positionAfter;
            }
            return {
                viewZoneId: viewZoneWhitespace.id,
                afterLineNumber: viewZoneWhitespace.afterLineNumber,
                positionBefore: positionBefore,
                positionAfter: positionAfter,
                position: position
            };
        }
        return null;
    };
    MouseTargetFactory.prototype._getFullLineRangeAtCoord = function (mouseVerticalOffset) {
        if (this._viewHelper.isAfterLines(mouseVerticalOffset)) {
            // Below the last line
            var lineNumber_1 = this._context.model.getLineCount();
            var maxLineColumn_1 = this._context.model.getLineMaxColumn(lineNumber_1);
            return {
                range: new range_1.Range(lineNumber_1, maxLineColumn_1, lineNumber_1, maxLineColumn_1),
                isAfterLines: true
            };
        }
        var lineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
        var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);
        return {
            range: new range_1.Range(lineNumber, 1, lineNumber, maxLineColumn),
            isAfterLines: false
        };
    };
    MouseTargetFactory.prototype.getMouseColumn = function (layoutInfo, e) {
        var mouseContentHorizontalOffset = this._viewHelper.getScrollLeft() + (e.posx - e.editorPos.left) - layoutInfo.contentLeft;
        return this._getMouseColumn(mouseContentHorizontalOffset);
    };
    MouseTargetFactory.prototype._getMouseColumn = function (mouseContentHorizontalOffset) {
        if (mouseContentHorizontalOffset < 0) {
            return 1;
        }
        var charWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        var chars = Math.round(mouseContentHorizontalOffset / charWidth);
        return (chars + 1);
    };
    MouseTargetFactory.prototype.createMouseTargetFromViewCursor = function (target, lineNumber, column, mouseColumn) {
        return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, new position_1.Position(lineNumber, column));
    };
    MouseTargetFactory.prototype.createMouseTargetFromViewLines = function (target, mouseVerticalOffset, mouseColumn) {
        // This most likely indicates it happened after the last view-line
        var lineCount = this._context.model.getLineCount();
        var maxLineColumn = this._context.model.getLineMaxColumn(lineCount);
        return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, new position_1.Position(lineCount, maxLineColumn));
    };
    MouseTargetFactory.prototype.createMouseTargetFromHitTestPosition = function (target, lineNumber, column, mouseHorizontalOffset, mouseColumn) {
        var pos = new position_1.Position(lineNumber, column);
        var lineWidth = this._viewHelper.getLineWidth(lineNumber);
        if (mouseHorizontalOffset > lineWidth) {
            if (browser.isEdge && pos.column === 1) {
                // See https://github.com/Microsoft/vscode/issues/10875
                return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, new position_1.Position(lineNumber, this._context.model.getLineMaxColumn(lineNumber)));
            }
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, pos);
        }
        var visibleRange = this._viewHelper.visibleRangeForPosition2(lineNumber, column);
        if (!visibleRange) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN, mouseColumn, pos);
        }
        var columnHorizontalOffset = visibleRange.left;
        if (mouseHorizontalOffset === columnHorizontalOffset) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos);
        }
        var mouseIsBetween;
        if (column > 1) {
            var prevColumnHorizontalOffset = visibleRange.left;
            mouseIsBetween = false;
            mouseIsBetween = mouseIsBetween || (prevColumnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < columnHorizontalOffset); // LTR case
            mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < prevColumnHorizontalOffset); // RTL case
            if (mouseIsBetween) {
                var rng = new range_1.Range(lineNumber, column, lineNumber, column - 1);
                return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos, rng);
            }
        }
        var lineMaxColumn = this._context.model.getLineMaxColumn(lineNumber);
        if (column < lineMaxColumn) {
            var nextColumnVisibleRange = this._viewHelper.visibleRangeForPosition2(lineNumber, column + 1);
            if (nextColumnVisibleRange) {
                var nextColumnHorizontalOffset = nextColumnVisibleRange.left;
                mouseIsBetween = false;
                mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < nextColumnHorizontalOffset); // LTR case
                mouseIsBetween = mouseIsBetween || (nextColumnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < columnHorizontalOffset); // RTL case
                if (mouseIsBetween) {
                    var rng = new range_1.Range(lineNumber, column, lineNumber, column + 1);
                    return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos, rng);
                }
            }
        }
        return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos);
    };
    MouseTargetFactory.prototype.createMouseTargetFromContentWidgetsChild = function (target, mouseColumn) {
        var widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
        if (widgetId) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_WIDGET, mouseColumn, null, null, widgetId);
        }
        else {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
        }
    };
    MouseTargetFactory.prototype.createMouseTargetFromOverlayWidgetsChild = function (target, mouseColumn) {
        var widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
        if (widgetId) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.OVERLAY_WIDGET, mouseColumn, null, null, widgetId);
        }
        else {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
        }
    };
    MouseTargetFactory.prototype.createMouseTargetFromLinesDecorationsChild = function (target, mouseVerticalOffset, mouseColumn) {
        var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
        if (viewZoneData) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
        }
        var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
        return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
    };
    MouseTargetFactory.prototype.createMouseTargetFromLineNumbers = function (target, mouseVerticalOffset, mouseColumn) {
        var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
        if (viewZoneData) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
        }
        var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
        return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
    };
    MouseTargetFactory.prototype.createMouseTargetFromGlyphMargin = function (target, mouseVerticalOffset, mouseColumn) {
        var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
        if (viewZoneData) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
        }
        var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
        return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
    };
    MouseTargetFactory.prototype.createMouseTargetFromScrollbar = function (target, mouseVerticalOffset, mouseColumn) {
        var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
        var maxColumn = this._context.model.getLineMaxColumn(possibleLineNumber);
        return new MouseTarget(target, editorCommon_1.MouseTargetType.SCROLLBAR, mouseColumn, new position_1.Position(possibleLineNumber, maxColumn));
    };
    MouseTargetFactory.prototype.createMouseTargetFromUnknownTarget = function (target) {
        var isInView = this._isChild(target, this._viewHelper.viewDomNode, this._viewHelper.viewDomNode);
        var widgetId = null;
        if (isInView) {
            widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
        }
        if (widgetId) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.OVERLAY_WIDGET, null, null, widgetId);
        }
        else {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
        }
    };
    return MouseTargetFactory;
}());
exports.MouseTargetFactory = MouseTargetFactory;
