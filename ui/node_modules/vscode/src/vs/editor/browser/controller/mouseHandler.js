/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lifecycle_1 = require('vs/base/common/lifecycle');
var platform = require('vs/base/common/platform');
var browser = require('vs/base/browser/browser');
var dom = require('vs/base/browser/dom');
var position_1 = require('vs/editor/common/core/position');
var selection_1 = require('vs/editor/common/core/selection');
var editorCommon = require('vs/editor/common/editorCommon');
var viewEventHandler_1 = require('vs/editor/common/viewModel/viewEventHandler');
var mouseTarget_1 = require('vs/editor/browser/controller/mouseTarget');
var async_1 = require('vs/base/common/async');
var editorDom_1 = require('vs/editor/browser/editorDom');
var mouseEvent_1 = require('vs/base/browser/mouseEvent');
var commonEditorConfig_1 = require('vs/editor/common/config/commonEditorConfig');
/**
 * Merges mouse events when mouse move events are throttled
 */
function createMouseMoveEventMerger(mouseTargetFactory) {
    return function (lastEvent, currentEvent) {
        var targetIsWidget = false;
        if (mouseTargetFactory) {
            targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);
        }
        if (!targetIsWidget) {
            currentEvent.preventDefault();
        }
        return currentEvent;
    };
}
var EventGateKeeper = (function (_super) {
    __extends(EventGateKeeper, _super);
    function EventGateKeeper(destination, condition) {
        var _this = this;
        _super.call(this);
        this._destination = destination;
        this._condition = condition;
        this._retryTimer = this._register(new async_1.TimeoutTimer());
        this.handler = function (value) { return _this._handle(value); };
    }
    EventGateKeeper.prototype.dispose = function () {
        this._retryValue = null;
        _super.prototype.dispose.call(this);
    };
    EventGateKeeper.prototype._handle = function (value) {
        var _this = this;
        if (this._condition()) {
            this._retryTimer.cancel();
            this._retryValue = null;
            this._destination(value);
        }
        else {
            this._retryValue = value;
            this._retryTimer.setIfNotSet(function () {
                var tmp = _this._retryValue;
                _this._retryValue = null;
                _this._handle(tmp);
            }, 10);
        }
    };
    return EventGateKeeper;
}(lifecycle_1.Disposable));
var MousePosition = (function () {
    function MousePosition(position, mouseColumn) {
        this.position = position;
        this.mouseColumn = mouseColumn;
    }
    return MousePosition;
}());
var MouseHandler = (function (_super) {
    __extends(MouseHandler, _super);
    function MouseHandler(context, viewController, viewHelper) {
        var _this = this;
        _super.call(this);
        this._isFocused = false;
        this._context = context;
        this.viewController = viewController;
        this.viewHelper = viewHelper;
        this.mouseTargetFactory = new mouseTarget_1.MouseTargetFactory(this._context, viewHelper);
        this.listenersToRemove = [];
        this._mouseDownOperation = new MouseDownOperation(this._context, this.viewController, this.viewHelper, function (e, testEventTarget) { return _this._createMouseTarget(e, testEventTarget); }, function (e) { return _this._getMouseColumn(e); });
        this.toDispose = [];
        this._asyncFocus = new async_1.RunOnceScheduler(function () { return _this.viewHelper.focusTextArea(); }, 0);
        this.toDispose.push(this._asyncFocus);
        this.lastMouseLeaveTime = -1;
        var mouseEvents = new editorDom_1.EditorMouseEventFactory(this.viewHelper.viewDomNode);
        this.listenersToRemove.push(mouseEvents.onContextMenu(this.viewHelper.viewDomNode, function (e) { return _this._onContextMenu(e, true); }));
        this._mouseMoveEventHandler = new EventGateKeeper(function (e) { return _this._onMouseMove(e); }, function () { return !_this.viewHelper.isDirty(); });
        this.toDispose.push(this._mouseMoveEventHandler);
        this.listenersToRemove.push(mouseEvents.onMouseMoveThrottled(this.viewHelper.viewDomNode, this._mouseMoveEventHandler.handler, createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
        this.listenersToRemove.push(mouseEvents.onMouseUp(this.viewHelper.viewDomNode, function (e) { return _this._onMouseUp(e); }));
        this.listenersToRemove.push(mouseEvents.onMouseLeave(this.viewHelper.viewDomNode, function (e) { return _this._onMouseLeave(e); }));
        this.listenersToRemove.push(mouseEvents.onMouseDown(this.viewHelper.viewDomNode, function (e) { return _this._onMouseDown(e); }));
        var onMouseWheel = function (browserEvent) {
            if (!_this._context.configuration.editor.viewInfo.mouseWheelZoom) {
                return;
            }
            var e = new mouseEvent_1.StandardMouseWheelEvent(browserEvent);
            if (e.browserEvent.ctrlKey || e.browserEvent.metaKey) {
                var zoomLevel = commonEditorConfig_1.EditorZoom.getZoomLevel();
                var delta = e.deltaY > 0 ? 1 : -1;
                commonEditorConfig_1.EditorZoom.setZoomLevel(zoomLevel + delta);
                e.preventDefault();
                e.stopPropagation();
            }
        };
        this.listenersToRemove.push(dom.addDisposableListener(this.viewHelper.viewDomNode, 'mousewheel', onMouseWheel, true));
        this.listenersToRemove.push(dom.addDisposableListener(this.viewHelper.viewDomNode, 'DOMMouseScroll', onMouseWheel, true));
        this._context.addEventHandler(this);
    }
    MouseHandler.prototype.dispose = function () {
        this._context.removeEventHandler(this);
        this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
        this.toDispose = lifecycle_1.dispose(this.toDispose);
        this._mouseDownOperation.dispose();
    };
    MouseHandler.prototype.onLayoutChanged = function (layoutInfo) {
        this._layoutInfo = layoutInfo;
        return false;
    };
    MouseHandler.prototype.onScrollChanged = function (e) {
        this._mouseDownOperation.onScrollChanged();
        return false;
    };
    MouseHandler.prototype.onCursorSelectionChanged = function (e) {
        this._mouseDownOperation.onCursorSelectionChanged(e);
        return false;
    };
    MouseHandler.prototype.onViewFocusChanged = function (isFocused) {
        this._isFocused = isFocused;
        return false;
    };
    // --- end event handlers
    MouseHandler.prototype._createMouseTarget = function (e, testEventTarget) {
        var lastViewCursorsRenderData = this.viewHelper.getLastViewCursorsRenderData();
        return this.mouseTargetFactory.createMouseTarget(this._layoutInfo, lastViewCursorsRenderData, e, testEventTarget);
    };
    MouseHandler.prototype._getMouseColumn = function (e) {
        return this.mouseTargetFactory.getMouseColumn(this._layoutInfo, e);
    };
    MouseHandler.prototype._onContextMenu = function (e, testEventTarget) {
        this.viewController.emitContextMenu({
            event: e,
            target: this._createMouseTarget(e, testEventTarget)
        });
    };
    MouseHandler.prototype._onMouseMove = function (e) {
        if (this._mouseDownOperation.isActive()) {
            // In selection/drag operation
            return;
        }
        var actualMouseMoveTime = e.timestamp;
        if (actualMouseMoveTime < this.lastMouseLeaveTime) {
            // Due to throttling, this event occured before the mouse left the editor, therefore ignore it.
            return;
        }
        this.viewController.emitMouseMove({
            event: e,
            target: this._createMouseTarget(e, true)
        });
    };
    MouseHandler.prototype._onMouseLeave = function (e) {
        this.lastMouseLeaveTime = (new Date()).getTime();
        this.viewController.emitMouseLeave({
            event: e,
            target: null
        });
    };
    MouseHandler.prototype._onMouseUp = function (e) {
        this.viewController.emitMouseUp({
            event: e,
            target: this._createMouseTarget(e, true)
        });
    };
    MouseHandler.prototype._onMouseDown = function (e) {
        var _this = this;
        var t = this._createMouseTarget(e, true);
        var targetIsContent = (t.type === editorCommon.MouseTargetType.CONTENT_TEXT || t.type === editorCommon.MouseTargetType.CONTENT_EMPTY);
        var targetIsGutter = (t.type === editorCommon.MouseTargetType.GUTTER_GLYPH_MARGIN || t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS || t.type === editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS);
        var targetIsLineNumbers = (t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
        var selectOnLineNumbers = this._context.configuration.editor.viewInfo.selectOnLineNumbers;
        var targetIsViewZone = (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE);
        var targetIsWidget = (t.type === editorCommon.MouseTargetType.CONTENT_WIDGET);
        var shouldHandle = e.leftButton;
        if (platform.isMacintosh && e.ctrlKey) {
            shouldHandle = false;
        }
        var focus = function () {
            // In IE11, if the focus is in the browser's address bar and
            // then you click in the editor, calling preventDefault()
            // will not move focus properly (focus remains the address bar)
            if (browser.isIE11orEarlier && !_this._isFocused) {
                _this._asyncFocus.schedule();
            }
            else {
                e.preventDefault();
                _this.viewHelper.focusTextArea();
            }
        };
        if (shouldHandle && (targetIsContent || (targetIsLineNumbers && selectOnLineNumbers))) {
            focus();
            this._mouseDownOperation.start(t.type, e);
        }
        else if (targetIsGutter) {
            // Do not steal focus
            e.preventDefault();
        }
        else if (targetIsViewZone) {
            var viewZoneData = t.detail;
            if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {
                focus();
                this._mouseDownOperation.start(t.type, e);
                e.preventDefault();
            }
        }
        else if (targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail)) {
            focus();
            e.preventDefault();
        }
        this.viewController.emitMouseDown({
            event: e,
            target: t
        });
    };
    MouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100; // ms
    return MouseHandler;
}(viewEventHandler_1.ViewEventHandler));
exports.MouseHandler = MouseHandler;
var MouseDownOperation = (function (_super) {
    __extends(MouseDownOperation, _super);
    function MouseDownOperation(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {
        var _this = this;
        _super.call(this);
        this._context = context;
        this._viewController = viewController;
        this._viewHelper = viewHelper;
        this._createMouseTarget = createMouseTarget;
        this._getMouseColumn = getMouseColumn;
        this._currentSelection = new selection_1.Selection(1, 1, 1, 1);
        this._mouseState = new MouseDownState();
        this._onScrollTimeout = this._register(new async_1.TimeoutTimer());
        this._isActive = false;
        this._lastMouseEvent = null;
        this._mouseMoveMonitor = this._register(new editorDom_1.GlobalEditorMouseMoveMonitor(this._viewHelper.viewDomNode));
        this._mouseDownThenMoveEventHandler = this._register(new EventGateKeeper(function (e) { return _this._onMouseDownThenMove(e); }, function () { return !_this._viewHelper.isDirty(); }));
    }
    MouseDownOperation.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    MouseDownOperation.prototype.isActive = function () {
        return this._isActive;
    };
    MouseDownOperation.prototype._onMouseDownThenMove = function (e) {
        this._lastMouseEvent = e;
        this._mouseState.setModifiers(e);
        var position = this._findMousePosition(e, true);
        if (!position) {
            // Ignoring because position is unknown
            return;
        }
        this._dispatchMouse(position, true);
    };
    MouseDownOperation.prototype.start = function (targetType, e) {
        var _this = this;
        this._lastMouseEvent = e;
        this._mouseState.setStartedOnLineNumbers(targetType === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
        this._mouseState.setModifiers(e);
        var position = this._findMousePosition(e, true);
        if (!position) {
            // Ignoring because position is unknown
            return;
        }
        this._mouseState.trySetCount(e.detail, position.position);
        // Overwrite the detail of the MouseEvent, as it will be sent out in an event and contributions might rely on it.
        e.detail = this._mouseState.count;
        this._dispatchMouse(position, e.shiftKey);
        if (!this._isActive) {
            this._isActive = true;
            this._mouseMoveMonitor.startMonitoring(createMouseMoveEventMerger(null), this._mouseDownThenMoveEventHandler.handler, function () { return _this._stop(); });
        }
    };
    MouseDownOperation.prototype._stop = function () {
        this._isActive = false;
        this._onScrollTimeout.cancel();
    };
    MouseDownOperation.prototype.onScrollChanged = function () {
        var _this = this;
        if (!this._isActive) {
            return;
        }
        this._onScrollTimeout.setIfNotSet(function () {
            var position = _this._findMousePosition(_this._lastMouseEvent, false);
            if (!position) {
                // Ignoring because position is unknown
                return;
            }
            _this._dispatchMouse(position, true);
        }, 10);
    };
    MouseDownOperation.prototype.onCursorSelectionChanged = function (e) {
        this._currentSelection = e.selection;
    };
    MouseDownOperation.prototype._getPositionOutsideEditor = function (e) {
        var editorContent = e.editorPos;
        var mouseColumn = this._getMouseColumn(e);
        if (e.posy < editorContent.top) {
            var aboveLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(Math.max(this._viewHelper.getScrollTop() - (editorContent.top - e.posy), 0));
            return new MousePosition(new position_1.Position(aboveLineNumber, 1), mouseColumn);
        }
        if (e.posy > editorContent.top + editorContent.height) {
            var belowLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.top));
            return new MousePosition(new position_1.Position(belowLineNumber, this._context.model.getLineMaxColumn(belowLineNumber)), mouseColumn);
        }
        var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.top));
        if (e.posx < editorContent.left) {
            return new MousePosition(new position_1.Position(possibleLineNumber, 1), mouseColumn);
        }
        if (e.posx > editorContent.left + editorContent.width) {
            return new MousePosition(new position_1.Position(possibleLineNumber, this._context.model.getLineMaxColumn(possibleLineNumber)), mouseColumn);
        }
        return null;
    };
    MouseDownOperation.prototype._findMousePosition = function (e, testEventTarget) {
        var positionOutsideEditor = this._getPositionOutsideEditor(e);
        if (positionOutsideEditor) {
            return positionOutsideEditor;
        }
        var t = this._createMouseTarget(e, testEventTarget);
        var hintedPosition = t.position;
        if (!hintedPosition) {
            return null;
        }
        if (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE) {
            // Force position on view zones to go above or below depending on where selection started from
            var selectionStart = new position_1.Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);
            var viewZoneData = t.detail;
            var positionBefore = viewZoneData.positionBefore;
            var positionAfter = viewZoneData.positionAfter;
            if (positionBefore && positionAfter) {
                if (positionBefore.isBefore(selectionStart)) {
                    return new MousePosition(positionBefore, t.mouseColumn);
                }
                else {
                    return new MousePosition(positionAfter, t.mouseColumn);
                }
            }
        }
        return new MousePosition(hintedPosition, t.mouseColumn);
    };
    MouseDownOperation.prototype._dispatchMouse = function (position, inSelectionMode) {
        this._viewController.dispatchMouse({
            position: position.position,
            mouseColumn: position.mouseColumn,
            startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
            inSelectionMode: inSelectionMode,
            mouseDownCount: this._mouseState.count,
            altKey: this._mouseState.altKey,
            ctrlKey: this._mouseState.ctrlKey,
            metaKey: this._mouseState.metaKey,
            shiftKey: this._mouseState.shiftKey,
        });
    };
    return MouseDownOperation;
}(lifecycle_1.Disposable));
var MouseDownState = (function () {
    function MouseDownState() {
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._startedOnLineNumbers = false;
        this._lastMouseDownPosition = null;
        this._lastMouseDownPositionEqualCount = 0;
        this._lastMouseDownCount = 0;
        this._lastSetMouseDownCountTime = 0;
    }
    Object.defineProperty(MouseDownState.prototype, "altKey", {
        get: function () { return this._altKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "ctrlKey", {
        get: function () { return this._ctrlKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "metaKey", {
        get: function () { return this._metaKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "shiftKey", {
        get: function () { return this._shiftKey; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "startedOnLineNumbers", {
        get: function () { return this._startedOnLineNumbers; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseDownState.prototype, "count", {
        get: function () {
            return this._lastMouseDownCount;
        },
        enumerable: true,
        configurable: true
    });
    MouseDownState.prototype.setModifiers = function (source) {
        this._altKey = source.altKey;
        this._ctrlKey = source.ctrlKey;
        this._metaKey = source.metaKey;
        this._shiftKey = source.shiftKey;
    };
    MouseDownState.prototype.setStartedOnLineNumbers = function (startedOnLineNumbers) {
        this._startedOnLineNumbers = startedOnLineNumbers;
    };
    MouseDownState.prototype.trySetCount = function (setMouseDownCount, newMouseDownPosition) {
        // a. Invalidate multiple clicking if too much time has passed (will be hit by IE because the detail field of mouse events contains garbage in IE10)
        var currentTime = (new Date()).getTime();
        if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
            setMouseDownCount = 1;
        }
        this._lastSetMouseDownCountTime = currentTime;
        // b. Ensure that we don't jump from single click to triple click in one go (will be hit by IE because the detail field of mouse events contains garbage in IE10)
        if (setMouseDownCount > this._lastMouseDownCount + 1) {
            setMouseDownCount = this._lastMouseDownCount + 1;
        }
        // c. Invalidate multiple clicking if the logical position is different
        if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {
            this._lastMouseDownPositionEqualCount++;
        }
        else {
            this._lastMouseDownPositionEqualCount = 1;
        }
        this._lastMouseDownPosition = newMouseDownPosition;
        // Finally set the lastMouseDownCount
        this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
    };
    MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400; // ms
    return MouseDownState;
}());
