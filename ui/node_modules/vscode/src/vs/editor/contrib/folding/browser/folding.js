/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/// <amd-dependency path="vs/css!./folding" />
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var nls = require('vs/nls');
var types = require('vs/base/common/types');
var async_1 = require('vs/base/common/async');
var keyCodes_1 = require('vs/base/common/keyCodes');
var lifecycle_1 = require('vs/base/common/lifecycle');
var winjs_base_1 = require('vs/base/common/winjs.base');
var editorCommon = require('vs/editor/common/editorCommon');
var range_1 = require('vs/editor/common/core/range');
var editorCommonExtensions_1 = require('vs/editor/common/editorCommonExtensions');
var editorBrowserExtensions_1 = require('vs/editor/browser/editorBrowserExtensions');
var foldingModel_1 = require('vs/editor/contrib/folding/common/foldingModel');
var indentFoldStrategy_1 = require('vs/editor/contrib/folding/common/indentFoldStrategy');
var EditorContextKeys = editorCommon.EditorContextKeys;
var FoldingController = (function () {
    function FoldingController(editor) {
        var _this = this;
        this.editor = editor;
        this._isEnabled = this.editor.getConfiguration().contribInfo.folding;
        this.globalToDispose = [];
        this.localToDispose = [];
        this.decorations = [];
        this.computeToken = 0;
        this.globalToDispose.push(this.editor.onDidChangeModel(function () { return _this.onModelChanged(); }));
        this.globalToDispose.push(this.editor.onDidChangeConfiguration(function (e) {
            var oldIsEnabled = _this._isEnabled;
            _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;
            if (oldIsEnabled !== _this._isEnabled) {
                _this.onModelChanged();
            }
        }));
        this.onModelChanged();
    }
    FoldingController.get = function (editor) {
        return editor.getContribution(FoldingController.ID);
    };
    FoldingController.prototype.getId = function () {
        return FoldingController.ID;
    };
    FoldingController.prototype.dispose = function () {
        this.cleanState();
        this.globalToDispose = lifecycle_1.dispose(this.globalToDispose);
    };
    /**
     * Store view state.
     */
    FoldingController.prototype.saveViewState = function () {
        var model = this.editor.getModel();
        if (!model) {
            return {};
        }
        var collapsedRegions = [];
        this.decorations.forEach(function (d) {
            if (d.isCollapsed) {
                var range = d.getDecorationRange(model);
                if (range) {
                    collapsedRegions.push({ startLineNumber: range.startLineNumber, endLineNumber: range.endLineNumber, indent: d.indent, isCollapsed: true });
                }
            }
        });
        return { collapsedRegions: collapsedRegions, lineCount: model.getLineCount() };
    };
    /**
     * Restore view state.
     */
    FoldingController.prototype.restoreViewState = function (state) {
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        if (!this._isEnabled) {
            return;
        }
        if (!state || !Array.isArray(state.collapsedRegions) || state.collapsedRegions.length === 0 || state.lineCount !== model.getLineCount()) {
            return;
        }
        this.applyRegions(state.collapsedRegions);
    };
    FoldingController.prototype.cleanState = function () {
        this.localToDispose = lifecycle_1.dispose(this.localToDispose);
    };
    FoldingController.prototype.applyRegions = function (regions) {
        var _this = this;
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        var updateHiddenRegions = false;
        regions = indentFoldStrategy_1.limitByIndent(regions, FoldingController.MAX_FOLDING_REGIONS).sort(function (r1, r2) { return r1.startLineNumber - r2.startLineNumber; });
        this.editor.changeDecorations(function (changeAccessor) {
            var newDecorations = [];
            var k = 0, i = 0;
            while (i < _this.decorations.length && k < regions.length) {
                var dec = _this.decorations[i];
                var decRange = dec.getDecorationRange(model);
                if (!decRange) {
                    updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                    dec.dispose(changeAccessor);
                    i++;
                }
                else {
                    while (k < regions.length && decRange.startLineNumber > regions[k].startLineNumber) {
                        var region = regions[k];
                        updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                        newDecorations.push(new foldingModel_1.CollapsibleRegion(region, model, changeAccessor));
                        k++;
                    }
                    if (k < regions.length) {
                        var currRange = regions[k];
                        if (decRange.startLineNumber < currRange.startLineNumber) {
                            updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                            dec.dispose(changeAccessor);
                            i++;
                        }
                        else if (decRange.startLineNumber === currRange.startLineNumber) {
                            if (dec.isCollapsed && (dec.startLineNumber !== currRange.startLineNumber || dec.endLineNumber !== currRange.endLineNumber)) {
                                updateHiddenRegions = true;
                            }
                            currRange.isCollapsed = dec.isCollapsed; // preserve collapse state
                            dec.update(currRange, model, changeAccessor);
                            newDecorations.push(dec);
                            i++;
                            k++;
                        }
                    }
                }
            }
            while (i < _this.decorations.length) {
                var dec = _this.decorations[i];
                updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                dec.dispose(changeAccessor);
                i++;
            }
            while (k < regions.length) {
                var region = regions[k];
                updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                newDecorations.push(new foldingModel_1.CollapsibleRegion(region, model, changeAccessor));
                k++;
            }
            _this.decorations = newDecorations;
        });
        if (updateHiddenRegions) {
            this.updateHiddenAreas(void 0);
        }
    };
    FoldingController.prototype.onModelChanged = function () {
        var _this = this;
        this.cleanState();
        var model = this.editor.getModel();
        if (!this._isEnabled || !model) {
            return;
        }
        this.contentChangedScheduler = new async_1.RunOnceScheduler(function () {
            var myToken = (++_this.computeToken);
            _this.computeCollapsibleRegions().then(function (regions) {
                if (myToken !== _this.computeToken) {
                    return; // A new request was made in the meantime or the model was changed
                }
                _this.applyRegions(regions);
            });
        }, 200);
        this.cursorChangedScheduler = new async_1.RunOnceScheduler(function () {
            _this.revealCursor();
        }, 200);
        this.localToDispose.push(this.contentChangedScheduler);
        this.localToDispose.push(this.cursorChangedScheduler);
        this.localToDispose.push(this.editor.onDidChangeModelContent(function () {
            _this.contentChangedScheduler.schedule();
        }));
        this.localToDispose.push({
            dispose: function () {
                ++_this.computeToken;
                _this.editor.changeDecorations(function (changeAccessor) {
                    _this.decorations.forEach(function (dec) { return dec.dispose(changeAccessor); });
                });
                _this.decorations = [];
                _this.editor.setHiddenAreas([]);
            }
        });
        this.localToDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
        this.localToDispose.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
        this.localToDispose.push(this.editor.onDidChangeCursorPosition(function (e) {
            _this.cursorChangedScheduler.schedule();
        }));
        this.contentChangedScheduler.schedule();
    };
    FoldingController.prototype.computeCollapsibleRegions = function () {
        var model = this.editor.getModel();
        if (!model) {
            return winjs_base_1.TPromise.as([]);
        }
        var ranges = indentFoldStrategy_1.computeRanges(model);
        return winjs_base_1.TPromise.as(ranges);
    };
    FoldingController.prototype.revealCursor = function () {
        var _this = this;
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        var hasChanges = false;
        var selections = this.editor.getSelections();
        this.editor.changeDecorations(function (changeAccessor) {
            return _this.decorations.forEach(function (dec) {
                if (dec.isCollapsed) {
                    var decRange = dec.getDecorationRange(model);
                    if (decRange) {
                        for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
                            var selection = selections_1[_i];
                            // reveal if cursor in in one of the collapsed line (not the first)
                            if (decRange.startLineNumber < selection.selectionStartLineNumber && selection.selectionStartLineNumber <= decRange.endLineNumber) {
                                dec.setCollapsed(false, changeAccessor);
                                hasChanges = true;
                                break;
                            }
                        }
                    }
                }
            });
        });
        if (hasChanges) {
            this.updateHiddenAreas(this.editor.getPosition().lineNumber);
        }
    };
    FoldingController.prototype.onEditorMouseDown = function (e) {
        this.mouseDownInfo = null;
        if (this.decorations.length === 0) {
            return;
        }
        var range = e.target.range;
        if (!range || !range.isEmpty) {
            return;
        }
        if (!e.event.leftButton) {
            return;
        }
        var model = this.editor.getModel();
        var iconClicked = false;
        switch (e.target.type) {
            case editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS:
                iconClicked = true;
                break;
            case editorCommon.MouseTargetType.CONTENT_TEXT:
                if (range.isEmpty && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
                    break;
                }
                return;
            default:
                return;
        }
        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked: iconClicked };
    };
    FoldingController.prototype.onEditorMouseUp = function (e) {
        var _this = this;
        if (!this.mouseDownInfo) {
            return;
        }
        var lineNumber = this.mouseDownInfo.lineNumber;
        var iconClicked = this.mouseDownInfo.iconClicked;
        var range = e.target.range;
        if (!range || !range.isEmpty || range.startLineNumber !== lineNumber) {
            return;
        }
        var model = this.editor.getModel();
        if (iconClicked) {
            if (e.target.type !== editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS) {
                return;
            }
        }
        else {
            if (range.startColumn !== model.getLineMaxColumn(lineNumber)) {
                return;
            }
        }
        this.editor.changeDecorations(function (changeAccessor) {
            for (var i = 0; i < _this.decorations.length; i++) {
                var dec = _this.decorations[i];
                var decRange = dec.getDecorationRange(model);
                if (decRange.startLineNumber === lineNumber) {
                    if (iconClicked || dec.isCollapsed) {
                        dec.setCollapsed(!dec.isCollapsed, changeAccessor);
                        _this.updateHiddenAreas(lineNumber);
                    }
                    return;
                }
            }
        });
    };
    FoldingController.prototype.updateHiddenAreas = function (focusLine) {
        var model = this.editor.getModel();
        var selections = this.editor.getSelections();
        var updateSelections = false;
        var hiddenAreas = [];
        this.decorations.filter(function (dec) { return dec.isCollapsed; }).forEach(function (dec) {
            var decRange = dec.getDecorationRange(model);
            hiddenAreas.push({
                startLineNumber: decRange.startLineNumber + 1,
                startColumn: 1,
                endLineNumber: decRange.endLineNumber,
                endColumn: 1
            });
            selections.forEach(function (selection, i) {
                if (range_1.Range.containsPosition(decRange, selection.getStartPosition())) {
                    selections[i] = selection = selection.setStartPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                    updateSelections = true;
                }
                if (range_1.Range.containsPosition(decRange, selection.getEndPosition())) {
                    selections[i] = selection.setEndPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                    updateSelections = true;
                }
            });
        });
        var revealPosition;
        if (focusLine) {
            revealPosition = { lineNumber: focusLine, column: 1 };
        }
        else {
            revealPosition = selections[0].getStartPosition();
        }
        if (updateSelections) {
            this.editor.setSelections(selections);
        }
        this.editor.setHiddenAreas(hiddenAreas);
        this.editor.revealPositionInCenterIfOutsideViewport(revealPosition);
    };
    FoldingController.prototype.unfold = function (levels) {
        var _this = this;
        var model = this.editor.getModel();
        var hasChanges = false;
        var selections = this.editor.getSelections();
        var selectionsHasChanged = false;
        selections.forEach(function (selection, index) {
            var toUnfold = foldingModel_1.getCollapsibleRegionsToUnfoldAtLine(_this.decorations, model, selection.startLineNumber, levels);
            if (toUnfold.length > 0) {
                toUnfold.forEach(function (collapsibleRegion, index) {
                    _this.editor.changeDecorations(function (changeAccessor) {
                        collapsibleRegion.setCollapsed(false, changeAccessor);
                        hasChanges = true;
                    });
                });
                if (!foldingModel_1.doesLineBelongsToCollapsibleRegion(toUnfold[0].foldingRange, selection.startLineNumber)) {
                    var lineNumber = toUnfold[0].startLineNumber, column = model.getLineMaxColumn(toUnfold[0].startLineNumber);
                    selections[index] = selection.setEndPosition(lineNumber, column).setStartPosition(lineNumber, column);
                    selectionsHasChanged = true;
                }
            }
        });
        if (selectionsHasChanged) {
            this.editor.setSelections(selections);
        }
        if (hasChanges) {
            this.updateHiddenAreas(selections[0].startLineNumber);
        }
    };
    FoldingController.prototype.fold = function (levels, up) {
        var _this = this;
        var hasChanges = false;
        var selections = this.editor.getSelections();
        selections.forEach(function (selection) {
            var lineNumber = selection.startLineNumber;
            var toFold = foldingModel_1.getCollapsibleRegionsToFoldAtLine(_this.decorations, _this.editor.getModel(), lineNumber, levels, up);
            toFold.forEach(function (collapsibleRegion) { return _this.editor.changeDecorations(function (changeAccessor) {
                collapsibleRegion.setCollapsed(true, changeAccessor);
                hasChanges = true;
            }); });
        });
        if (hasChanges) {
            this.updateHiddenAreas(selections[0].startLineNumber);
        }
    };
    FoldingController.prototype.foldUnfoldRecursively = function (isFold) {
        var _this = this;
        var hasChanges = false;
        var model = this.editor.getModel();
        var selections = this.editor.getSelections();
        selections.forEach(function (selection) {
            var lineNumber = selection.startLineNumber;
            var endLineNumber;
            var decToFoldUnfold = [];
            for (var i = 0, len = _this.decorations.length; i < len; i++) {
                var dec = _this.decorations[i];
                var decRange = dec.getDecorationRange(model);
                if (!decRange) {
                    continue;
                }
                if (decRange.startLineNumber >= lineNumber && (decRange.endLineNumber <= endLineNumber || typeof endLineNumber === 'undefined')) {
                    //Protect against cursor not being in decoration and lower decoration folding/unfolding
                    if (decRange.startLineNumber !== lineNumber && typeof endLineNumber === 'undefined') {
                        return;
                    }
                    endLineNumber = endLineNumber || decRange.endLineNumber;
                    decToFoldUnfold.push(dec);
                }
            }
            ;
            if (decToFoldUnfold.length > 0) {
                decToFoldUnfold.forEach(function (dec) {
                    _this.editor.changeDecorations(function (changeAccessor) {
                        dec.setCollapsed(isFold, changeAccessor);
                        hasChanges = true;
                    });
                });
            }
        });
        if (hasChanges) {
            this.updateHiddenAreas(selections[0].startLineNumber);
        }
    };
    FoldingController.prototype.changeAll = function (collapse) {
        var _this = this;
        if (this.decorations.length > 0) {
            var hasChanges_1 = true;
            this.editor.changeDecorations(function (changeAccessor) {
                _this.decorations.forEach(function (d) {
                    if (collapse !== d.isCollapsed) {
                        d.setCollapsed(collapse, changeAccessor);
                        hasChanges_1 = true;
                    }
                });
            });
            if (hasChanges_1) {
                this.updateHiddenAreas(void 0);
            }
        }
    };
    FoldingController.prototype.foldLevel = function (foldLevel, selectedLineNumbers) {
        var _this = this;
        var model = this.editor.getModel();
        var foldingRegionStack = [model.getFullModelRange()]; // sentinel
        var hasChanges = false;
        this.editor.changeDecorations(function (changeAccessor) {
            _this.decorations.forEach(function (dec) {
                var decRange = dec.getDecorationRange(model);
                if (decRange) {
                    while (!range_1.Range.containsRange(foldingRegionStack[foldingRegionStack.length - 1], decRange)) {
                        foldingRegionStack.pop();
                    }
                    foldingRegionStack.push(decRange);
                    if (foldingRegionStack.length === foldLevel + 1 && !dec.isCollapsed && !selectedLineNumbers.some(function (lineNumber) { return decRange.startLineNumber < lineNumber && lineNumber <= decRange.endLineNumber; })) {
                        dec.setCollapsed(true, changeAccessor);
                        hasChanges = true;
                    }
                }
            });
        });
        if (hasChanges) {
            this.updateHiddenAreas(selectedLineNumbers[0]);
        }
    };
    FoldingController.ID = 'editor.contrib.folding';
    FoldingController.MAX_FOLDING_REGIONS = 5000;
    FoldingController = __decorate([
        editorBrowserExtensions_1.editorContribution
    ], FoldingController);
    return FoldingController;
}());
exports.FoldingController = FoldingController;
var FoldingAction = (function (_super) {
    __extends(FoldingAction, _super);
    function FoldingAction() {
        _super.apply(this, arguments);
    }
    FoldingAction.prototype.runEditorCommand = function (accessor, editor, args) {
        var foldingController = FoldingController.get(editor);
        if (!foldingController) {
            return;
        }
        this.reportTelemetry(accessor);
        this.invoke(foldingController, editor, args);
    };
    FoldingAction.prototype.run = function (accessor, editor) {
    };
    return FoldingAction;
}(editorCommonExtensions_1.EditorAction));
function foldingArgumentsConstraint(args) {
    if (!types.isUndefined(args)) {
        if (!types.isObject(args)) {
            return false;
        }
        var foldingArgs = args;
        if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {
            return false;
        }
        if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {
            return false;
        }
    }
    return true;
}
var UnfoldAction = (function (_super) {
    __extends(UnfoldAction, _super);
    function UnfoldAction() {
        _super.call(this, {
            id: 'editor.unfold',
            label: nls.localize('unfoldAction.label', "Unfold"),
            alias: 'Unfold',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: 32768 /* CtrlCmd */ | 16384 /* Shift */ | 89 /* US_CLOSE_SQUARE_BRACKET */
            },
            description: {
                description: 'Unfold the content in the editor',
                args: [
                    {
                        name: 'Unfold editor argument',
                        description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'level': Number of levels to unfold\n\t\t\t\t\t\t",
                        constraint: foldingArgumentsConstraint
                    }
                ]
            }
        });
    }
    UnfoldAction.prototype.invoke = function (foldingController, editor, args) {
        foldingController.unfold(args ? args.levels || 1 : 1);
    };
    UnfoldAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnfoldAction);
    return UnfoldAction;
}(FoldingAction));
var UnFoldRecursivelyAction = (function (_super) {
    __extends(UnFoldRecursivelyAction, _super);
    function UnFoldRecursivelyAction() {
        _super.call(this, {
            id: 'editor.unFoldRecursively',
            label: nls.localize('unFoldRecursivelyAction.label', "Unfold Recursively"),
            alias: 'Unfold Recursively',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 89 /* US_CLOSE_SQUARE_BRACKET */)
            }
        });
    }
    UnFoldRecursivelyAction.prototype.invoke = function (foldingController, editor, args) {
        foldingController.foldUnfoldRecursively(false);
    };
    UnFoldRecursivelyAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnFoldRecursivelyAction);
    return UnFoldRecursivelyAction;
}(FoldingAction));
var FoldAction = (function (_super) {
    __extends(FoldAction, _super);
    function FoldAction() {
        _super.call(this, {
            id: 'editor.fold',
            label: nls.localize('foldAction.label', "Fold"),
            alias: 'Fold',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: 32768 /* CtrlCmd */ | 16384 /* Shift */ | 87 /* US_OPEN_SQUARE_BRACKET */
            },
            description: {
                description: 'Fold the content in the editor',
                args: [
                    {
                        name: 'Fold editor argument',
                        description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold\n\t\t\t\t\t\t\t* 'up': If 'true' folds given number of levels up otherwise folds down\n\t\t\t\t\t\t",
                        constraint: foldingArgumentsConstraint
                    }
                ]
            }
        });
    }
    FoldAction.prototype.invoke = function (foldingController, editor, args) {
        args = args ? args : { levels: 1, direction: 'up' };
        foldingController.fold(args.levels || 1, args.direction === 'up');
    };
    FoldAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldAction);
    return FoldAction;
}(FoldingAction));
var FoldRecursivelyAction = (function (_super) {
    __extends(FoldRecursivelyAction, _super);
    function FoldRecursivelyAction() {
        _super.call(this, {
            id: 'editor.foldRecursively',
            label: nls.localize('foldRecursivelyAction.label', "Fold Recursively"),
            alias: 'Fold Recursively',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 87 /* US_OPEN_SQUARE_BRACKET */)
            }
        });
    }
    FoldRecursivelyAction.prototype.invoke = function (foldingController, editor) {
        foldingController.foldUnfoldRecursively(true);
    };
    FoldRecursivelyAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldRecursivelyAction);
    return FoldRecursivelyAction;
}(FoldingAction));
var FoldAllAction = (function (_super) {
    __extends(FoldAllAction, _super);
    function FoldAllAction() {
        _super.call(this, {
            id: 'editor.foldAll',
            label: nls.localize('foldAllAction.label', "Fold All"),
            alias: 'Fold All',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 21 /* KEY_0 */)
            }
        });
    }
    FoldAllAction.prototype.invoke = function (foldingController, editor) {
        foldingController.changeAll(true);
    };
    FoldAllAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldAllAction);
    return FoldAllAction;
}(FoldingAction));
var UnfoldAllAction = (function (_super) {
    __extends(UnfoldAllAction, _super);
    function UnfoldAllAction() {
        _super.call(this, {
            id: 'editor.unfoldAll',
            label: nls.localize('unfoldAllAction.label', "Unfold All"),
            alias: 'Unfold All',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 40 /* KEY_J */)
            }
        });
    }
    UnfoldAllAction.prototype.invoke = function (foldingController, editor) {
        foldingController.changeAll(false);
    };
    UnfoldAllAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnfoldAllAction);
    return UnfoldAllAction;
}(FoldingAction));
var FoldLevelAction = (function (_super) {
    __extends(FoldLevelAction, _super);
    function FoldLevelAction() {
        _super.apply(this, arguments);
    }
    FoldLevelAction.prototype.getFoldingLevel = function () {
        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
    };
    FoldLevelAction.prototype.getSelectedLines = function (editor) {
        return editor.getSelections().map(function (s) { return s.startLineNumber; });
    };
    FoldLevelAction.prototype.invoke = function (foldingController, editor) {
        foldingController.foldLevel(this.getFoldingLevel(), this.getSelectedLines(editor));
    };
    FoldLevelAction.ID_PREFIX = 'editor.foldLevel';
    FoldLevelAction.ID = function (level) { return FoldLevelAction.ID_PREFIX + level; };
    return FoldLevelAction;
}(FoldingAction));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(1),
    label: nls.localize('foldLevel1Action.label', "Fold Level 1"),
    alias: 'Fold Level 1',
    precondition: null,
    kbOpts: {
        kbExpr: EditorContextKeys.TextFocus,
        primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 22 /* KEY_1 */)
    }
}));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(2),
    label: nls.localize('foldLevel2Action.label', "Fold Level 2"),
    alias: 'Fold Level 2',
    precondition: null,
    kbOpts: {
        kbExpr: EditorContextKeys.TextFocus,
        primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 23 /* KEY_2 */)
    }
}));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(3),
    label: nls.localize('foldLevel3Action.label', "Fold Level 3"),
    alias: 'Fold Level 3',
    precondition: null,
    kbOpts: {
        kbExpr: EditorContextKeys.TextFocus,
        primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 24 /* KEY_3 */)
    }
}));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(4),
    label: nls.localize('foldLevel4Action.label', "Fold Level 4"),
    alias: 'Fold Level 4',
    precondition: null,
    kbOpts: {
        kbExpr: EditorContextKeys.TextFocus,
        primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 25 /* KEY_4 */)
    }
}));
editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(5),
    label: nls.localize('foldLevel5Action.label', "Fold Level 5"),
    alias: 'Fold Level 5',
    precondition: null,
    kbOpts: {
        kbExpr: EditorContextKeys.TextFocus,
        primary: keyCodes_1.KeyChord(32768 /* CtrlCmd */ | 41 /* KEY_K */, 32768 /* CtrlCmd */ | 26 /* KEY_5 */)
    }
}));
