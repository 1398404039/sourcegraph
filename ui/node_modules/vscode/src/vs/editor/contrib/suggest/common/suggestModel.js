/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require('vs/base/common/errors');
var arrays_1 = require('vs/base/common/arrays');
var collections_1 = require('vs/base/common/collections');
var event_1 = require('vs/base/common/event');
var lifecycle_1 = require('vs/base/common/lifecycle');
var strings_1 = require('vs/base/common/strings');
var winjs_base_1 = require('vs/base/common/winjs.base');
var editorCommon_1 = require('vs/editor/common/editorCommon');
var modes_1 = require('vs/editor/common/modes');
var suggest_1 = require('./suggest');
var completionModel_1 = require('./completionModel');
var Context = (function () {
    function Context(model, position, auto) {
        this.auto = auto;
        var lineContent = model.getLineContent(position.lineNumber);
        var wordUnderCursor = model.getWordAtPosition(position);
        if (wordUnderCursor) {
            this.wordBefore = lineContent.substring(wordUnderCursor.startColumn - 1, position.column - 1);
            this.wordAfter = lineContent.substring(position.column - 1, wordUnderCursor.endColumn - 1);
        }
        else {
            this.wordBefore = '';
            this.wordAfter = '';
        }
        this.lineNumber = position.lineNumber;
        this.column = position.column;
        this.lineContentBefore = lineContent.substr(0, position.column - 1);
        this.lineContentAfter = lineContent.substr(position.column - 1);
        this.isInEditableRange = true;
        if (model.hasEditableRange()) {
            var editableRange = model.getEditableRange();
            if (!editableRange.containsPosition(position)) {
                this.isInEditableRange = false;
            }
        }
    }
    Context.prototype.shouldAutoTrigger = function () {
        if (this.wordBefore.length === 0) {
            // Word before position is empty
            return false;
        }
        if (!isNaN(Number(this.wordBefore))) {
            // Word before is number only
            return false;
        }
        if (this.wordAfter.length > 0) {
            // Word after position is non empty
            return false;
        }
        return true;
    };
    Context.prototype.isDifferentContext = function (context) {
        if (this.lineNumber !== context.lineNumber) {
            // Line number has changed
            return true;
        }
        if (context.column < this.column - this.wordBefore.length) {
            // column went before word start
            return true;
        }
        if (!strings_1.startsWith(context.lineContentBefore, this.lineContentBefore) || this.lineContentAfter !== context.lineContentAfter) {
            // Line has changed before position
            return true;
        }
        if (context.wordBefore === '' && context.lineContentBefore !== this.lineContentBefore) {
            // Most likely a space has been typed
            return true;
        }
        return false;
    };
    Context.prototype.shouldRetrigger = function (context) {
        if (!strings_1.startsWith(this.lineContentBefore, context.lineContentBefore) || this.lineContentAfter !== context.lineContentAfter) {
            // Doesn't look like the same line
            return false;
        }
        if (this.lineContentBefore.length > context.lineContentBefore.length && this.wordBefore.length === 0) {
            // Text was deleted and previous current word was empty
            return false;
        }
        if (this.auto && context.wordBefore.length === 0) {
            // Currently in auto mode and new current word is empty
            return false;
        }
        return true;
    };
    return Context;
}());
exports.Context = Context;
var State;
(function (State) {
    State[State["Idle"] = 0] = "Idle";
    State[State["Manual"] = 1] = "Manual";
    State[State["Auto"] = 2] = "Auto";
})(State || (State = {}));
var SuggestModel = (function () {
    function SuggestModel(editor) {
        var _this = this;
        this.editor = editor;
        this.toDispose = [];
        this.triggerCharacterListeners = [];
        this._onDidCancel = new event_1.Emitter();
        this._onDidTrigger = new event_1.Emitter();
        this._onDidSuggest = new event_1.Emitter();
        this.state = 0 /* Idle */;
        this.triggerAutoSuggestPromise = null;
        this.requestPromise = null;
        this.completionModel = null;
        this.context = null;
        // wire up various listeners
        this.toDispose.push(this.editor.onDidChangeModel(function () {
            _this.updateTriggerCharacters();
            _this.cancel();
        }));
        this.toDispose.push(editor.onDidChangeModelMode(function () {
            _this.updateTriggerCharacters();
            _this.cancel();
        }));
        this.toDispose.push(this.editor.onDidChangeConfiguration(function () {
            _this.updateTriggerCharacters();
            _this.updateQuickSuggest();
        }));
        this.toDispose.push(modes_1.SuggestRegistry.onDidChange(function () {
            _this.updateTriggerCharacters();
            _this.updateActiveSuggestSession();
        }));
        this.toDispose.push(this.editor.onDidChangeCursorSelection(function (e) {
            _this.onCursorChange(e);
        }));
        this.updateTriggerCharacters();
        this.updateQuickSuggest();
    }
    Object.defineProperty(SuggestModel.prototype, "onDidCancel", {
        get: function () { return this._onDidCancel.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuggestModel.prototype, "onDidTrigger", {
        get: function () { return this._onDidTrigger.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SuggestModel.prototype, "onDidSuggest", {
        get: function () { return this._onDidSuggest.event; },
        enumerable: true,
        configurable: true
    });
    SuggestModel.prototype.dispose = function () {
        lifecycle_1.dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger]);
        this.toDispose = lifecycle_1.dispose(this.toDispose);
        this.triggerCharacterListeners = lifecycle_1.dispose(this.triggerCharacterListeners);
        this.cancel();
    };
    // --- handle configuration & precondition changes
    SuggestModel.prototype.updateQuickSuggest = function () {
        this.quickSuggestDelay = this.editor.getConfiguration().contribInfo.quickSuggestionsDelay;
        if (isNaN(this.quickSuggestDelay) || (!this.quickSuggestDelay && this.quickSuggestDelay !== 0) || this.quickSuggestDelay < 0) {
            this.quickSuggestDelay = 10;
        }
    };
    SuggestModel.prototype.updateTriggerCharacters = function () {
        var _this = this;
        this.triggerCharacterListeners = lifecycle_1.dispose(this.triggerCharacterListeners);
        if (this.editor.getConfiguration().readOnly
            || !this.editor.getModel()
            || !this.editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {
            return;
        }
        var supportsByTriggerCharacter = Object.create(null);
        for (var _i = 0, _a = modes_1.SuggestRegistry.all(this.editor.getModel()); _i < _a.length; _i++) {
            var support = _a[_i];
            if (arrays_1.isFalsyOrEmpty(support.triggerCharacters)) {
                continue;
            }
            for (var _b = 0, _c = support.triggerCharacters; _b < _c.length; _b++) {
                var ch = _c[_b];
                var array = supportsByTriggerCharacter[ch];
                if (!array) {
                    supportsByTriggerCharacter[ch] = [support];
                }
                else {
                    array.push(support);
                }
            }
        }
        collections_1.forEach(supportsByTriggerCharacter, function (entry) {
            _this.triggerCharacterListeners.push(_this.editor.addTypingListener(entry.key, function () {
                _this.trigger(true, false, entry.value);
            }));
        });
    };
    // --- trigger/retrigger/cancel suggest
    SuggestModel.prototype.cancel = function (retrigger) {
        if (retrigger === void 0) { retrigger = false; }
        if (this.triggerAutoSuggestPromise) {
            this.triggerAutoSuggestPromise.cancel();
            this.triggerAutoSuggestPromise = null;
        }
        if (this.requestPromise) {
            this.requestPromise.cancel();
            this.requestPromise = null;
        }
        this.state = 0 /* Idle */;
        this.completionModel = null;
        this.context = null;
        this._onDidCancel.fire({ retrigger: retrigger });
    };
    SuggestModel.prototype.updateActiveSuggestSession = function () {
        if (this.state !== 0 /* Idle */) {
            if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
                this.cancel();
            }
            else {
                this.trigger(this.state === 2 /* Auto */, true);
            }
        }
    };
    SuggestModel.prototype.onCursorChange = function (e) {
        var _this = this;
        if (!e.selection.isEmpty()) {
            this.cancel();
            return;
        }
        if (e.source !== 'keyboard' || e.reason !== editorCommon_1.CursorChangeReason.NotSet) {
            this.cancel();
            return;
        }
        if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
            return;
        }
        var isInactive = this.state === 0 /* Idle */;
        if (isInactive && !this.editor.getConfiguration().contribInfo.quickSuggestions) {
            return;
        }
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        var ctx = new Context(model, this.editor.getPosition(), false);
        if (isInactive) {
            // trigger was not called or it was canceled
            this.cancel();
            if (ctx.shouldAutoTrigger()) {
                this.triggerAutoSuggestPromise = winjs_base_1.TPromise.timeout(this.quickSuggestDelay);
                this.triggerAutoSuggestPromise.then(function () {
                    _this.triggerAutoSuggestPromise = null;
                    _this.trigger(true);
                });
            }
        }
        else if (this.completionModel && this.completionModel.incomplete.length > 0) {
            this.triggerFromIncomplete(this.state === 2 /* Auto */);
        }
        else {
            this.onNewContext(ctx);
        }
    };
    SuggestModel.prototype.trigger = function (auto, retrigger, onlyFrom) {
        var _this = this;
        if (retrigger === void 0) { retrigger = false; }
        var model = this.editor.getModel();
        if (!model) {
            return;
        }
        var ctx = new Context(model, this.editor.getPosition(), auto);
        if (!ctx.isInEditableRange) {
            return;
        }
        // Cancel previous requests, change state & update UI
        this.cancel(retrigger);
        this.state = auto ? 2 /* Auto */ : 1 /* Manual */;
        this._onDidTrigger.fire({ auto: auto });
        // Capture context when request was sent
        this.context = ctx;
        this.requestPromise = suggest_1.provideSuggestionItems(model, this.editor.getPosition(), this.editor.getConfiguration().contribInfo.snippetSuggestions, onlyFrom).then(function (items) {
            _this.requestPromise = null;
            if (_this.state === 0 /* Idle */) {
                return;
            }
            var model = _this.editor.getModel();
            if (!model) {
                return;
            }
            var ctx = new Context(model, _this.editor.getPosition(), auto);
            _this.completionModel = new completionModel_1.CompletionModel(items, _this.context.column, {
                leadingLineContent: ctx.lineContentBefore,
                characterCountDelta: _this.context ? ctx.column - _this.context.column : 0
            });
            _this.onNewContext(ctx);
        }).then(null, errors_1.onUnexpectedError);
    };
    SuggestModel.prototype.triggerFromIncomplete = function (auto) {
        var _this = this;
        this.requestPromise = suggest_1.provideSuggestionItems(this.editor.getModel(), this.editor.getPosition(), this.editor.getConfiguration().contribInfo.snippetSuggestions, this.completionModel.incomplete).then(function (items) {
            _this.requestPromise = null;
            if (_this.state === 0 /* Idle */) {
                return;
            }
            var model = _this.editor.getModel();
            if (!model) {
                return;
            }
            _this.completionModel.replaceIncomplete(items, suggest_1.getSuggestionComparator(_this.editor.getConfiguration().contribInfo.snippetSuggestions));
            _this.onNewContext(new Context(model, _this.editor.getPosition(), auto));
        });
    };
    SuggestModel.prototype.onNewContext = function (ctx) {
        if (this.context && this.context.isDifferentContext(ctx)) {
            if (this.context.shouldRetrigger(ctx)) {
                this.trigger(this.state === 2 /* Auto */, true);
            }
            else {
                this.cancel();
            }
        }
        else if (this.completionModel) {
            var auto = this.state === 2 /* Auto */;
            var oldLineContext = this.completionModel.lineContext;
            var isFrozen = false;
            this.completionModel.lineContext = {
                leadingLineContent: ctx.lineContentBefore,
                characterCountDelta: this.context ? ctx.column - this.context.column : 0
            };
            // when explicitly request when the next context goes
            // from 'results' to 'no results' freeze
            if (!auto && this.completionModel.items.length === 0) {
                this.completionModel.lineContext = oldLineContext;
                isFrozen = this.completionModel.items.length > 0;
            }
            this._onDidSuggest.fire({
                completionModel: this.completionModel,
                isFrozen: isFrozen,
                auto: auto
            });
        }
    };
    return SuggestModel;
}());
exports.SuggestModel = SuggestModel;
