/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var arrays_1 = require('vs/base/common/arrays');
var filters_1 = require('vs/base/common/filters');
var LineContext = (function () {
    function LineContext() {
    }
    return LineContext;
}());
exports.LineContext = LineContext;
var CompletionModel = (function () {
    function CompletionModel(items, column, lineContext) {
        this._items = items;
        this._column = column;
        this._lineContext = lineContext;
    }
    CompletionModel.prototype.replaceIncomplete = function (newItems, compareFn) {
        var newItemsIdx = 0;
        for (var i = 0; i < this._items.length; i++) {
            if (this._incomplete.indexOf(this._items[i].support) >= 0) {
                // we found an item which support signaled 'incomplete'
                // which means we remove the item. For perf reasons we
                // frist replace and only then splice.
                if (newItemsIdx < newItems.length) {
                    this._items[i] = newItems[newItemsIdx++];
                }
                else {
                    this._items.splice(i, 1);
                    i--;
                }
            }
        }
        // add remaining new items
        if (newItemsIdx < newItems.length) {
            (_a = this._items).push.apply(_a, newItems.slice(newItemsIdx));
        }
        // sort and reset cached state
        this._items.sort(compareFn);
        this._filteredItems = undefined;
        var _a;
    };
    Object.defineProperty(CompletionModel.prototype, "lineContext", {
        get: function () {
            return this._lineContext;
        },
        set: function (value) {
            if (this._lineContext.leadingLineContent !== value.leadingLineContent
                || this._lineContext.characterCountDelta !== value.characterCountDelta) {
                this._lineContext = value;
                this._filteredItems = undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "items", {
        get: function () {
            this._ensureCachedState();
            return this._filteredItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "topScoreIdx", {
        get: function () {
            this._ensureCachedState();
            return this._topScoreIdx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "incomplete", {
        get: function () {
            this._ensureCachedState();
            return this._incomplete;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "stats", {
        get: function () {
            this._ensureCachedState();
            return this._stats;
        },
        enumerable: true,
        configurable: true
    });
    CompletionModel.prototype._ensureCachedState = function () {
        if (!this._filteredItems) {
            this._createCachedState();
        }
    };
    CompletionModel.prototype._createCachedState = function () {
        this._filteredItems = [];
        this._incomplete = [];
        this._topScoreIdx = -1;
        this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };
        var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;
        var word = '';
        var topScore = -1;
        for (var _i = 0, _b = this._items; _i < _b.length; _i++) {
            var item = _b[_i];
            var suggestion = item.suggestion, support = item.support, container = item.container;
            var filter = support && support.filter || filters_1.fuzzyContiguousFilter;
            // 'word' is that remainder of the current line that we
            // filter and score against. In theory each suggestion uses a
            // differnet word, but in practice not - that's why we cache
            var wordLen = suggestion.overwriteBefore + characterCountDelta - (item.position.column - this._column);
            if (word.length !== wordLen) {
                word = leadingLineContent.slice(-wordLen);
            }
            var match = false;
            // compute highlights based on 'label'
            item.highlights = filter(word, suggestion.label);
            match = item.highlights !== null;
            // no match on label nor codeSnippet -> check on filterText
            if (!match && typeof suggestion.filterText === 'string') {
                if (!arrays_1.isFalsyOrEmpty(filter(word, suggestion.filterText))) {
                    match = true;
                    // try to compute highlights by stripping none-word
                    // characters from the end of the string
                    item.highlights = filter(word.replace(/^\W+|\W+$/, ''), suggestion.label);
                }
            }
            if (!match) {
                continue;
            }
            this._filteredItems.push(item);
            // compute score against word
            var wordLowerCase = word.toLowerCase();
            var score = CompletionModel._scoreByHighlight(item, word, wordLowerCase);
            if (score > topScore) {
                topScore = score;
                this._topScoreIdx = this._filteredItems.length - 1;
            }
            // collect those supports that signaled having
            // an incomplete result
            if (container.incomplete && this._incomplete.indexOf(support) < 0) {
                this._incomplete.push(support);
            }
            // update stats
            this._stats.suggestionCount++;
            switch (suggestion.type) {
                case 'snippet':
                    this._stats.snippetCount++;
                    break;
                case 'text':
                    this._stats.textCount++;
                    break;
            }
        }
    };
    CompletionModel._scoreByHighlight = function (item, currentWord, currentWordLowerCase) {
        var highlights = item.highlights, suggestion = item.suggestion;
        var score = 0;
        if (!arrays_1.isFalsyOrEmpty(highlights)) {
            for (var _i = 0, highlights_1 = highlights; _i < highlights_1.length; _i++) {
                var _a = highlights_1[_i], start = _a.start, end = _a.end;
                // find the highlight in the current word and
                // score it based on case-match and start index
                var part = suggestion.label.substring(start, end);
                if (currentWord.indexOf(part) >= 0) {
                    score += (2 * part.length) / (start + 1);
                }
                else if (currentWordLowerCase.indexOf(part) >= 0) {
                    score += part.length / (start + 1);
                }
            }
        }
        return score;
    };
    return CompletionModel;
}());
exports.CompletionModel = CompletionModel;
