/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var async_1 = require('vs/base/common/async');
var arrays_1 = require('vs/base/common/arrays');
var strings_1 = require('vs/base/common/strings');
var objects_1 = require('vs/base/common/objects');
var errors_1 = require('vs/base/common/errors');
var winjs_base_1 = require('vs/base/common/winjs.base');
var editorCommonExtensions_1 = require('vs/editor/common/editorCommonExtensions');
var modes_1 = require('vs/editor/common/modes');
var snippetsRegistry_1 = require('vs/editor/common/modes/snippetsRegistry');
var platform_1 = require('vs/platform/platform');
var contextkey_1 = require('vs/platform/contextkey/common/contextkey');
var defaultConfig_1 = require('vs/editor/common/config/defaultConfig');
exports.Context = {
    Visible: new contextkey_1.RawContextKey('suggestWidgetVisible', false),
    MultipleSuggestions: new contextkey_1.RawContextKey('suggestWidgetMultipleSuggestions', false),
    AcceptOnKey: new contextkey_1.RawContextKey('suggestionSupportsAcceptOnKey', true),
    AcceptSuggestionsOnEnter: new contextkey_1.RawContextKey('acceptSuggestionOnEnter', defaultConfig_1.DefaultConfig.editor.acceptSuggestionOnEnter)
};
// add suggestions from snippet registry.
exports.snippetSuggestSupport = {
    triggerCharacters: [],
    provideCompletionItems: function (model, position) {
        var suggestions = platform_1.Registry.as(snippetsRegistry_1.Extensions.Snippets).getSnippetCompletions(model, position);
        if (suggestions) {
            return { suggestions: suggestions, currentWord: '' };
        }
    }
};
function provideSuggestionItems(model, position, snippetConfig, onlyFrom) {
    if (snippetConfig === void 0) { snippetConfig = 'bottom'; }
    var result = [];
    var acceptSuggestion = createSuggesionFilter(snippetConfig);
    position = position.clone();
    // get provider groups, always add snippet suggestion provider
    var supports = modes_1.SuggestRegistry.orderedGroups(model);
    supports.unshift([exports.snippetSuggestSupport]);
    // add suggestions from contributed providers - providers are ordered in groups of
    // equal score and once a group produces a result the process stops
    var hasResult = false;
    var factory = supports.map(function (supports) {
        return function () {
            // stop when we have a result
            if (hasResult) {
                return;
            }
            // for each support in the group ask for suggestions
            return winjs_base_1.TPromise.join(supports.map(function (support) {
                if (!arrays_1.isFalsyOrEmpty(onlyFrom) && onlyFrom.indexOf(support) < 0) {
                    return;
                }
                return async_1.asWinJsPromise(function (token) { return support.provideCompletionItems(model, position, token); }).then(function (container) {
                    var len = result.length;
                    if (container && !arrays_1.isFalsyOrEmpty(container.suggestions)) {
                        for (var _i = 0, _a = container.suggestions; _i < _a.length; _i++) {
                            var suggestion = _a[_i];
                            if (acceptSuggestion(suggestion)) {
                                fixOverwriteBeforeAfter(suggestion, container);
                                result.push({
                                    position: position,
                                    container: container,
                                    suggestion: suggestion,
                                    support: support,
                                    resolve: createSuggestionResolver(support, suggestion, model, position)
                                });
                            }
                        }
                    }
                    if (len !== result.length && support !== exports.snippetSuggestSupport) {
                        hasResult = true;
                    }
                }, errors_1.onUnexpectedError);
            }));
        };
    });
    return async_1.sequence(factory).then(function () { return result.sort(getSuggestionComparator(snippetConfig)); });
}
exports.provideSuggestionItems = provideSuggestionItems;
function fixOverwriteBeforeAfter(suggestion, container) {
    if (typeof suggestion.overwriteBefore !== 'number') {
        suggestion.overwriteBefore = container.currentWord.length;
    }
    if (typeof suggestion.overwriteAfter !== 'number' || suggestion.overwriteAfter < 0) {
        suggestion.overwriteAfter = 0;
    }
}
function createSuggestionResolver(provider, suggestion, model, position) {
    return function () {
        if (typeof provider.resolveCompletionItem === 'function') {
            return async_1.asWinJsPromise(function (token) { return provider.resolveCompletionItem(model, position, suggestion, token); })
                .then(function (value) { objects_1.assign(suggestion, value); });
        }
        return winjs_base_1.TPromise.as(void 0);
    };
}
function createSuggesionFilter(snippetConfig) {
    if (snippetConfig === 'none') {
        return function (suggestion) { return suggestion.type !== 'snippet'; };
    }
    else {
        return function () { return true; };
    }
}
function getSuggestionComparator(snippetConfig) {
    function defaultComparator(a, b) {
        var ret = 0;
        // check with 'sortText'
        if (typeof a.suggestion.sortText === 'string' && typeof b.suggestion.sortText === 'string') {
            ret = strings_1.compare(a.suggestion.sortText.toLowerCase(), b.suggestion.sortText.toLowerCase());
        }
        // check with 'label'
        if (!ret) {
            ret = strings_1.compare(a.suggestion.label.toLowerCase(), b.suggestion.label.toLowerCase());
        }
        // check with 'type' and lower snippets
        if (!ret && a.suggestion.type !== b.suggestion.type) {
            if (a.suggestion.type === 'snippet') {
                ret = 1;
            }
            else if (b.suggestion.type === 'snippet') {
                ret = -1;
            }
        }
        return ret;
    }
    function snippetUpComparator(a, b) {
        if (a.suggestion.type !== b.suggestion.type) {
            if (a.suggestion.type === 'snippet') {
                return -1;
            }
            else if (b.suggestion.type === 'snippet') {
                return 1;
            }
        }
        return defaultComparator(a, b);
    }
    function snippetDownComparator(a, b) {
        if (a.suggestion.type !== b.suggestion.type) {
            if (a.suggestion.type === 'snippet') {
                return 1;
            }
            else if (b.suggestion.type === 'snippet') {
                return -1;
            }
        }
        return defaultComparator(a, b);
    }
    if (snippetConfig === 'top') {
        return snippetUpComparator;
    }
    else if (snippetConfig === 'bottom') {
        return snippetDownComparator;
    }
    else {
        return defaultComparator;
    }
}
exports.getSuggestionComparator = getSuggestionComparator;
editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeCompletionItemProvider', function (model, position, args) {
    return provideSuggestionItems(model, position);
});
