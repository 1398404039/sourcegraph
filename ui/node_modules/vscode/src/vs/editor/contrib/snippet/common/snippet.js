/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var strings = require("vs/base/common/strings");
var range_1 = require("vs/editor/common/core/range");
var collections = require("vs/base/common/collections");
var snippetParser_1 = require("vs/editor/contrib/snippet/common/snippetParser");
var CodeSnippet = (function () {
    function CodeSnippet() {
        this.lines = [];
        this.placeHolders = [];
        this.finishPlaceHolderIndex = -1;
    }
    CodeSnippet.fromTextmate = function (template, variableResolver) {
        var marker = new snippetParser_1.SnippetParser(true, false).parse(template);
        var snippet = new CodeSnippet();
        _resolveSnippetVariables(marker, variableResolver);
        _fillCodeSnippetFromMarker(snippet, marker);
        return snippet;
    };
    CodeSnippet.fromInternal = function (template) {
        var marker = new snippetParser_1.SnippetParser(false, true).parse(template);
        var snippet = new CodeSnippet();
        _fillCodeSnippetFromMarker(snippet, marker);
        return snippet;
    };
    CodeSnippet.none = function (template) {
        var snippet = new CodeSnippet();
        snippet.lines = template.split(/\r\n|\n|\r/);
        return snippet;
    };
    CodeSnippet.fromEmmet = function (template) {
        return EmmetSnippetParser.parse(template);
    };
    Object.defineProperty(CodeSnippet.prototype, "isInsertOnly", {
        get: function () {
            return this.placeHolders.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeSnippet.prototype, "isSingleTabstopOnly", {
        get: function () {
            if (this.placeHolders.length !== 1) {
                return false;
            }
            var placeHolder = this.placeHolders[0];
            if (placeHolder.value !== '' || placeHolder.occurences.length !== 1) {
                return false;
            }
            var placeHolderRange = placeHolder.occurences[0];
            if (!range_1.Range.isEmpty(placeHolderRange)) {
                return false;
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    CodeSnippet.prototype.extractLineIndentation = function (str, maxColumn) {
        if (maxColumn === void 0) { maxColumn = Number.MAX_VALUE; }
        var fullIndentation = strings.getLeadingWhitespace(str);
        if (fullIndentation.length > maxColumn - 1) {
            return fullIndentation.substring(0, maxColumn - 1);
        }
        return fullIndentation;
    };
    CodeSnippet.prototype.bind = function (referenceLine, deltaLine, firstLineDeltaColumn, config) {
        var resultLines = [];
        var resultPlaceHolders = [];
        var referenceIndentation = this.extractLineIndentation(referenceLine, firstLineDeltaColumn + 1);
        // Compute resultLines & keep deltaColumns as a reference for adjusting placeholders
        var deltaColumns = [];
        for (var i = 0, len = this.lines.length; i < len; i++) {
            var originalLine = this.lines[i];
            if (i === 0) {
                deltaColumns[i + 1] = firstLineDeltaColumn;
                resultLines[i] = originalLine;
            }
            else {
                var originalLineIndentation = this.extractLineIndentation(originalLine);
                var remainingLine = originalLine.substr(originalLineIndentation.length);
                var indentation = config.normalizeIndentation(referenceIndentation + originalLineIndentation);
                deltaColumns[i + 1] = indentation.length - originalLineIndentation.length;
                resultLines[i] = indentation + remainingLine;
            }
        }
        // Compute resultPlaceHolders
        for (var _i = 0, _a = this.placeHolders; _i < _a.length; _i++) {
            var originalPlaceHolder = _a[_i];
            var resultOccurences = [];
            for (var _b = 0, _c = originalPlaceHolder.occurences; _b < _c.length; _b++) {
                var _d = _c[_b], startLineNumber = _d.startLineNumber, startColumn = _d.startColumn, endLineNumber = _d.endLineNumber, endColumn = _d.endColumn;
                if (startColumn > 1) {
                    // placeholders that aren't at the beginning of the snippet line
                    // will be moved by how many characters the indentation has been
                    // adjusted
                    startColumn = startColumn + deltaColumns[startLineNumber];
                    endColumn = endColumn + deltaColumns[endLineNumber];
                }
                else {
                    // placeholders at the beginning of the snippet line
                    // will be indented by the reference indentation
                    startColumn += referenceIndentation.length;
                    endColumn += referenceIndentation.length;
                }
                resultOccurences.push({
                    startLineNumber: startLineNumber + deltaLine,
                    startColumn: startColumn,
                    endLineNumber: endLineNumber + deltaLine,
                    endColumn: endColumn
                });
            }
            resultPlaceHolders.push({
                id: originalPlaceHolder.id,
                value: originalPlaceHolder.value,
                occurences: resultOccurences
            });
        }
        return {
            lines: resultLines,
            placeHolders: resultPlaceHolders,
            finishPlaceHolderIndex: this.finishPlaceHolderIndex
        };
    };
    return CodeSnippet;
}());
exports.CodeSnippet = CodeSnippet;
var InternalFormatSnippetParser = new (function () {
    function class_1() {
    }
    class_1.prototype.parse = function (template) {
        this._lastGeneratedId = 0;
        this._snippet = new CodeSnippet();
        this.parseTemplate(template);
        return this._snippet;
    };
    class_1.prototype.parseTemplate = function (template) {
        var placeHoldersMap = Object.create(null);
        var i, len, j, lenJ, templateLines = template.split('\n');
        for (i = 0, len = templateLines.length; i < len; i++) {
            var parsedLine = this.parseLine(templateLines[i], function (id) {
                if (collections.contains(placeHoldersMap, id)) {
                    return placeHoldersMap[id].value;
                }
                return '';
            });
            for (j = 0, lenJ = parsedLine.placeHolders.length; j < lenJ; j++) {
                var linePlaceHolder = parsedLine.placeHolders[j];
                var occurence = new range_1.Range(i + 1, linePlaceHolder.startColumn, i + 1, linePlaceHolder.endColumn);
                var placeHolder;
                if (collections.contains(placeHoldersMap, linePlaceHolder.id)) {
                    placeHolder = placeHoldersMap[linePlaceHolder.id];
                }
                else {
                    placeHolder = {
                        id: linePlaceHolder.id,
                        value: linePlaceHolder.value,
                        occurences: []
                    };
                    this._snippet.placeHolders.push(placeHolder);
                    placeHoldersMap[linePlaceHolder.id] = placeHolder;
                }
                placeHolder.occurences.push(occurence);
            }
            this._snippet.lines.push(parsedLine.line);
        }
        // Named variables (e.g. {greeting} and {greeting:Hello}) are sorted first, followed by
        // tab-stops and numeric variables (e.g. $1, $2, ${3:foo}) which are sorted in ascending order
        this._snippet.placeHolders.sort(function (a, b) {
            var nonIntegerId = function (v) { return !(/^\d+$/).test(v.id); };
            var isFinishPlaceHolder = function (v) { return v.id === '' && v.value === ''; };
            // Sort finish placeholder last
            if (isFinishPlaceHolder(a)) {
                return 1;
            }
            else if (isFinishPlaceHolder(b)) {
                return -1;
            }
            // Sort named placeholders first
            if (nonIntegerId(a) && nonIntegerId(b)) {
                return 0;
            }
            else if (nonIntegerId(a)) {
                return -1;
            }
            else if (nonIntegerId(b)) {
                return 1;
            }
            if (a.id === b.id) {
                return 0;
            }
            return Number(a.id) < Number(b.id) ? -1 : 1;
        });
        if (this._snippet.placeHolders.length > 0 && this._snippet.placeHolders[this._snippet.placeHolders.length - 1].value === '') {
            this._snippet.finishPlaceHolderIndex = this._snippet.placeHolders.length - 1;
        }
    };
    class_1.prototype.parseLine = function (line, findDefaultValueForIdFromPrevLines) {
        // Placeholder 0 is the entire line
        var placeHolderStack = [{ placeHolderId: '', placeHolderText: '' }];
        var placeHolders = [];
        var findDefaultValueForId = function (id) {
            var result = findDefaultValueForIdFromPrevLines(id);
            if (result) {
                return result;
            }
            for (var _i = 0, placeHolders_1 = placeHolders; _i < placeHolders_1.length; _i++) {
                var placeHolder = placeHolders_1[_i];
                if (placeHolder.id === id && placeHolder.value) {
                    return placeHolder.value;
                }
            }
            return '';
        };
        var i = 0;
        var len = line.length;
        var resultIndex = 0;
        while (i < len) {
            var restOfLine = line.substr(i);
            // Look for the start of a placeholder {{
            if (/^{{/.test(restOfLine)) {
                i += 2;
                placeHolderStack.push({ placeHolderId: '', placeHolderText: '' });
                // Look for id
                var matches = restOfLine.match(/^{{(\w+):/);
                if (Array.isArray(matches) && matches.length === 2) {
                    placeHolderStack[placeHolderStack.length - 1].placeHolderId = matches[1];
                    i += matches[1].length + 1; // +1 to account for the : at the end of the id
                }
                continue;
            }
            // Look for the end of a placeholder. placeHolderStack[0] is the top-level line.
            if (placeHolderStack.length > 1 && /^}}/.test(restOfLine)) {
                i += 2;
                if (placeHolderStack[placeHolderStack.length - 1].placeHolderId.length === 0) {
                    // This placeholder did not have an explicit id
                    placeHolderStack[placeHolderStack.length - 1].placeHolderId = placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                    if (placeHolderStack[placeHolderStack.length - 1].placeHolderId === '_') {
                        // This is just an empty tab stop
                        placeHolderStack[placeHolderStack.length - 1].placeHolderId = 'TAB_STOP_' + String(++this._lastGeneratedId);
                        placeHolderStack[placeHolderStack.length - 1].placeHolderText = '';
                        --resultIndex; // Roll back one iteration of the result index as we made the text empty
                    }
                }
                if (placeHolderStack[placeHolderStack.length - 1].placeHolderText.length === 0) {
                    // This placeholder is empty or was a mirror
                    var defaultValue = findDefaultValueForId(placeHolderStack[placeHolderStack.length - 1].placeHolderId);
                    placeHolderStack[placeHolderStack.length - 1].placeHolderText = defaultValue;
                    resultIndex += defaultValue.length;
                }
                placeHolders.push({
                    id: placeHolderStack[placeHolderStack.length - 1].placeHolderId,
                    value: placeHolderStack[placeHolderStack.length - 1].placeHolderText,
                    startColumn: resultIndex + 1 - placeHolderStack[placeHolderStack.length - 1].placeHolderText.length,
                    endColumn: resultIndex + 1
                });
                // Insert our text into the previous placeholder
                placeHolderStack[placeHolderStack.length - 2].placeHolderText += placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                placeHolderStack.pop();
                continue;
            }
            // Look for escapes
            if (/^\\./.test(restOfLine)) {
                if (restOfLine.charAt(1) === '{' || restOfLine.charAt(1) === '}' || restOfLine.charAt(1) === '\\') {
                    ++i; // Skip the escape slash and take the character literally
                }
                else {
                    // invalid escapes
                    placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
                    ++resultIndex;
                    ++i;
                }
            }
            //This is an escape sequence or not a special character, just insert it
            placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
            ++resultIndex;
            ++i;
        }
        // Sort the placeholder in order of apperance:
        placeHolders.sort(function (a, b) {
            if (a.startColumn < b.startColumn) {
                return -1;
            }
            if (a.startColumn > b.startColumn) {
                return 1;
            }
            if (a.endColumn < b.endColumn) {
                return -1;
            }
            if (a.endColumn > b.endColumn) {
                return 1;
            }
            return 0;
        });
        return {
            line: placeHolderStack[0].placeHolderText,
            placeHolders: placeHolders
        };
    };
    return class_1;
}());
var EmmetSnippetParser = new (function () {
    function class_2() {
    }
    class_2.prototype.parse = function (template) {
        template = _convertExternalSnippet(template, ExternalSnippetType.EmmetSnippet);
        return InternalFormatSnippetParser.parse(template);
    };
    return class_2;
}());
var ExternalSnippetType;
(function (ExternalSnippetType) {
    ExternalSnippetType[ExternalSnippetType["TextMateSnippet"] = 0] = "TextMateSnippet";
    ExternalSnippetType[ExternalSnippetType["EmmetSnippet"] = 1] = "EmmetSnippet";
})(ExternalSnippetType = exports.ExternalSnippetType || (exports.ExternalSnippetType = {}));
// This is used for both TextMate and Emmet
function _convertExternalSnippet(snippet, snippetType) {
    var openBraces = 0;
    var convertedSnippet = '';
    var i = 0;
    var len = snippet.length;
    while (i < len) {
        var restOfLine = snippet.substr(i);
        // Cursor tab stop
        if (/^\$0/.test(restOfLine)) {
            i += 2;
            convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
            continue;
        }
        if (/^\$\{0\}/.test(restOfLine)) {
            i += 4;
            convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
            continue;
        }
        // Tab stops
        var matches = restOfLine.match(/^\$(\d+)/);
        if (Array.isArray(matches) && matches.length === 2) {
            i += 1 + matches[1].length;
            convertedSnippet += '{{' + matches[1] + ':}}';
            continue;
        }
        matches = restOfLine.match(/^\$\{(\d+)\}/);
        if (Array.isArray(matches) && matches.length === 2) {
            i += 3 + matches[1].length;
            convertedSnippet += '{{' + matches[1] + ':}}';
            continue;
        }
        // Open brace patterns placeholder
        if (/^\${/.test(restOfLine)) {
            i += 2;
            ++openBraces;
            convertedSnippet += '{{';
            continue;
        }
        // Close brace patterns placeholder
        if (openBraces > 0 && /^}/.test(restOfLine)) {
            i += 1;
            --openBraces;
            convertedSnippet += '}}';
            continue;
        }
        // Escapes
        if (/^\\./.test(restOfLine)) {
            i += 2;
            if (/^\\\$/.test(restOfLine)) {
                convertedSnippet += '$';
            }
            else {
                convertedSnippet += restOfLine.substr(0, 2);
            }
            continue;
        }
        // Escape braces that don't belong to a placeholder
        matches = restOfLine.match(/^({|})/);
        if (Array.isArray(matches) && matches.length === 2) {
            i += 1;
            convertedSnippet += '\\' + matches[1];
            continue;
        }
        i += 1;
        convertedSnippet += restOfLine.charAt(0);
    }
    return convertedSnippet;
}
;
function _resolveSnippetVariables(marker, resolver) {
    if (resolver) {
        var stack = marker.slice();
        while (stack.length > 0) {
            var marker_1 = stack.shift();
            if (marker_1 instanceof snippetParser_1.Variable) {
                try {
                    marker_1.resolvedValue = resolver.resolve(marker_1.name);
                }
                catch (e) {
                }
                if (marker_1.isDefined) {
                    continue;
                }
            }
            if (marker_1 instanceof snippetParser_1.Variable || marker_1 instanceof snippetParser_1.Placeholder) {
                // 'recurse'
                stack.unshift.apply(stack, marker_1.defaultValue);
            }
        }
    }
}
function _isFinishPlaceHolder(v) {
    return (v.id === '' && v.value === '') || v.id === '0';
}
function _fillCodeSnippetFromMarker(snippet, marker) {
    var placeHolders = Object.create(null);
    var hasFinishPlaceHolder = false;
    var stack = marker.slice();
    snippet.lines = [''];
    while (stack.length > 0) {
        var marker_2 = stack.shift();
        if (marker_2 instanceof snippetParser_1.Text) {
            // simple text
            var lines = marker_2.string.split(/\r\n|\n|\r/);
            snippet.lines[snippet.lines.length - 1] += lines.shift();
            (_a = snippet.lines).push.apply(_a, lines);
        }
        else if (marker_2 instanceof snippetParser_1.Placeholder) {
            var placeHolder = placeHolders[marker_2.name];
            if (!placeHolder) {
                placeHolders[marker_2.name] = placeHolder = {
                    id: marker_2.name,
                    value: snippetParser_1.Marker.toString(marker_2.defaultValue),
                    occurences: []
                };
                snippet.placeHolders.push(placeHolder);
            }
            hasFinishPlaceHolder = hasFinishPlaceHolder || _isFinishPlaceHolder(placeHolder);
            var line = snippet.lines.length;
            var column = snippet.lines[line - 1].length + 1;
            placeHolder.occurences.push({
                startLineNumber: line,
                startColumn: column,
                endLineNumber: line,
                endColumn: column + snippetParser_1.Marker.toString(marker_2.defaultValue).length // TODO multiline placeholders!
            });
            stack.unshift.apply(stack, marker_2.defaultValue);
        }
        else if (marker_2 instanceof snippetParser_1.Variable) {
            if (!marker_2.isDefined) {
                // contine as placeholder
                // THIS is because of us having falsy
                // advertised ${foo} as placeholder syntax
                stack.unshift(new snippetParser_1.Placeholder(marker_2.name, marker_2.defaultValue.length === 0
                    ? [new snippetParser_1.Text(marker_2.name)]
                    : marker_2.defaultValue));
            }
            else if (marker_2.resolvedValue) {
                // contine with the value
                stack.unshift(new snippetParser_1.Text(marker_2.resolvedValue));
            }
            else {
                // continue with default values
                stack.unshift.apply(stack, marker_2.defaultValue);
            }
        }
        if (stack.length === 0 && !hasFinishPlaceHolder) {
            stack.push(new snippetParser_1.Placeholder('0', []));
        }
    }
    // Named variables (e.g. {greeting} and {greeting:Hello}) are sorted first, followed by
    // tab-stops and numeric variables (e.g. $1, $2, ${3:foo}) which are sorted in ascending order
    snippet.placeHolders.sort(function (a, b) {
        var nonIntegerId = function (v) { return !(/^\d+$/).test(v.id); };
        // Sort finish placeholder last
        if (_isFinishPlaceHolder(a)) {
            return 1;
        }
        else if (_isFinishPlaceHolder(b)) {
            return -1;
        }
        // Sort named placeholders first
        if (nonIntegerId(a) && nonIntegerId(b)) {
            return 0;
        }
        else if (nonIntegerId(a)) {
            return -1;
        }
        else if (nonIntegerId(b)) {
            return 1;
        }
        if (a.id === b.id) {
            return 0;
        }
        return Number(a.id) < Number(b.id) ? -1 : 1;
    });
    if (snippet.placeHolders.length > 0) {
        snippet.finishPlaceHolderIndex = snippet.placeHolders.length - 1;
        snippet.placeHolders[snippet.finishPlaceHolderIndex].id = '';
    }
    var _a;
}
