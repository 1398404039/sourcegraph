/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
require('vs/base/browser/ui/progressbar/progressbar.css');
var nls = require('vs/nls');
var uri_1 = require('vs/base/common/uri');
var errors_1 = require('vs/base/common/errors');
var dom_1 = require('vs/base/browser/dom');
var winjs_base_1 = require('vs/base/common/winjs.base');
var htmlContentRenderer_1 = require('vs/base/browser/htmlContentRenderer');
var opener_1 = require('vs/platform/opener/common/opener');
var range_1 = require('vs/editor/common/core/range');
var position_1 = require('vs/editor/common/core/position');
var modes_1 = require('vs/editor/common/modes');
var textToHtmlTokenizer_1 = require('vs/editor/common/modes/textToHtmlTokenizer');
var hover_1 = require('../common/hover');
var hoverOperation_1 = require('./hoverOperation');
var hoverWidgets_1 = require('./hoverWidgets');
var htmlContent_1 = require('vs/base/common/htmlContent');
var ModesContentComputer = (function () {
    function ModesContentComputer(editor) {
        this._editor = editor;
        this._range = null;
    }
    ModesContentComputer.prototype.setRange = function (range) {
        this._range = range;
        this._result = [];
    };
    ModesContentComputer.prototype.clearResult = function () {
        this._result = [];
    };
    ModesContentComputer.prototype.computeAsync = function () {
        var model = this._editor.getModel();
        if (!modes_1.HoverProviderRegistry.has(model)) {
            return winjs_base_1.TPromise.as(null);
        }
        return hover_1.getHover(model, new position_1.Position(this._range.startLineNumber, this._range.startColumn));
    };
    ModesContentComputer.prototype.computeSync = function () {
        var _this = this;
        var result = [];
        var lineNumber = this._range.startLineNumber;
        if (lineNumber > this._editor.getModel().getLineCount()) {
            // Illegal line number => no results
            return result;
        }
        var hasHoverContent = function (contents) {
            return contents && (!Array.isArray(contents) || contents.length > 0);
        };
        var lineDecorations = this._editor.getLineDecorations(lineNumber);
        var maxColumn = this._editor.getModel().getLineMaxColumn(lineNumber);
        lineDecorations.forEach(function (d) {
            var startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;
            var endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;
            if (startColumn <= _this._range.startColumn && _this._range.endColumn <= endColumn && hasHoverContent(d.options.hoverMessage)) {
                var obj = {
                    contents: [],
                    range: new range_1.Range(_this._range.startLineNumber, startColumn, _this._range.startLineNumber, endColumn)
                };
                if (d.options.hoverMessage) {
                    if (Array.isArray(d.options.hoverMessage)) {
                        obj.contents = obj.contents.concat(d.options.hoverMessage);
                    }
                    else {
                        obj.contents.push(d.options.hoverMessage);
                    }
                }
                result.push(obj);
            }
        });
        return result;
    };
    ModesContentComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
        // Always put synchronous messages before asynchronous ones
        if (isFromSynchronousComputation) {
            this._result = result.concat(this._result);
        }
        else {
            this._result = this._result.concat(result);
        }
    };
    ModesContentComputer.prototype.getResult = function () {
        return this._result.slice(0);
    };
    ModesContentComputer.prototype.getResultWithLoadingMessage = function () {
        return this._result.slice(0).concat([this._getLoadingMessage()]);
    };
    ModesContentComputer.prototype._getLoadingMessage = function () {
        return {
            range: this._range,
            contents: [htmlContent_1.textToMarkedString(nls.localize('modesContentHover.loading', "Loading..."))]
        };
    };
    return ModesContentComputer;
}());
var ModesContentHoverWidget = (function (_super) {
    __extends(ModesContentHoverWidget, _super);
    function ModesContentHoverWidget(editor, openerService, modeService) {
        var _this = this;
        _super.call(this, ModesContentHoverWidget.ID, editor);
        this._computer = new ModesContentComputer(this._editor);
        this._highlightDecorations = [];
        this._isChangingDecorations = false;
        this._openerService = openerService || opener_1.NullOpenerService;
        this._modeService = modeService;
        this._hoverOperation = new hoverOperation_1.HoverOperation(this._computer, function (result) { return _this._withResult(result, true); }, null, function (result) { return _this._withResult(result, false); });
    }
    ModesContentHoverWidget.prototype.dispose = function () {
        this._hoverOperation.cancel();
        _super.prototype.dispose.call(this);
    };
    ModesContentHoverWidget.prototype.onModelDecorationsChanged = function () {
        if (this._isChangingDecorations) {
            return;
        }
        if (this.isVisible) {
            // The decorations have changed and the hover is visible,
            // we need to recompute the displayed text
            this._hoverOperation.cancel();
            this._computer.clearResult();
            this._hoverOperation.start();
        }
    };
    ModesContentHoverWidget.prototype.startShowingAt = function (range, focus) {
        if (this._lastRange) {
            if (this._lastRange.equalsRange(range)) {
                // We have to show the widget at the exact same range as before, so no work is needed
                return;
            }
        }
        this._hoverOperation.cancel();
        if (this.isVisible) {
            // The range might have changed, but the hover is visible
            // Instead of hiding it completely, filter out messages that are still in the new range and
            // kick off a new computation
            if (this._showAtPosition.lineNumber !== range.startLineNumber) {
                this.hide();
            }
            else {
                var filteredMessages = [];
                for (var i = 0, len = this._messages.length; i < len; i++) {
                    var msg = this._messages[i];
                    var rng = msg.range;
                    if (rng.startColumn <= range.startColumn && rng.endColumn >= range.endColumn) {
                        filteredMessages.push(msg);
                    }
                }
                if (filteredMessages.length > 0) {
                    this._renderMessages(range, filteredMessages);
                }
                else {
                    this.hide();
                }
            }
        }
        this._lastRange = range;
        this._computer.setRange(range);
        this._shouldFocus = focus;
        this._hoverOperation.start();
    };
    ModesContentHoverWidget.prototype.hide = function () {
        this._lastRange = null;
        this._hoverOperation.cancel();
        _super.prototype.hide.call(this);
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
        this._isChangingDecorations = false;
    };
    ModesContentHoverWidget.prototype._withResult = function (result, complete) {
        this._messages = result;
        if (this._lastRange && this._messages.length > 0) {
            this._renderMessages(this._lastRange, this._messages);
        }
        else if (complete) {
            this.hide();
        }
    };
    ModesContentHoverWidget.prototype._renderMessages = function (renderRange, messages) {
        var _this = this;
        // update column from which to show
        var renderColumn = Number.MAX_VALUE, highlightRange = messages[0].range, fragment = document.createDocumentFragment();
        messages.forEach(function (msg) {
            if (!msg.range) {
                return;
            }
            renderColumn = Math.min(renderColumn, msg.range.startColumn);
            highlightRange = range_1.Range.plusRange(highlightRange, msg.range);
            msg.contents
                .filter(function (contents) { return !!contents; })
                .forEach(function (contents) {
                var renderedContents = htmlContentRenderer_1.renderMarkedString(contents, {
                    actionCallback: function (content) {
                        _this._openerService.open(uri_1.default.parse(content)).then(void 0, errors_1.onUnexpectedError);
                    },
                    codeBlockRenderer: function (languageAlias, value) {
                        // In markdown, it is possible that we stumble upon language aliases (e.g. js instead of javascript)
                        var modeId = _this._modeService.getModeIdForLanguageName(languageAlias);
                        return _this._modeService.getOrCreateMode(modeId).then(function (_) {
                            return "<div class=\"code\">" + textToHtmlTokenizer_1.tokenizeToString(value, modeId) + "</div>";
                        });
                    }
                });
                fragment.appendChild(dom_1.$('div.hover-row', null, renderedContents));
            });
        });
        // show
        this.showAt({
            lineNumber: renderRange.startLineNumber,
            column: renderColumn
        }, this._shouldFocus);
        this.updateContents(fragment);
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, [{
                range: highlightRange,
                options: {
                    className: 'hoverHighlight'
                }
            }]);
        this._isChangingDecorations = false;
    };
    ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';
    return ModesContentHoverWidget;
}(hoverWidgets_1.ContentHoverWidget));
exports.ModesContentHoverWidget = ModesContentHoverWidget;
