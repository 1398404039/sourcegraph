/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var dom_1 = require('vs/base/browser/dom');
var position_1 = require('vs/editor/common/core/position');
var editorBrowser = require('vs/editor/browser/editorBrowser');
var widget_1 = require('vs/base/browser/ui/widget');
var scrollableElement_1 = require('vs/base/browser/ui/scrollbar/scrollableElement');
var lifecycle_1 = require('vs/base/common/lifecycle');
var ContentHoverWidget = (function (_super) {
    __extends(ContentHoverWidget, _super);
    function ContentHoverWidget(id, editor) {
        var _this = this;
        _super.call(this);
        this.disposables = [];
        // Editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this._id = id;
        this._editor = editor;
        this._isVisible = false;
        this._containerDomNode = document.createElement('div');
        this._containerDomNode.className = 'monaco-editor-hover hidden';
        this._containerDomNode.tabIndex = 0;
        this._domNode = document.createElement('div');
        this._domNode.className = 'monaco-editor-hover-content';
        this.scrollbar = new scrollableElement_1.DomScrollableElement(this._domNode, { canUseTranslate3d: false });
        this.disposables.push(this.scrollbar);
        this._containerDomNode.appendChild(this.scrollbar.getDomNode());
        this.onkeydown(this._containerDomNode, function (e) {
            if (e.equals(9 /* Escape */)) {
                _this.hide();
            }
        });
        this._register(this._editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.updateFont();
            }
        }));
        this._editor.onDidLayoutChange(function (e) { return _this.updateMaxHeight(); });
        this.updateMaxHeight();
        this._editor.addContentWidget(this);
        this._showAtPosition = null;
    }
    Object.defineProperty(ContentHoverWidget.prototype, "isVisible", {
        get: function () {
            return this._isVisible;
        },
        set: function (value) {
            this._isVisible = value;
            dom_1.toggleClass(this._containerDomNode, 'hidden', !this._isVisible);
        },
        enumerable: true,
        configurable: true
    });
    ContentHoverWidget.prototype.getId = function () {
        return this._id;
    };
    ContentHoverWidget.prototype.getDomNode = function () {
        return this._containerDomNode;
    };
    ContentHoverWidget.prototype.showAt = function (position, focus) {
        // Position has changed
        this._showAtPosition = new position_1.Position(position.lineNumber, position.column);
        this.isVisible = true;
        this._editor.layoutContentWidget(this);
        // Simply force a synchronous render on the editor
        // such that the widget does not really render with left = '0px'
        this._editor.render();
        this._stoleFocus = focus;
        if (focus) {
            this._containerDomNode.focus();
        }
    };
    ContentHoverWidget.prototype.hide = function () {
        if (!this.isVisible) {
            return;
        }
        this.isVisible = false;
        this._editor.layoutContentWidget(this);
        if (this._stoleFocus) {
            this._editor.focus();
        }
    };
    ContentHoverWidget.prototype.getPosition = function () {
        if (this.isVisible) {
            return {
                position: this._showAtPosition,
                preference: [
                    editorBrowser.ContentWidgetPositionPreference.ABOVE,
                    editorBrowser.ContentWidgetPositionPreference.BELOW
                ]
            };
        }
        return null;
    };
    ContentHoverWidget.prototype.dispose = function () {
        this._editor.removeContentWidget(this);
        this.disposables = lifecycle_1.dispose(this.disposables);
        _super.prototype.dispose.call(this);
    };
    ContentHoverWidget.prototype.updateFont = function () {
        var _this = this;
        var codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName('code'));
        var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
        codeTags.concat(codeClasses).forEach(function (node) { return _this._editor.applyFontInfo(node); });
    };
    ContentHoverWidget.prototype.updateContents = function (node) {
        this._domNode.textContent = '';
        this._domNode.appendChild(node);
        this.updateFont();
        this._editor.layoutContentWidget(this);
        this.scrollbar.scanDomNode();
    };
    ContentHoverWidget.prototype.updateMaxHeight = function () {
        var height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
        this._domNode.style.maxHeight = height + "px";
    };
    return ContentHoverWidget;
}(widget_1.Widget));
exports.ContentHoverWidget = ContentHoverWidget;
var GlyphHoverWidget = (function (_super) {
    __extends(GlyphHoverWidget, _super);
    function GlyphHoverWidget(id, editor) {
        var _this = this;
        _super.call(this);
        this._id = id;
        this._editor = editor;
        this._isVisible = false;
        this._domNode = document.createElement('div');
        this._domNode.className = 'monaco-editor-hover hidden';
        this._domNode.setAttribute('aria-hidden', 'true');
        this._domNode.setAttribute('role', 'presentation');
        this._showAtLineNumber = -1;
        this._register(this._editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.updateFont();
            }
        }));
        this._editor.addOverlayWidget(this);
    }
    Object.defineProperty(GlyphHoverWidget.prototype, "isVisible", {
        get: function () {
            return this._isVisible;
        },
        set: function (value) {
            this._isVisible = value;
            dom_1.toggleClass(this._domNode, 'hidden', !this._isVisible);
        },
        enumerable: true,
        configurable: true
    });
    GlyphHoverWidget.prototype.getId = function () {
        return this._id;
    };
    GlyphHoverWidget.prototype.getDomNode = function () {
        return this._domNode;
    };
    GlyphHoverWidget.prototype.showAt = function (lineNumber) {
        this._showAtLineNumber = lineNumber;
        if (!this.isVisible) {
            this.isVisible = true;
        }
        var editorLayout = this._editor.getLayoutInfo();
        var topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);
        var editorScrollTop = this._editor.getScrollTop();
        var lineHeight = this._editor.getConfiguration().lineHeight;
        var nodeHeight = this._domNode.clientHeight;
        var top = topForLineNumber - editorScrollTop - ((nodeHeight - lineHeight) / 2);
        this._domNode.style.left = (editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth) + "px";
        this._domNode.style.top = Math.max(Math.round(top), 0) + "px";
    };
    GlyphHoverWidget.prototype.hide = function () {
        if (!this.isVisible) {
            return;
        }
        this.isVisible = false;
    };
    GlyphHoverWidget.prototype.getPosition = function () {
        return null;
    };
    GlyphHoverWidget.prototype.dispose = function () {
        this._editor.removeOverlayWidget(this);
        _super.prototype.dispose.call(this);
    };
    GlyphHoverWidget.prototype.updateFont = function () {
        var _this = this;
        var codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName('code'));
        var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
        codeTags.concat(codeClasses).forEach(function (node) { return _this._editor.applyFontInfo(node); });
    };
    GlyphHoverWidget.prototype.updateContents = function (node) {
        this._domNode.textContent = '';
        this._domNode.appendChild(node);
        this.updateFont();
    };
    return GlyphHoverWidget;
}(widget_1.Widget));
exports.GlyphHoverWidget = GlyphHoverWidget;
