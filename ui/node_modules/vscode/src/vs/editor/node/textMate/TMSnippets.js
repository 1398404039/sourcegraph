/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var json_1 = require("vs/base/common/json");
var paths = require("vs/base/common/paths");
var pfs_1 = require("vs/base/node/pfs");
var extensionsRegistry_1 = require("vs/platform/extensions/common/extensionsRegistry");
var snippetsRegistry_1 = require("vs/editor/common/modes/snippetsRegistry");
var modeService_1 = require("vs/editor/common/services/modeService");
var platform = require("vs/platform/platform");
var modeServiceImpl_1 = require("vs/editor/common/services/modeServiceImpl");
var snippetsExtensionPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('snippets', [modeServiceImpl_1.languagesExtPoint], {
    description: nls.localize('vscode.extension.contributes.snippets', 'Contributes snippets.'),
    type: 'array',
    defaultSnippets: [{ body: [{ language: '', path: '' }] }],
    items: {
        type: 'object',
        defaultSnippets: [{ body: { language: '${1:id}', path: './snippets/${2:id}.json.' } }],
        properties: {
            language: {
                description: nls.localize('vscode.extension.contributes.snippets-language', 'Language identifier for which this snippet is contributed to.'),
                type: 'string'
            },
            path: {
                description: nls.localize('vscode.extension.contributes.snippets-path', 'Path of the snippets file. The path is relative to the extension folder and typically starts with \'./snippets/\'.'),
                type: 'string'
            }
        }
    }
});
var MainProcessTextMateSnippet = (function () {
    function MainProcessTextMateSnippet(modeService) {
        var _this = this;
        this._modeService = modeService;
        snippetsExtensionPoint.setHandler(function (extensions) {
            for (var i = 0; i < extensions.length; i++) {
                var tmSnippets = extensions[i].value;
                for (var j = 0; j < tmSnippets.length; j++) {
                    _this._withSnippetContribution(extensions[i].description.name, extensions[i].description.extensionFolderPath, tmSnippets[j], extensions[i].collector);
                }
            }
        });
    }
    MainProcessTextMateSnippet.prototype._withSnippetContribution = function (extensionName, extensionFolderPath, snippet, collector) {
        if (!snippet.language || (typeof snippet.language !== 'string') || !this._modeService.isRegisteredMode(snippet.language)) {
            collector.error(nls.localize('invalid.language', "Unknown language in `contributes.{0}.language`. Provided value: {1}", snippetsExtensionPoint.name, String(snippet.language)));
            return;
        }
        if (!snippet.path || (typeof snippet.path !== 'string')) {
            collector.error(nls.localize('invalid.path.0', "Expected string in `contributes.{0}.path`. Provided value: {1}", snippetsExtensionPoint.name, String(snippet.path)));
            return;
        }
        var normalizedAbsolutePath = paths.normalize(paths.join(extensionFolderPath, snippet.path));
        if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
            collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", snippetsExtensionPoint.name, normalizedAbsolutePath, extensionFolderPath));
        }
        var modeId = snippet.language;
        var disposable = this._modeService.onDidCreateMode(function (mode) {
            if (mode.getId() !== modeId) {
                return;
            }
            readAndRegisterSnippets(modeId, normalizedAbsolutePath, extensionName);
            disposable.dispose();
        });
    };
    return MainProcessTextMateSnippet;
}());
MainProcessTextMateSnippet = __decorate([
    __param(0, modeService_1.IModeService)
], MainProcessTextMateSnippet);
exports.MainProcessTextMateSnippet = MainProcessTextMateSnippet;
var snippetsRegistry = platform.Registry.as(snippetsRegistry_1.Extensions.Snippets);
function readAndRegisterSnippets(modeId, filePath, ownerName) {
    return pfs_1.readFile(filePath).then(function (fileContents) {
        var snippets = parseSnippetFile(fileContents.toString(), ownerName);
        snippetsRegistry.registerSnippets(modeId, snippets, filePath);
    });
}
exports.readAndRegisterSnippets = readAndRegisterSnippets;
function parseSnippetFile(snippetFileContent, owner) {
    var snippetsObj = json_1.parse(snippetFileContent);
    if (!snippetsObj || typeof snippetsObj !== 'object') {
        return [];
    }
    var topLevelProperties = Object.keys(snippetsObj);
    var result = [];
    var processSnippet = function (snippet, name) {
        var prefix = snippet['prefix'];
        var bodyStringOrArray = snippet['body'];
        if (Array.isArray(bodyStringOrArray)) {
            bodyStringOrArray = bodyStringOrArray.join('\n');
        }
        if (typeof prefix === 'string' && typeof bodyStringOrArray === 'string') {
            result.push({
                name: name,
                owner: owner,
                prefix: prefix,
                description: snippet['description'] || name,
                codeSnippet: bodyStringOrArray
            });
        }
    };
    topLevelProperties.forEach(function (topLevelProperty) {
        var scopeOrTemplate = snippetsObj[topLevelProperty];
        if (scopeOrTemplate['body'] && scopeOrTemplate['prefix']) {
            processSnippet(scopeOrTemplate, topLevelProperty);
        }
        else {
            var snippetNames = Object.keys(scopeOrTemplate);
            snippetNames.forEach(function (name) {
                processSnippet(scopeOrTemplate[name], name);
            });
        }
    });
    return result;
}
