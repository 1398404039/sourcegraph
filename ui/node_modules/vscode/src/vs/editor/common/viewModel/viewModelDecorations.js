/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var range_1 = require("vs/editor/common/core/range");
var editorCommon = require("vs/editor/common/editorCommon");
var viewModel_1 = require("vs/editor/common/viewModel/viewModel");
var ViewModelDecorations = (function () {
    function ViewModelDecorations(editorId, model, configuration, converter) {
        this.editorId = editorId;
        this.model = model;
        this.configuration = configuration;
        this.converter = converter;
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    }
    ViewModelDecorations.prototype._clearCachedModelDecorationsResolver = function () {
        this._cachedModelDecorationsResolver = null;
        this._cachedModelDecorationsResolverStartLineNumber = 0;
        this._cachedModelDecorationsResolverEndLineNumber = 0;
    };
    ViewModelDecorations.prototype.dispose = function () {
        this._decorationsCache = null;
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype.reset = function () {
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
    };
    ViewModelDecorations.prototype.onModelDecorationsChanged = function (e, emit) {
        var changedDecorations = e.changedDecorations;
        for (var i = 0, len = changedDecorations.length; i < len; i++) {
            var changedDecoration = changedDecorations[i];
            var myDecoration = this._decorationsCache[changedDecoration];
            if (!myDecoration) {
                continue;
            }
            myDecoration.range = null;
        }
        var removedDecorations = e.removedDecorations;
        for (var i = 0, len = removedDecorations.length; i < len; i++) {
            var removedDecoration = removedDecorations[i];
            delete this._decorationsCache[removedDecoration];
        }
        this._clearCachedModelDecorationsResolver();
        emit(editorCommon.ViewEventNames.DecorationsChangedEvent, {});
    };
    ViewModelDecorations.prototype.onLineMappingChanged = function (emit) {
        this._decorationsCache = Object.create(null);
        this._clearCachedModelDecorationsResolver();
        emit(editorCommon.ViewEventNames.DecorationsChangedEvent, {});
    };
    ViewModelDecorations.prototype._getOrCreateViewModelDecoration = function (modelDecoration) {
        var id = modelDecoration.id;
        var r = this._decorationsCache[id];
        if (!r) {
            r = new viewModel_1.ViewModelDecoration(modelDecoration);
            this._decorationsCache[id] = r;
        }
        if (r.range === null) {
            r.range = this.converter.convertModelRangeToViewRange(modelDecoration.range, modelDecoration.options.isWholeLine);
        }
        return r;
    };
    ViewModelDecorations.prototype.getAllOverviewRulerDecorations = function () {
        var modelDecorations = this.model.getAllDecorations(this.editorId, this.configuration.editor.readOnly);
        var result = [], resultLen = 0;
        for (var i = 0, len = modelDecorations.length; i < len; i++) {
            var modelDecoration = modelDecorations[i];
            var decorationOptions = modelDecoration.options;
            if (!decorationOptions.overviewRuler.color) {
                continue;
            }
            var viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
            result[resultLen++] = viewModelDecoration;
        }
        return result;
    };
    ViewModelDecorations.prototype.getDecorationsViewportData = function (startLineNumber, endLineNumber) {
        var cacheIsValid = true;
        cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolver !== null);
        cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolverStartLineNumber === startLineNumber);
        cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolverEndLineNumber === endLineNumber);
        if (!cacheIsValid) {
            this._cachedModelDecorationsResolver = this._getDecorationsViewportData(startLineNumber, endLineNumber);
            this._cachedModelDecorationsResolverStartLineNumber = startLineNumber;
            this._cachedModelDecorationsResolverEndLineNumber = endLineNumber;
        }
        return this._cachedModelDecorationsResolver;
    };
    ViewModelDecorations.prototype._getDecorationsViewportData = function (startLineNumber, endLineNumber) {
        var viewportModelRange = this.converter.convertViewRangeToModelRange(new range_1.Range(startLineNumber, 1, endLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */));
        var modelDecorations = this.model.getDecorationsInRange(viewportModelRange, this.editorId, this.configuration.editor.readOnly);
        var decorationsInViewport = [], decorationsInViewportLen = 0;
        var inlineDecorations = [];
        for (var j = startLineNumber; j <= endLineNumber; j++) {
            inlineDecorations[j - startLineNumber] = [];
        }
        for (var i = 0, len = modelDecorations.length; i < len; i++) {
            var modelDecoration = modelDecorations[i];
            var decorationOptions = modelDecoration.options;
            var viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
            var viewRange = viewModelDecoration.range;
            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;
            if (decorationOptions.inlineClassName) {
                var inlineDecoration = new viewModel_1.InlineDecoration(viewRange, decorationOptions.inlineClassName);
                var intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);
                var intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);
                for (var j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {
                    insert(inlineDecoration, inlineDecorations[j - startLineNumber]);
                }
            }
            if (decorationOptions.beforeContentClassName && viewRange.startLineNumber >= startLineNumber) {
                // TODO: What happens if the startLineNumber and startColumn is at the end of a line?
                var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn + 1), decorationOptions.beforeContentClassName);
                insert(inlineDecoration, inlineDecorations[viewRange.startLineNumber - startLineNumber]);
            }
            if (decorationOptions.afterContentClassName && viewRange.endLineNumber <= endLineNumber) {
                if (viewRange.endColumn > 1) {
                    var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.endLineNumber, viewRange.endColumn - 1, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName);
                    insert(inlineDecoration, inlineDecorations[viewRange.endLineNumber - startLineNumber]);
                }
            }
        }
        return {
            decorations: decorationsInViewport,
            inlineDecorations: inlineDecorations
        };
    };
    return ViewModelDecorations;
}());
exports.ViewModelDecorations = ViewModelDecorations;
// insert sorted by startColumn. All decorations are already sorted but this is necessary
// as the startColumn of 'afterContent'-InlineDecoration is different from the decoration startColumn.
function insert(decoration, decorations) {
    var startColumn = decoration.range.startColumn;
    var last = decorations.length - 1;
    var idx = last;
    while (idx >= 0 && decorations[idx].range.startColumn > startColumn) {
        idx--;
    }
    if (idx === last) {
        decorations.push(decoration);
    }
    else {
        decorations.splice(idx + 1, 0, decoration);
    }
}
