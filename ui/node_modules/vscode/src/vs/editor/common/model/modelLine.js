/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var tokensBinaryEncoding_1 = require("vs/editor/common/model/tokensBinaryEncoding");
var modeTransition_1 = require("vs/editor/common/core/modeTransition");
var lineTokens_1 = require("vs/editor/common/core/lineTokens");
var position_1 = require("vs/editor/common/core/position");
var LineMarker = (function () {
    function LineMarker(id, internalDecorationId, position, stickToPreviousCharacter) {
        this.id = id;
        this.internalDecorationId = internalDecorationId;
        this.position = position;
        this.stickToPreviousCharacter = stickToPreviousCharacter;
    }
    LineMarker.prototype.toString = function () {
        return '{\'' + this.id + '\';' + this.position.toString() + ',' + this.stickToPreviousCharacter + '}';
    };
    LineMarker.prototype.updateLineNumber = function (markersTracker, lineNumber) {
        if (this.position.lineNumber === lineNumber) {
            return;
        }
        markersTracker.addChangedMarker(this);
        this.position = new position_1.Position(lineNumber, this.position.column);
    };
    LineMarker.prototype.updateColumn = function (markersTracker, column) {
        if (this.position.column === column) {
            return;
        }
        markersTracker.addChangedMarker(this);
        this.position = new position_1.Position(this.position.lineNumber, column);
    };
    LineMarker.prototype.updatePosition = function (markersTracker, position) {
        if (this.position.lineNumber === position.lineNumber && this.position.column === position.column) {
            return;
        }
        markersTracker.addChangedMarker(this);
        this.position = position;
    };
    LineMarker.prototype.setPosition = function (position) {
        this.position = position;
    };
    LineMarker.compareMarkers = function (a, b) {
        if (a.position.column === b.position.column) {
            return (a.stickToPreviousCharacter ? 0 : 1) - (b.stickToPreviousCharacter ? 0 : 1);
        }
        return a.position.column - b.position.column;
    };
    return LineMarker;
}());
exports.LineMarker = LineMarker;
var MarkersTracker = (function () {
    function MarkersTracker() {
        this._changedDecorations = [];
        this._changedDecorationsLen = 0;
    }
    MarkersTracker.prototype.addChangedMarker = function (marker) {
        var internalDecorationId = marker.internalDecorationId;
        if (internalDecorationId !== 0) {
            this._changedDecorations[this._changedDecorationsLen++] = internalDecorationId;
        }
    };
    MarkersTracker.prototype.getDecorationIds = function () {
        return this._changedDecorations;
    };
    return MarkersTracker;
}());
exports.MarkersTracker = MarkersTracker;
var NO_OP_TOKENS_ADJUSTER = {
    adjust: function () { },
    finish: function () { }
};
var NO_OP_MARKERS_ADJUSTER = {
    adjustDelta: function () { },
    adjustSet: function () { },
    finish: function () { }
};
var MarkerMoveSemantics;
(function (MarkerMoveSemantics) {
    MarkerMoveSemantics[MarkerMoveSemantics["MarkerDefined"] = 0] = "MarkerDefined";
    MarkerMoveSemantics[MarkerMoveSemantics["ForceMove"] = 1] = "ForceMove";
    MarkerMoveSemantics[MarkerMoveSemantics["ForceStay"] = 2] = "ForceStay";
})(MarkerMoveSemantics || (MarkerMoveSemantics = {}));
/**
 * Returns:
 *  - 0 => the line consists of whitespace
 *  - otherwise => the indent level is returned value - 1
 */
function computePlusOneIndentLevel(line, tabSize) {
    var indent = 0;
    var i = 0;
    var len = line.length;
    while (i < len) {
        var chCode = line.charCodeAt(i);
        if (chCode === 32 /* Space */) {
            indent++;
        }
        else if (chCode === 9 /* Tab */) {
            indent = indent - indent % tabSize + tabSize;
        }
        else {
            break;
        }
        i++;
    }
    if (i === len) {
        return 0; // line only consists of whitespace
    }
    return indent + 1;
}
var ModelLine = (function () {
    function ModelLine(lineNumber, text, tabSize) {
        this._lineNumber = lineNumber | 0;
        this._metadata = 0;
        this._setText(text, tabSize);
        this._state = null;
        this._modeTransitions = null;
        this._lineTokens = null;
        this._markers = null;
    }
    Object.defineProperty(ModelLine.prototype, "lineNumber", {
        get: function () { return this._lineNumber; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelLine.prototype, "text", {
        get: function () { return this._text; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelLine.prototype, "isInvalid", {
        get: function () {
            return (this._metadata & 0x00000001) ? true : false;
        },
        set: function (value) {
            this._metadata = (this._metadata & 0xfffffffe) | (value ? 1 : 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns:
     *  - -1 => the line consists of whitespace
     *  - otherwise => the indent level is returned value
     */
    ModelLine.prototype.getIndentLevel = function () {
        return ((this._metadata & 0xfffffffe) >> 1) - 1;
    };
    ModelLine.prototype._setPlusOneIndentLevel = function (value) {
        this._metadata = (this._metadata & 0x00000001) | ((value & 0xefffffff) << 1);
    };
    ModelLine.prototype.updateTabSize = function (tabSize) {
        if (tabSize === 0) {
            // don't care mark
            this._metadata = this._metadata & 0x00000001;
        }
        else {
            this._setPlusOneIndentLevel(computePlusOneIndentLevel(this._text, tabSize));
        }
    };
    // --- BEGIN STATE
    ModelLine.prototype.resetTokenizationState = function () {
        this._state = null;
        this._modeTransitions = null;
        this._lineTokens = null;
    };
    ModelLine.prototype.setState = function (state) {
        this._state = state;
    };
    ModelLine.prototype.getState = function () {
        return this._state || null;
    };
    // --- END STATE
    // --- BEGIN MODE TRANSITIONS
    ModelLine.prototype.getModeTransitions = function (topLevelModeId) {
        if (this._modeTransitions) {
            return this._modeTransitions;
        }
        else {
            return [new modeTransition_1.ModeTransition(0, topLevelModeId)];
        }
    };
    // --- END MODE TRANSITIONS
    // --- BEGIN TOKENS
    ModelLine.prototype.setTokens = function (map, tokens, modeTransitions) {
        this._lineTokens = toLineTokensFromInflated(map, tokens, this._text.length);
        this._modeTransitions = toModeTransitions(map.topLevelModeId, modeTransitions);
    };
    ModelLine.prototype._setLineTokensFromDeflated = function (tokens) {
        this._lineTokens = toLineTokensFromDeflated(tokens, this._text.length);
    };
    ModelLine.prototype.getTokens = function (map) {
        var lineTokens = this._lineTokens;
        if (!lineTokens) {
            if (this._text.length === 0) {
                lineTokens = tokensBinaryEncoding_1.DEFLATED_TOKENS_EMPTY_TEXT;
            }
            else {
                lineTokens = tokensBinaryEncoding_1.DEFLATED_TOKENS_NON_EMPTY_TEXT;
            }
        }
        return new lineTokens_1.LineTokens(map, lineTokens, this.getModeTransitions(map.topLevelModeId), this._text);
    };
    // --- END TOKENS
    ModelLine.prototype._createTokensAdjuster = function () {
        if (!this._lineTokens) {
            // This line does not have real tokens, so there is nothing to adjust
            return NO_OP_TOKENS_ADJUSTER;
        }
        var tokens = this._lineTokens;
        var tokensLength = tokens.length;
        var tokensIndex = 0;
        var currentTokenStartIndex = 0;
        var adjust = function (toColumn, delta, minimumAllowedColumn) {
            // console.log('before call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
            // console.log('adjustTokens: ' + toColumn + ' with delta: ' + delta + ' and [' + minimumAllowedColumn + ']');
            // console.log('currentTokenStartIndex: ' + currentTokenStartIndex);
            var minimumAllowedIndex = minimumAllowedColumn - 1;
            while (currentTokenStartIndex < toColumn && tokensIndex < tokensLength) {
                if (currentTokenStartIndex > 0 && delta !== 0) {
                    // adjust token's `startIndex` by `delta`
                    var deflatedType = (tokens[tokensIndex] / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
                    var newStartIndex = Math.max(minimumAllowedIndex, currentTokenStartIndex + delta);
                    var newToken = deflatedType * 4294967296 /* TYPE_OFFSET */ + newStartIndex * 1 /* START_INDEX_OFFSET */;
                    if (delta < 0) {
                        // pop all previous tokens that have become `collapsed`
                        while (tokensIndex > 0) {
                            var prevTokenStartIndex = (tokens[tokensIndex - 1] / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
                            if (prevTokenStartIndex >= newStartIndex) {
                                // Token at `tokensIndex` - 1 is now `collapsed` => pop it
                                tokens.splice(tokensIndex - 1, 1);
                                tokensLength--;
                                tokensIndex--;
                            }
                            else {
                                break;
                            }
                        }
                    }
                    tokens[tokensIndex] = newToken;
                }
                tokensIndex++;
                if (tokensIndex < tokensLength) {
                    currentTokenStartIndex = (tokens[tokensIndex] / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
                }
            }
            // console.log('after call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
        };
        var finish = function (delta, lineTextLength) {
            adjust(Number.MAX_VALUE, delta, 1);
        };
        return {
            adjust: adjust,
            finish: finish
        };
    };
    ModelLine.prototype._setText = function (text, tabSize) {
        this._text = text;
        if (tabSize === 0) {
            // don't care mark
            this._metadata = this._metadata & 0x00000001;
        }
        else {
            this._setPlusOneIndentLevel(computePlusOneIndentLevel(text, tabSize));
        }
        var tokens = this._lineTokens;
        if (tokens) {
            var lineTextLength = this._text.length;
            // Remove overflowing tokens
            while (tokens.length > 0) {
                var lastTokenStartIndex = (tokens[tokens.length - 1] / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
                if (lastTokenStartIndex < lineTextLength) {
                    // Valid token
                    break;
                }
                // This token now overflows the text => remove it
                tokens.pop();
            }
            this._setLineTokensFromDeflated(tokens);
        }
    };
    // private _printMarkers(): string {
    // 	if (!this._markers) {
    // 		return '[]';
    // 	}
    // 	if (this._markers.length === 0) {
    // 		return '[]';
    // 	}
    // 	var markers = this._markers;
    // 	var printMarker = (m:ILineMarker) => {
    // 		if (m.stickToPreviousCharacter) {
    // 			return '|' + m.column;
    // 		}
    // 		return m.column + '|';
    // 	};
    // 	return '[' + markers.map(printMarker).join(', ') + ']';
    // }
    ModelLine.prototype._createMarkersAdjuster = function (markersTracker) {
        if (!this._markers) {
            return NO_OP_MARKERS_ADJUSTER;
        }
        if (this._markers.length === 0) {
            return NO_OP_MARKERS_ADJUSTER;
        }
        this._markers.sort(LineMarker.compareMarkers);
        var markers = this._markers;
        var markersLength = markers.length;
        var markersIndex = 0;
        var marker = markers[markersIndex];
        // console.log('------------- INITIAL MARKERS: ' + this._printMarkers());
        var adjustMarkerBeforeColumn = function (toColumn, moveSemantics) {
            if (marker.position.column < toColumn) {
                return true;
            }
            if (marker.position.column > toColumn) {
                return false;
            }
            if (moveSemantics === 1 /* ForceMove */) {
                return false;
            }
            if (moveSemantics === 2 /* ForceStay */) {
                return true;
            }
            return marker.stickToPreviousCharacter;
        };
        var adjustDelta = function (toColumn, delta, minimumAllowedColumn, moveSemantics) {
            // console.log('------------------------------');
            // console.log('adjustDelta called: toColumn: ' + toColumn + ', delta: ' + delta + ', minimumAllowedColumn: ' + minimumAllowedColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
            // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                if (delta !== 0) {
                    var newColumn = Math.max(minimumAllowedColumn, marker.position.column + delta);
                    marker.updateColumn(markersTracker, newColumn);
                }
                markersIndex++;
                if (markersIndex < markersLength) {
                    marker = markers[markersIndex];
                }
            }
            // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
        };
        var adjustSet = function (toColumn, newColumn, moveSemantics) {
            // console.log('------------------------------');
            // console.log('adjustSet called: toColumn: ' + toColumn + ', newColumn: ' + newColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
            // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                marker.updateColumn(markersTracker, newColumn);
                markersIndex++;
                if (markersIndex < markersLength) {
                    marker = markers[markersIndex];
                }
            }
            // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
        };
        var finish = function (delta, lineTextLength) {
            adjustDelta(Number.MAX_VALUE, delta, 1, 0 /* MarkerDefined */);
            // console.log('------------- FINAL MARKERS: ' + this._printMarkers());
        };
        return {
            adjustDelta: adjustDelta,
            adjustSet: adjustSet,
            finish: finish
        };
    };
    ModelLine.prototype.applyEdits = function (markersTracker, edits, tabSize) {
        var deltaColumn = 0;
        var resultText = this._text;
        var tokensAdjuster = this._createTokensAdjuster();
        var markersAdjuster = this._createMarkersAdjuster(markersTracker);
        for (var i = 0, len = edits.length; i < len; i++) {
            var edit = edits[i];
            // console.log();
            // console.log('=============================');
            // console.log('EDIT #' + i + ' [ ' + edit.startColumn + ' -> ' + edit.endColumn + ' ] : <<<' + edit.text + '>>>, forceMoveMarkers: ' + edit.forceMoveMarkers);
            // console.log('deltaColumn: ' + deltaColumn);
            var startColumn = deltaColumn + edit.startColumn;
            var endColumn = deltaColumn + edit.endColumn;
            var deletingCnt = endColumn - startColumn;
            var insertingCnt = edit.text.length;
            // Adjust tokens & markers before this edit
            // console.log('Adjust tokens & markers before this edit');
            tokensAdjuster.adjust(edit.startColumn - 1, deltaColumn, 1);
            markersAdjuster.adjustDelta(edit.startColumn, deltaColumn, 1, edit.forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */));
            // Adjust tokens & markers for the common part of this edit
            var commonLength = Math.min(deletingCnt, insertingCnt);
            if (commonLength > 0) {
                // console.log('Adjust tokens & markers for the common part of this edit');
                tokensAdjuster.adjust(edit.startColumn - 1 + commonLength, deltaColumn, startColumn);
                if (!edit.forceMoveMarkers) {
                    markersAdjuster.adjustDelta(edit.startColumn + commonLength, deltaColumn, startColumn, edit.forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */));
                }
            }
            // Perform the edit & update `deltaColumn`
            resultText = resultText.substring(0, startColumn - 1) + edit.text + resultText.substring(endColumn - 1);
            deltaColumn += insertingCnt - deletingCnt;
            // Adjust tokens & markers inside this edit
            // console.log('Adjust tokens & markers inside this edit');
            tokensAdjuster.adjust(edit.endColumn, deltaColumn, startColumn);
            markersAdjuster.adjustSet(edit.endColumn, startColumn + insertingCnt, edit.forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */);
        }
        // Wrap up tokens & markers; adjust remaining if needed
        tokensAdjuster.finish(deltaColumn, resultText.length);
        markersAdjuster.finish(deltaColumn, resultText.length);
        // Save the resulting text
        this._setText(resultText, tabSize);
        return deltaColumn;
    };
    ModelLine.prototype.split = function (markersTracker, splitColumn, forceMoveMarkers, tabSize) {
        // console.log('--> split @ ' + splitColumn + '::: ' + this._printMarkers());
        var myText = this._text.substring(0, splitColumn - 1);
        var otherText = this._text.substring(splitColumn - 1);
        var otherMarkers = null;
        if (this._markers) {
            this._markers.sort(LineMarker.compareMarkers);
            for (var i = 0, len = this._markers.length; i < len; i++) {
                var marker = this._markers[i];
                if (marker.position.column > splitColumn
                    || (marker.position.column === splitColumn
                        && (forceMoveMarkers
                            || !marker.stickToPreviousCharacter))) {
                    var myMarkers = this._markers.slice(0, i);
                    otherMarkers = this._markers.slice(i);
                    this._markers = myMarkers;
                    break;
                }
            }
            if (otherMarkers) {
                for (var i = 0, len = otherMarkers.length; i < len; i++) {
                    var marker = otherMarkers[i];
                    marker.updateColumn(markersTracker, marker.position.column - (splitColumn - 1));
                }
            }
        }
        this._setText(myText, tabSize);
        var otherLine = new ModelLine(this._lineNumber + 1, otherText, tabSize);
        if (otherMarkers) {
            otherLine.addMarkers(otherMarkers);
        }
        return otherLine;
    };
    ModelLine.prototype.append = function (markersTracker, other, tabSize) {
        // console.log('--> append: THIS :: ' + this._printMarkers());
        // console.log('--> append: OTHER :: ' + this._printMarkers());
        var thisTextLength = this._text.length;
        this._setText(this._text + other._text, tabSize);
        var otherTokens = other._lineTokens;
        if (otherTokens) {
            // Other has real tokens
            // Adjust other tokens
            if (thisTextLength > 0) {
                for (var i = 0, len = otherTokens.length; i < len; i++) {
                    var token = otherTokens[i];
                    var deflatedStartIndex = (token / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
                    var deflatedType = (token / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
                    var newStartIndex = deflatedStartIndex + thisTextLength;
                    var newToken = deflatedType * 4294967296 /* TYPE_OFFSET */ + newStartIndex * 1 /* START_INDEX_OFFSET */;
                    otherTokens[i] = newToken;
                }
            }
            // Append other tokens
            var myLineTokens = this._lineTokens;
            if (myLineTokens) {
                // I have real tokens
                this._setLineTokensFromDeflated(myLineTokens.concat(otherTokens));
            }
            else {
                // I don't have real tokens
                this._setLineTokensFromDeflated(otherTokens);
            }
        }
        if (other._markers) {
            // Other has markers
            var otherMarkers = other._markers;
            // Adjust other markers
            for (var i = 0, len = otherMarkers.length; i < len; i++) {
                var marker = otherMarkers[i];
                marker.updatePosition(markersTracker, new position_1.Position(this._lineNumber, marker.position.column + thisTextLength));
            }
            this.addMarkers(otherMarkers);
        }
    };
    ModelLine.prototype.addMarker = function (marker) {
        if (!this._markers) {
            this._markers = [marker];
        }
        else {
            this._markers.push(marker);
        }
    };
    ModelLine.prototype.addMarkers = function (markers) {
        if (markers.length === 0) {
            return;
        }
        if (!this._markers) {
            this._markers = markers.slice(0);
        }
        else {
            this._markers = this._markers.concat(markers);
        }
    };
    ModelLine.prototype.removeMarker = function (marker) {
        if (!this._markers) {
            return;
        }
        var index = this._indexOfMarkerId(marker.id);
        if (index < 0) {
            return;
        }
        if (this._markers.length === 1) {
            // was last marker on line
            this._markers = null;
        }
        else {
            this._markers.splice(index, 1);
        }
    };
    ModelLine.prototype.removeMarkers = function (deleteMarkers) {
        if (!this._markers) {
            return;
        }
        for (var i = 0, len = this._markers.length; i < len; i++) {
            var marker = this._markers[i];
            if (deleteMarkers[marker.id]) {
                this._markers.splice(i, 1);
                len--;
                i--;
            }
        }
        if (this._markers.length === 0) {
            this._markers = null;
        }
    };
    ModelLine.prototype.getMarkers = function () {
        if (!this._markers) {
            return [];
        }
        return this._markers.slice(0);
    };
    ModelLine.prototype.updateLineNumber = function (markersTracker, newLineNumber) {
        if (this._lineNumber === newLineNumber) {
            return;
        }
        if (this._markers) {
            var markers = this._markers;
            for (var i = 0, len = markers.length; i < len; i++) {
                var marker = markers[i];
                marker.updateLineNumber(markersTracker, newLineNumber);
            }
        }
        this._lineNumber = newLineNumber;
    };
    ModelLine.prototype.deleteLine = function () {
        if (!this._markers) {
            return [];
        }
        return this._markers;
    };
    ModelLine.prototype._indexOfMarkerId = function (markerId) {
        var markers = this._markers;
        for (var i = 0, len = markers.length; i < len; i++) {
            if (markers[i].id === markerId) {
                return i;
            }
        }
    };
    return ModelLine;
}());
exports.ModelLine = ModelLine;
function toLineTokensFromInflated(map, tokens, textLength) {
    if (textLength === 0) {
        return null;
    }
    if (!tokens || tokens.length === 0) {
        return null;
    }
    if (tokens.length === 1) {
        if (tokens[0].startIndex === 0 && tokens[0].type === '') {
            return null;
        }
    }
    return tokensBinaryEncoding_1.TokensBinaryEncoding.deflateArr(map, tokens);
}
function toLineTokensFromDeflated(tokens, textLength) {
    if (textLength === 0) {
        return null;
    }
    if (!tokens || tokens.length === 0) {
        return null;
    }
    if (tokens.length === 1) {
        if (tokens[0] === 0) {
            return null;
        }
    }
    return tokens;
}
function toModeTransitions(topLevelModeId, modeTransitions) {
    if (!modeTransitions || modeTransitions.length === 0) {
        return null;
    }
    else if (modeTransitions.length === 1 && modeTransitions[0].startIndex === 0 && modeTransitions[0].modeId === topLevelModeId) {
        return null;
    }
    return modeTransitions;
}
