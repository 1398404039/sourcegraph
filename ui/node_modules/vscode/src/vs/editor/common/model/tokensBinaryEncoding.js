/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require('vs/base/common/errors');
var strings = require('vs/base/common/strings');
var viewLineToken_1 = require('vs/editor/common/core/viewLineToken');
(function (TokensBinaryEncodingValues) {
    TokensBinaryEncodingValues[TokensBinaryEncodingValues["START_INDEX_MASK"] = 4294967295] = "START_INDEX_MASK";
    TokensBinaryEncodingValues[TokensBinaryEncodingValues["TYPE_MASK"] = 65535] = "TYPE_MASK";
    TokensBinaryEncodingValues[TokensBinaryEncodingValues["START_INDEX_OFFSET"] = 1] = "START_INDEX_OFFSET";
    TokensBinaryEncodingValues[TokensBinaryEncodingValues["TYPE_OFFSET"] = 4294967296] = "TYPE_OFFSET"; // Math.pow(2, 32)
})(exports.TokensBinaryEncodingValues || (exports.TokensBinaryEncodingValues = {}));
var TokensBinaryEncodingValues = exports.TokensBinaryEncodingValues;
var DEFAULT_VIEW_TOKEN = new viewLineToken_1.ViewLineToken(0, '');
var INFLATED_TOKENS_EMPTY_TEXT = [];
exports.DEFLATED_TOKENS_EMPTY_TEXT = [];
var INFLATED_TOKENS_NON_EMPTY_TEXT = [DEFAULT_VIEW_TOKEN];
exports.DEFLATED_TOKENS_NON_EMPTY_TEXT = [0];
var TokensInflatorMap = (function () {
    function TokensInflatorMap(topLevelModeId) {
        this.topLevelModeId = topLevelModeId;
        this._inflate = [''];
        this._deflate = { '': 0 };
    }
    return TokensInflatorMap;
}());
exports.TokensInflatorMap = TokensInflatorMap;
var TokensBinaryEncoding = (function () {
    function TokensBinaryEncoding() {
    }
    TokensBinaryEncoding.deflateArr = function (map, tokens) {
        if (tokens.length === 0) {
            return exports.DEFLATED_TOKENS_EMPTY_TEXT;
        }
        if (tokens.length === 1 && tokens[0].startIndex === 0 && !tokens[0].type) {
            return exports.DEFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var i, len, deflatedToken, deflated, token, inflateMap = map._inflate, deflateMap = map._deflate, prevStartIndex = -1, result = new Array(tokens.length);
        for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.startIndex <= prevStartIndex) {
                token.startIndex = prevStartIndex + 1;
                errors_1.onUnexpectedError({
                    message: 'Invalid tokens detected',
                    tokens: tokens
                });
            }
            if (deflateMap.hasOwnProperty(token.type)) {
                deflatedToken = deflateMap[token.type];
            }
            else {
                deflatedToken = inflateMap.length;
                deflateMap[token.type] = deflatedToken;
                inflateMap.push(token.type);
            }
            // http://stackoverflow.com/a/2803010
            // All numbers in JavaScript are actually IEEE-754 compliant floating-point doubles.
            // These have a 53-bit mantissa which should mean that any integer value with a magnitude
            // of approximately 9 quadrillion or less -- more specifically, 9,007,199,254,740,991 --
            // will be represented accurately.
            // http://stackoverflow.com/a/6729252
            // Bitwise operations cast numbers to 32bit representation in JS
            // 32 bits for startIndex => up to 2^32 = 4,294,967,296
            // 16 bits for token => up to 2^16 = 65,536
            // [token][startIndex]
            deflated = deflatedToken * 4294967296 /* TYPE_OFFSET */ + token.startIndex * 1 /* START_INDEX_OFFSET */;
            result[i] = deflated;
            prevStartIndex = token.startIndex;
        }
        return result;
    };
    TokensBinaryEncoding.getStartIndex = function (binaryEncodedToken) {
        return (binaryEncodedToken / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
    };
    TokensBinaryEncoding.getType = function (map, binaryEncodedToken) {
        var deflatedType = (binaryEncodedToken / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
        if (deflatedType === 0) {
            return strings.empty;
        }
        return map._inflate[deflatedType];
    };
    TokensBinaryEncoding.inflateArr = function (map, binaryEncodedTokens) {
        if (binaryEncodedTokens.length === 0) {
            return INFLATED_TOKENS_EMPTY_TEXT;
        }
        if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
            return INFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var result = [];
        var inflateMap = map._inflate;
        for (var i = 0, len = binaryEncodedTokens.length; i < len; i++) {
            var deflated = binaryEncodedTokens[i];
            var startIndex = (deflated / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
            var deflatedType = (deflated / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
            result.push(new viewLineToken_1.ViewLineToken(startIndex, inflateMap[deflatedType]));
        }
        return result;
    };
    TokensBinaryEncoding.findIndexOfOffset = function (binaryEncodedTokens, offset) {
        return this.findIndexInSegmentsArray(binaryEncodedTokens, offset);
    };
    TokensBinaryEncoding.sliceAndInflate = function (map, binaryEncodedTokens, startOffset, endOffset, deltaStartIndex) {
        if (binaryEncodedTokens.length === 0) {
            return INFLATED_TOKENS_EMPTY_TEXT;
        }
        if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
            return INFLATED_TOKENS_NON_EMPTY_TEXT;
        }
        var startIndex = this.findIndexInSegmentsArray(binaryEncodedTokens, startOffset);
        var result = [];
        var inflateMap = map._inflate;
        var originalToken = binaryEncodedTokens[startIndex];
        var deflatedType = (originalToken / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
        var newStartIndex = 0;
        result.push(new viewLineToken_1.ViewLineToken(newStartIndex, inflateMap[deflatedType]));
        for (var i = startIndex + 1, len = binaryEncodedTokens.length; i < len; i++) {
            originalToken = binaryEncodedTokens[i];
            var originalStartIndex = (originalToken / 1 /* START_INDEX_OFFSET */) & 4294967295 /* START_INDEX_MASK */;
            if (originalStartIndex >= endOffset) {
                break;
            }
            deflatedType = (originalToken / 4294967296 /* TYPE_OFFSET */) & 65535 /* TYPE_MASK */;
            newStartIndex = originalStartIndex - startOffset + deltaStartIndex;
            result.push(new viewLineToken_1.ViewLineToken(newStartIndex, inflateMap[deflatedType]));
        }
        return result;
    };
    TokensBinaryEncoding.findIndexInSegmentsArray = function (arr, desiredIndex) {
        var low = 0, high = arr.length - 1, mid, value;
        while (low < high) {
            mid = low + Math.ceil((high - low) / 2);
            value = arr[mid] & 0xffffffff;
            if (value > desiredIndex) {
                high = mid - 1;
            }
            else {
                low = mid;
            }
        }
        return low;
    };
    return TokensBinaryEncoding;
}());
exports.TokensBinaryEncoding = TokensBinaryEncoding;
