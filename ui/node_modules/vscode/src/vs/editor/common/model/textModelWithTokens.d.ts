import { Range } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { TextModel } from 'vs/editor/common/model/textModel';
import { TokenIterator } from 'vs/editor/common/model/tokenIterator';
import { ILineContext, IMode } from 'vs/editor/common/modes';
import { ModeTransition } from 'vs/editor/common/core/modeTransition';
import { LineTokens } from 'vs/editor/common/core/lineTokens';
export declare class TextModelWithTokens extends TextModel implements editorCommon.ITokenizedModel {
    private static MODE_TOKENIZATION_FAILED_MSG;
    private _languageId;
    private _tokenizationListener;
    private _tokenizationSupport;
    private _tokensInflatorMap;
    private _invalidLineStartIndex;
    private _lastState;
    private _revalidateTokensTimeout;
    constructor(allowedEventTypes: string[], rawText: editorCommon.IRawText, languageId: string);
    dispose(): void;
    protected _shouldAutoTokenize(): boolean;
    protected _resetValue(e: editorCommon.IModelContentChangedFlushEvent, newValue: editorCommon.IRawText): void;
    protected _resetTokenizationState(): void;
    private _clearTimers();
    getLineTokens(lineNumber: number, inaccurateTokensAcceptable?: boolean): LineTokens;
    getLineContext(lineNumber: number): ILineContext;
    getMode(): IMode;
    getModeId(): string;
    setMode(languageId: string): void;
    getModeIdAtPosition(_lineNumber: number, _column: number): string;
    protected _invalidateLine(lineIndex: number): void;
    private _beginBackgroundTokenization();
    _warmUpTokens(): void;
    private _revalidateTokensNow(toLineNumber?);
    private getStateBeforeLine(lineNumber);
    private getStateAfterLine(lineNumber);
    _getLineModeTransitions(lineNumber: number): ModeTransition[];
    private _updateTokensUntilLine(lineNumber, emitEvents);
    private emitModelTokensChangedEvent(fromLineNumber, toLineNumber);
    private _emitModelModeChangedEvent(e);
    _lineIsTokenized(lineNumber: number): boolean;
    protected _getWordDefinition(): RegExp;
    getWordAtPosition(position: editorCommon.IPosition): editorCommon.IWordAtPosition;
    getWordUntilPosition(position: editorCommon.IPosition): editorCommon.IWordAtPosition;
    tokenIterator(position: editorCommon.IPosition, callback: (it: TokenIterator) => any): any;
    findMatchingBracketUp(_bracket: string, _position: editorCommon.IPosition): Range;
    matchBracket(position: editorCommon.IPosition): [Range, Range];
    private _matchBracket(position);
    private _matchFoundBracket(foundBracket, data, isOpen);
    private _findMatchingBracketUp(bracket, position);
    private _findMatchingBracketDown(bracket, position);
    findPrevBracket(_position: editorCommon.IPosition): editorCommon.IFoundBracket;
    findNextBracket(_position: editorCommon.IPosition): editorCommon.IFoundBracket;
    private _toFoundBracket(modeBrackets, r);
}
