/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var uri_1 = require('vs/base/common/uri');
var editorCommon_1 = require('vs/editor/common/editorCommon');
var editableTextModel_1 = require('vs/editor/common/model/editableTextModel');
var textModel_1 = require('vs/editor/common/model/textModel');
// The hierarchy is:
// Model -> EditableTextModel -> TextModelWithDecorations -> TextModelWithTrackedRanges -> TextModelWithMarkers -> TextModelWithTokens -> TextModel
var MODEL_ID = 0;
var aliveModels = {};
// var LAST_CNT = 0;
// setInterval(() => {
// 	var cnt = Object.keys(aliveModels).length;
// 	if (cnt === LAST_CNT) {
// 		return;
// 	}
// 	console.warn('ALIVE MODELS:');
// 	console.log(Object.keys(aliveModels).join('\n'));
// 	LAST_CNT = cnt;
// }, 100);
var Model = (function (_super) {
    __extends(Model, _super);
    /**
     * Instantiates a new model
     * @param rawText
     *   The raw text buffer. It may start with a UTF-16 BOM, which can be
     *   optionally preserved when doing a getValue call. The lines may be
     *   separated by different EOL combinations, such as \n or \r\n. These
     *   can also be preserved when doing a getValue call.
     * @param mode
     *   The language service name this model is bound to.
     * @param associatedResource
     *   The resource associated with this model. If the value is not provided an
     *   unique in memory URL is constructed as the associated resource.
     */
    function Model(rawText, languageId, associatedResource) {
        if (associatedResource === void 0) { associatedResource = null; }
        _super.call(this, [editorCommon_1.EventType.ModelDispose], rawText, languageId);
        // Generate a new unique model id
        MODEL_ID++;
        this.id = '$model' + MODEL_ID;
        if (typeof associatedResource === 'undefined' || associatedResource === null) {
            this._associatedResource = uri_1.default.parse('inmemory://model/' + MODEL_ID);
        }
        else {
            this._associatedResource = associatedResource;
        }
        if (aliveModels[String(this._associatedResource)]) {
            throw new Error('Cannot instantiate a second Model with the same URI: ' + String(this._associatedResource));
        }
        this._attachedEditorCount = 0;
        aliveModels[String(this._associatedResource)] = true;
        // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
    }
    Model.prototype.onDidChangeDecorations = function (listener) {
        return this.addListener2(editorCommon_1.EventType.ModelDecorationsChanged, listener);
    };
    Model.prototype.onDidChangeOptions = function (listener) {
        return this.addListener2(editorCommon_1.EventType.ModelOptionsChanged, listener);
    };
    Model.prototype.onWillDispose = function (listener) {
        return this.addListener2(editorCommon_1.EventType.ModelDispose, listener);
    };
    Model.prototype.onDidChangeMode = function (listener) {
        return this.addListener2(editorCommon_1.EventType.ModelModeChanged, listener);
    };
    Model.prototype.addBulkListener = function (listener) {
        return _super.prototype.addBulkListener.call(this, listener);
    };
    Model.createFromString = function (text, options, languageId, uri) {
        if (options === void 0) { options = textModel_1.TextModel.DEFAULT_CREATION_OPTIONS; }
        if (languageId === void 0) { languageId = null; }
        if (uri === void 0) { uri = null; }
        var rawText = textModel_1.TextModel.toRawText(text, options);
        return new Model(rawText, languageId, uri);
    };
    Model.prototype.destroy = function () {
        this.dispose();
    };
    Model.prototype.dispose = function () {
        this._isDisposing = true;
        delete aliveModels[String(this._associatedResource)];
        this.emit(editorCommon_1.EventType.ModelDispose);
        _super.prototype.dispose.call(this);
        this._isDisposing = false;
        // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
    };
    Model.prototype.onBeforeAttached = function () {
        this._attachedEditorCount++;
        // Warm up tokens for the editor
        this._warmUpTokens();
    };
    Model.prototype.onBeforeDetached = function () {
        this._attachedEditorCount--;
        // Intentional empty (for now)
    };
    Model.prototype._shouldAutoTokenize = function () {
        return this.isAttachedToEditor();
    };
    Model.prototype.isAttachedToEditor = function () {
        return this._attachedEditorCount > 0;
    };
    Object.defineProperty(Model.prototype, "uri", {
        get: function () {
            return this._associatedResource;
        },
        enumerable: true,
        configurable: true
    });
    return Model;
}(editableTextModel_1.EditableTextModel));
exports.Model = Model;
