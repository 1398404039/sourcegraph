/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls = require('vs/nls');
var errors_1 = require('vs/base/common/errors');
var stopwatch_1 = require('vs/base/common/stopwatch');
var timer = require('vs/base/common/timer');
var editorCommon = require('vs/editor/common/editorCommon');
var textModel_1 = require('vs/editor/common/model/textModel');
var textModelWithTokensHelpers_1 = require('vs/editor/common/model/textModelWithTokensHelpers');
var tokenIterator_1 = require('vs/editor/common/model/tokenIterator');
var modes_1 = require('vs/editor/common/modes');
var nullMode_1 = require('vs/editor/common/modes/nullMode');
var supports_1 = require('vs/editor/common/modes/supports');
var richEditBrackets_1 = require('vs/editor/common/modes/supports/richEditBrackets');
var modeTransition_1 = require('vs/editor/common/core/modeTransition');
var tokensBinaryEncoding_1 = require('vs/editor/common/model/tokensBinaryEncoding');
var languageConfigurationRegistry_1 = require('vs/editor/common/modes/languageConfigurationRegistry');
var token_1 = require('vs/editor/common/core/token');
var Mode = (function () {
    function Mode(languageId) {
        this._languageId = languageId;
    }
    Mode.prototype.getId = function () {
        return this._languageId;
    };
    return Mode;
}());
/**
 * TODO@Alex: remove this wrapper
 */
var LineContext = (function () {
    function LineContext(topLevelModeId, line, map) {
        this.modeTransitions = line.getModeTransitions(topLevelModeId);
        this._text = line.text;
        this._lineTokens = line.getTokens(map);
    }
    LineContext.prototype.getLineContent = function () {
        return this._text;
    };
    LineContext.prototype.getTokenCount = function () {
        return this._lineTokens.getTokenCount();
    };
    LineContext.prototype.getTokenStartOffset = function (tokenIndex) {
        return this._lineTokens.getTokenStartOffset(tokenIndex);
    };
    LineContext.prototype.getTokenType = function (tokenIndex) {
        return this._lineTokens.getTokenType(tokenIndex);
    };
    LineContext.prototype.findIndexOfOffset = function (offset) {
        return this._lineTokens.findTokenIndexAtOffset(offset);
    };
    return LineContext;
}());
var TextModelWithTokens = (function (_super) {
    __extends(TextModelWithTokens, _super);
    function TextModelWithTokens(allowedEventTypes, rawText, languageId) {
        var _this = this;
        allowedEventTypes.push(editorCommon.EventType.ModelTokensChanged);
        allowedEventTypes.push(editorCommon.EventType.ModelModeChanged);
        _super.call(this, allowedEventTypes, rawText);
        this._languageId = languageId || nullMode_1.NULL_MODE_ID;
        this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange(function (e) {
            if (e.languageId !== _this._languageId) {
                return;
            }
            _this._resetTokenizationState();
            _this.emitModelTokensChangedEvent(1, _this.getLineCount());
        });
        this._tokensInflatorMap = null;
        this._invalidLineStartIndex = 0;
        this._lastState = null;
        this._revalidateTokensTimeout = -1;
        this._resetTokenizationState();
    }
    TextModelWithTokens.prototype.dispose = function () {
        this._tokenizationListener.dispose();
        this._clearTimers();
        this._lastState = null;
        this._tokensInflatorMap = null;
        _super.prototype.dispose.call(this);
    };
    TextModelWithTokens.prototype._shouldAutoTokenize = function () {
        return false;
    };
    TextModelWithTokens.prototype._resetValue = function (e, newValue) {
        _super.prototype._resetValue.call(this, e, newValue);
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
    };
    TextModelWithTokens.prototype._resetTokenizationState = function () {
        this._clearTimers();
        for (var i = 0; i < this._lines.length; i++) {
            this._lines[i].resetTokenizationState();
        }
        this._tokenizationSupport = null;
        if (!this.isTooLargeForHavingAMode()) {
            this._tokenizationSupport = modes_1.TokenizationRegistry.get(this._languageId);
        }
        if (this._tokenizationSupport) {
            var initialState = null;
            try {
                initialState = this._tokenizationSupport.getInitialState();
            }
            catch (e) {
                e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                errors_1.onUnexpectedError(e);
                this._tokenizationSupport = null;
            }
            if (initialState) {
                this._lines[0].setState(initialState);
            }
        }
        this._lastState = null;
        this._tokensInflatorMap = new tokensBinaryEncoding_1.TokensInflatorMap(this.getModeId());
        this._invalidLineStartIndex = 0;
        this._beginBackgroundTokenization();
    };
    TextModelWithTokens.prototype._clearTimers = function () {
        if (this._revalidateTokensTimeout !== -1) {
            clearTimeout(this._revalidateTokensTimeout);
            this._revalidateTokensTimeout = -1;
        }
    };
    TextModelWithTokens.prototype.getLineTokens = function (lineNumber, inaccurateTokensAcceptable) {
        if (inaccurateTokensAcceptable === void 0) { inaccurateTokensAcceptable = false; }
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        if (!inaccurateTokensAcceptable) {
            this._updateTokensUntilLine(lineNumber, true);
        }
        return this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
    };
    TextModelWithTokens.prototype.getLineContext = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        this._updateTokensUntilLine(lineNumber, true);
        return new LineContext(this.getModeId(), this._lines[lineNumber - 1], this._tokensInflatorMap);
    };
    TextModelWithTokens.prototype.getMode = function () {
        return new Mode(this._languageId);
    };
    TextModelWithTokens.prototype.getModeId = function () {
        return this.getMode().getId();
    };
    TextModelWithTokens.prototype.setMode = function (languageId) {
        if (this._languageId === languageId) {
            // There's nothing to do
            return;
        }
        var e = {
            oldMode: new Mode(this._languageId),
            newMode: new Mode(languageId)
        };
        this._languageId = languageId;
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
        this.emitModelTokensChangedEvent(1, this.getLineCount());
        this._emitModelModeChangedEvent(e);
    };
    TextModelWithTokens.prototype.getModeIdAtPosition = function (_lineNumber, _column) {
        if (!this._tokenizationSupport) {
            return this.getModeId();
        }
        var validPosition = this.validatePosition({
            lineNumber: _lineNumber,
            column: _column
        });
        var lineNumber = validPosition.lineNumber;
        var column = validPosition.column;
        if (column === 1) {
            return this.getStateBeforeLine(lineNumber).getModeId();
        }
        else if (column === this.getLineMaxColumn(lineNumber)) {
            return this.getStateAfterLine(lineNumber).getModeId();
        }
        else {
            var modeTransitions = this._getLineModeTransitions(lineNumber);
            var modeTransitionIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, column - 1);
            return modeTransitions[modeTransitionIndex].modeId;
        }
    };
    TextModelWithTokens.prototype._invalidateLine = function (lineIndex) {
        this._lines[lineIndex].isInvalid = true;
        if (lineIndex < this._invalidLineStartIndex) {
            if (this._invalidLineStartIndex < this._lines.length) {
                this._lines[this._invalidLineStartIndex].isInvalid = true;
            }
            this._invalidLineStartIndex = lineIndex;
            this._beginBackgroundTokenization();
        }
    };
    TextModelWithTokens.prototype._beginBackgroundTokenization = function () {
        var _this = this;
        if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {
            this._revalidateTokensTimeout = setTimeout(function () {
                _this._revalidateTokensTimeout = -1;
                _this._revalidateTokensNow();
            }, 0);
        }
    };
    TextModelWithTokens.prototype._warmUpTokens = function () {
        // Warm up first 100 lines (if it takes less than 50ms)
        var maxLineNumber = Math.min(100, this.getLineCount());
        var toLineNumber = maxLineNumber;
        for (var lineNumber = 1; lineNumber <= maxLineNumber; lineNumber++) {
            var text = this._lines[lineNumber - 1].text;
            if (text.length >= 200) {
                // This line is over 200 chars long, so warm up without it
                toLineNumber = lineNumber - 1;
                break;
            }
        }
        this._revalidateTokensNow(toLineNumber);
        if (this._invalidLineStartIndex < this._lines.length) {
            this._beginBackgroundTokenization();
        }
    };
    TextModelWithTokens.prototype._revalidateTokensNow = function (toLineNumber) {
        if (toLineNumber === void 0) { toLineNumber = this._invalidLineStartIndex + 1000000; }
        var t1 = timer.start(timer.Topic.EDITOR, 'backgroundTokenization');
        toLineNumber = Math.min(this._lines.length, toLineNumber);
        var MAX_ALLOWED_TIME = 20, fromLineNumber = this._invalidLineStartIndex + 1, tokenizedChars = 0, currentCharsToTokenize = 0, currentEstimatedTimeToTokenize = 0, sw = stopwatch_1.StopWatch.create(false), elapsedTime;
        // Tokenize at most 1000 lines. Estimate the tokenization speed per character and stop when:
        // - MAX_ALLOWED_TIME is reached
        // - tokenizing the next line would go above MAX_ALLOWED_TIME
        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            elapsedTime = sw.elapsed();
            if (elapsedTime > MAX_ALLOWED_TIME) {
                // Stop if MAX_ALLOWED_TIME is reached
                toLineNumber = lineNumber - 1;
                break;
            }
            // Compute how many characters will be tokenized for this line
            currentCharsToTokenize = this._lines[lineNumber - 1].text.length;
            if (tokenizedChars > 0) {
                // If we have enough history, estimate how long tokenizing this line would take
                currentEstimatedTimeToTokenize = (elapsedTime / tokenizedChars) * currentCharsToTokenize;
                if (elapsedTime + currentEstimatedTimeToTokenize > MAX_ALLOWED_TIME) {
                    // Tokenizing this line will go above MAX_ALLOWED_TIME
                    toLineNumber = lineNumber - 1;
                    break;
                }
            }
            this._updateTokensUntilLine(lineNumber, false);
            tokenizedChars += currentCharsToTokenize;
        }
        elapsedTime = sw.elapsed();
        if (fromLineNumber <= toLineNumber) {
            this.emitModelTokensChangedEvent(fromLineNumber, toLineNumber);
        }
        if (this._invalidLineStartIndex < this._lines.length) {
            this._beginBackgroundTokenization();
        }
        t1.stop();
    };
    TextModelWithTokens.prototype.getStateBeforeLine = function (lineNumber) {
        this._updateTokensUntilLine(lineNumber - 1, true);
        return this._lines[lineNumber - 1].getState();
    };
    TextModelWithTokens.prototype.getStateAfterLine = function (lineNumber) {
        this._updateTokensUntilLine(lineNumber, true);
        return lineNumber < this._lines.length ? this._lines[lineNumber].getState() : this._lastState;
    };
    TextModelWithTokens.prototype._getLineModeTransitions = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        this._updateTokensUntilLine(lineNumber, true);
        return this._lines[lineNumber - 1].getModeTransitions(this.getModeId());
    };
    TextModelWithTokens.prototype._updateTokensUntilLine = function (lineNumber, emitEvents) {
        if (!this._tokenizationSupport) {
            this._invalidLineStartIndex = this._lines.length;
            return;
        }
        var linesLength = this._lines.length;
        var endLineIndex = lineNumber - 1;
        var stopLineTokenizationAfter = 1000000000; // 1 billion, if a line is so long, you have other trouble :).
        var fromLineNumber = this._invalidLineStartIndex + 1, toLineNumber = lineNumber;
        // Validate all states up to and including endLineIndex
        for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
            var endStateIndex = lineIndex + 1;
            var r = null;
            var text = this._lines[lineIndex].text;
            try {
                // Tokenize only the first X characters
                r = this._tokenizationSupport.tokenize(this._lines[lineIndex].text, this._lines[lineIndex].getState(), 0, stopLineTokenizationAfter);
            }
            catch (e) {
                e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                errors_1.onUnexpectedError(e);
            }
            if (r && r.tokens && r.tokens.length > 0) {
                // Cannot have a stop offset before the last token
                r.actualStopOffset = Math.max(r.actualStopOffset, r.tokens[r.tokens.length - 1].startIndex + 1);
            }
            if (r && r.actualStopOffset < text.length) {
                // Treat the rest of the line (if above limit) as one default token
                r.tokens.push(new token_1.Token(r.actualStopOffset, ''));
                // Use as end state the starting state
                r.endState = this._lines[lineIndex].getState();
            }
            if (!r) {
                r = nullMode_1.nullTokenize(this.getModeId(), text, this._lines[lineIndex].getState());
            }
            if (!r.modeTransitions) {
                r.modeTransitions = [];
            }
            if (r.modeTransitions.length === 0) {
                // Make sure there is at least the transition to the top-most mode
                r.modeTransitions.push(new modeTransition_1.ModeTransition(0, this.getModeId()));
            }
            this._lines[lineIndex].setTokens(this._tokensInflatorMap, r.tokens, r.modeTransitions);
            this._lines[lineIndex].isInvalid = false;
            if (endStateIndex < linesLength) {
                if (this._lines[endStateIndex].getState() !== null && r.endState.equals(this._lines[endStateIndex].getState())) {
                    // The end state of this line remains the same
                    var nextInvalidLineIndex = lineIndex + 1;
                    while (nextInvalidLineIndex < linesLength) {
                        if (this._lines[nextInvalidLineIndex].isInvalid) {
                            break;
                        }
                        if (nextInvalidLineIndex + 1 < linesLength) {
                            if (this._lines[nextInvalidLineIndex + 1].getState() === null) {
                                break;
                            }
                        }
                        else {
                            if (this._lastState === null) {
                                break;
                            }
                        }
                        nextInvalidLineIndex++;
                    }
                    this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                    lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                }
                else {
                    this._lines[endStateIndex].setState(r.endState);
                }
            }
            else {
                this._lastState = r.endState;
            }
        }
        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
        if (emitEvents && fromLineNumber <= toLineNumber) {
            this.emitModelTokensChangedEvent(fromLineNumber, toLineNumber);
        }
    };
    TextModelWithTokens.prototype.emitModelTokensChangedEvent = function (fromLineNumber, toLineNumber) {
        var e = {
            fromLineNumber: fromLineNumber,
            toLineNumber: toLineNumber
        };
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelTokensChanged, e);
        }
    };
    TextModelWithTokens.prototype._emitModelModeChangedEvent = function (e) {
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelModeChanged, e);
        }
    };
    // Having tokens allows implementing additional helper methods
    TextModelWithTokens.prototype._lineIsTokenized = function (lineNumber) {
        return this._invalidLineStartIndex > lineNumber - 1;
    };
    TextModelWithTokens.prototype._getWordDefinition = function () {
        return textModelWithTokensHelpers_1.WordHelper.massageWordDefinitionOf(this.getModeId());
    };
    TextModelWithTokens.prototype.getWordAtPosition = function (position) {
        return textModelWithTokensHelpers_1.WordHelper.getWordAtPosition(this, this.validatePosition(position));
    };
    TextModelWithTokens.prototype.getWordUntilPosition = function (position) {
        var wordAtPosition = this.getWordAtPosition(position);
        if (!wordAtPosition) {
            return {
                word: '',
                startColumn: position.column,
                endColumn: position.column
            };
        }
        return {
            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
            startColumn: wordAtPosition.startColumn,
            endColumn: position.column
        };
    };
    TextModelWithTokens.prototype.tokenIterator = function (position, callback) {
        var iter = new tokenIterator_1.TokenIterator(this, this.validatePosition(position));
        var result = callback(iter);
        iter._invalidate();
        return result;
    };
    TextModelWithTokens.prototype.findMatchingBracketUp = function (_bracket, _position) {
        var bracket = _bracket.toLowerCase();
        var position = this.validatePosition(_position);
        var modeTransitions = this._lines[position.lineNumber - 1].getModeTransitions(this.getModeId());
        var currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
        var currentMode = modeTransitions[currentModeIndex];
        var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentMode.modeId);
        if (!currentModeBrackets) {
            return null;
        }
        var data = currentModeBrackets.textIsBracket[bracket];
        if (!data) {
            return null;
        }
        return this._findMatchingBracketUp(data, position);
    };
    TextModelWithTokens.prototype.matchBracket = function (position) {
        return this._matchBracket(this.validatePosition(position));
    };
    TextModelWithTokens.prototype._matchBracket = function (position) {
        var lineNumber = position.lineNumber;
        var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
        var lineText = this._lines[lineNumber - 1].text;
        var currentToken = lineTokens.findTokenAtOffset(position.column - 1);
        if (!currentToken) {
            return null;
        }
        var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentToken.modeId);
        // check that the token is not to be ignored
        if (currentModeBrackets && !supports_1.ignoreBracketsInToken(currentToken.type)) {
            // limit search to not go before `maxBracketLength`
            var searchStartOffset = Math.max(currentToken.startOffset, position.column - 1 - currentModeBrackets.maxBracketLength);
            // limit search to not go after `maxBracketLength`
            var searchEndOffset = Math.min(currentToken.endOffset, position.column - 1 + currentModeBrackets.maxBracketLength);
            // first, check if there is a bracket to the right of `position`
            var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, position.column - 1, searchEndOffset);
            if (foundBracket && foundBracket.startColumn === position.column) {
                var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                foundBracketText = foundBracketText.toLowerCase();
                var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                // check that we can actually match this bracket
                if (r) {
                    return r;
                }
            }
            // it might still be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
            while (true) {
                var foundBracket_1 = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!foundBracket_1) {
                    // there are no brackets in this text
                    break;
                }
                // check that we didn't hit a bracket too far away from position
                if (foundBracket_1.startColumn <= position.column && position.column <= foundBracket_1.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket_1.startColumn - 1, foundBracket_1.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket_1, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
                searchStartOffset = foundBracket_1.endColumn - 1;
            }
        }
        // If position is in between two tokens, try also looking in the previous token
        if (currentToken.hasPrev && currentToken.startOffset === position.column - 1) {
            var prevToken = currentToken.prev();
            var prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(prevToken.modeId);
            // check that previous token is not to be ignored
            if (prevModeBrackets && !supports_1.ignoreBracketsInToken(prevToken.type)) {
                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                var searchStartOffset = Math.max(prevToken.startOffset, position.column - 1 - prevModeBrackets.maxBracketLength);
                var searchEndOffset = currentToken.startOffset;
                var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                // check that we didn't hit a bracket too far away from position
                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
        if (isOpen) {
            var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        else {
            var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._findMatchingBracketUp = function (bracket, position) {
        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var modeId = bracket.modeId;
        var reversedBracketRegex = bracket.reversedRegex;
        var count = -1;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStopOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.lastToken();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
            while (currentToken) {
                if (currentToken.modeId === modeId && !supports_1.ignoreBracketsInToken(currentToken.type)) {
                    while (true) {
                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStopOffset = r.startColumn - 1;
                    }
                }
                currentToken = currentToken.prev();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._findMatchingBracketDown = function (bracket, position) {
        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var modeId = bracket.modeId;
        var bracketRegex = bracket.forwardRegex;
        var count = 1;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStartOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.firstToken();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
            while (currentToken) {
                if (currentToken.modeId === modeId && !supports_1.ignoreBracketsInToken(currentToken.type)) {
                    while (true) {
                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStartOffset = r.endColumn - 1;
                    }
                }
                currentToken = currentToken.next();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype.findPrevBracket = function (_position) {
        var position = this.validatePosition(_position);
        var modeId = null;
        var modeBrackets;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStopOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.lastToken();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
            while (currentToken) {
                if (modeId !== currentToken.modeId) {
                    modeId = currentToken.modeId;
                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(modeId);
                }
                if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.type)) {
                    var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                currentToken = currentToken.prev();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype.findNextBracket = function (_position) {
        var position = this.validatePosition(_position);
        var modeId = null;
        var modeBrackets;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStartOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.firstToken();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
            while (currentToken) {
                if (modeId !== currentToken.modeId) {
                    modeId = currentToken.modeId;
                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(modeId);
                }
                if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.type)) {
                    var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                currentToken = currentToken.next();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._toFoundBracket = function (modeBrackets, r) {
        if (!r) {
            return null;
        }
        var text = this.getValueInRange(r);
        text = text.toLowerCase();
        var data = modeBrackets.textIsBracket[text];
        if (!data) {
            return null;
        }
        return {
            range: r,
            open: data.open,
            close: data.close,
            isOpen: modeBrackets.textIsOpenBracket[text]
        };
    };
    TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG = nls.localize('mode.tokenizationSupportFailed', "The mode has failed while tokenizing the input.");
    return TextModelWithTokens;
}(textModel_1.TextModel));
exports.TextModelWithTokens = TextModelWithTokens;
