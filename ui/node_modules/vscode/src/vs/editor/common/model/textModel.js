/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var eventEmitter_1 = require('vs/base/common/eventEmitter');
var strings = require('vs/base/common/strings');
var position_1 = require('vs/editor/common/core/position');
var range_1 = require('vs/editor/common/core/range');
var editorCommon = require('vs/editor/common/editorCommon');
var modelLine_1 = require('vs/editor/common/model/modelLine');
var indentationGuesser_1 = require('vs/editor/common/model/indentationGuesser');
var defaultConfig_1 = require('vs/editor/common/config/defaultConfig');
var prefixSumComputer_1 = require('vs/editor/common/viewModel/prefixSumComputer');
var indentRanges_1 = require('vs/editor/common/model/indentRanges');
var LIMIT_FIND_COUNT = 999;
exports.LONG_LINE_BOUNDARY = 1000;
var TextModel = (function (_super) {
    __extends(TextModel, _super);
    function TextModel(allowedEventTypes, rawText) {
        allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged, editorCommon.EventType.ModelOptionsChanged);
        _super.call(this, allowedEventTypes);
        this._shouldSimplifyMode = (rawText.length > TextModel.MODEL_SYNC_LIMIT);
        this._shouldDenyMode = (rawText.length > TextModel.MODEL_TOKENIZATION_LIMIT);
        this._options = rawText.options;
        this._constructLines(rawText);
        this._setVersionId(1);
        this._isDisposed = false;
        this._isDisposing = false;
    }
    TextModel.prototype.isTooLargeForHavingAMode = function () {
        return this._shouldDenyMode;
    };
    TextModel.prototype.isTooLargeForHavingARichMode = function () {
        return this._shouldSimplifyMode;
    };
    TextModel.prototype.getOptions = function () {
        return this._options;
    };
    TextModel.prototype.updateOptions = function (newOpts) {
        var somethingChanged = false;
        var changed = {
            tabSize: false,
            insertSpaces: false,
            trimAutoWhitespace: false
        };
        if (typeof newOpts.insertSpaces !== 'undefined') {
            if (this._options.insertSpaces !== newOpts.insertSpaces) {
                somethingChanged = true;
                changed.insertSpaces = true;
                this._options.insertSpaces = newOpts.insertSpaces;
            }
        }
        if (typeof newOpts.tabSize !== 'undefined') {
            var newTabSize = newOpts.tabSize | 0;
            if (this._options.tabSize !== newTabSize) {
                somethingChanged = true;
                changed.tabSize = true;
                this._options.tabSize = newTabSize;
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    this._lines[i].updateTabSize(newTabSize);
                }
            }
        }
        if (typeof newOpts.trimAutoWhitespace !== 'undefined') {
            if (this._options.trimAutoWhitespace !== newOpts.trimAutoWhitespace) {
                somethingChanged = true;
                changed.trimAutoWhitespace = true;
                this._options.trimAutoWhitespace = newOpts.trimAutoWhitespace;
            }
        }
        if (somethingChanged) {
            this.emit(editorCommon.EventType.ModelOptionsChanged, changed);
        }
    };
    TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
        var lines = this._lines.map(function (line) { return line.text; });
        var guessedIndentation = indentationGuesser_1.guessIndentation(lines, defaultTabSize, defaultInsertSpaces);
        this.updateOptions({
            insertSpaces: guessedIndentation.insertSpaces,
            tabSize: guessedIndentation.tabSize
        });
    };
    TextModel.prototype._normalizeIndentationFromWhitespace = function (str) {
        var tabSize = this._options.tabSize;
        var insertSpaces = this._options.insertSpaces;
        var spacesCnt = 0;
        for (var i = 0; i < str.length; i++) {
            if (str.charAt(i) === '\t') {
                spacesCnt += tabSize;
            }
            else {
                spacesCnt++;
            }
        }
        var result = '';
        if (!insertSpaces) {
            var tabsCnt = Math.floor(spacesCnt / tabSize);
            spacesCnt = spacesCnt % tabSize;
            for (var i = 0; i < tabsCnt; i++) {
                result += '\t';
            }
        }
        for (var i = 0; i < spacesCnt; i++) {
            result += ' ';
        }
        return result;
    };
    TextModel.prototype.normalizeIndentation = function (str) {
        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
        if (firstNonWhitespaceIndex === -1) {
            firstNonWhitespaceIndex = str.length;
        }
        return this._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex)) + str.substring(firstNonWhitespaceIndex);
    };
    TextModel.prototype.getOneIndent = function () {
        var tabSize = this._options.tabSize;
        var insertSpaces = this._options.insertSpaces;
        if (insertSpaces) {
            var result = '';
            for (var i = 0; i < tabSize; i++) {
                result += ' ';
            }
            return result;
        }
        else {
            return '\t';
        }
    };
    TextModel.prototype.getVersionId = function () {
        return this._versionId;
    };
    TextModel.prototype.getAlternativeVersionId = function () {
        return this._alternativeVersionId;
    };
    TextModel.prototype._ensureLineStarts = function () {
        if (!this._lineStarts) {
            var lineStartValues = [];
            var eolLength = this._EOL.length;
            for (var i = 0, len = this._lines.length; i < len; i++) {
                lineStartValues.push(this._lines[i].text.length + eolLength);
            }
            this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
        }
    };
    TextModel.prototype.getOffsetAt = function (rawPosition) {
        var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);
        this._ensureLineStarts();
        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + position.column - 1;
    };
    TextModel.prototype.getPositionAt = function (offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        var out = this._lineStarts.getIndexOf(offset);
        var lineLength = this._lines[out.index].text.length;
        // Ensure we return a valid position
        return new position_1.Position(out.index + 1, Math.min(out.remainder + 1, lineLength + 1));
    };
    TextModel.prototype._increaseVersionId = function () {
        this._setVersionId(this._versionId + 1);
    };
    TextModel.prototype._setVersionId = function (newVersionId) {
        this._versionId = newVersionId;
        this._alternativeVersionId = this._versionId;
    };
    TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
        this._alternativeVersionId = newAlternativeVersionId;
    };
    TextModel.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    TextModel.prototype.dispose = function () {
        this._isDisposed = true;
        // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
        this._lines = null;
        this._EOL = null;
        this._BOM = null;
        _super.prototype.dispose.call(this);
    };
    TextModel.prototype._createContentChangedFlushEvent = function () {
        return {
            changeType: editorCommon.EventType.ModelRawContentChangedFlush,
            detail: null,
            // TODO@Alex -> remove these fields from here
            versionId: -1,
            isUndoing: false,
            isRedoing: false
        };
    };
    TextModel.prototype._emitContentChanged2 = function (startLineNumber, startColumn, endLineNumber, endColumn, rangeLength, text, isUndoing, isRedoing) {
        var e = {
            range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
            rangeLength: rangeLength,
            text: text,
            eol: this._EOL,
            versionId: this.getVersionId(),
            isUndoing: isUndoing,
            isRedoing: isRedoing
        };
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelContentChanged2, e);
        }
    };
    TextModel.prototype._resetValue = function (e, newValue) {
        this._constructLines(newValue);
        this._increaseVersionId();
        e.detail = this.toRawText();
        e.versionId = this._versionId;
    };
    TextModel.prototype.toRawText = function () {
        return {
            BOM: this._BOM,
            EOL: this._EOL,
            lines: this.getLinesContent(),
            length: this.getValueLength(),
            options: this._options
        };
    };
    TextModel.prototype.equals = function (other) {
        if (this._BOM !== other.BOM) {
            return false;
        }
        if (this._EOL !== other.EOL) {
            return false;
        }
        if (this._lines.length !== other.lines.length) {
            return false;
        }
        for (var i = 0, len = this._lines.length; i < len; i++) {
            if (this._lines[i].text !== other.lines[i]) {
                return false;
            }
        }
        return true;
    };
    TextModel.prototype.setValue = function (value) {
        if (value === null) {
            // There's nothing to do
            return;
        }
        var rawText = null;
        rawText = TextModel.toRawText(value, {
            tabSize: this._options.tabSize,
            insertSpaces: this._options.insertSpaces,
            trimAutoWhitespace: this._options.trimAutoWhitespace,
            detectIndentation: false,
            defaultEOL: this._options.defaultEOL
        });
        this.setValueFromRawText(rawText);
    };
    TextModel.prototype.setValueFromRawText = function (newValue) {
        if (newValue === null) {
            // There's nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        var e = this._createContentChangedFlushEvent();
        this._resetValue(e, newValue);
        this._emitModelContentChangedFlushEvent(e);
        this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
    };
    TextModel.prototype.getValue = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._BOM + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.getValueLength = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._BOM.length + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.getEmptiedValueInRange = function (rawRange, fillCharacter, eol) {
        if (fillCharacter === void 0) { fillCharacter = ''; }
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return '';
        }
        if (range.startLineNumber === range.endLineNumber) {
            return this._repeatCharacter(fillCharacter, range.endColumn - range.startColumn);
        }
        var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
        resultLines.push(this._repeatCharacter(fillCharacter, this._lines[startLineIndex].text.length - range.startColumn + 1));
        for (var i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._repeatCharacter(fillCharacter, this._lines[i].text.length));
        }
        resultLines.push(this._repeatCharacter(fillCharacter, range.endColumn - 1));
        return resultLines.join(lineEnding);
    };
    TextModel.prototype._repeatCharacter = function (fillCharacter, count) {
        var r = '';
        for (var i = 0; i < count; i++) {
            r += fillCharacter;
        }
        return r;
    };
    TextModel.prototype.getValueInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return '';
        }
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].text.substring(range.startColumn - 1, range.endColumn - 1);
        }
        var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
        resultLines.push(this._lines[startLineIndex].text.substring(range.startColumn - 1));
        for (var i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i].text);
        }
        resultLines.push(this._lines[endLineIndex].text.substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    };
    TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return 0;
        }
        if (range.startLineNumber === range.endLineNumber) {
            return (range.endColumn - range.startColumn);
        }
        var startOffset = this.getOffsetAt(new position_1.Position(range.startLineNumber, range.startColumn));
        var endOffset = this.getOffsetAt(new position_1.Position(range.endLineNumber, range.endColumn));
        return endOffset - startOffset;
    };
    TextModel.prototype.isDominatedByLongLines = function () {
        var smallLineCharCount = 0, longLineCharCount = 0, i, len, lines = this._lines, lineLength;
        for (i = 0, len = this._lines.length; i < len; i++) {
            lineLength = lines[i].text.length;
            if (lineLength >= exports.LONG_LINE_BOUNDARY) {
                longLineCharCount += lineLength;
            }
            else {
                smallLineCharCount += lineLength;
            }
        }
        return (longLineCharCount > smallLineCharCount);
    };
    TextModel.prototype.getLineCount = function () {
        return this._lines.length;
    };
    TextModel.prototype.getLineContent = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].text;
    };
    TextModel.prototype.getIndentLevel = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].getIndentLevel();
    };
    TextModel.prototype._resetIndentRanges = function () {
        this._indentRanges = null;
    };
    TextModel.prototype._getIndentRanges = function () {
        if (!this._indentRanges) {
            this._indentRanges = indentRanges_1.computeRanges(this);
        }
        return this._indentRanges;
    };
    TextModel.prototype.getIndentRanges = function () {
        var indentRanges = this._getIndentRanges();
        return indentRanges_1.IndentRange.deepCloneArr(indentRanges);
    };
    TextModel.prototype._toValidLineIndentGuide = function (lineNumber, indentGuide) {
        var lineIndentLevel = this._lines[lineNumber - 1].getIndentLevel();
        if (lineIndentLevel === -1) {
            return indentGuide;
        }
        var maxIndentGuide = Math.ceil(lineIndentLevel / this._options.tabSize);
        return Math.min(maxIndentGuide, indentGuide);
    };
    TextModel.prototype.getLineIndentGuide = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var indentRanges = this._getIndentRanges();
        for (var i = indentRanges.length - 1; i >= 0; i--) {
            var rng = indentRanges[i];
            if (rng.startLineNumber === lineNumber) {
                return this._toValidLineIndentGuide(lineNumber, Math.ceil(rng.indent / this._options.tabSize));
            }
            if (rng.startLineNumber < lineNumber && lineNumber <= rng.endLineNumber) {
                return this._toValidLineIndentGuide(lineNumber, 1 + Math.floor(rng.indent / this._options.tabSize));
            }
            if (rng.endLineNumber + 1 === lineNumber) {
                var bestIndent = rng.indent;
                while (i > 0) {
                    i--;
                    rng = indentRanges[i];
                    if (rng.endLineNumber + 1 === lineNumber) {
                        bestIndent = rng.indent;
                    }
                }
                return this._toValidLineIndentGuide(lineNumber, Math.ceil(bestIndent / this._options.tabSize));
            }
        }
        return 0;
    };
    TextModel.prototype.getLinesContent = function () {
        var r = [];
        for (var i = 0, len = this._lines.length; i < len; i++) {
            r[i] = this._lines[i].text;
        }
        return r;
    };
    TextModel.prototype.getEOL = function () {
        return this._EOL;
    };
    TextModel.prototype.setEOL = function (eol) {
        var newEOL = (eol === editorCommon.EndOfLineSequence.CRLF ? '\r\n' : '\n');
        if (this._EOL === newEOL) {
            // Nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        this._EOL = newEOL;
        this._lineStarts = null;
        this._increaseVersionId();
        var e = this._createContentChangedFlushEvent();
        e.detail = this.toRawText();
        e.versionId = this._versionId;
        this._emitModelContentChangedFlushEvent(e);
        this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
    };
    TextModel.prototype.getLineMinColumn = function (lineNumber) {
        return 1;
    };
    TextModel.prototype.getLineMaxColumn = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].text.length + 1;
    };
    TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var result = strings.firstNonWhitespaceIndex(this._lines[lineNumber - 1].text);
        if (result === -1) {
            return 0;
        }
        return result + 1;
    };
    TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var result = strings.lastNonWhitespaceIndex(this._lines[lineNumber - 1].text);
        if (result === -1) {
            return 0;
        }
        return result + 2;
    };
    TextModel.prototype.validateLineNumber = function (lineNumber) {
        if (lineNumber < 1) {
            lineNumber = 1;
        }
        if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
        }
        return lineNumber;
    };
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {
        var lineNumber = Math.floor(typeof _lineNumber === 'number' ? _lineNumber : 1);
        var column = Math.floor(typeof _column === 'number' ? _column : 1);
        if (lineNumber < 1) {
            return new position_1.Position(1, 1);
        }
        if (lineNumber > this._lines.length) {
            return new position_1.Position(this._lines.length, this.getLineMaxColumn(this._lines.length));
        }
        if (column <= 1) {
            return new position_1.Position(lineNumber, 1);
        }
        var maxColumn = this.getLineMaxColumn(lineNumber);
        if (column >= maxColumn) {
            return new position_1.Position(lineNumber, maxColumn);
        }
        if (strict) {
            // If the position would end up in the middle of a high-low surrogate pair,
            // we move it to before the pair
            // !!At this point, column > 1
            var charCodeBefore = this._lines[lineNumber - 1].text.charCodeAt(column - 2);
            if (strings.isHighSurrogate(charCodeBefore)) {
                return new position_1.Position(lineNumber, column - 1);
            }
        }
        return new position_1.Position(lineNumber, column);
    };
    TextModel.prototype.validatePosition = function (position) {
        return this._validatePosition(position.lineNumber, position.column, true);
    };
    TextModel.prototype.validateRange = function (_range) {
        var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);
        var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);
        var startLineNumber = start.lineNumber;
        var startColumn = start.column;
        var endLineNumber = end.lineNumber;
        var endColumn = end.column;
        var startLineText = this._lines[startLineNumber - 1].text;
        var endLineText = this._lines[endLineNumber - 1].text;
        var charCodeBeforeStart = (startColumn > 1 ? startLineText.charCodeAt(startColumn - 2) : 0);
        var charCodeBeforeEnd = (endColumn > 1 && endColumn <= endLineText.length ? endLineText.charCodeAt(endColumn - 2) : 0);
        var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);
        var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);
        if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        if (startLineNumber === endLineNumber && startColumn === endColumn) {
            // do not expand a collapsed range, simply move it to a valid location
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
        }
        if (startInsideSurrogatePair && endInsideSurrogatePair) {
            // expand range at both ends
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
        }
        if (startInsideSurrogatePair) {
            // only expand range at the start
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
        }
        // only expand range at the end
        return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
    };
    TextModel.prototype.modifyPosition = function (rawPosition, offset) {
        return this.getPositionAt(this.getOffsetAt(rawPosition) + offset);
    };
    TextModel.prototype.getFullModelRange = function () {
        var lineCount = this.getLineCount();
        return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
    };
    TextModel.prototype._emitModelContentChangedFlushEvent = function (e) {
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelRawContentChanged, e);
        }
    };
    TextModel.toRawText = function (rawText, opts) {
        // Count the number of lines that end with \r\n
        var carriageReturnCnt = 0, lastCarriageReturnIndex = -1;
        while ((lastCarriageReturnIndex = rawText.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
            carriageReturnCnt++;
        }
        // Split the text into lines
        var lines = rawText.split(/\r\n|\r|\n/);
        // Remove the BOM (if present)
        var BOM = '';
        if (strings.startsWithUTF8BOM(lines[0])) {
            BOM = strings.UTF8_BOM_CHARACTER;
            lines[0] = lines[0].substr(1);
        }
        var lineFeedCnt = lines.length - 1;
        var EOL = '';
        if (lineFeedCnt === 0) {
            // This is an empty file or a file with precisely one line
            EOL = (opts.defaultEOL === editorCommon.DefaultEndOfLine.LF ? '\n' : '\r\n');
        }
        else if (carriageReturnCnt > lineFeedCnt / 2) {
            // More than half of the file contains \r\n ending lines
            EOL = '\r\n';
        }
        else {
            // At least one line more ends in \n
            EOL = '\n';
        }
        var resolvedOpts;
        if (opts.detectIndentation) {
            var guessedIndentation = indentationGuesser_1.guessIndentation(lines, opts.tabSize, opts.insertSpaces);
            resolvedOpts = {
                tabSize: guessedIndentation.tabSize,
                insertSpaces: guessedIndentation.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                defaultEOL: opts.defaultEOL
            };
        }
        else {
            resolvedOpts = {
                tabSize: opts.tabSize,
                insertSpaces: opts.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                defaultEOL: opts.defaultEOL
            };
        }
        return {
            BOM: BOM,
            EOL: EOL,
            lines: lines,
            length: rawText.length,
            options: resolvedOpts
        };
    };
    TextModel.prototype._constructLines = function (rawText) {
        var tabSize = rawText.options.tabSize;
        var rawLines = rawText.lines;
        var modelLines = [];
        for (var i = 0, len = rawLines.length; i < len; i++) {
            modelLines[i] = new modelLine_1.ModelLine(i + 1, rawLines[i], tabSize);
        }
        this._BOM = rawText.BOM;
        this._EOL = rawText.EOL;
        this._lines = modelLines;
        this._lineStarts = null;
        this._resetIndentRanges();
    };
    TextModel.prototype._getEndOfLine = function (eol) {
        switch (eol) {
            case editorCommon.EndOfLinePreference.LF:
                return '\n';
            case editorCommon.EndOfLinePreference.CRLF:
                return '\r\n';
            case editorCommon.EndOfLinePreference.TextDefined:
                return this.getEOL();
        }
        throw new Error('Unknown EOL preference');
    };
    TextModel._isMultiline = function (searchString) {
        if (!searchString || searchString.length === 0) {
            return false;
        }
        for (var i = 0, len = searchString.length; i < len; i++) {
            var chCode = searchString.charCodeAt(i);
            if (chCode === 92 /* Backslash */) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a \
                    break;
                }
                var nextChCode = searchString.charCodeAt(i);
                if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */) {
                    return true;
                }
            }
        }
        return false;
    };
    TextModel.parseSearchRequest = function (searchString, isRegex, matchCase, wholeWord) {
        if (searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        var regex = null;
        var multiline = isRegex && TextModel._isMultiline(searchString);
        try {
            regex = strings.createRegExp(searchString, isRegex, { matchCase: matchCase, wholeWord: wholeWord, multiline: multiline, global: true });
        }
        catch (err) {
            return null;
        }
        if (!regex) {
            return null;
        }
        return regex;
    };
    TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wholeWord, limitResultCount) {
        if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
        var regex = TextModel.parseSearchRequest(searchString, isRegex, matchCase, wholeWord);
        if (!regex) {
            return [];
        }
        var searchRange = this.getFullModelRange();
        if (regex.multiline) {
            return this._doFindMatchesMultiline(searchRange, regex, limitResultCount);
        }
        return this._doFindMatchesLineByLine(searchRange, regex, limitResultCount);
    };
    TextModel.prototype._doFindMatchesMultiline = function (searchRange, searchRegex, limitResultCount) {
        var deltaOffset = this.getOffsetAt(searchRange.getStartPosition());
        var text = this.getValueInRange(searchRange);
        var result = [];
        var prevStartOffset = 0;
        var prevEndOffset = 0;
        var counter = 0;
        var m;
        while ((m = searchRegex.exec(text))) {
            var startOffset = deltaOffset + m.index;
            var endOffset = startOffset + m[0].length;
            if (prevStartOffset === startOffset && prevEndOffset === endOffset) {
                // Exit early if the regex matches the same range
                return result;
            }
            var startPosition = this.getPositionAt(startOffset);
            var endPosition = this.getPositionAt(endOffset);
            result[counter++] = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
            if (counter >= limitResultCount) {
                return result;
            }
            prevStartOffset = startOffset;
            prevEndOffset = endOffset;
        }
        return result;
    };
    TextModel.prototype._doFindMatchesLineByLine = function (searchRange, searchRegex, limitResultCount) {
        var result = [];
        var text;
        var counter = 0;
        // Early case for a search range that starts & stops on the same line number
        if (searchRange.startLineNumber === searchRange.endLineNumber) {
            text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
            counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
            return result;
        }
        // Collect results from first line
        text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1);
        counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
        // Collect results from middle lines
        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && counter < limitResultCount; lineNumber++) {
            counter = this._findMatchesInLine(searchRegex, this._lines[lineNumber - 1].text, lineNumber, 0, counter, result, limitResultCount);
        }
        // Collect results from last line
        if (counter < limitResultCount) {
            text = this._lines[searchRange.endLineNumber - 1].text.substring(0, searchRange.endColumn - 1);
            counter = this._findMatchesInLine(searchRegex, text, searchRange.endLineNumber, 0, counter, result, limitResultCount);
        }
        return result;
    };
    TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
        var regex = TextModel.parseSearchRequest(searchString, isRegex, matchCase, wholeWord);
        if (!regex) {
            return null;
        }
        var searchStart = this.validatePosition(rawSearchStart);
        if (regex.multiline) {
            return this._doFindNextMatchMultiline(searchStart, regex);
        }
        return this._doFindNextMatchLineByLine(searchStart, regex);
    };
    TextModel.prototype._doFindNextMatchMultiline = function (searchStart, searchRegex) {
        var searchTextStart = { lineNumber: searchStart.lineNumber, column: 1 };
        var deltaOffset = this.getOffsetAt(searchTextStart);
        var text = this.getValueInRange(new range_1.Range(searchTextStart.lineNumber, searchTextStart.column, this.getLineCount(), this.getLineMaxColumn(this.getLineCount())));
        searchRegex.lastIndex = searchStart.column - 1;
        var m = searchRegex.exec(text);
        if (m) {
            var startOffset = deltaOffset + m.index;
            var endOffset = startOffset + m[0].length;
            var startPosition = this.getPositionAt(startOffset);
            var endPosition = this.getPositionAt(endOffset);
            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        }
        if (searchStart.lineNumber !== 1 || searchStart.column !== -1) {
            // Try again from the top
            return this._doFindNextMatchMultiline(new position_1.Position(1, 1), searchRegex);
        }
        return null;
    };
    TextModel.prototype._doFindNextMatchLineByLine = function (searchStart, searchRegex) {
        var lineCount = this.getLineCount();
        var startLineNumber = searchStart.lineNumber;
        var text;
        var r;
        // Look in first line
        text = this._lines[startLineNumber - 1].text;
        r = this._findFirstMatchInLine(searchRegex, text, startLineNumber, searchStart.column);
        if (r) {
            return r;
        }
        for (var i = 1; i <= lineCount; i++) {
            var lineIndex = (startLineNumber + i - 1) % lineCount;
            text = this._lines[lineIndex].text;
            r = this._findFirstMatchInLine(searchRegex, text, lineIndex + 1, 1);
            if (r) {
                return r;
            }
        }
        return null;
    };
    TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
        var regex = TextModel.parseSearchRequest(searchString, isRegex, matchCase, wholeWord);
        if (!regex) {
            return null;
        }
        var searchStart = this.validatePosition(rawSearchStart);
        if (regex.multiline) {
            return this._doFindPreviousMatchMultiline(searchStart, regex);
        }
        return this._doFindPreviousMatchLineByLine(searchStart, regex);
    };
    TextModel.prototype._doFindPreviousMatchMultiline = function (searchStart, searchRegex) {
        var matches = this._doFindMatchesMultiline(new range_1.Range(1, 1, searchStart.lineNumber, searchStart.column), searchRegex, 10 * LIMIT_FIND_COUNT);
        if (matches.length > 0) {
            return matches[matches.length - 1];
        }
        if (searchStart.lineNumber !== this.getLineCount() || searchStart.column !== this.getLineMaxColumn(this.getLineCount())) {
            // Try again with all content
            return this._doFindPreviousMatchMultiline(new position_1.Position(this.getLineCount(), this.getLineMaxColumn(this.getLineCount())), searchRegex);
        }
        return null;
    };
    TextModel.prototype._doFindPreviousMatchLineByLine = function (searchStart, searchRegex) {
        var lineCount = this.getLineCount();
        var startLineNumber = searchStart.lineNumber;
        var text;
        var r;
        // Look in first line
        text = this._lines[startLineNumber - 1].text.substring(0, searchStart.column - 1);
        r = this._findLastMatchInLine(searchRegex, text, startLineNumber);
        if (r) {
            return r;
        }
        for (var i = 1; i <= lineCount; i++) {
            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
            text = this._lines[lineIndex].text;
            r = this._findLastMatchInLine(searchRegex, text, lineIndex + 1);
            if (r) {
                return r;
            }
        }
        return null;
    };
    TextModel.prototype._findFirstMatchInLine = function (searchRegex, text, lineNumber, fromColumn) {
        // Set regex to search from column
        searchRegex.lastIndex = fromColumn - 1;
        var m = searchRegex.exec(text);
        return m ? new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length) : null;
    };
    TextModel.prototype._findLastMatchInLine = function (searchRegex, text, lineNumber) {
        var bestResult = null;
        var m;
        while ((m = searchRegex.exec(text))) {
            var result = new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length);
            if (result.equalsRange(bestResult)) {
                break;
            }
            bestResult = result;
            if (m.index + m[0].length === text.length) {
                // Reached the end of the line
                break;
            }
        }
        return bestResult;
    };
    TextModel.prototype._findMatchesInLine = function (searchRegex, text, lineNumber, deltaOffset, counter, result, limitResultCount) {
        var m;
        // Reset regex to search from the beginning
        searchRegex.lastIndex = 0;
        do {
            m = searchRegex.exec(text);
            if (m) {
                var range = new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
                if (range.equalsRange(result[result.length - 1])) {
                    // Exit early if the regex matches the same range
                    return counter;
                }
                result.push(range);
                counter++;
                if (counter >= limitResultCount) {
                    return counter;
                }
                if (m.index + m[0].length === text.length) {
                    // Reached the end of the line
                    return counter;
                }
            }
        } while (m);
        return counter;
    };
    TextModel.MODEL_SYNC_LIMIT = 5 * 1024 * 1024; // 5 MB
    TextModel.MODEL_TOKENIZATION_LIMIT = 20 * 1024 * 1024; // 20 MB
    TextModel.DEFAULT_CREATION_OPTIONS = {
        tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
        insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
        detectIndentation: false,
        defaultEOL: editorCommon.DefaultEndOfLine.LF,
        trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
    };
    return TextModel;
}(eventEmitter_1.OrderGuaranteeEventEmitter));
exports.TextModel = TextModel;
var RawText = (function () {
    function RawText() {
    }
    RawText.fromString = function (rawText, opts) {
        return TextModel.toRawText(rawText, opts);
    };
    RawText.fromStringWithModelOptions = function (rawText, model) {
        var opts = model.getOptions();
        return TextModel.toRawText(rawText, {
            tabSize: opts.tabSize,
            insertSpaces: opts.insertSpaces,
            trimAutoWhitespace: opts.trimAutoWhitespace,
            detectIndentation: false,
            defaultEOL: opts.defaultEOL
        });
    };
    return RawText;
}());
exports.RawText = RawText;
