import { OrderGuaranteeEventEmitter } from 'vs/base/common/eventEmitter';
import { Position } from 'vs/editor/common/core/position';
import { Range } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { ModelLine } from 'vs/editor/common/model/modelLine';
import { PrefixSumComputer } from 'vs/editor/common/viewModel/prefixSumComputer';
import { IndentRange } from 'vs/editor/common/model/indentRanges';
export declare const LONG_LINE_BOUNDARY = 1000;
export declare class TextModel extends OrderGuaranteeEventEmitter implements editorCommon.ITextModel {
    private static MODEL_SYNC_LIMIT;
    private static MODEL_TOKENIZATION_LIMIT;
    static DEFAULT_CREATION_OPTIONS: editorCommon.ITextModelCreationOptions;
    _lines: ModelLine[];
    protected _EOL: string;
    protected _isDisposed: boolean;
    protected _isDisposing: boolean;
    protected _options: editorCommon.TextModelResolvedOptions;
    protected _lineStarts: PrefixSumComputer;
    private _indentRanges;
    private _versionId;
    /**
     * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)
     */
    private _alternativeVersionId;
    private _BOM;
    protected _mightContainRTL: boolean;
    private _shouldSimplifyMode;
    private _shouldDenyMode;
    constructor(allowedEventTypes: string[], rawText: editorCommon.IRawText);
    protected _assertNotDisposed(): void;
    isTooLargeForHavingAMode(): boolean;
    isTooLargeForHavingARichMode(): boolean;
    getOptions(): editorCommon.TextModelResolvedOptions;
    updateOptions(_newOpts: editorCommon.ITextModelUpdateOptions): void;
    detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
    private static _normalizeIndentationFromWhitespace(str, tabSize, insertSpaces);
    static normalizeIndentation(str: string, tabSize: number, insertSpaces: boolean): string;
    normalizeIndentation(str: string): string;
    getOneIndent(): string;
    getVersionId(): number;
    mightContainRTL(): boolean;
    getAlternativeVersionId(): number;
    private _ensureLineStarts();
    getOffsetAt(rawPosition: editorCommon.IPosition): number;
    getPositionAt(offset: number): Position;
    protected _increaseVersionId(): void;
    protected _setVersionId(newVersionId: number): void;
    protected _overwriteAlternativeVersionId(newAlternativeVersionId: number): void;
    isDisposed(): boolean;
    dispose(): void;
    protected _createContentChangedFlushEvent(): editorCommon.IModelContentChangedFlushEvent;
    protected _emitContentChanged2(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, rangeLength: number, text: string, isUndoing: boolean, isRedoing: boolean): void;
    protected _resetValue(newValue: editorCommon.IRawText): void;
    toRawText(): editorCommon.IRawText;
    equals(other: editorCommon.IRawText): boolean;
    setValue(value: string): void;
    setValueFromRawText(newValue: editorCommon.IRawText): void;
    getValue(eol?: editorCommon.EndOfLinePreference, preserveBOM?: boolean): string;
    getValueLength(eol?: editorCommon.EndOfLinePreference, preserveBOM?: boolean): number;
    getEmptiedValueInRange(rawRange: editorCommon.IRange, fillCharacter?: string, eol?: editorCommon.EndOfLinePreference): string;
    private _repeatCharacter(fillCharacter, count);
    getValueInRange(rawRange: editorCommon.IRange, eol?: editorCommon.EndOfLinePreference): string;
    getValueLengthInRange(rawRange: editorCommon.IRange, eol?: editorCommon.EndOfLinePreference): number;
    isDominatedByLongLines(): boolean;
    getLineCount(): number;
    getLineContent(lineNumber: number): string;
    getIndentLevel(lineNumber: number): number;
    protected _resetIndentRanges(): void;
    private _getIndentRanges();
    getIndentRanges(): IndentRange[];
    private _toValidLineIndentGuide(lineNumber, indentGuide);
    getLineIndentGuide(lineNumber: number): number;
    getLinesContent(): string[];
    getEOL(): string;
    setEOL(eol: editorCommon.EndOfLineSequence): void;
    getLineMinColumn(lineNumber: number): number;
    getLineMaxColumn(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    validateLineNumber(lineNumber: number): number;
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    private _validatePosition(_lineNumber, _column, strict);
    validatePosition(position: editorCommon.IPosition): Position;
    validateRange(_range: editorCommon.IRange): Range;
    modifyPosition(rawPosition: editorCommon.IPosition, offset: number): Position;
    getFullModelRange(): Range;
    protected _emitModelContentChangedFlushEvent(e: editorCommon.IModelContentChangedFlushEvent): void;
    static toRawText(rawText: string, opts: editorCommon.ITextModelCreationOptions): editorCommon.IRawText;
    protected _constructLines(rawText: editorCommon.IRawText): void;
    private _getEndOfLine(eol);
    private static _isMultilineRegexSource(searchString);
    static parseSearchRequest(searchString: string, isRegex: boolean, matchCase: boolean, wholeWord: boolean): RegExp;
    findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wholeWord: boolean, limitResultCount?: number): Range[];
    private _doFindMatchesMultiline(searchRange, searchRegex, limitResultCount);
    private _doFindMatchesLineByLine(searchRange, searchRegex, limitResultCount);
    findNextMatch(searchString: string, rawSearchStart: editorCommon.IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean): Range;
    private _doFindNextMatchMultiline(searchStart, searchRegex);
    private _doFindNextMatchLineByLine(searchStart, searchRegex);
    findPreviousMatch(searchString: string, rawSearchStart: editorCommon.IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean): Range;
    private _doFindPreviousMatchMultiline(searchStart, searchRegex);
    private _doFindPreviousMatchLineByLine(searchStart, searchRegex);
    private _findFirstMatchInLine(searchRegex, text, lineNumber, fromColumn);
    private _findLastMatchInLine(searchRegex, text, lineNumber);
    private _findMatchesInLine(searchRegex, text, lineNumber, deltaOffset, counter, result, limitResultCount);
}
export declare class RawText {
    static fromString(rawText: string, opts: editorCommon.ITextModelCreationOptions): editorCommon.IRawText;
    static fromStringWithModelOptions(rawText: string, model: editorCommon.IModel): editorCommon.IRawText;
}
