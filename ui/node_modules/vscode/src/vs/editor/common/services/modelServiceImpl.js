/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var network = require("vs/base/common/network");
var event_1 = require("vs/base/common/event");
var severity_1 = require("vs/base/common/severity");
var winjs_base_1 = require("vs/base/common/winjs.base");
var markers_1 = require("vs/platform/markers/common/markers");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var range_1 = require("vs/editor/common/core/range");
var editorCommon = require("vs/editor/common/editorCommon");
var model_1 = require("vs/editor/common/model/model");
var platform = require("vs/base/common/platform");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var defaultConfig_1 = require("vs/editor/common/config/defaultConfig");
var message_1 = require("vs/platform/message/common/message");
var modesRegistry_1 = require("vs/editor/common/modes/modesRegistry");
function MODEL_ID(resource) {
    return resource.toString();
}
var ModelData = (function () {
    function ModelData(model, eventsHandler) {
        var _this = this;
        this.model = model;
        this._markerDecorations = [];
        this._modelEventsListener = model.addBulkListener(function (events) { return eventsHandler(_this, events); });
    }
    ModelData.prototype.dispose = function () {
        this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, []);
        this._modelEventsListener.dispose();
        this._modelEventsListener = null;
        this.model = null;
    };
    ModelData.prototype.getModelId = function () {
        return MODEL_ID(this.model.uri);
    };
    ModelData.prototype.acceptMarkerDecorations = function (newDecorations) {
        this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, newDecorations);
    };
    return ModelData;
}());
var ModelMarkerHandler = (function () {
    function ModelMarkerHandler() {
    }
    ModelMarkerHandler.setMarkers = function (modelData, markerService) {
        var _this = this;
        // Limit to the first 500 errors/warnings
        var markers = markerService.read({ resource: modelData.model.uri, take: 500 });
        var newModelDecorations = markers.map(function (marker) {
            return {
                range: _this._createDecorationRange(modelData.model, marker),
                options: _this._createDecorationOption(marker)
            };
        });
        modelData.acceptMarkerDecorations(newModelDecorations);
    };
    ModelMarkerHandler._createDecorationRange = function (model, rawMarker) {
        var marker = model.validateRange(new range_1.Range(rawMarker.startLineNumber, rawMarker.startColumn, rawMarker.endLineNumber, rawMarker.endColumn));
        var ret = new range_1.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn);
        if (ret.isEmpty()) {
            var word = model.getWordAtPosition(ret.getStartPosition());
            if (word) {
                ret = new range_1.Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
            }
            else {
                var maxColumn = model.getLineLastNonWhitespaceColumn(marker.startLineNumber) ||
                    model.getLineMaxColumn(marker.startLineNumber);
                if (maxColumn === 1) {
                }
                else if (ret.endColumn >= maxColumn) {
                    // behind eol
                    ret = new range_1.Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);
                }
                else {
                    // extend marker to width = 1
                    ret = new range_1.Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);
                }
            }
        }
        else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
            var minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
            if (minColumn < ret.endColumn) {
                ret = new range_1.Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
                rawMarker.startColumn = minColumn;
            }
        }
        return ret;
    };
    ModelMarkerHandler._createDecorationOption = function (marker) {
        var className;
        var color;
        var darkColor;
        switch (marker.severity) {
            case severity_1.default.Ignore:
                // do something
                break;
            case severity_1.default.Warning:
            case severity_1.default.Info:
                className = editorCommon.ClassName.EditorWarningDecoration;
                color = 'rgba(18,136,18,0.7)';
                darkColor = 'rgba(18,136,18,0.7)';
                break;
            case severity_1.default.Error:
            default:
                className = editorCommon.ClassName.EditorErrorDecoration;
                color = 'rgba(255,18,18,0.7)';
                darkColor = 'rgba(255,18,18,0.7)';
                break;
        }
        var hoverMessage = null;
        var message = marker.message, source = marker.source;
        if (typeof message === 'string') {
            message = message.trim();
            if (source) {
                if (/\n/g.test(message)) {
                    message = nls.localize('diagAndSourceMultiline', "[{0}]\n{1}", source, message);
                }
                else {
                    message = nls.localize('diagAndSource', "[{0}] {1}", source, message);
                }
            }
            hoverMessage = [{ language: '_', value: message }];
        }
        return {
            stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: className,
            hoverMessage: hoverMessage,
            overviewRuler: {
                color: color,
                darkColor: darkColor,
                position: editorCommon.OverviewRulerLane.Right
            }
        };
    };
    return ModelMarkerHandler;
}());
var ModelServiceImpl = (function () {
    function ModelServiceImpl(markerService, configurationService, messageService) {
        var _this = this;
        this._modelCreationOptions = {
            tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
            insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
            detectIndentation: defaultConfig_1.DEFAULT_INDENTATION.detectIndentation,
            defaultEOL: (platform.isLinux || platform.isMacintosh) ? editorCommon.DefaultEndOfLine.LF : editorCommon.DefaultEndOfLine.CRLF,
            trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE
        };
        this._markerService = markerService;
        this._configurationService = configurationService;
        this._messageService = messageService;
        this._hasShownMigrationMessage = false;
        this._models = {};
        this._onModelAdded = new event_1.Emitter();
        this._onModelRemoved = new event_1.Emitter();
        this._onModelModeChanged = new event_1.Emitter();
        if (this._markerService) {
            this._markerServiceSubscription = this._markerService.onMarkerChanged(this._handleMarkerChange, this);
        }
        var readConfig = function (config) {
            var shouldShowMigrationMessage = false;
            var tabSize = defaultConfig_1.DEFAULT_INDENTATION.tabSize;
            if (config.editor && typeof config.editor.tabSize !== 'undefined') {
                var parsedTabSize = parseInt(config.editor.tabSize, 10);
                if (!isNaN(parsedTabSize)) {
                    tabSize = parsedTabSize;
                }
                shouldShowMigrationMessage = shouldShowMigrationMessage || (config.editor.tabSize === 'auto');
            }
            var insertSpaces = defaultConfig_1.DEFAULT_INDENTATION.insertSpaces;
            if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {
                insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));
                shouldShowMigrationMessage = shouldShowMigrationMessage || (config.editor.insertSpaces === 'auto');
            }
            var newDefaultEOL = _this._modelCreationOptions.defaultEOL;
            var eol = config.files && config.files.eol;
            if (eol === '\r\n') {
                newDefaultEOL = editorCommon.DefaultEndOfLine.CRLF;
            }
            else if (eol === '\n') {
                newDefaultEOL = editorCommon.DefaultEndOfLine.LF;
            }
            var trimAutoWhitespace = _this._modelCreationOptions.trimAutoWhitespace;
            if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {
                trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));
            }
            var detectIndentation = defaultConfig_1.DEFAULT_INDENTATION.detectIndentation;
            if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {
                detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));
            }
            _this._setModelOptions({
                tabSize: tabSize,
                insertSpaces: insertSpaces,
                detectIndentation: detectIndentation,
                defaultEOL: newDefaultEOL,
                trimAutoWhitespace: trimAutoWhitespace
            });
            if (shouldShowMigrationMessage && !_this._hasShownMigrationMessage) {
                _this._hasShownMigrationMessage = true;
                _this._messageService.show(severity_1.default.Info, nls.localize('indentAutoMigrate', "Please update your settings: `editor.detectIndentation` replaces `editor.tabSize`: \"auto\" or `editor.insertSpaces`: \"auto\""));
            }
        };
        this._configurationServiceSubscription = this._configurationService.onDidUpdateConfiguration(function (e) {
            readConfig(e.config);
        });
        readConfig(this._configurationService.getConfiguration());
    }
    ModelServiceImpl.prototype.getCreationOptions = function () {
        return this._modelCreationOptions;
    };
    ModelServiceImpl.prototype._setModelOptions = function (newOpts) {
        if ((this._modelCreationOptions.detectIndentation === newOpts.detectIndentation)
            && (this._modelCreationOptions.insertSpaces === newOpts.insertSpaces)
            && (this._modelCreationOptions.tabSize === newOpts.tabSize)
            && (this._modelCreationOptions.trimAutoWhitespace === newOpts.trimAutoWhitespace)) {
            // Same indent opts, no need to touch created models
            this._modelCreationOptions = newOpts;
            return;
        }
        this._modelCreationOptions = newOpts;
        // Update options on all models
        var keys = Object.keys(this._models);
        for (var i = 0, len = keys.length; i < len; i++) {
            var modelId = keys[i];
            var modelData = this._models[modelId];
            if (this._modelCreationOptions.detectIndentation) {
                modelData.model.detectIndentation(this._modelCreationOptions.insertSpaces, this._modelCreationOptions.tabSize);
                modelData.model.updateOptions({
                    trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                });
            }
            else {
                modelData.model.updateOptions({
                    insertSpaces: this._modelCreationOptions.insertSpaces,
                    tabSize: this._modelCreationOptions.tabSize,
                    trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                });
            }
        }
    };
    ModelServiceImpl.prototype.dispose = function () {
        if (this._markerServiceSubscription) {
            this._markerServiceSubscription.dispose();
        }
        this._configurationServiceSubscription.dispose();
    };
    ModelServiceImpl.prototype._handleMarkerChange = function (changedResources) {
        var _this = this;
        changedResources.forEach(function (resource) {
            var modelId = MODEL_ID(resource);
            var modelData = _this._models[modelId];
            if (!modelData) {
                return;
            }
            ModelMarkerHandler.setMarkers(modelData, _this._markerService);
        });
    };
    ModelServiceImpl.prototype._cleanUp = function (model) {
        var _this = this;
        // clean up markers for internal, transient models
        if (model.uri.scheme === network.Schemas.inMemory
            || model.uri.scheme === network.Schemas.internal
            || model.uri.scheme === network.Schemas.vscode) {
            if (this._markerService) {
                this._markerService.read({ resource: model.uri }).map(function (marker) { return marker.owner; }).forEach(function (owner) { return _this._markerService.remove(owner, [model.uri]); });
            }
        }
    };
    // --- begin IModelService
    ModelServiceImpl.prototype._createModelData = function (value, languageId, resource) {
        var _this = this;
        // create & save the model
        var model;
        if (typeof value === 'string') {
            model = model_1.Model.createFromString(value, this._modelCreationOptions, languageId, resource);
        }
        else {
            model = new model_1.Model(value, languageId, resource);
        }
        var modelId = MODEL_ID(model.uri);
        if (this._models[modelId]) {
            // There already exists a model with this id => this is a programmer error
            throw new Error('ModelService: Cannot add model ' + telemetry_1.anonymize(modelId) + ' because it already exists!');
        }
        var modelData = new ModelData(model, function (modelData, events) { return _this._onModelEvents(modelData, events); });
        this._models[modelId] = modelData;
        return modelData;
    };
    ModelServiceImpl.prototype.createModel = function (value, modeOrPromise, resource) {
        var modelData;
        if (!modeOrPromise || winjs_base_1.TPromise.is(modeOrPromise)) {
            modelData = this._createModelData(value, modesRegistry_1.PLAINTEXT_MODE_ID, resource);
            this.setMode(modelData.model, modeOrPromise);
        }
        else {
            modelData = this._createModelData(value, modeOrPromise.getId(), resource);
        }
        // handle markers (marker service => model)
        if (this._markerService) {
            ModelMarkerHandler.setMarkers(modelData, this._markerService);
        }
        this._onModelAdded.fire(modelData.model);
        return modelData.model;
    };
    ModelServiceImpl.prototype.setMode = function (model, modeOrPromise) {
        if (!modeOrPromise) {
            return;
        }
        if (winjs_base_1.TPromise.is(modeOrPromise)) {
            modeOrPromise.then(function (mode) {
                if (!model.isDisposed()) {
                    model.setMode(mode.getId());
                }
            });
        }
        else {
            model.setMode(modeOrPromise.getId());
        }
    };
    ModelServiceImpl.prototype.destroyModel = function (resource) {
        // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
        var modelData = this._models[MODEL_ID(resource)];
        if (!modelData) {
            return;
        }
        modelData.model.dispose();
    };
    ModelServiceImpl.prototype.getModels = function () {
        var ret = [];
        var keys = Object.keys(this._models);
        for (var i = 0, len = keys.length; i < len; i++) {
            var modelId = keys[i];
            ret.push(this._models[modelId].model);
        }
        return ret;
    };
    ModelServiceImpl.prototype.getModel = function (resource) {
        var modelId = MODEL_ID(resource);
        var modelData = this._models[modelId];
        if (!modelData) {
            return null;
        }
        return modelData.model;
    };
    Object.defineProperty(ModelServiceImpl.prototype, "onModelAdded", {
        get: function () {
            return this._onModelAdded ? this._onModelAdded.event : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelServiceImpl.prototype, "onModelRemoved", {
        get: function () {
            return this._onModelRemoved ? this._onModelRemoved.event : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModelServiceImpl.prototype, "onModelModeChanged", {
        get: function () {
            return this._onModelModeChanged ? this._onModelModeChanged.event : null;
        },
        enumerable: true,
        configurable: true
    });
    // --- end IModelService
    ModelServiceImpl.prototype._onModelDisposing = function (model) {
        var modelId = MODEL_ID(model.uri);
        var modelData = this._models[modelId];
        delete this._models[modelId];
        modelData.dispose();
        this._cleanUp(model);
        this._onModelRemoved.fire(model);
    };
    ModelServiceImpl.prototype._onModelEvents = function (modelData, events) {
        // First look for dispose
        for (var i = 0, len = events.length; i < len; i++) {
            var e = events[i];
            if (e.getType() === editorCommon.EventType.ModelDispose) {
                this._onModelDisposing(modelData.model);
                // no more processing since model got disposed
                return;
            }
        }
        // Second, look for mode change
        for (var i = 0, len = events.length; i < len; i++) {
            var e = events[i];
            if (e.getType() === editorCommon.EventType.ModelModeChanged) {
                this._onModelModeChanged.fire({
                    model: modelData.model,
                    oldModeId: e.getData().oldMode.getId()
                });
            }
        }
    };
    return ModelServiceImpl;
}());
ModelServiceImpl = __decorate([
    __param(0, markers_1.IMarkerService),
    __param(1, configuration_1.IConfigurationService),
    __param(2, message_1.IMessageService)
], ModelServiceImpl);
exports.ModelServiceImpl = ModelServiceImpl;
