/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls = require("vs/nls");
var strings = require("vs/base/common/strings");
var errors_1 = require("vs/base/common/errors");
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var lifecycle_1 = require("vs/base/common/lifecycle");
var replaceCommand_1 = require("vs/editor/common/commands/replaceCommand");
var cursorCollection_1 = require("vs/editor/common/controller/cursorCollection");
var oneCursor_1 = require("vs/editor/common/controller/oneCursor");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var editorCommon = require("vs/editor/common/editorCommon");
var cursorCommon_1 = require("vs/editor/common/controller/cursorCommon");
var languageConfigurationRegistry_1 = require("vs/editor/common/modes/languageConfigurationRegistry");
var cursorWordOperations_1 = require("vs/editor/common/controller/cursorWordOperations");
var cursorColumnSelection_1 = require("vs/editor/common/controller/cursorColumnSelection");
var cursorDeleteOperations_1 = require("vs/editor/common/controller/cursorDeleteOperations");
var cursorTypeOperations_1 = require("vs/editor/common/controller/cursorTypeOperations");
var RevealTarget;
(function (RevealTarget) {
    RevealTarget[RevealTarget["Primary"] = 0] = "Primary";
    RevealTarget[RevealTarget["TopMost"] = 1] = "TopMost";
    RevealTarget[RevealTarget["BottomMost"] = 2] = "BottomMost";
})(RevealTarget || (RevealTarget = {}));
var Cursor = (function (_super) {
    __extends(Cursor, _super);
    function Cursor(editorId, configuration, model, viewModelHelper, enableEmptySelectionClipboard) {
        var _this = _super.call(this, [
            editorCommon.EventType.CursorPositionChanged,
            editorCommon.EventType.CursorSelectionChanged,
            editorCommon.EventType.CursorRevealRange,
            editorCommon.EventType.CursorScrollRequest
        ]) || this;
        _this._columnSelectToLineNumber = 0;
        _this._columnSelectToVisualColumn = 0;
        _this.editorId = editorId;
        _this.configuration = configuration;
        _this.model = model;
        _this.viewModelHelper = viewModelHelper;
        _this.enableEmptySelectionClipboard = enableEmptySelectionClipboard;
        _this.cursors = new cursorCollection_1.CursorCollection(_this.editorId, _this.model, _this.configuration, _this.viewModelHelper);
        _this.cursorUndoStack = [];
        _this.typingListeners = {};
        _this._isHandling = false;
        _this.modelUnbinds = [];
        _this.modelUnbinds.push(_this.model.onDidChangeRawContent(function (e) {
            _this._onModelContentChanged(e);
        }));
        _this.modelUnbinds.push(_this.model.onDidChangeMode(function (e) {
            _this._onModelModeChanged();
        }));
        _this.modelUnbinds.push(languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange(function () {
            // TODO@Alex: react only if certain supports changed? (and if my model's mode changed)
            _this._onModelModeChanged();
        }));
        _this._handlers = {};
        _this._registerHandlers();
        return _this;
    }
    Cursor.prototype.dispose = function () {
        this.modelUnbinds = lifecycle_1.dispose(this.modelUnbinds);
        this.model = null;
        this.cursors.dispose();
        this.cursors = null;
        this.configuration = null;
        this.viewModelHelper = null;
        _super.prototype.dispose.call(this);
    };
    Cursor.prototype.saveState = function () {
        var selections = this.cursors.getSelections(), result = [], selection;
        for (var i = 0; i < selections.length; i++) {
            selection = selections[i];
            result.push({
                inSelectionMode: !selection.isEmpty(),
                selectionStart: {
                    lineNumber: selection.selectionStartLineNumber,
                    column: selection.selectionStartColumn,
                },
                position: {
                    lineNumber: selection.positionLineNumber,
                    column: selection.positionColumn,
                }
            });
        }
        return result;
    };
    Cursor.prototype.restoreState = function (states) {
        var _this = this;
        var desiredSelections = [], state;
        for (var i = 0; i < states.length; i++) {
            state = states[i];
            var positionLineNumber = 1, positionColumn = 1;
            // Avoid missing properties on the literal
            if (state.position && state.position.lineNumber) {
                positionLineNumber = state.position.lineNumber;
            }
            if (state.position && state.position.column) {
                positionColumn = state.position.column;
            }
            var selectionStartLineNumber = positionLineNumber, selectionStartColumn = positionColumn;
            // Avoid missing properties on the literal
            if (state.selectionStart && state.selectionStart.lineNumber) {
                selectionStartLineNumber = state.selectionStart.lineNumber;
            }
            if (state.selectionStart && state.selectionStart.column) {
                selectionStartColumn = state.selectionStart.column;
            }
            desiredSelections.push({
                selectionStartLineNumber: selectionStartLineNumber,
                selectionStartColumn: selectionStartColumn,
                positionLineNumber: positionLineNumber,
                positionColumn: positionColumn
            });
        }
        this._onHandler('restoreState', function (ctx) {
            _this.cursors.setSelections(desiredSelections);
            return false;
        }, 'restoreState', null);
    };
    Cursor.prototype.addTypingListener = function (character, callback) {
        if (!this.typingListeners.hasOwnProperty(character)) {
            this.typingListeners[character] = [];
        }
        this.typingListeners[character].push(callback);
    };
    Cursor.prototype.removeTypingListener = function (character, callback) {
        if (this.typingListeners.hasOwnProperty(character)) {
            var listeners = this.typingListeners[character];
            for (var i = 0; i < listeners.length; i++) {
                if (listeners[i] === callback) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        }
    };
    Cursor.prototype._onModelModeChanged = function () {
        // the mode of this model has changed
        this.cursors.updateMode();
    };
    Cursor.prototype._onModelContentChanged = function (e) {
        var _this = this;
        if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
            // a model.setValue() was called
            this.cursors.dispose();
            this.cursors = new cursorCollection_1.CursorCollection(this.editorId, this.model, this.configuration, this.viewModelHelper);
            this.emitCursorPositionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
            this.emitCursorSelectionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
        }
        else {
            if (!this._isHandling) {
                // Read the markers before entering `_onHandler`, since that would validate
                // the position and ruin the markers
                var selections_1 = this.cursors.getAll().map(function (cursor) {
                    return cursor.beginRecoverSelectionFromMarkers();
                });
                this._onHandler('recoverSelectionFromMarkers', function (ctx) {
                    var result = _this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor.endRecoverSelectionFromMarkers(oneCtx, selections_1[cursorIndex]); });
                    ctx.shouldPushStackElementBefore = false;
                    ctx.shouldPushStackElementAfter = false;
                    return result;
                }, 'modelChange', null);
            }
        }
    };
    // ------ some getters/setters
    Cursor.prototype.getSelection = function () {
        return this.cursors.getSelection(0);
    };
    Cursor.prototype.getSelections = function () {
        return this.cursors.getSelections();
    };
    Cursor.prototype.getPosition = function () {
        return this.cursors.getPosition(0);
    };
    Cursor.prototype.setSelections = function (source, selections) {
        var _this = this;
        this._onHandler('setSelections', function (ctx) {
            ctx.shouldReveal = false;
            _this.cursors.setSelections(selections);
            return false;
        }, source, null);
    };
    // ------ auxiliary handling logic
    Cursor.prototype._createAndInterpretHandlerCtx = function (eventSource, eventData, callback) {
        var currentHandlerCtx = {
            cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
            shouldReveal: true,
            shouldRevealVerticalInCenter: false,
            shouldRevealHorizontal: true,
            shouldRevealTarget: 0 /* Primary */,
            eventSource: eventSource,
            eventData: eventData,
            executeCommands: [],
            isAutoWhitespaceCommand: [],
            hasExecutedCommands: false,
            isCursorUndo: false,
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false,
            setColumnSelectToLineNumber: 0,
            setColumnSelectToVisualColumn: 0
        };
        callback(currentHandlerCtx);
        this._interpretHandlerContext(currentHandlerCtx);
        this.cursors.normalize();
        return currentHandlerCtx.hasExecutedCommands;
    };
    Cursor.prototype._onHandler = function (command, handler, source, data) {
        this._isHandling = true;
        this.charactersTyped = '';
        var handled = false;
        try {
            var oldSelections = this.cursors.getSelections();
            var oldViewSelections = this.cursors.getViewSelections();
            // ensure valid state on all cursors
            this.cursors.ensureValidState();
            var prevCursorsState = this.cursors.saveState();
            var eventSource = source;
            var cursorPositionChangeReason;
            var shouldReveal;
            var shouldRevealVerticalInCenter;
            var shouldRevealHorizontal;
            var shouldRevealTarget;
            var isCursorUndo;
            var hasExecutedCommands = this._createAndInterpretHandlerCtx(eventSource, data, function (currentHandlerCtx) {
                handled = handler(currentHandlerCtx);
                cursorPositionChangeReason = currentHandlerCtx.cursorPositionChangeReason;
                shouldReveal = currentHandlerCtx.shouldReveal;
                shouldRevealTarget = currentHandlerCtx.shouldRevealTarget;
                shouldRevealVerticalInCenter = currentHandlerCtx.shouldRevealVerticalInCenter;
                shouldRevealHorizontal = currentHandlerCtx.shouldRevealHorizontal;
                isCursorUndo = currentHandlerCtx.isCursorUndo;
            });
            if (hasExecutedCommands) {
                this.cursorUndoStack = [];
            }
            // Ping typing listeners after the model emits events & after I emit events
            for (var i = 0; i < this.charactersTyped.length; i++) {
                var chr = this.charactersTyped.charAt(i);
                if (this.typingListeners.hasOwnProperty(chr)) {
                    var listeners = this.typingListeners[chr].slice(0);
                    for (var j = 0, lenJ = listeners.length; j < lenJ; j++) {
                        // Hoping that listeners understand that the view might be in an awkward state
                        try {
                            listeners[j]();
                        }
                        catch (e) {
                            errors_1.onUnexpectedError(e);
                        }
                    }
                }
            }
            var newSelections = this.cursors.getSelections();
            var newViewSelections = this.cursors.getViewSelections();
            var somethingChanged = false;
            if (oldSelections.length !== newSelections.length) {
                somethingChanged = true;
            }
            else {
                for (var i = 0, len = oldSelections.length; !somethingChanged && i < len; i++) {
                    if (!oldSelections[i].equalsSelection(newSelections[i])) {
                        somethingChanged = true;
                    }
                }
                for (var i = 0, len = oldViewSelections.length; !somethingChanged && i < len; i++) {
                    if (!oldViewSelections[i].equalsSelection(newViewSelections[i])) {
                        somethingChanged = true;
                    }
                }
            }
            if (somethingChanged) {
                if (!hasExecutedCommands && !isCursorUndo) {
                    this.cursorUndoStack.push(prevCursorsState);
                }
                if (this.cursorUndoStack.length > 50) {
                    this.cursorUndoStack = this.cursorUndoStack.splice(0, this.cursorUndoStack.length - 50);
                }
                this.emitCursorPositionChanged(eventSource, cursorPositionChangeReason);
                if (shouldReveal) {
                    this.revealRange(shouldRevealTarget, shouldRevealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, shouldRevealHorizontal);
                }
                this.emitCursorSelectionChanged(eventSource, cursorPositionChangeReason);
            }
        }
        catch (err) {
            errors_1.onUnexpectedError(err);
        }
        this._isHandling = false;
        return handled;
    };
    Cursor.prototype._interpretHandlerContext = function (ctx) {
        if (ctx.shouldPushStackElementBefore) {
            this.model.pushStackElement();
            ctx.shouldPushStackElementBefore = false;
        }
        this._columnSelectToLineNumber = ctx.setColumnSelectToLineNumber;
        this._columnSelectToVisualColumn = ctx.setColumnSelectToVisualColumn;
        ctx.hasExecutedCommands = this._internalExecuteCommands(ctx.executeCommands, ctx.isAutoWhitespaceCommand) || ctx.hasExecutedCommands;
        ctx.executeCommands = [];
        if (ctx.shouldPushStackElementAfter) {
            this.model.pushStackElement();
            ctx.shouldPushStackElementAfter = false;
        }
    };
    Cursor.prototype._interpretCommandResult = function (cursorState) {
        if (!cursorState) {
            return false;
        }
        this.cursors.setSelections(cursorState);
        return true;
    };
    Cursor.prototype._getEditOperationsFromCommand = function (ctx, majorIdentifier, command, isAutoWhitespaceCommand) {
        var _this = this;
        // This method acts as a transaction, if the command fails
        // everything it has done is ignored
        var operations = [], operationMinor = 0;
        var addEditOperation = function (selection, text) {
            if (selection.isEmpty() && text === '') {
                // This command wants to add a no-op => no thank you
                return;
            }
            operations.push({
                identifier: {
                    major: majorIdentifier,
                    minor: operationMinor++
                },
                range: selection,
                text: text,
                forceMoveMarkers: false,
                isAutoWhitespaceEdit: isAutoWhitespaceCommand
            });
        };
        var hadTrackedRange = false;
        var trackSelection = function (selection, trackPreviousOnEmpty) {
            var selectionMarkerStickToPreviousCharacter, positionMarkerStickToPreviousCharacter;
            if (selection.isEmpty()) {
                // Try to lock it with surrounding text
                if (typeof trackPreviousOnEmpty === 'boolean') {
                    selectionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                    positionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                }
                else {
                    var maxLineColumn = _this.model.getLineMaxColumn(selection.startLineNumber);
                    if (selection.startColumn === maxLineColumn) {
                        selectionMarkerStickToPreviousCharacter = true;
                        positionMarkerStickToPreviousCharacter = true;
                    }
                    else {
                        selectionMarkerStickToPreviousCharacter = false;
                        positionMarkerStickToPreviousCharacter = false;
                    }
                }
            }
            else {
                if (selection.getDirection() === selection_1.SelectionDirection.LTR) {
                    selectionMarkerStickToPreviousCharacter = false;
                    positionMarkerStickToPreviousCharacter = true;
                }
                else {
                    selectionMarkerStickToPreviousCharacter = true;
                    positionMarkerStickToPreviousCharacter = false;
                }
            }
            var l = ctx.selectionStartMarkers.length;
            ctx.selectionStartMarkers[l] = _this.model._addMarker(0, selection.selectionStartLineNumber, selection.selectionStartColumn, selectionMarkerStickToPreviousCharacter);
            ctx.positionMarkers[l] = _this.model._addMarker(0, selection.positionLineNumber, selection.positionColumn, positionMarkerStickToPreviousCharacter);
            return l.toString();
        };
        var editOperationBuilder = {
            addEditOperation: addEditOperation,
            trackSelection: trackSelection
        };
        try {
            command.getEditOperations(this.model, editOperationBuilder);
        }
        catch (e) {
            e.friendlyMessage = nls.localize('corrupt.commands', "Unexpected exception while executing command.");
            errors_1.onUnexpectedError(e);
            return {
                operations: [],
                hadTrackedRange: false
            };
        }
        return {
            operations: operations,
            hadTrackedRange: hadTrackedRange
        };
    };
    Cursor.prototype._getEditOperations = function (ctx, commands, isAutoWhitespaceCommand) {
        var oneResult;
        var operations = [];
        var hadTrackedRanges = [];
        var anyoneHadTrackedRange;
        for (var i = 0; i < commands.length; i++) {
            if (commands[i]) {
                oneResult = this._getEditOperationsFromCommand(ctx, i, commands[i], isAutoWhitespaceCommand[i]);
                operations = operations.concat(oneResult.operations);
                hadTrackedRanges[i] = oneResult.hadTrackedRange;
                anyoneHadTrackedRange = anyoneHadTrackedRange || hadTrackedRanges[i];
            }
            else {
                hadTrackedRanges[i] = false;
            }
        }
        return {
            operations: operations,
            hadTrackedRanges: hadTrackedRanges,
            anyoneHadTrackedRange: anyoneHadTrackedRange
        };
    };
    Cursor.prototype._getLoserCursorMap = function (operations) {
        // This is destructive on the array
        operations = operations.slice(0);
        // Sort operations with last one first
        operations.sort(function (a, b) {
            // Note the minus!
            return -(range_1.Range.compareRangesUsingEnds(a.range, b.range));
        });
        // Operations can not overlap!
        var loserCursorsMap = {};
        var previousOp;
        var currentOp;
        var loserMajor;
        for (var i = 1; i < operations.length; i++) {
            previousOp = operations[i - 1];
            currentOp = operations[i];
            if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {
                if (previousOp.identifier.major > currentOp.identifier.major) {
                    // previousOp loses the battle
                    loserMajor = previousOp.identifier.major;
                }
                else {
                    loserMajor = currentOp.identifier.major;
                }
                loserCursorsMap[loserMajor.toString()] = true;
                for (var j = 0; j < operations.length; j++) {
                    if (operations[j].identifier.major === loserMajor) {
                        operations.splice(j, 1);
                        if (j < i) {
                            i--;
                        }
                        j--;
                    }
                }
                if (i > 0) {
                    i--;
                }
            }
        }
        return loserCursorsMap;
    };
    Cursor.prototype._collapseDeleteCommands = function (rawCmds, isAutoWhitespaceCommand) {
        if (rawCmds.length === 1) {
            return;
        }
        // Merge adjacent delete commands
        var allAreDeleteCommands = rawCmds.every(function (command) {
            if (!(command instanceof replaceCommand_1.ReplaceCommand)) {
                return false;
            }
            var replCmd = command;
            if (replCmd.getText().length > 0) {
                return false;
            }
            return true;
        });
        if (!allAreDeleteCommands) {
            return;
        }
        var commands = rawCmds;
        var cursors = commands.map(function (cmd, i) {
            return {
                range: commands[i].getRange(),
                order: i
            };
        });
        cursors.sort(function (a, b) {
            return range_1.Range.compareRangesUsingStarts(a.range, b.range);
        });
        var previousCursor = cursors[0];
        for (var i = 1; i < cursors.length; i++) {
            if (previousCursor.range.endLineNumber === cursors[i].range.startLineNumber && previousCursor.range.endColumn === cursors[i].range.startColumn) {
                // Merge ranges
                var mergedRange = new range_1.Range(previousCursor.range.startLineNumber, previousCursor.range.startColumn, cursors[i].range.endLineNumber, cursors[i].range.endColumn);
                previousCursor.range = mergedRange;
                commands[cursors[i].order].setRange(mergedRange);
                commands[previousCursor.order].setRange(mergedRange);
            }
            else {
                // Push previous cursor
                previousCursor = cursors[i];
            }
        }
    };
    Cursor.prototype._internalExecuteCommands = function (commands, isAutoWhitespaceCommand) {
        var ctx = {
            selectionStartMarkers: [],
            positionMarkers: []
        };
        this._collapseDeleteCommands(commands, isAutoWhitespaceCommand);
        var r = this._innerExecuteCommands(ctx, commands, isAutoWhitespaceCommand);
        for (var i = 0; i < ctx.selectionStartMarkers.length; i++) {
            this.model._removeMarker(ctx.selectionStartMarkers[i]);
            this.model._removeMarker(ctx.positionMarkers[i]);
        }
        return r;
    };
    Cursor.prototype._arrayIsEmpty = function (commands) {
        var i, len;
        for (i = 0, len = commands.length; i < len; i++) {
            if (commands[i]) {
                return false;
            }
        }
        return true;
    };
    Cursor.prototype._innerExecuteCommands = function (ctx, commands, isAutoWhitespaceCommand) {
        var _this = this;
        if (this.configuration.editor.readOnly) {
            return false;
        }
        if (this._arrayIsEmpty(commands)) {
            return false;
        }
        var selectionsBefore = this.cursors.getSelections();
        var commandsData = this._getEditOperations(ctx, commands, isAutoWhitespaceCommand);
        if (commandsData.operations.length === 0 && !commandsData.anyoneHadTrackedRange) {
            return false;
        }
        var rawOperations = commandsData.operations;
        var editableRange = this.model.getEditableRange();
        var editableRangeStart = editableRange.getStartPosition();
        var editableRangeEnd = editableRange.getEndPosition();
        for (var i = 0; i < rawOperations.length; i++) {
            var operationRange = rawOperations[i].range;
            if (!editableRangeStart.isBeforeOrEqual(operationRange.getStartPosition()) || !operationRange.getEndPosition().isBeforeOrEqual(editableRangeEnd)) {
                // These commands are outside of the editable range
                return false;
            }
        }
        var loserCursorsMap = this._getLoserCursorMap(rawOperations);
        if (loserCursorsMap.hasOwnProperty('0')) {
            // These commands are very messed up
            console.warn('Ignoring commands');
            return false;
        }
        // Remove operations belonging to losing cursors
        var filteredOperations = [];
        for (var i = 0; i < rawOperations.length; i++) {
            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {
                filteredOperations.push(rawOperations[i]);
            }
        }
        var selectionsAfter = this.model.pushEditOperations(selectionsBefore, filteredOperations, function (inverseEditOperations) {
            var groupedInverseEditOperations = [];
            for (var i = 0; i < selectionsBefore.length; i++) {
                groupedInverseEditOperations[i] = [];
            }
            for (var i = 0; i < inverseEditOperations.length; i++) {
                var op = inverseEditOperations[i];
                if (!op.identifier) {
                    // perhaps auto whitespace trim edits
                    continue;
                }
                groupedInverseEditOperations[op.identifier.major].push(op);
            }
            var minorBasedSorter = function (a, b) {
                return a.identifier.minor - b.identifier.minor;
            };
            var cursorSelections = [];
            for (var i = 0; i < selectionsBefore.length; i++) {
                if (groupedInverseEditOperations[i].length > 0 || commandsData.hadTrackedRanges[i]) {
                    groupedInverseEditOperations[i].sort(minorBasedSorter);
                    cursorSelections[i] = commands[i].computeCursorState(_this.model, {
                        getInverseEditOperations: function () {
                            return groupedInverseEditOperations[i];
                        },
                        getTrackedSelection: function (id) {
                            var idx = parseInt(id, 10);
                            var selectionStartMarker = _this.model._getMarker(ctx.selectionStartMarkers[idx]);
                            var positionMarker = _this.model._getMarker(ctx.positionMarkers[idx]);
                            return new selection_1.Selection(selectionStartMarker.lineNumber, selectionStartMarker.column, positionMarker.lineNumber, positionMarker.column);
                        }
                    });
                }
                else {
                    cursorSelections[i] = selectionsBefore[i];
                }
            }
            return cursorSelections;
        });
        // Extract losing cursors
        var losingCursorIndex;
        var losingCursors = [];
        for (losingCursorIndex in loserCursorsMap) {
            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {
                losingCursors.push(parseInt(losingCursorIndex, 10));
            }
        }
        // Sort losing cursors descending
        losingCursors.sort(function (a, b) {
            return b - a;
        });
        // Remove losing cursors
        for (var i = 0; i < losingCursors.length; i++) {
            selectionsAfter.splice(losingCursors[i], 1);
        }
        return this._interpretCommandResult(selectionsAfter);
    };
    // -----------------------------------------------------------------------------------------------------------
    // ----- emitting events
    Cursor.prototype.emitCursorPositionChanged = function (source, reason) {
        var positions = this.cursors.getPositions();
        var primaryPosition = positions[0];
        var secondaryPositions = positions.slice(1);
        var viewPositions = this.cursors.getViewPositions();
        var primaryViewPosition = viewPositions[0];
        var secondaryViewPositions = viewPositions.slice(1);
        var isInEditableRange = true;
        if (this.model.hasEditableRange()) {
            var editableRange = this.model.getEditableRange();
            if (!editableRange.containsPosition(primaryPosition)) {
                isInEditableRange = false;
            }
        }
        var e = {
            position: primaryPosition,
            viewPosition: primaryViewPosition,
            secondaryPositions: secondaryPositions,
            secondaryViewPositions: secondaryViewPositions,
            reason: reason,
            source: source,
            isInEditableRange: isInEditableRange
        };
        this.emit(editorCommon.EventType.CursorPositionChanged, e);
    };
    Cursor.prototype.emitCursorSelectionChanged = function (source, reason) {
        var selections = this.cursors.getSelections();
        var primarySelection = selections[0];
        var secondarySelections = selections.slice(1);
        var viewSelections = this.cursors.getViewSelections();
        var primaryViewSelection = viewSelections[0];
        var secondaryViewSelections = viewSelections.slice(1);
        var e = {
            selection: primarySelection,
            viewSelection: primaryViewSelection,
            secondarySelections: secondarySelections,
            secondaryViewSelections: secondaryViewSelections,
            source: source,
            reason: reason
        };
        this.emit(editorCommon.EventType.CursorSelectionChanged, e);
    };
    Cursor.prototype.emitCursorScrollRequest = function (deltaLines, revealCursor) {
        var e = {
            deltaLines: deltaLines,
            revealCursor: revealCursor
        };
        this.emit(editorCommon.EventType.CursorScrollRequest, e);
    };
    Cursor.prototype.revealRange = function (revealTarget, verticalType, revealHorizontal) {
        var positions = this.cursors.getPositions();
        var viewPositions = this.cursors.getViewPositions();
        var position = positions[0];
        var viewPosition = viewPositions[0];
        if (revealTarget === 1 /* TopMost */) {
            for (var i = 1; i < positions.length; i++) {
                if (positions[i].isBefore(position)) {
                    position = positions[i];
                    viewPosition = viewPositions[i];
                }
            }
        }
        else if (revealTarget === 2 /* BottomMost */) {
            for (var i = 1; i < positions.length; i++) {
                if (position.isBeforeOrEqual(positions[i])) {
                    position = positions[i];
                    viewPosition = viewPositions[i];
                }
            }
        }
        else {
            if (positions.length > 1) {
                // no revealing!
                return;
            }
        }
        var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
        var viewRange = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
        this.emitCursorRevealRange(range, viewRange, verticalType, revealHorizontal, false);
    };
    Cursor.prototype.emitCursorRevealRange = function (range, viewRange, verticalType, revealHorizontal, revealCursor) {
        var e = {
            range: range,
            viewRange: viewRange,
            verticalType: verticalType,
            revealHorizontal: revealHorizontal,
            revealCursor: revealCursor
        };
        this.emit(editorCommon.EventType.CursorRevealRange, e);
    };
    // -----------------------------------------------------------------------------------------------------------
    // ----- handlers beyond this point
    Cursor.prototype.trigger = function (source, handlerId, payload) {
        if (!this._handlers.hasOwnProperty(handlerId)) {
            return;
        }
        var handler = this._handlers[handlerId];
        this._onHandler(handlerId, handler, source, payload);
    };
    Cursor.prototype._registerHandlers = function () {
        var _this = this;
        var H = editorCommon.Handler;
        this._handlers[H.JumpToBracket] = function (ctx) { return _this._jumpToBracket(ctx); };
        this._handlers[H.CursorMove] = function (ctx) { return _this._cursorMove(ctx); };
        this._handlers[H.MoveTo] = function (ctx) { return _this._moveTo(false, ctx); };
        this._handlers[H.MoveToSelect] = function (ctx) { return _this._moveTo(true, ctx); };
        this._handlers[H.ColumnSelect] = function (ctx) { return _this._columnSelectMouse(ctx); };
        this._handlers[H.AddCursorUp] = function (ctx) { return _this._addCursorUp(ctx); };
        this._handlers[H.AddCursorDown] = function (ctx) { return _this._addCursorDown(ctx); };
        this._handlers[H.CreateCursor] = function (ctx) { return _this._createCursor(ctx); };
        this._handlers[H.LastCursorMoveToSelect] = function (ctx) { return _this._lastCursorMoveTo(ctx); };
        this._handlers[H.CursorLeft] = function (ctx) { return _this._moveLeft(false, ctx); };
        this._handlers[H.CursorLeftSelect] = function (ctx) { return _this._moveLeft(true, ctx); };
        this._handlers[H.CursorWordLeft] = function (ctx) { return _this._moveWordLeft(false, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordStartLeft] = function (ctx) { return _this._moveWordLeft(false, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordEndLeft] = function (ctx) { return _this._moveWordLeft(false, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorWordLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordStartLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordEndLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorRight] = function (ctx) { return _this._moveRight(false, ctx); };
        this._handlers[H.CursorRightSelect] = function (ctx) { return _this._moveRight(true, ctx); };
        this._handlers[H.CursorWordRight] = function (ctx) { return _this._moveWordRight(false, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorWordStartRight] = function (ctx) { return _this._moveWordRight(false, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordEndRight] = function (ctx) { return _this._moveWordRight(false, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorWordRightSelect] = function (ctx) { return _this._moveWordRight(true, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorWordStartRightSelect] = function (ctx) { return _this._moveWordRight(true, 0 /* WordStart */, ctx); };
        this._handlers[H.CursorWordEndRightSelect] = function (ctx) { return _this._moveWordRight(true, 1 /* WordEnd */, ctx); };
        this._handlers[H.CursorUp] = function (ctx) { return _this._moveUp(false, false, ctx); };
        this._handlers[H.CursorUpSelect] = function (ctx) { return _this._moveUp(true, false, ctx); };
        this._handlers[H.CursorDown] = function (ctx) { return _this._moveDown(false, false, ctx); };
        this._handlers[H.CursorDownSelect] = function (ctx) { return _this._moveDown(true, false, ctx); };
        this._handlers[H.CursorPageUp] = function (ctx) { return _this._moveUp(false, true, ctx); };
        this._handlers[H.CursorPageUpSelect] = function (ctx) { return _this._moveUp(true, true, ctx); };
        this._handlers[H.CursorPageDown] = function (ctx) { return _this._moveDown(false, true, ctx); };
        this._handlers[H.CursorPageDownSelect] = function (ctx) { return _this._moveDown(true, true, ctx); };
        this._handlers[H.CursorHome] = function (ctx) { return _this._moveToBeginningOfLine(false, ctx); };
        this._handlers[H.CursorHomeSelect] = function (ctx) { return _this._moveToBeginningOfLine(true, ctx); };
        this._handlers[H.CursorEnd] = function (ctx) { return _this._moveToEndOfLine(false, ctx); };
        this._handlers[H.CursorEndSelect] = function (ctx) { return _this._moveToEndOfLine(true, ctx); };
        this._handlers[H.CursorTop] = function (ctx) { return _this._moveToBeginningOfBuffer(false, ctx); };
        this._handlers[H.CursorTopSelect] = function (ctx) { return _this._moveToBeginningOfBuffer(true, ctx); };
        this._handlers[H.CursorBottom] = function (ctx) { return _this._moveToEndOfBuffer(false, ctx); };
        this._handlers[H.CursorBottomSelect] = function (ctx) { return _this._moveToEndOfBuffer(true, ctx); };
        this._handlers[H.CursorColumnSelectLeft] = function (ctx) { return _this._columnSelectLeft(ctx); };
        this._handlers[H.CursorColumnSelectRight] = function (ctx) { return _this._columnSelectRight(ctx); };
        this._handlers[H.CursorColumnSelectUp] = function (ctx) { return _this._columnSelectUp(false, ctx); };
        this._handlers[H.CursorColumnSelectPageUp] = function (ctx) { return _this._columnSelectUp(true, ctx); };
        this._handlers[H.CursorColumnSelectDown] = function (ctx) { return _this._columnSelectDown(false, ctx); };
        this._handlers[H.CursorColumnSelectPageDown] = function (ctx) { return _this._columnSelectDown(true, ctx); };
        this._handlers[H.SelectAll] = function (ctx) { return _this._selectAll(ctx); };
        this._handlers[H.LineSelect] = function (ctx) { return _this._line(false, ctx); };
        this._handlers[H.LineSelectDrag] = function (ctx) { return _this._line(true, ctx); };
        this._handlers[H.LastCursorLineSelect] = function (ctx) { return _this._lastCursorLine(false, ctx); };
        this._handlers[H.LastCursorLineSelectDrag] = function (ctx) { return _this._lastCursorLine(true, ctx); };
        this._handlers[H.LineInsertBefore] = function (ctx) { return _this._lineInsertBefore(ctx); };
        this._handlers[H.LineInsertAfter] = function (ctx) { return _this._lineInsertAfter(ctx); };
        this._handlers[H.LineBreakInsert] = function (ctx) { return _this._lineBreakInsert(ctx); };
        this._handlers[H.WordSelect] = function (ctx) { return _this._word(false, ctx); };
        this._handlers[H.WordSelectDrag] = function (ctx) { return _this._word(true, ctx); };
        this._handlers[H.LastCursorWordSelect] = function (ctx) { return _this._lastCursorWord(ctx); };
        this._handlers[H.CancelSelection] = function (ctx) { return _this._cancelSelection(ctx); };
        this._handlers[H.RemoveSecondaryCursors] = function (ctx) { return _this._removeSecondaryCursors(ctx); };
        this._handlers[H.Type] = function (ctx) { return _this._type(ctx); };
        this._handlers[H.ReplacePreviousChar] = function (ctx) { return _this._replacePreviousChar(ctx); };
        this._handlers[H.Tab] = function (ctx) { return _this._tab(ctx); };
        this._handlers[H.Indent] = function (ctx) { return _this._indent(ctx); };
        this._handlers[H.Outdent] = function (ctx) { return _this._outdent(ctx); };
        this._handlers[H.Paste] = function (ctx) { return _this._paste(ctx); };
        this._handlers[H.EditorScroll] = function (ctx) { return _this._editorScroll(ctx); };
        this._handlers[H.ScrollLineUp] = function (ctx) { return _this._scrollUp(false, ctx); };
        this._handlers[H.ScrollLineDown] = function (ctx) { return _this._scrollDown(false, ctx); };
        this._handlers[H.ScrollPageUp] = function (ctx) { return _this._scrollUp(true, ctx); };
        this._handlers[H.ScrollPageDown] = function (ctx) { return _this._scrollDown(true, ctx); };
        this._handlers[H.DeleteLeft] = function (ctx) { return _this._deleteLeft(ctx); };
        this._handlers[H.DeleteWordLeft] = function (ctx) { return _this._deleteWordLeft(true, 0 /* WordStart */, ctx); };
        this._handlers[H.DeleteWordStartLeft] = function (ctx) { return _this._deleteWordLeft(false, 0 /* WordStart */, ctx); };
        this._handlers[H.DeleteWordEndLeft] = function (ctx) { return _this._deleteWordLeft(false, 1 /* WordEnd */, ctx); };
        this._handlers[H.DeleteRight] = function (ctx) { return _this._deleteRight(ctx); };
        this._handlers[H.DeleteWordRight] = function (ctx) { return _this._deleteWordRight(true, 1 /* WordEnd */, ctx); };
        this._handlers[H.DeleteWordStartRight] = function (ctx) { return _this._deleteWordRight(false, 0 /* WordStart */, ctx); };
        this._handlers[H.DeleteWordEndRight] = function (ctx) { return _this._deleteWordRight(false, 1 /* WordEnd */, ctx); };
        this._handlers[H.DeleteAllRight] = function (ctx) { return _this._deleteAllRight(ctx); };
        this._handlers[H.Cut] = function (ctx) { return _this._cut(ctx); };
        this._handlers[H.ExpandLineSelection] = function (ctx) { return _this._expandLineSelection(ctx); };
        this._handlers[H.Undo] = function (ctx) { return _this._undo(ctx); };
        this._handlers[H.CursorUndo] = function (ctx) { return _this._cursorUndo(ctx); };
        this._handlers[H.Redo] = function (ctx) { return _this._redo(ctx); };
        this._handlers[H.ExecuteCommand] = function (ctx) { return _this._externalExecuteCommand(ctx); };
        this._handlers[H.ExecuteCommands] = function (ctx) { return _this._externalExecuteCommands(ctx); };
        this._handlers[H.RevealLine] = function (ctx) { return _this._revealLine(ctx); };
    };
    Cursor.prototype._invokeForAllSorted = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
        if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
        if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
        return this._doInvokeForAll(ctx, true, callable, pushStackElementBefore, pushStackElementAfter);
    };
    Cursor.prototype._invokeForAll = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
        if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
        if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
        return this._doInvokeForAll(ctx, false, callable, pushStackElementBefore, pushStackElementAfter);
    };
    Cursor.prototype._doInvokeForAll = function (ctx, sorted, callable, pushStackElementBefore, pushStackElementAfter) {
        if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
        if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
        var result = false;
        var cursors = this.cursors.getAll();
        if (sorted) {
            cursors = cursors.sort(function (a, b) {
                return range_1.Range.compareRangesUsingStarts(a.modelState.selection, b.modelState.selection);
            });
        }
        var context;
        ctx.shouldPushStackElementBefore = pushStackElementBefore;
        ctx.shouldPushStackElementAfter = pushStackElementAfter;
        for (var i = 0; i < cursors.length; i++) {
            context = {
                cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
                shouldReveal: true,
                shouldRevealVerticalInCenter: false,
                shouldRevealHorizontal: true,
                executeCommand: null,
                isAutoWhitespaceCommand: false,
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false
            };
            result = callable(i, cursors[i], context) || result;
            if (i === 0) {
                ctx.cursorPositionChangeReason = context.cursorPositionChangeReason;
                ctx.shouldRevealHorizontal = context.shouldRevealHorizontal;
                ctx.shouldReveal = context.shouldReveal;
                ctx.shouldRevealVerticalInCenter = context.shouldRevealVerticalInCenter;
            }
            ctx.shouldPushStackElementBefore = ctx.shouldPushStackElementBefore || context.shouldPushStackElementBefore;
            ctx.shouldPushStackElementAfter = ctx.shouldPushStackElementAfter || context.shouldPushStackElementAfter;
            ctx.executeCommands[i] = context.executeCommand;
            ctx.isAutoWhitespaceCommand[i] = context.isAutoWhitespaceCommand;
        }
        return result;
    };
    Cursor.prototype._jumpToBracket = function (ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.jumpToBracket(oneCursor, oneCtx); });
    };
    Cursor.prototype._moveTo = function (inSelectionMode, ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveTo(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx); });
    };
    Cursor.prototype._cursorMove = function (ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.move(oneCursor, ctx.eventData, ctx.eventSource, oneCtx); });
    };
    Cursor.prototype._getColumnSelectToLineNumber = function () {
        if (!this._columnSelectToLineNumber) {
            var primaryCursor = this.cursors.getAll()[0];
            var primaryPos = primaryCursor.viewState.position;
            return primaryPos.lineNumber;
        }
        return this._columnSelectToLineNumber;
    };
    Cursor.prototype._getColumnSelectToVisualColumn = function () {
        if (!this._columnSelectToVisualColumn) {
            var primaryCursor = this.cursors.getAll()[0];
            var primaryPos = primaryCursor.viewState.position;
            return cursorCommon_1.CursorColumns.visibleColumnFromColumn2(primaryCursor.config, primaryCursor.viewModel, primaryPos);
        }
        return this._columnSelectToVisualColumn;
    };
    Cursor.prototype._columnSelectMouse = function (ctx) {
        var primary = this.cursors.getAll()[0];
        // validate `eventData`
        var validatedPosition = primary.model.validatePosition(ctx.eventData.position);
        var validatedViewPosition;
        if (ctx.eventData.viewPosition) {
            validatedViewPosition = primary.validateViewPosition(ctx.eventData.viewPosition.lineNumber, ctx.eventData.viewPosition.column, validatedPosition);
        }
        else {
            validatedViewPosition = primary.convertModelPositionToViewPosition(validatedPosition.lineNumber, validatedPosition.column);
        }
        var result = cursorColumnSelection_1.ColumnSelection.columnSelect(primary.config, primary.viewModel, primary.viewState.selection.getStartPosition(), validatedViewPosition.lineNumber, ctx.eventData.mouseColumn - 1);
        var selections = result.viewSelections.map(function (viewSel) { return primary.convertViewSelectionToModelSelection(viewSel); });
        ctx.shouldRevealTarget = (result.reversed ? 1 /* TopMost */ : 2 /* BottomMost */);
        ctx.shouldReveal = true;
        ctx.setColumnSelectToLineNumber = result.toLineNumber;
        ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
        this.cursors.setSelections(selections, result.viewSelections);
        return true;
    };
    Cursor.prototype._columnSelectOp = function (ctx, op) {
        var primary = this.cursors.getAll()[0];
        var result = op(primary, this._getColumnSelectToLineNumber(), this._getColumnSelectToVisualColumn());
        var selections = result.viewSelections.map(function (viewSel) { return primary.convertViewSelectionToModelSelection(viewSel); });
        ctx.shouldRevealTarget = (result.reversed ? 1 /* TopMost */ : 2 /* BottomMost */);
        ctx.shouldReveal = true;
        ctx.setColumnSelectToLineNumber = result.toLineNumber;
        ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
        this.cursors.setSelections(selections, result.viewSelections);
        return true;
    };
    Cursor.prototype._columnSelectLeft = function (ctx) {
        return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectLeft(cursor.config, cursor.viewModel, cursor.viewState, toViewLineNumber, toViewVisualColumn); });
    };
    Cursor.prototype._columnSelectRight = function (ctx) {
        return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectRight(cursor.config, cursor.viewModel, cursor.viewState, toViewLineNumber, toViewVisualColumn); });
    };
    Cursor.prototype._columnSelectUp = function (isPaged, ctx) {
        return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectUp(cursor.config, cursor.viewModel, cursor.viewState, isPaged, toViewLineNumber, toViewVisualColumn); });
    };
    Cursor.prototype._columnSelectDown = function (isPaged, ctx) {
        return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectDown(cursor.config, cursor.viewModel, cursor.viewState, isPaged, toViewLineNumber, toViewVisualColumn); });
    };
    Cursor.prototype._createCursor = function (ctx) {
        if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
            return false;
        }
        this.cursors.addSecondaryCursor({
            selectionStartLineNumber: 1,
            selectionStartColumn: 1,
            positionLineNumber: 1,
            positionColumn: 1
        });
        // Manually move to get events
        var lastAddedCursor = this.cursors.getLastAddedCursor();
        this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (oneCursor === lastAddedCursor) {
                if (ctx.eventData.wholeLine) {
                    return oneCursor_1.OneCursorOp.line(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
                }
                else {
                    return oneCursor_1.OneCursorOp.moveTo(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
                }
            }
            return false;
        });
        ctx.shouldReveal = false;
        ctx.shouldRevealHorizontal = false;
        return true;
    };
    Cursor.prototype._lastCursorMoveTo = function (ctx) {
        if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
            return false;
        }
        var lastAddedCursor = this.cursors.getLastAddedCursor();
        this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (oneCursor === lastAddedCursor) {
                return oneCursor_1.OneCursorOp.moveTo(oneCursor, true, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
            }
            return false;
        });
        ctx.shouldReveal = false;
        ctx.shouldRevealHorizontal = false;
        return true;
    };
    Cursor.prototype._addCursorUp = function (ctx) {
        if (this.configuration.editor.readOnly) {
            return false;
        }
        var originalCnt = this.cursors.getSelections().length;
        this.cursors.duplicateCursors();
        ctx.shouldRevealTarget = 1 /* TopMost */;
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (cursorIndex >= originalCnt) {
                return oneCursor_1.OneCursorOp.translateUp(oneCursor, oneCtx);
            }
            return false;
        });
    };
    Cursor.prototype._addCursorDown = function (ctx) {
        if (this.configuration.editor.readOnly) {
            return false;
        }
        var originalCnt = this.cursors.getSelections().length;
        this.cursors.duplicateCursors();
        ctx.shouldRevealTarget = 2 /* BottomMost */;
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (cursorIndex >= originalCnt) {
                return oneCursor_1.OneCursorOp.translateDown(oneCursor, oneCtx);
            }
            return false;
        });
    };
    Cursor.prototype._moveLeft = function (inSelectionMode, ctx) {
        ctx.eventData = ctx.eventData || {};
        ctx.eventData.to = editorCommon.CursorMovePosition.Left;
        ctx.eventData.select = inSelectionMode;
        return this._cursorMove(ctx);
    };
    Cursor.prototype._moveWordLeft = function (inSelectionMode, wordNavigationType, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordLeft(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
    };
    Cursor.prototype._moveRight = function (inSelectionMode, ctx) {
        ctx.eventData = ctx.eventData || {};
        ctx.eventData.to = editorCommon.CursorMovePosition.Right;
        ctx.eventData.select = inSelectionMode;
        return this._cursorMove(ctx);
    };
    Cursor.prototype._moveWordRight = function (inSelectionMode, wordNavigationType, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordRight(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
    };
    Cursor.prototype._moveDown = function (inSelectionMode, isPaged, ctx) {
        ctx.eventData = ctx.eventData || {};
        ctx.eventData.to = editorCommon.CursorMovePosition.Down;
        ctx.eventData.select = inSelectionMode;
        ctx.eventData.by = editorCommon.CursorMoveByUnit.WrappedLine;
        ctx.eventData.isPaged = isPaged;
        return this._cursorMove(ctx);
    };
    Cursor.prototype._moveUp = function (inSelectionMode, isPaged, ctx) {
        ctx.eventData = ctx.eventData || {};
        ctx.eventData.to = editorCommon.CursorMovePosition.Up;
        ctx.eventData.select = inSelectionMode;
        ctx.eventData.by = editorCommon.CursorMoveByUnit.WrappedLine;
        ctx.eventData.isPaged = isPaged;
        return this._cursorMove(ctx);
    };
    Cursor.prototype._moveToBeginningOfLine = function (inSelectionMode, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfLine(oneCursor, inSelectionMode, oneCtx); });
    };
    Cursor.prototype._moveToEndOfLine = function (inSelectionMode, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfLine(oneCursor, inSelectionMode, oneCtx); });
    };
    Cursor.prototype._moveToBeginningOfBuffer = function (inSelectionMode, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfBuffer(oneCursor, inSelectionMode, oneCtx); });
    };
    Cursor.prototype._moveToEndOfBuffer = function (inSelectionMode, ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfBuffer(oneCursor, inSelectionMode, oneCtx); });
    };
    Cursor.prototype._selectAll = function (ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.selectAll(oneCursor, oneCtx); });
    };
    Cursor.prototype._line = function (inSelectionMode, ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx); });
    };
    Cursor.prototype._lastCursorLine = function (inSelectionMode, ctx) {
        if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
            return false;
        }
        var lastAddedCursor = this.cursors.getLastAddedCursor();
        this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (oneCursor === lastAddedCursor) {
                return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
            }
            return false;
        });
        ctx.shouldReveal = false;
        ctx.shouldRevealHorizontal = false;
        return true;
    };
    Cursor.prototype._expandLineSelection = function (ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.expandLineSelection(oneCursor, oneCtx); });
    };
    Cursor.prototype._word = function (inSelectionMode, ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.word(oneCursor, inSelectionMode, oneCursor.validatePosition(ctx.eventData.position), oneCtx); });
    };
    Cursor.prototype._lastCursorWord = function (ctx) {
        if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
            return false;
        }
        var lastAddedCursor = this.cursors.getLastAddedCursor();
        this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            if (oneCursor === lastAddedCursor) {
                return oneCursor_1.OneCursorOp.word(oneCursor, true, oneCursor.validatePosition(ctx.eventData.position), oneCtx);
            }
            return false;
        });
        ctx.shouldReveal = false;
        ctx.shouldRevealHorizontal = false;
        return true;
    };
    Cursor.prototype._removeSecondaryCursors = function (ctx) {
        this.cursors.killSecondaryCursors();
        return true;
    };
    Cursor.prototype._cancelSelection = function (ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.cancelSelection(oneCursor, oneCtx); });
    };
    // -------------------- START editing operations
    Cursor.prototype._doApplyEdit = function (cursorIndex, oneCursor, oneCtx, callable) {
        var r = callable(oneCursor, cursorIndex);
        if (r) {
            oneCtx.executeCommand = r.command;
            oneCtx.shouldPushStackElementBefore = r.shouldPushStackElementBefore;
            oneCtx.shouldPushStackElementAfter = r.shouldPushStackElementAfter;
            oneCtx.isAutoWhitespaceCommand = r.isAutoWhitespaceCommand;
            oneCtx.shouldRevealHorizontal = r.shouldRevealHorizontal;
            oneCtx.cursorPositionChangeReason = r.cursorPositionChangeReason;
        }
        return true;
    };
    Cursor.prototype._applyEditForAll = function (ctx, callable) {
        var _this = this;
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return _this._doApplyEdit(cursorIndex, oneCursor, oneCtx, callable); }, false, false);
    };
    Cursor.prototype._applyEditForAllSorted = function (ctx, callable) {
        var _this = this;
        return this._invokeForAllSorted(ctx, function (cursorIndex, oneCursor, oneCtx) { return _this._doApplyEdit(cursorIndex, oneCursor, oneCtx, callable); }, false, false);
    };
    Cursor.prototype._lineInsertBefore = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineInsertBefore(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._lineInsertAfter = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineInsertAfter(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._lineBreakInsert = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineBreakInsert(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._type = function (ctx) {
        var _this = this;
        var text = ctx.eventData.text;
        if (ctx.eventSource === 'keyboard') {
            var _loop_1 = function (i, len) {
                var charCode = text.charCodeAt(i);
                var chr;
                if (strings.isHighSurrogate(charCode) && i + 1 < len) {
                    chr = text.charAt(i) + text.charAt(i + 1);
                    i++;
                }
                else {
                    chr = text.charAt(i);
                }
                this_1.charactersTyped += chr;
                // Here we must interpret each typed character individually, that's why we create a new context
                ctx.hasExecutedCommands = this_1._createAndInterpretHandlerCtx(ctx.eventSource, ctx.eventData, function (charHandlerCtx) {
                    _this._applyEditForAll(charHandlerCtx, function (cursor) { return cursorTypeOperations_1.TypeOperations.typeWithInterceptors(cursor.config, cursor.model, cursor.modelState, chr); });
                    // The last typed character gets to win
                    ctx.cursorPositionChangeReason = charHandlerCtx.cursorPositionChangeReason;
                    ctx.shouldReveal = charHandlerCtx.shouldReveal;
                    ctx.shouldRevealVerticalInCenter = charHandlerCtx.shouldRevealVerticalInCenter;
                    ctx.shouldRevealHorizontal = charHandlerCtx.shouldRevealHorizontal;
                }) || ctx.hasExecutedCommands;
                out_i_1 = i;
            };
            var this_1 = this, out_i_1;
            // If this event is coming straight from the keyboard, look for electric characters and enter
            for (var i = 0, len = text.length; i < len; i++) {
                _loop_1(i, len);
                i = out_i_1;
            }
        }
        else {
            this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.typeWithoutInterceptors(cursor.config, cursor.model, cursor.modelState, text); });
        }
        return true;
    };
    Cursor.prototype._replacePreviousChar = function (ctx) {
        var text = ctx.eventData.text;
        var replaceCharCnt = ctx.eventData.replaceCharCnt;
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.replacePreviousChar(cursor.config, cursor.model, cursor.modelState, text, replaceCharCnt); });
    };
    Cursor.prototype._tab = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.tab(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._indent = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.indent(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._outdent = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.outdent(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._distributePasteToCursors = function (ctx) {
        if (ctx.eventData.pasteOnNewLine) {
            return null;
        }
        var selections = this.cursors.getSelections();
        if (selections.length === 1) {
            return null;
        }
        for (var i = 0; i < selections.length; i++) {
            if (selections[i].startLineNumber !== selections[i].endLineNumber) {
                return null;
            }
        }
        var pastePieces = ctx.eventData.text.split(/\r\n|\r|\n/);
        if (pastePieces.length !== selections.length) {
            return null;
        }
        return pastePieces;
    };
    Cursor.prototype._paste = function (ctx) {
        var distributedPaste = this._distributePasteToCursors(ctx);
        if (distributedPaste) {
            return this._applyEditForAllSorted(ctx, function (cursor, cursorIndex) { return cursorTypeOperations_1.TypeOperations.paste(cursor.config, cursor.model, cursor.modelState, distributedPaste[cursorIndex], false); });
        }
        else {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.paste(cursor.config, cursor.model, cursor.modelState, ctx.eventData.text, ctx.eventData.pasteOnNewLine); });
        }
    };
    Cursor.prototype._deleteLeft = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.deleteLeft(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._deleteWordLeft = function (whitespaceHeuristics, wordNavigationType, ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorWordOperations_1.WordOperations.deleteWordLeft(cursor.config, cursor.model, cursor.modelState, whitespaceHeuristics, wordNavigationType); });
    };
    Cursor.prototype._deleteRight = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.deleteRight(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._deleteWordRight = function (whitespaceHeuristics, wordNavigationType, ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorWordOperations_1.WordOperations.deleteWordRight(cursor.config, cursor.model, cursor.modelState, whitespaceHeuristics, wordNavigationType); });
    };
    Cursor.prototype._deleteAllRight = function (ctx) {
        return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.deleteAllRight(cursor.config, cursor.model, cursor.modelState); });
    };
    Cursor.prototype._cut = function (ctx) {
        var _this = this;
        return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.cut(cursor.config, cursor.model, cursor.modelState, _this.enableEmptySelectionClipboard); });
    };
    // -------------------- END editing operations
    Cursor.prototype._revealLine = function (ctx) {
        var revealLineArg = ctx.eventData;
        var lineNumber = revealLineArg.lineNumber + 1;
        var range = this.model.validateRange({
            startLineNumber: lineNumber,
            startColumn: 1,
            endLineNumber: lineNumber,
            endColumn: 1
        });
        range = new range_1.Range(range.startLineNumber, range.startColumn, range.endLineNumber, this.model.getLineMaxColumn(range.endLineNumber));
        var revealAt = 0 /* Simple */;
        if (revealLineArg.at) {
            switch (revealLineArg.at) {
                case editorCommon.RevealLineAtArgument.Top:
                    revealAt = 3 /* Top */;
                    break;
                case editorCommon.RevealLineAtArgument.Center:
                    revealAt = 1 /* Center */;
                    break;
                case editorCommon.RevealLineAtArgument.Bottom:
                    revealAt = 4 /* Bottom */;
                    break;
                default:
                    break;
            }
        }
        this.emitCursorRevealRange(range, null, revealAt, false, false);
        return true;
    };
    Cursor.prototype._editorScroll = function (ctx) {
        var editorScrollArg = ctx.eventData;
        editorScrollArg.value = editorScrollArg.value || 1;
        switch (editorScrollArg.to) {
            case editorCommon.EditorScrollDirection.Up:
            case editorCommon.EditorScrollDirection.Down:
                return this._scrollUpOrDown(editorScrollArg, ctx);
        }
        return true;
    };
    Cursor.prototype._scrollUpOrDown = function (editorScrollArg, ctx) {
        if (this._scrollByReveal(editorScrollArg, ctx)) {
            return true;
        }
        var up = editorScrollArg.to === editorCommon.EditorScrollDirection.Up;
        var cursor = this.cursors.getAll()[0];
        var noOfLines = editorScrollArg.value || 1;
        switch (editorScrollArg.by) {
            case editorCommon.EditorScrollByUnit.Page:
                noOfLines = cursor.config.pageSize * noOfLines;
                break;
            case editorCommon.EditorScrollByUnit.HalfPage:
                noOfLines = Math.round(cursor.config.pageSize / 2) * noOfLines;
                break;
        }
        this.emitCursorScrollRequest((up ? -1 : 1) * noOfLines, !!editorScrollArg.revealCursor);
        return true;
    };
    Cursor.prototype._scrollByReveal = function (editorScrollArg, ctx) {
        var up = editorScrollArg.to === editorCommon.EditorScrollDirection.Up;
        var cursor = this.cursors.getAll()[0];
        if (editorCommon.EditorScrollByUnit.Line !== editorScrollArg.by) {
            // Scroll by reveal is done only when unit is line.
            return false;
        }
        if (!up && cursor.isLastLineVisibleInViewPort()) {
            // Scroll by reveal is not done if last line is visible and scrolling down.
            return false;
        }
        var range = up ? cursor.getRangeToRevealModelLinesBeforeViewPortTop(editorScrollArg.value) : cursor.getRangeToRevealModelLinesAfterViewPortBottom(editorScrollArg.value);
        this.emitCursorRevealRange(range, null, up ? 3 /* Top */ : 4 /* Bottom */, false, true);
        return true;
    };
    Cursor.prototype._scrollUp = function (isPaged, ctx) {
        ctx.eventData = { to: editorCommon.EditorScrollDirection.Up, value: 1 };
        ctx.eventData.by = isPaged ? editorCommon.EditorScrollByUnit.Page : editorCommon.EditorScrollByUnit.WrappedLine;
        return this._editorScroll(ctx);
    };
    Cursor.prototype._scrollDown = function (isPaged, ctx) {
        ctx.eventData = { to: editorCommon.EditorScrollDirection.Down, value: 1 };
        ctx.eventData.by = isPaged ? editorCommon.EditorScrollByUnit.Page : editorCommon.EditorScrollByUnit.WrappedLine;
        return this._editorScroll(ctx);
    };
    Cursor.prototype._undo = function (ctx) {
        ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
        ctx.hasExecutedCommands = true;
        this._interpretCommandResult(this.model.undo());
        return true;
    };
    Cursor.prototype._cursorUndo = function (ctx) {
        if (this.cursorUndoStack.length === 0) {
            return false;
        }
        ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
        ctx.isCursorUndo = true;
        this.cursors.restoreState(this.cursorUndoStack.pop());
        return true;
    };
    Cursor.prototype._redo = function (ctx) {
        ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Redo;
        ctx.hasExecutedCommands = true;
        this._interpretCommandResult(this.model.redo());
        return true;
    };
    Cursor.prototype._externalExecuteCommand = function (ctx) {
        this.cursors.killSecondaryCursors();
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            oneCtx.shouldPushStackElementBefore = true;
            oneCtx.shouldPushStackElementAfter = true;
            oneCtx.executeCommand = ctx.eventData;
            return false;
        });
    };
    Cursor.prototype._externalExecuteCommands = function (ctx) {
        return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
            oneCtx.shouldPushStackElementBefore = true;
            oneCtx.shouldPushStackElementAfter = true;
            oneCtx.executeCommand = ctx.eventData[cursorIndex];
            return false;
        });
    };
    return Cursor;
}(eventEmitter_1.EventEmitter));
exports.Cursor = Cursor;
