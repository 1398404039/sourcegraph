/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var tokensBinaryEncoding_1 = require('vs/editor/common/model/tokensBinaryEncoding');
var modeTransition_1 = require('vs/editor/common/core/modeTransition');
var LineToken = (function () {
    function LineToken(source, tokenIndex, modeIndex) {
        this._source = source;
        this._tokenIndex = tokenIndex;
        this._modeIndex = modeIndex;
        this.startOffset = this._source.getTokenStartOffset(this._tokenIndex);
        this.endOffset = this._source.getTokenEndOffset(this._tokenIndex);
        this.type = this._source.getTokenType(this._tokenIndex);
        this.modeId = this._source.modeTransitions[this._modeIndex].modeId;
        this.hasPrev = (this._tokenIndex > 0);
        this.hasNext = (this._tokenIndex + 1 < this._source.getTokenCount());
    }
    LineToken.prototype.prev = function () {
        if (!this.hasPrev) {
            return null;
        }
        if (this._modeIndex === 0) {
            return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex);
        }
        var modeTransitions = this._source.modeTransitions;
        var currentModeTransition = modeTransitions[this._modeIndex];
        var prevStartOffset = this._source.getTokenStartOffset(this._tokenIndex - 1);
        if (prevStartOffset < currentModeTransition.startIndex) {
            // Going to previous mode transition
            return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex - 1);
        }
        return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex);
    };
    LineToken.prototype.next = function () {
        if (!this.hasNext) {
            return null;
        }
        var modeTransitions = this._source.modeTransitions;
        if (this._modeIndex === modeTransitions.length - 1) {
            return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex);
        }
        var nextModeTransition = modeTransitions[this._modeIndex + 1];
        var nextStartOffset = this._source.getTokenStartOffset(this._tokenIndex + 1);
        if (nextStartOffset >= nextModeTransition.startIndex) {
            // Going to next mode transition
            return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex + 1);
        }
        return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex);
    };
    return LineToken;
}());
exports.LineToken = LineToken;
var LineTokens = (function () {
    function LineTokens(map, tokens, modeTransitions, textLength) {
        this._map = map;
        this._tokens = tokens;
        this.modeTransitions = modeTransitions;
        this._textLength = textLength;
    }
    LineTokens.prototype.getTokenCount = function () {
        return this._tokens.length;
    };
    LineTokens.prototype.getTokenStartOffset = function (tokenIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex]);
    };
    LineTokens.prototype.getTokenType = function (tokenIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.getType(this._map, this._tokens[tokenIndex]);
    };
    LineTokens.prototype.getTokenEndOffset = function (tokenIndex) {
        if (tokenIndex + 1 < this._tokens.length) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex + 1]);
        }
        return this._textLength;
    };
    LineTokens.prototype.equals = function (other) {
        if (other instanceof LineTokens) {
            if (this._map !== other._map) {
                return false;
            }
            if (this._tokens.length !== other._tokens.length) {
                return false;
            }
            for (var i = 0, len = this._tokens.length; i < len; i++) {
                if (this._tokens[i] !== other._tokens[i]) {
                    return false;
                }
            }
            return true;
        }
        if (!(other instanceof LineTokens)) {
            return false;
        }
    };
    LineTokens.prototype.findTokenIndexAtOffset = function (offset) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.findIndexOfOffset(this._tokens, offset);
    };
    LineTokens.prototype.findTokenAtOffset = function (offset) {
        if (this._textLength === 0) {
            return null;
        }
        var tokenIndex = this.findTokenIndexAtOffset(offset);
        var modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(this.modeTransitions, offset);
        return new LineToken(this, tokenIndex, modeIndex);
    };
    LineTokens.prototype.firstToken = function () {
        if (this._textLength === 0) {
            return null;
        }
        return new LineToken(this, 0, 0);
    };
    LineTokens.prototype.lastToken = function () {
        if (this._textLength === 0) {
            return null;
        }
        return new LineToken(this, this._tokens.length - 1, this.modeTransitions.length - 1);
    };
    LineTokens.prototype.inflate = function () {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.inflateArr(this._map, this._tokens);
    };
    LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaStartIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.sliceAndInflate(this._map, this._tokens, startOffset, endOffset, deltaStartIndex);
    };
    return LineTokens;
}());
exports.LineTokens = LineTokens;
