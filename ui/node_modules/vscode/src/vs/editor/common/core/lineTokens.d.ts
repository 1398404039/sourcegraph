import { TokensInflatorMap } from 'vs/editor/common/model/tokensBinaryEncoding';
import { ModeTransition } from 'vs/editor/common/core/modeTransition';
import { ViewLineToken } from 'vs/editor/common/core/viewLineToken';
/**
 * A standard token type. Values are 2^x such that a bit mask can be used.
 */
export declare const enum StandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 4,
}
export declare class LineToken {
    _lineTokenBrand: void;
    private _source;
    private _tokenIndex;
    private _modeIndex;
    readonly startOffset: number;
    readonly endOffset: number;
    readonly standardType: StandardTokenType;
    readonly modeId: string;
    readonly hasPrev: boolean;
    readonly hasNext: boolean;
    constructor(source: LineTokens, tokenIndex: number, modeIndex: number);
    prev(): LineToken;
    next(): LineToken;
}
export declare class LineTokens {
    _lineTokensBrand: void;
    private readonly _map;
    private readonly _tokens;
    private readonly _text;
    private readonly _textLength;
    readonly modeTransitions: ModeTransition[];
    constructor(map: TokensInflatorMap, tokens: number[], modeTransitions: ModeTransition[], text: string);
    getTokenCount(): number;
    getLineContent(): string;
    getTokenStartOffset(tokenIndex: number): number;
    /**
     * Deprecated. Do not use.
     * @deprecated
     */
    getTokenType(tokenIndex: number): string;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
    getTokenEndOffset(tokenIndex: number): number;
    /**
     * Find the token containing offset `offset`.
     *    For example, with the following tokens [0, 5), [5, 9), [9, infinity)
     *    Searching for 0, 1, 2, 3 or 4 will return 0.
     *    Searching for 5, 6, 7 or 8 will return 1.
     *    Searching for 9, 10, 11, ... will return 2.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    findTokenIndexAtOffset(offset: number): number;
    findTokenAtOffset(offset: number): LineToken;
    firstToken(): LineToken;
    lastToken(): LineToken;
    inflate(): ViewLineToken[];
    sliceAndInflate(startOffset: number, endOffset: number, deltaStartIndex: number): ViewLineToken[];
}
