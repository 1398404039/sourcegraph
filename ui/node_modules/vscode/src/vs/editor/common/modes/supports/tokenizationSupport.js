/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var modes = require('vs/editor/common/modes');
var lineStream_1 = require('vs/editor/common/modes/lineStream');
var nullMode_1 = require('vs/editor/common/modes/nullMode');
var token_1 = require('vs/editor/common/core/token');
var modeTransition_1 = require('vs/editor/common/core/modeTransition');
function isFunction(something) {
    return typeof something === 'function';
}
var TokenizationSupport = (function () {
    function TokenizationSupport(modeService, modeId, customization, supportsNestedModes) {
        var _this = this;
        this._modeService = modeService;
        this._modeId = modeId;
        this.customization = customization;
        this.supportsNestedModes = supportsNestedModes;
        this.defaults = {
            enterNestedMode: !isFunction(customization.enterNestedMode),
            getNestedMode: !isFunction(customization.getNestedMode),
            getLeavingNestedModeData: !isFunction(customization.getLeavingNestedModeData),
        };
        this._embeddedModes = Object.create(null);
        // Set up listening for embedded modes
        var emitting = false;
        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {
            if (emitting) {
                return;
            }
            var isOneOfMyEmbeddedModes = _this._embeddedModes[e.languageId];
            if (isOneOfMyEmbeddedModes) {
                emitting = true;
                modes.TokenizationRegistry.fire(_this._modeId);
                emitting = false;
            }
        });
    }
    TokenizationSupport.prototype.dispose = function () {
        this._tokenizationRegistryListener.dispose();
    };
    TokenizationSupport.prototype.getInitialState = function () {
        return this.customization.getInitialState();
    };
    TokenizationSupport.prototype.tokenize = function (line, state, deltaOffset, stopAtOffset) {
        if (deltaOffset === void 0) { deltaOffset = 0; }
        if (stopAtOffset === void 0) { stopAtOffset = deltaOffset + line.length; }
        if (state.getModeId() !== this._modeId) {
            return this._nestedTokenize(line, state, deltaOffset, stopAtOffset, [], []);
        }
        else {
            return this._myTokenize(line, state, deltaOffset, stopAtOffset, [], []);
        }
    };
    /**
     * Precondition is: nestedModeState.getModeId() !== this._modeId
     * This means we are in a nested mode when parsing starts on this line.
     */
    TokenizationSupport.prototype._nestedTokenize = function (buffer, nestedModeState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
        var myStateBeforeNestedMode = nestedModeState.getStateData();
        var leavingNestedModeData = this._getLeavingNestedModeData(buffer, myStateBeforeNestedMode);
        // Be sure to give every embedded mode the
        // opportunity to leave nested mode.
        // i.e. Don't go straight to the most nested mode
        var stepOnceNestedState = nestedModeState;
        while (stepOnceNestedState.getStateData() && stepOnceNestedState.getStateData().getModeId() !== this._modeId) {
            stepOnceNestedState = stepOnceNestedState.getStateData();
        }
        var nestedModeId = stepOnceNestedState.getModeId();
        if (!leavingNestedModeData) {
            // tokenization will not leave nested mode
            var result = void 0;
            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);
            if (tokenizationSupport) {
                result = tokenizationSupport.tokenize(buffer, nestedModeState, deltaOffset, stopAtOffset);
            }
            else {
                // The nested mode doesn't have tokenization support,
                // unfortunatelly this means we have to fake it
                result = nullMode_1.nullTokenize(nestedModeId, buffer, nestedModeState, deltaOffset);
            }
            result.tokens = prependTokens.concat(result.tokens);
            result.modeTransitions = prependModeTransitions.concat(result.modeTransitions);
            return result;
        }
        var nestedModeBuffer = leavingNestedModeData.nestedModeBuffer;
        if (nestedModeBuffer.length > 0) {
            // Tokenize with the nested mode
            var nestedModeLineTokens = void 0;
            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);
            if (tokenizationSupport) {
                nestedModeLineTokens = tokenizationSupport.tokenize(nestedModeBuffer, nestedModeState, deltaOffset, stopAtOffset);
            }
            else {
                // The nested mode doesn't have tokenization support,
                // unfortunatelly this means we have to fake it
                nestedModeLineTokens = nullMode_1.nullTokenize(nestedModeId, nestedModeBuffer, nestedModeState, deltaOffset);
            }
            // Save last state of nested mode
            nestedModeState = nestedModeLineTokens.endState;
            // Prepend nested mode's result to our result
            prependTokens = prependTokens.concat(nestedModeLineTokens.tokens);
            prependModeTransitions = prependModeTransitions.concat(nestedModeLineTokens.modeTransitions);
        }
        var bufferAfterNestedMode = leavingNestedModeData.bufferAfterNestedMode;
        var myStateAfterNestedMode = leavingNestedModeData.stateAfterNestedMode;
        myStateAfterNestedMode.setStateData(myStateBeforeNestedMode.getStateData());
        return this._myTokenize(bufferAfterNestedMode, myStateAfterNestedMode, deltaOffset + nestedModeBuffer.length, stopAtOffset, prependTokens, prependModeTransitions);
    };
    /**
     * Precondition is: state.getMode() === this
     * This means we are in the current mode when parsing starts on this line.
     */
    TokenizationSupport.prototype._myTokenize = function (buffer, myState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
        var lineStream = new lineStream_1.LineStream(buffer);
        var tokenResult, beforeTokenizeStreamPos;
        var previousType = null;
        myState = myState.clone();
        if (prependModeTransitions.length <= 0 || prependModeTransitions[prependModeTransitions.length - 1].modeId !== this._modeId) {
            // Avoid transitioning to the same mode (this can happen in case of empty embedded modes)
            prependModeTransitions.push(new modeTransition_1.ModeTransition(deltaOffset, this._modeId));
        }
        var maxPos = Math.min(stopAtOffset - deltaOffset, buffer.length);
        while (lineStream.pos() < maxPos) {
            beforeTokenizeStreamPos = lineStream.pos();
            do {
                tokenResult = myState.tokenize(lineStream);
                if (tokenResult === null || tokenResult === undefined ||
                    ((tokenResult.type === undefined || tokenResult.type === null) &&
                        (tokenResult.nextState === undefined || tokenResult.nextState === null))) {
                    throw new Error('Tokenizer must return a valid state');
                }
                if (tokenResult.nextState) {
                    tokenResult.nextState.setStateData(myState.getStateData());
                    myState = tokenResult.nextState;
                }
                if (lineStream.pos() <= beforeTokenizeStreamPos) {
                    throw new Error('Stream did not advance while tokenizing. Mode id is ' + this._modeId + ' (stuck at token type: "' + tokenResult.type + '", prepend tokens: "' + (prependTokens.map(function (t) { return t.type; }).join(',')) + '").');
                }
            } while (!tokenResult.type && tokenResult.type !== '');
            if (previousType !== tokenResult.type || tokenResult.dontMergeWithPrev || previousType === null) {
                prependTokens.push(new token_1.Token(beforeTokenizeStreamPos + deltaOffset, tokenResult.type));
            }
            previousType = tokenResult.type;
            if (this.supportsNestedModes && this._enterNestedMode(myState)) {
                var currentEmbeddedLevels = this._getEmbeddedLevel(myState);
                if (currentEmbeddedLevels < TokenizationSupport.MAX_EMBEDDED_LEVELS) {
                    var nestedModeState = this._getNestedModeInitialState(myState);
                    if (!lineStream.eos()) {
                        // There is content from the embedded mode
                        var restOfBuffer = buffer.substr(lineStream.pos());
                        var result = this._nestedTokenize(restOfBuffer, nestedModeState, deltaOffset + lineStream.pos(), stopAtOffset, prependTokens, prependModeTransitions);
                        return result;
                    }
                    else {
                        // Transition to the nested mode state
                        myState = nestedModeState;
                    }
                }
            }
        }
        return {
            tokens: prependTokens,
            actualStopOffset: lineStream.pos() + deltaOffset,
            modeTransitions: prependModeTransitions,
            endState: myState
        };
    };
    TokenizationSupport.prototype._getEmbeddedLevel = function (state) {
        var result = -1;
        while (state) {
            result++;
            state = state.getStateData();
        }
        return result;
    };
    TokenizationSupport.prototype._enterNestedMode = function (state) {
        if (this.defaults.enterNestedMode) {
            return false;
        }
        return this.customization.enterNestedMode(state);
    };
    TokenizationSupport.prototype._getNestedMode = function (state) {
        var _this = this;
        if (this.defaults.getNestedMode) {
            return null;
        }
        var locator = {
            getMode: function (mimetypeOrModeId) {
                if (!mimetypeOrModeId || !_this._modeService.isRegisteredMode(mimetypeOrModeId)) {
                    return null;
                }
                var modeId = _this._modeService.getModeId(mimetypeOrModeId);
                var mode = _this._modeService.getMode(modeId);
                if (mode) {
                    // Re-emit tokenizationSupport change events from all modes that I ever embedded
                    _this._embeddedModes[modeId] = true;
                    return mode;
                }
                // Fire mode loading event
                _this._modeService.getOrCreateMode(modeId);
                _this._embeddedModes[modeId] = true;
                return null;
            }
        };
        return this.customization.getNestedMode(state, locator);
    };
    TokenizationSupport.prototype._getNestedModeInitialState = function (state) {
        var nestedMode = this._getNestedMode(state);
        if (nestedMode) {
            var tokenizationSupport = modes.TokenizationRegistry.get(nestedMode.getId());
            if (tokenizationSupport) {
                var nestedModeState = tokenizationSupport.getInitialState();
                nestedModeState.setStateData(state);
                return nestedModeState;
            }
        }
        return new nullMode_1.NullState(nestedMode ? nestedMode.getId() : nullMode_1.NULL_MODE_ID, state);
    };
    TokenizationSupport.prototype._getLeavingNestedModeData = function (line, state) {
        if (this.defaults.getLeavingNestedModeData) {
            return null;
        }
        return this.customization.getLeavingNestedModeData(line, state);
    };
    TokenizationSupport.MAX_EMBEDDED_LEVELS = 5;
    return TokenizationSupport;
}());
exports.TokenizationSupport = TokenizationSupport;
