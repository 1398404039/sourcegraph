/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var strings = require('vs/base/common/strings');
var supports_1 = require('vs/editor/common/modes/supports');
var richEditBrackets_1 = require('vs/editor/common/modes/supports/richEditBrackets');
var BracketElectricCharacterSupport = (function () {
    function BracketElectricCharacterSupport(registry, modeId, brackets, autoClosePairs, contribution) {
        this._registry = registry;
        this._modeId = modeId;
        this.contribution = contribution || {};
        this.brackets = new Brackets(modeId, brackets, autoClosePairs, this.contribution.docComment);
    }
    BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
        if (Array.isArray(this.contribution.embeddedElectricCharacters)) {
            return this.contribution.embeddedElectricCharacters.concat(this.brackets.getElectricCharacters());
        }
        return this.brackets.getElectricCharacters();
    };
    BracketElectricCharacterSupport.prototype.onElectricCharacter = function (context, offset) {
        var _this = this;
        return supports_1.handleEvent(context, offset, function (nestedModeId, context, offset) {
            if (_this._modeId === nestedModeId) {
                return _this.brackets.onElectricCharacter(context, offset);
            }
            var electricCharacterSupport = _this._registry.getElectricCharacterSupport(nestedModeId);
            if (electricCharacterSupport) {
                return electricCharacterSupport.onElectricCharacter(context, offset);
            }
            return null;
        });
    };
    return BracketElectricCharacterSupport;
}());
exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
var Brackets = (function () {
    function Brackets(modeId, richEditBrackets, autoClosePairs, docComment) {
        this._modeId = modeId;
        this._richEditBrackets = richEditBrackets;
        this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; });
        if (docComment) {
            // IDocComment is legacy, only partially supported
            this._complexAutoClosePairs.push({ open: docComment.open, close: docComment.close });
        }
    }
    Brackets.prototype.getElectricCharacters = function () {
        var result = [];
        if (this._richEditBrackets) {
            for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                var bracketPair = this._richEditBrackets.brackets[i];
                var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                result.push(lastChar);
            }
        }
        // auto close
        for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {
            var pair = _a[_i];
            result.push(pair.open.charAt(pair.open.length - 1));
        }
        // Filter duplicate entries
        result = result.filter(function (item, pos, array) {
            return array.indexOf(item) === pos;
        });
        return result;
    };
    Brackets.prototype.onElectricCharacter = function (context, offset) {
        if (context.getTokenCount() === 0) {
            return null;
        }
        return (this._onElectricAutoClose(context, offset) ||
            this._onElectricAutoIndent(context, offset));
    };
    Brackets.prototype.containsTokenTypes = function (fullTokenSpec, tokensToLookFor) {
        var array = tokensToLookFor.split('.');
        for (var i = 0; i < array.length; ++i) {
            if (fullTokenSpec.indexOf(array[i]) < 0) {
                return false;
            }
        }
        return true;
    };
    Brackets.prototype._onElectricAutoIndent = function (context, offset) {
        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
            return null;
        }
        var reversedBracketRegex = this._richEditBrackets.reversedRegex;
        var lineText = context.getLineContent();
        var tokenIndex = context.findIndexOfOffset(offset);
        var tokenStart = context.getTokenStartOffset(tokenIndex);
        var tokenEnd = offset + 1;
        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(context.getLineContent());
        if (firstNonWhitespaceIndex !== -1 && firstNonWhitespaceIndex < tokenStart) {
            return null;
        }
        if (!supports_1.ignoreBracketsInToken(context.getTokenType(tokenIndex))) {
            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, lineText, tokenStart, tokenEnd);
            if (r) {
                var text = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                text = text.toLowerCase();
                var isOpen = this._richEditBrackets.textIsOpenBracket[text];
                if (!isOpen) {
                    return {
                        matchOpenBracket: text
                    };
                }
            }
        }
        return null;
    };
    Brackets.prototype._onElectricAutoClose = function (context, offset) {
        var _this = this;
        if (!this._complexAutoClosePairs.length) {
            return null;
        }
        var line = context.getLineContent();
        var char = line[offset];
        var _loop_1 = function(i) {
            var pair = this_1._complexAutoClosePairs[i];
            // See if the right electric character was pressed
            if (char !== pair.open.charAt(pair.open.length - 1)) {
                return "continue";
            }
            // If this line already contains the closing tag, do nothing.
            if (line.indexOf(pair.close, offset) >= 0) {
                return "continue";
            }
            // check if the full open bracket matches
            var lastTokenIndex = context.findIndexOfOffset(offset);
            if (line.substring(context.getTokenStartOffset(lastTokenIndex), offset + 1 /* include electric char*/) !== pair.open) {
                return "continue";
            }
            // If we're in a scope listen in 'notIn', do nothing
            if (pair.notIn) {
                var tokenType_1 = context.getTokenType(lastTokenIndex);
                if (pair.notIn.some(function (scope) { return _this.containsTokenTypes(tokenType_1, scope); })) {
                    return "continue";
                }
            }
            return { value: { appendText: pair.close } };
        };
        var this_1 = this;
        for (var i = 0; i < this._complexAutoClosePairs.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object") return state_1.value;
        }
    };
    return Brackets;
}());
exports.Brackets = Brackets;
