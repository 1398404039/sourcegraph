import URI from 'vs/base/common/uri';
import { IAction, Action } from 'vs/base/common/actions';
import { Promise, TPromise } from 'vs/base/common/winjs.base';
import { SyncDescriptor0, AsyncDescriptor0 } from 'vs/platform/instantiation/common/descriptors';
import { IConstructorSignature2, IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { IKeybindings } from 'vs/platform/keybinding/common/keybinding';
import { ContextKeyExpr, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
import { ICommandService } from 'vs/platform/commands/common/commands';
import { IDisposable } from 'vs/base/common/lifecycle';
import Event from 'vs/base/common/event';
export interface ICommandAction {
    id: string;
    title: string;
    category?: string;
    iconClass?: string;
}
export interface IMenu extends IDisposable {
    onDidChange: Event<IMenu>;
    getActions(): [string, IAction[]][];
}
export interface IMenuItem {
    command: ICommandAction;
    alt?: ICommandAction;
    when?: ContextKeyExpr;
    group?: 'navigation' | string;
    order?: number;
}
export declare enum MenuId {
    EditorTitle = 1,
    EditorTitleContext = 2,
    EditorContext = 3,
    ExplorerContext = 4,
    ProblemsPanelContext = 5,
}
export declare const IMenuService: {
    (...args: any[]): void;
    type: IMenuService;
};
export interface IMenuService {
    _serviceBrand: any;
    createMenu(id: MenuId, scopedKeybindingService: IContextKeyService): IMenu;
    getCommandActions(): ICommandAction[];
}
export interface IMenuRegistry {
    commands: {
        [id: string]: ICommandAction;
    };
    addCommand(userCommand: ICommandAction): boolean;
    getCommand(id: string): ICommandAction;
    appendMenuItem(menu: MenuId, item: IMenuItem): IDisposable;
    getMenuItems(loc: MenuId): IMenuItem[];
}
export declare const MenuRegistry: IMenuRegistry;
export declare class MenuItemAction extends Action {
    private _item;
    private _commandService;
    private static _getMenuItemId(item);
    private _resource;
    constructor(_item: IMenuItem, _commandService: ICommandService);
    resource: URI;
    readonly item: IMenuItem;
    readonly command: ICommandAction;
    readonly altCommand: ICommandAction;
    run(alt: boolean): TPromise<{}>;
}
export declare class ExecuteCommandAction extends Action {
    private _commandService;
    constructor(id: string, label: string, _commandService: ICommandService);
    run(...args: any[]): TPromise<any>;
}
export declare class SyncActionDescriptor {
    private _descriptor;
    private _id;
    private _label;
    private _keybindings;
    private _keybindingContext;
    private _keybindingWeight;
    constructor(ctor: IConstructorSignature2<string, string, Action>, id: string, label: string, keybindings?: IKeybindings, keybindingContext?: ContextKeyExpr, keybindingWeight?: number);
    readonly syncDescriptor: SyncDescriptor0<Action>;
    readonly id: string;
    readonly label: string;
    readonly keybindings: IKeybindings;
    readonly keybindingContext: ContextKeyExpr;
    readonly keybindingWeight: number;
}
/**
 * A proxy for an action that needs to load code in order to confunction. Can be used from contributions to defer
 * module loading up to the point until the run method is being executed.
 */
export declare class DeferredAction extends Action {
    private _instantiationService;
    private _descriptor;
    private _cachedAction;
    private _emitterUnbind;
    constructor(_instantiationService: IInstantiationService, _descriptor: AsyncDescriptor0<Action>, id: string, label?: string, cssClass?: string, enabled?: boolean);
    cachedAction: IAction;
    readonly id: string;
    label: string;
    class: string;
    enabled: boolean;
    order: number;
    run(event?: any): Promise;
    private _createAction();
    dispose(): void;
}
