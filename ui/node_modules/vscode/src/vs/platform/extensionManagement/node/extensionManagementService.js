/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require('vs/nls');
var path = require('path');
var pfs = require('vs/base/node/pfs');
var errors = require('vs/base/common/errors');
var objects_1 = require('vs/base/common/objects');
var lifecycle_1 = require('vs/base/common/lifecycle');
var arrays_1 = require('vs/base/common/arrays');
var zip_1 = require('vs/base/node/zip');
var winjs_base_1 = require('vs/base/common/winjs.base');
var extensionManagement_1 = require('vs/platform/extensionManagement/common/extensionManagement');
var extensionNls_1 = require('../common/extensionNls');
var environment_1 = require('vs/platform/environment/common/environment');
var async_1 = require('vs/base/common/async');
var event_1 = require('vs/base/common/event');
var semver = require('semver');
var collections_1 = require('vs/base/common/collections');
var uri_1 = require('vs/base/common/uri');
var message_1 = require('vs/platform/message/common/message');
var SystemExtensionsRoot = path.normalize(path.join(uri_1.default.parse(require.toUrl('')).fsPath, '..', 'extensions'));
function parseManifest(raw) {
    return new winjs_base_1.Promise(function (c, e) {
        try {
            var manifest = JSON.parse(raw);
            var metadata = manifest.__metadata || null;
            delete manifest.__metadata;
            c({ manifest: manifest, metadata: metadata });
        }
        catch (err) {
            e(new Error(nls.localize('invalidManifest', "Extension invalid: package.json is not a JSON file.")));
        }
    });
}
function validate(zipPath, extension, version) {
    return zip_1.buffer(zipPath, 'extension/package.json')
        .then(function (buffer) { return parseManifest(buffer.toString('utf8')); })
        .then(function (_a) {
        var manifest = _a.manifest;
        if (extension) {
            if (extension.name !== manifest.name) {
                return winjs_base_1.Promise.wrapError(Error(nls.localize('invalidName', "Extension invalid: manifest name mismatch.")));
            }
            if (extension.publisher !== manifest.publisher) {
                return winjs_base_1.Promise.wrapError(Error(nls.localize('invalidPublisher', "Extension invalid: manifest publisher mismatch.")));
            }
            if (version !== manifest.version) {
                return winjs_base_1.Promise.wrapError(Error(nls.localize('invalidVersion', "Extension invalid: manifest version mismatch.")));
            }
        }
        return winjs_base_1.TPromise.as(manifest);
    });
}
function readManifest(extensionPath) {
    var promises = [
        pfs.readFile(path.join(extensionPath, 'package.json'), 'utf8')
            .then(function (raw) { return parseManifest(raw); }),
        pfs.readFile(path.join(extensionPath, 'package.nls.json'), 'utf8')
            .then(null, function (err) { return err.code !== 'ENOENT' ? winjs_base_1.TPromise.wrapError(err) : '{}'; })
            .then(function (raw) { return JSON.parse(raw); })
    ];
    return winjs_base_1.TPromise.join(promises).then(function (_a) {
        var _b = _a[0], manifest = _b.manifest, metadata = _b.metadata, translations = _a[1];
        return {
            manifest: extensionNls_1.localizeManifest(manifest, translations),
            metadata: metadata
        };
    });
}
function getExtensionId(extension, version) {
    return extension.publisher + "." + extension.name + "-" + version;
}
var ExtensionManagementService = (function () {
    function ExtensionManagementService(environmentService, choiceService, galleryService) {
        this.environmentService = environmentService;
        this.choiceService = choiceService;
        this.galleryService = galleryService;
        this._onInstallExtension = new event_1.Emitter();
        this.onInstallExtension = this._onInstallExtension.event;
        this._onDidInstallExtension = new event_1.Emitter();
        this.onDidInstallExtension = this._onDidInstallExtension.event;
        this._onUninstallExtension = new event_1.Emitter();
        this.onUninstallExtension = this._onUninstallExtension.event;
        this._onDidUninstallExtension = new event_1.Emitter();
        this.onDidUninstallExtension = this._onDidUninstallExtension.event;
        this.extensionsPath = environmentService.extensionsPath;
        this.obsoletePath = path.join(this.extensionsPath, '.obsolete');
        this.obsoleteFileLimiter = new async_1.Limiter(1);
    }
    ExtensionManagementService.prototype.install = function (zipPath) {
        var _this = this;
        zipPath = path.resolve(zipPath);
        return validate(zipPath).then(function (manifest) {
            var id = getExtensionId(manifest, manifest.version);
            return _this.isObsolete(id).then(function (isObsolete) {
                if (isObsolete) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls.localize('restartCode', "Please restart Code before reinstalling {0}.", manifest.displayName || manifest.name)));
                }
                _this._onInstallExtension.fire({ id: id, zipPath: zipPath });
                return _this.installExtension(zipPath, id)
                    .then(function (local) { return _this._onDidInstallExtension.fire({ id: id, zipPath: zipPath, local: local }); }, function (error) { _this._onDidInstallExtension.fire({ id: id, zipPath: zipPath, error: error }); return winjs_base_1.TPromise.wrapError(error); });
            });
        });
    };
    ExtensionManagementService.prototype.installFromGallery = function (extension, promptToInstallDependencies) {
        var _this = this;
        if (promptToInstallDependencies === void 0) { promptToInstallDependencies = true; }
        var id = getExtensionId(extension, extension.version);
        return this.isObsolete(id).then(function (isObsolete) {
            if (isObsolete) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize('restartCode', "Please restart Code before reinstalling {0}.", extension.displayName || extension.name)));
            }
            _this._onInstallExtension.fire({ id: id, gallery: extension });
            return _this.installCompatibleVersion(extension, true, promptToInstallDependencies)
                .then(function (local) { return _this._onDidInstallExtension.fire({ id: id, local: local, gallery: extension }); }, function (error) {
                _this._onDidInstallExtension.fire({ id: id, gallery: extension, error: error });
                return winjs_base_1.TPromise.wrapError(error);
            });
        });
    };
    ExtensionManagementService.prototype.installCompatibleVersion = function (extension, installDependencies, promptToInstallDependencies) {
        var _this = this;
        return this.galleryService.loadCompatibleVersion(extension)
            .then(function (compatibleVersion) { return _this.getDependenciesToInstall(extension, installDependencies)
            .then(function (dependencies) {
            if (!dependencies.length) {
                return _this.downloadAndInstall(compatibleVersion);
            }
            if (promptToInstallDependencies) {
                var message = nls.localize('installDependeciesConfirmation', "Installing '{0}' also installs its dependencies. Would you like to continue?", extension.displayName);
                var options = [
                    nls.localize('install', "Yes"),
                    nls.localize('doNotInstall', "No")
                ];
                return _this.choiceService.choose(message_1.Severity.Info, message, options)
                    .then(function (value) {
                    if (value === 0) {
                        return _this.installWithDependencies(compatibleVersion);
                    }
                    return winjs_base_1.TPromise.wrapError(errors.canceled());
                }, function (error) { return winjs_base_1.TPromise.wrapError(errors.canceled()); });
            }
            else {
                return _this.installWithDependencies(compatibleVersion);
            }
        }); });
    };
    ExtensionManagementService.prototype.getDependenciesToInstall = function (extension, checkDependecies) {
        if (!checkDependecies) {
            return winjs_base_1.TPromise.wrap([]);
        }
        // Filter out self
        var extensionName = extension.publisher + "." + extension.name;
        var dependencies = extension.properties.dependencies ? extension.properties.dependencies.filter(function (name) { return name !== extensionName; }) : [];
        if (!dependencies.length) {
            return winjs_base_1.TPromise.wrap([]);
        }
        // Filter out installed dependencies
        return this.getInstalled().then(function (installed) {
            return dependencies.filter(function (dep) { return installed.every(function (i) { return i.manifest.publisher + "." + i.manifest.name !== dep; }); });
        });
    };
    ExtensionManagementService.prototype.installWithDependencies = function (extension) {
        var _this = this;
        return this.galleryService.getAllDependencies(extension)
            .then(function (allDependencies) { return _this.filterOutInstalled(allDependencies); })
            .then(function (toInstall) { return _this.filterObsolete.apply(_this, toInstall.map(function (i) { return getExtensionId(i, i.version); }))
            .then(function (obsolete) {
            if (obsolete.length) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize('restartCode', "Please restart Code before reinstalling {0}.", extension.displayName || extension.name)));
            }
            return _this.bulkInstallWithDependencies(extension, toInstall);
        }); });
    };
    ExtensionManagementService.prototype.bulkInstallWithDependencies = function (extension, dependecies) {
        var _this = this;
        for (var _i = 0, dependecies_1 = dependecies; _i < dependecies_1.length; _i++) {
            var dependency = dependecies_1[_i];
            var id = getExtensionId(dependency, dependency.version);
            this._onInstallExtension.fire({ id: id, gallery: dependency });
        }
        return this.downloadAndInstall(extension)
            .then(function (localExtension) {
            return winjs_base_1.TPromise.join(dependecies.map(function (dep) { return _this.installCompatibleVersion(dep, false, false); }))
                .then(function (installedLocalExtensions) {
                for (var _i = 0, installedLocalExtensions_1 = installedLocalExtensions; _i < installedLocalExtensions_1.length; _i++) {
                    var installedLocalExtension = installedLocalExtensions_1[_i];
                    var gallery = _this.getGalleryExtensionForLocalExtension(dependecies, installedLocalExtension);
                    _this._onDidInstallExtension.fire({ id: installedLocalExtension.id, local: installedLocalExtension, gallery: gallery });
                }
                return localExtension;
            }, function (error) {
                return _this.rollback(localExtension, dependecies).then(function () {
                    return winjs_base_1.TPromise.wrapError(Array.isArray(error) ? error[error.length - 1] : error);
                });
            });
        })
            .then(function (localExtension) { return localExtension; }, function (error) {
            for (var _i = 0, dependecies_2 = dependecies; _i < dependecies_2.length; _i++) {
                var dependency = dependecies_2[_i];
                _this._onDidInstallExtension.fire({ id: getExtensionId(dependency, dependency.version), gallery: dependency, error: error });
            }
            return winjs_base_1.TPromise.wrapError(error);
        });
    };
    ExtensionManagementService.prototype.rollback = function (localExtension, dependecies) {
        var _this = this;
        return this.uninstall(localExtension)
            .then(function () { return _this.filterOutUnInstalled(dependecies); })
            .then(function (installed) { return winjs_base_1.TPromise.join(installed.map(function (i) { return _this.uninstall(i); })); })
            .then(function () { return null; });
    };
    ExtensionManagementService.prototype.filterOutInstalled = function (extensions) {
        return this.getInstalled().then(function (local) {
            return extensions.filter(function (extension) {
                var extensionId = getExtensionId(extension, extension.version);
                return local.every(function (local) { return local.id !== extensionId; });
            });
        });
    };
    ExtensionManagementService.prototype.filterOutUnInstalled = function (extensions) {
        var _this = this;
        return this.getInstalled().then(function (installed) {
            return installed.filter(function (local) {
                return !!_this.getGalleryExtensionForLocalExtension(extensions, local);
            });
        });
    };
    ExtensionManagementService.prototype.getGalleryExtensionForLocalExtension = function (galleryExtensions, localExtension) {
        var filtered = galleryExtensions.filter(function (galleryExtension) { return getExtensionId(galleryExtension, galleryExtension.version) === localExtension.id; });
        return filtered.length ? filtered[0] : null;
    };
    ExtensionManagementService.prototype.downloadAndInstall = function (extension) {
        var _this = this;
        var id = getExtensionId(extension, extension.version);
        var metadata = {
            id: extension.id,
            publisherId: extension.publisherId,
            publisherDisplayName: extension.publisherDisplayName,
        };
        return this.galleryService.download(extension)
            .then(function (zipPath) { return validate(zipPath).then(function () { return zipPath; }); })
            .then(function (zipPath) { return _this.installExtension(zipPath, id, metadata); });
    };
    ExtensionManagementService.prototype.installExtension = function (zipPath, id, metadata) {
        if (metadata === void 0) { metadata = null; }
        var extensionPath = path.join(this.extensionsPath, id);
        return zip_1.extract(zipPath, extensionPath, { sourcePath: 'extension', overwrite: true })
            .then(function () { return readManifest(extensionPath); })
            .then(function (_a) {
            var manifest = _a.manifest;
            return pfs.readdir(extensionPath).then(function (children) {
                var readme = children.filter(function (child) { return /^readme(\.txt|\.md|)$/i.test(child); })[0];
                var readmeUrl = readme ? uri_1.default.file(path.join(extensionPath, readme)).toString() : null;
                var changelog = children.filter(function (child) { return /^changelog(\.txt|\.md|)$/i.test(child); })[0];
                var changelogUrl = changelog ? uri_1.default.file(path.join(extensionPath, changelog)).toString() : null;
                var type = extensionManagement_1.LocalExtensionType.User;
                var local = { type: type, id: id, manifest: manifest, metadata: metadata, path: extensionPath, readmeUrl: readmeUrl, changelogUrl: changelogUrl };
                var manifestPath = path.join(extensionPath, 'package.json');
                return pfs.readFile(manifestPath, 'utf8')
                    .then(function (raw) { return parseManifest(raw); })
                    .then(function (_a) {
                    var manifest = _a.manifest;
                    return objects_1.assign(manifest, { __metadata: metadata });
                })
                    .then(function (manifest) { return pfs.writeFile(manifestPath, JSON.stringify(manifest, null, '\t')); })
                    .then(function () { return local; });
            });
        });
    };
    ExtensionManagementService.prototype.uninstall = function (extension) {
        var _this = this;
        return this.scanUserExtensions().then(function (installed) {
            var promises = installed
                .filter(function (e) { return e.manifest.publisher === extension.manifest.publisher && e.manifest.name === extension.manifest.name; })
                .map(function (_a) {
                var id = _a.id;
                return _this.uninstallExtension(id);
            });
            return winjs_base_1.TPromise.join(promises);
        });
    };
    ExtensionManagementService.prototype.uninstallExtension = function (id) {
        var _this = this;
        var extensionPath = path.join(this.extensionsPath, id);
        return pfs.exists(extensionPath)
            .then(function (exists) { return exists ? null : winjs_base_1.Promise.wrapError(new Error(nls.localize('notExists', "Could not find extension"))); })
            .then(function () { return _this._onUninstallExtension.fire(id); })
            .then(function () { return _this.setObsolete(id); })
            .then(function () { return pfs.rimraf(extensionPath); })
            .then(function () { return _this.unsetObsolete(id); })
            .then(function () { return _this._onDidUninstallExtension.fire(id); });
    };
    ExtensionManagementService.prototype.getInstalled = function (type) {
        if (type === void 0) { type = null; }
        var promises = [];
        if (type === null || type === extensionManagement_1.LocalExtensionType.System) {
            promises.push(this.scanSystemExtensions());
        }
        if (type === null || type === extensionManagement_1.LocalExtensionType.User) {
            promises.push(this.scanUserExtensions());
        }
        return winjs_base_1.TPromise.join(promises).then(arrays_1.flatten);
    };
    ExtensionManagementService.prototype.scanSystemExtensions = function () {
        return this.scanExtensions(SystemExtensionsRoot, extensionManagement_1.LocalExtensionType.System);
    };
    ExtensionManagementService.prototype.scanUserExtensions = function () {
        return this.scanExtensions(this.extensionsPath, extensionManagement_1.LocalExtensionType.User).then(function (extensions) {
            var byId = collections_1.values(collections_1.groupBy(extensions, function (p) { return (p.manifest.publisher + "." + p.manifest.name); }));
            return byId.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.manifest.version, b.manifest.version); })[0]; });
        });
    };
    ExtensionManagementService.prototype.scanExtensions = function (root, type) {
        var limiter = new async_1.Limiter(10);
        return this.getObsoleteExtensions()
            .then(function (obsolete) {
            return pfs.readdir(root)
                .then(function (extensions) { return extensions.filter(function (id) { return !obsolete[id]; }); })
                .then(function (extensionIds) { return winjs_base_1.Promise.join(extensionIds.map(function (id) {
                var extensionPath = path.join(root, id);
                var each = function () { return pfs.readdir(extensionPath).then(function (children) {
                    var readme = children.filter(function (child) { return /^readme(\.txt|\.md|)$/i.test(child); })[0];
                    var readmeUrl = readme ? uri_1.default.file(path.join(extensionPath, readme)).toString() : null;
                    var changelog = children.filter(function (child) { return /^changelog(\.txt|\.md|)$/i.test(child); })[0];
                    var changelogUrl = changelog ? uri_1.default.file(path.join(extensionPath, changelog)).toString() : null;
                    return readManifest(extensionPath)
                        .then(function (_a) {
                        var manifest = _a.manifest, metadata = _a.metadata;
                        return ({ type: type, id: id, manifest: manifest, metadata: metadata, path: extensionPath, readmeUrl: readmeUrl, changelogUrl: changelogUrl });
                    });
                }).then(null, function () { return null; }); };
                return limiter.queue(each);
            })); })
                .then(function (result) { return result.filter(function (a) { return !!a; }); });
        });
    };
    ExtensionManagementService.prototype.removeDeprecatedExtensions = function () {
        var _this = this;
        var outdated = this.getOutdatedExtensionIds()
            .then(function (extensions) { return extensions.map(function (e) { return getExtensionId(e.manifest, e.manifest.version); }); });
        var obsolete = this.getObsoleteExtensions()
            .then(function (obsolete) { return Object.keys(obsolete); });
        return winjs_base_1.TPromise.join([outdated, obsolete])
            .then(function (result) { return arrays_1.flatten(result); })
            .then(function (extensionsIds) {
            return winjs_base_1.TPromise.join(extensionsIds.map(function (id) {
                return pfs.rimraf(path.join(_this.extensionsPath, id))
                    .then(function () { return _this.withObsoleteExtensions(function (obsolete) { return delete obsolete[id]; }); });
            }));
        });
    };
    ExtensionManagementService.prototype.getOutdatedExtensionIds = function () {
        return this.scanExtensions(this.extensionsPath, extensionManagement_1.LocalExtensionType.User)
            .then(function (extensions) { return collections_1.values(collections_1.groupBy(extensions, function (p) { return (p.manifest.publisher + "." + p.manifest.name); })); })
            .then(function (versions) { return arrays_1.flatten(versions.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.manifest.version, b.manifest.version); }).slice(1); })); });
    };
    ExtensionManagementService.prototype.isObsolete = function (id) {
        return this.filterObsolete(id).then(function (obsolete) { return obsolete.length === 1; });
    };
    ExtensionManagementService.prototype.filterObsolete = function () {
        var ids = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ids[_i - 0] = arguments[_i];
        }
        return this.withObsoleteExtensions(function (allObsolete) {
            var obsolete = [];
            for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                var id = ids_1[_i];
                if (!!allObsolete[id]) {
                    obsolete.push(id);
                }
            }
            return obsolete;
        });
    };
    ExtensionManagementService.prototype.setObsolete = function (id) {
        return this.withObsoleteExtensions(function (obsolete) { return objects_1.assign(obsolete, (_a = {}, _a[id] = true, _a)); var _a; });
    };
    ExtensionManagementService.prototype.unsetObsolete = function (id) {
        return this.withObsoleteExtensions(function (obsolete) { return delete obsolete[id]; });
    };
    ExtensionManagementService.prototype.getObsoleteExtensions = function () {
        return this.withObsoleteExtensions(function (obsolete) { return obsolete; });
    };
    ExtensionManagementService.prototype.withObsoleteExtensions = function (fn) {
        var _this = this;
        return this.obsoleteFileLimiter.queue(function () {
            var result = null;
            return pfs.readFile(_this.obsoletePath, 'utf8')
                .then(null, function (err) { return err.code === 'ENOENT' ? winjs_base_1.TPromise.as('{}') : winjs_base_1.TPromise.wrapError(err); })
                .then(function (raw) { try {
                return JSON.parse(raw);
            }
            catch (e) {
                return {};
            } })
                .then(function (obsolete) { result = fn(obsolete); return obsolete; })
                .then(function (obsolete) {
                if (Object.keys(obsolete).length === 0) {
                    return pfs.rimraf(_this.obsoletePath);
                }
                else {
                    var raw = JSON.stringify(obsolete);
                    return pfs.writeFile(_this.obsoletePath, raw);
                }
            })
                .then(function () { return result; });
        });
    };
    ExtensionManagementService.prototype.dispose = function () {
        this.disposables = lifecycle_1.dispose(this.disposables);
    };
    ExtensionManagementService = __decorate([
        __param(0, environment_1.IEnvironmentService),
        __param(1, message_1.IChoiceService),
        __param(2, extensionManagement_1.IExtensionGalleryService)
    ], ExtensionManagementService);
    return ExtensionManagementService;
}());
exports.ExtensionManagementService = ExtensionManagementService;
