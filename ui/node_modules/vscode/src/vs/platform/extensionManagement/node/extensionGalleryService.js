/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls_1 = require('vs/nls');
var os_1 = require('os');
var path = require('path');
var winjs_base_1 = require('vs/base/common/winjs.base');
var arrays_1 = require('vs/base/common/arrays');
var errors_1 = require('vs/base/common/errors');
var decorators_1 = require('vs/base/common/decorators');
var set_1 = require('vs/base/common/set');
var extensionManagement_1 = require('vs/platform/extensionManagement/common/extensionManagement');
var extensionTelemetry_1 = require('vs/platform/extensionManagement/common/extensionTelemetry');
var objects_1 = require('vs/base/common/objects');
var request_1 = require('vs/platform/request/common/request');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var request_2 = require('vs/base/node/request');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var package_1 = require('vs/platform/package');
var product_1 = require('vs/platform/product');
var extensionValidator_1 = require('vs/platform/extensions/node/extensionValidator');
var url = require('url');
var Flags;
(function (Flags) {
    Flags[Flags["None"] = 0] = "None";
    Flags[Flags["IncludeVersions"] = 1] = "IncludeVersions";
    Flags[Flags["IncludeFiles"] = 2] = "IncludeFiles";
    Flags[Flags["IncludeCategoryAndTags"] = 4] = "IncludeCategoryAndTags";
    Flags[Flags["IncludeSharedAccounts"] = 8] = "IncludeSharedAccounts";
    Flags[Flags["IncludeVersionProperties"] = 16] = "IncludeVersionProperties";
    Flags[Flags["ExcludeNonValidated"] = 32] = "ExcludeNonValidated";
    Flags[Flags["IncludeInstallationTargets"] = 64] = "IncludeInstallationTargets";
    Flags[Flags["IncludeAssetUri"] = 128] = "IncludeAssetUri";
    Flags[Flags["IncludeStatistics"] = 256] = "IncludeStatistics";
    Flags[Flags["IncludeLatestVersionOnly"] = 512] = "IncludeLatestVersionOnly";
    Flags[Flags["Unpublished"] = 4096] = "Unpublished";
})(Flags || (Flags = {}));
function flagsToString() {
    var flags = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        flags[_i - 0] = arguments[_i];
    }
    return String(flags.reduce(function (r, f) { return r | f; }, 0));
}
var FilterType;
(function (FilterType) {
    FilterType[FilterType["Tag"] = 1] = "Tag";
    FilterType[FilterType["ExtensionId"] = 4] = "ExtensionId";
    FilterType[FilterType["Category"] = 5] = "Category";
    FilterType[FilterType["ExtensionName"] = 7] = "ExtensionName";
    FilterType[FilterType["Target"] = 8] = "Target";
    FilterType[FilterType["Featured"] = 9] = "Featured";
    FilterType[FilterType["SearchText"] = 10] = "SearchText";
    FilterType[FilterType["ExcludeWithFlags"] = 12] = "ExcludeWithFlags";
})(FilterType || (FilterType = {}));
var AssetType = {
    Icon: 'Microsoft.VisualStudio.Services.Icons.Default',
    Details: 'Microsoft.VisualStudio.Services.Content.Details',
    Changelog: 'Microsoft.VisualStudio.Services.Content.Changelog',
    Manifest: 'Microsoft.VisualStudio.Code.Manifest',
    VSIX: 'Microsoft.VisualStudio.Services.VSIXPackage',
    License: 'Microsoft.VisualStudio.Services.Content.License',
};
var PropertyType = {
    Dependency: 'Microsoft.VisualStudio.Code.ExtensionDependencies',
    Engine: 'Microsoft.VisualStudio.Code.Engine'
};
var DefaultPageSize = 10;
var DefaultQueryState = {
    pageNumber: 1,
    pageSize: DefaultPageSize,
    sortBy: extensionManagement_1.SortBy.NoneOrRelevance,
    sortOrder: extensionManagement_1.SortOrder.Default,
    flags: Flags.None,
    criteria: [],
    assetTypes: []
};
var Query = (function () {
    function Query(state) {
        if (state === void 0) { state = DefaultQueryState; }
        this.state = state;
    }
    Object.defineProperty(Query.prototype, "pageNumber", {
        get: function () { return this.state.pageNumber; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "pageSize", {
        get: function () { return this.state.pageSize; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "sortBy", {
        get: function () { return this.state.sortBy; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "sortOrder", {
        get: function () { return this.state.sortOrder; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "flags", {
        get: function () { return this.state.flags; },
        enumerable: true,
        configurable: true
    });
    Query.prototype.withPage = function (pageNumber, pageSize) {
        if (pageSize === void 0) { pageSize = this.state.pageSize; }
        return new Query(objects_1.assign({}, this.state, { pageNumber: pageNumber, pageSize: pageSize }));
    };
    Query.prototype.withFilter = function (filterType) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var criteria = this.state.criteria.concat(values.map(function (value) { return ({ filterType: filterType, value: value }); }));
        return new Query(objects_1.assign({}, this.state, { criteria: criteria }));
    };
    Query.prototype.withSortBy = function (sortBy) {
        return new Query(objects_1.assign({}, this.state, { sortBy: sortBy }));
    };
    Query.prototype.withSortOrder = function (sortOrder) {
        return new Query(objects_1.assign({}, this.state, { sortOrder: sortOrder }));
    };
    Query.prototype.withFlags = function () {
        var flags = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            flags[_i - 0] = arguments[_i];
        }
        return new Query(objects_1.assign({}, this.state, { flags: flags.reduce(function (r, f) { return r | f; }, 0) }));
    };
    Query.prototype.withAssetTypes = function () {
        var assetTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            assetTypes[_i - 0] = arguments[_i];
        }
        return new Query(objects_1.assign({}, this.state, { assetTypes: assetTypes }));
    };
    Object.defineProperty(Query.prototype, "raw", {
        get: function () {
            var _a = this.state, criteria = _a.criteria, pageNumber = _a.pageNumber, pageSize = _a.pageSize, sortBy = _a.sortBy, sortOrder = _a.sortOrder, flags = _a.flags, assetTypes = _a.assetTypes;
            var filters = [{ criteria: criteria, pageNumber: pageNumber, pageSize: pageSize, sortBy: sortBy, sortOrder: sortOrder }];
            return { filters: filters, assetTypes: assetTypes, flags: flags };
        },
        enumerable: true,
        configurable: true
    });
    return Query;
}());
function getStatistic(statistics, name) {
    var result = (statistics || []).filter(function (s) { return s.statisticName === name; })[0];
    return result ? result.value : 0;
}
function getAssetSource(files, type) {
    var result = files.filter(function (f) { return f.assetType === type; })[0];
    return result && result.source;
}
function getDependencies(version) {
    var values = version.properties ? version.properties.filter(function (p) { return p.key === PropertyType.Dependency; }) : [];
    var value = values.length > 0 && values[0].value;
    return value ? value.split(',') : [];
}
function getEngine(version) {
    var values = version.properties ? version.properties.filter(function (p) { return p.key === PropertyType.Engine; }) : [];
    return (values.length > 0 && values[0].value) || '';
}
function toExtension(galleryExtension, extensionsGalleryUrl) {
    var version = galleryExtension.versions[0];
    var iconFallback = getAssetSource(version.files, AssetType.Icon);
    var icon;
    if (iconFallback) {
        var parsedUrl = url.parse(iconFallback, true);
        parsedUrl.search = undefined;
        parsedUrl.query['redirect'] = 'true';
        icon = url.format(parsedUrl);
    }
    else {
        iconFallback = icon = require.toUrl('./media/defaultIcon.png');
    }
    var assets = {
        manifest: getAssetSource(version.files, AssetType.Manifest),
        readme: getAssetSource(version.files, AssetType.Details),
        changelog: getAssetSource(version.files, AssetType.Changelog),
        download: getAssetSource(version.files, AssetType.VSIX) + "?install=true",
        icon: icon,
        iconFallback: iconFallback,
        license: getAssetSource(version.files, AssetType.License)
    };
    return {
        id: galleryExtension.extensionId,
        name: galleryExtension.extensionName,
        version: version.version,
        date: version.lastUpdated,
        displayName: galleryExtension.displayName,
        publisherId: galleryExtension.publisher.publisherId,
        publisher: galleryExtension.publisher.publisherName,
        publisherDisplayName: galleryExtension.publisher.displayName,
        description: galleryExtension.shortDescription || '',
        installCount: getStatistic(galleryExtension.statistics, 'install'),
        rating: getStatistic(galleryExtension.statistics, 'averagerating'),
        ratingCount: getStatistic(galleryExtension.statistics, 'ratingcount'),
        assets: assets,
        properties: {
            dependencies: getDependencies(version),
            engine: getEngine(version)
        }
    };
}
var ExtensionGalleryService = (function () {
    function ExtensionGalleryService(requestService, telemetryService, configurationService) {
        this.requestService = requestService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        var config = product_1.default.extensionsGallery;
        this.extensionsGalleryUrl = config && config.serviceUrl;
    }
    Object.defineProperty(ExtensionGalleryService.prototype, "commonHeaders", {
        get: function () {
            return this.telemetryService.getTelemetryInfo().then(function (_a) {
                var machineId = _a.machineId;
                var result = {
                    'X-Market-Client-Id': "VSCode " + package_1.default.version,
                    'User-Agent': "VSCode " + package_1.default.version
                };
                if (machineId) {
                    result['X-Market-User-Id'] = machineId;
                }
                return result;
            });
        },
        enumerable: true,
        configurable: true
    });
    ExtensionGalleryService.prototype.api = function (path) {
        if (path === void 0) { path = ''; }
        return "" + this.extensionsGalleryUrl + path;
    };
    ExtensionGalleryService.prototype.isEnabled = function () {
        return !!this.extensionsGalleryUrl;
    };
    ExtensionGalleryService.prototype.query = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.isEnabled()) {
            return winjs_base_1.TPromise.wrapError(new Error('No extension gallery service configured.'));
        }
        var type = options.names ? 'ids' : (options.text ? 'text' : 'all');
        var text = options.text || '';
        var pageSize = objects_1.getOrDefault(options, function (o) { return o.pageSize; }, 50);
        this.telemetryService.publicLog('galleryService:query', { type: type, text: text });
        var query = new Query()
            .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)
            .withPage(1, pageSize)
            .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
            .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))
            .withAssetTypes(AssetType.Icon, AssetType.License, AssetType.Details, AssetType.Manifest, AssetType.VSIX);
        if (text) {
            query = query.withFilter(FilterType.SearchText, text).withSortBy(extensionManagement_1.SortBy.NoneOrRelevance);
        }
        else if (options.ids) {
            query = query.withFilter.apply(query, [FilterType.ExtensionId].concat(options.ids));
        }
        else if (options.names) {
            query = query.withFilter.apply(query, [FilterType.ExtensionName].concat(options.names));
        }
        else {
            query = query.withSortBy(extensionManagement_1.SortBy.InstallCount);
        }
        if (typeof options.sortBy === 'number') {
            query = query.withSortBy(options.sortBy);
        }
        if (typeof options.sortOrder === 'number') {
            query = query.withSortOrder(options.sortOrder);
        }
        return this.queryGallery(query).then(function (_a) {
            var galleryExtensions = _a.galleryExtensions, total = _a.total;
            var extensions = galleryExtensions.map(function (e) { return toExtension(e, _this.extensionsGalleryUrl); });
            var pageSize = query.pageSize;
            var getPage = function (pageIndex) { return _this.queryGallery(query.withPage(pageIndex + 1))
                .then(function (_a) {
                var galleryExtensions = _a.galleryExtensions;
                return galleryExtensions.map(function (e) { return toExtension(e, _this.extensionsGalleryUrl); });
            }); };
            return { firstPage: extensions, total: total, pageSize: pageSize, getPage: getPage };
        });
    };
    ExtensionGalleryService.prototype.queryGallery = function (query) {
        var _this = this;
        return this.commonHeaders
            .then(function (headers) {
            var data = JSON.stringify(query.raw);
            headers = objects_1.assign({}, headers, {
                'Content-Type': 'application/json',
                'Accept': 'application/json;api-version=3.0-preview.1',
                'Accept-Encoding': 'gzip',
                'Content-Length': data.length
            });
            return _this.requestService.request({
                type: 'POST',
                url: _this.api('/extensionquery'),
                data: data,
                headers: headers
            });
        })
            .then(function (context) { return request_2.asJson(context); })
            .then(function (result) {
            var r = result.results[0];
            var galleryExtensions = r.extensions;
            var resultCount = r.resultMetadata && r.resultMetadata.filter(function (m) { return m.metadataType === 'ResultCount'; })[0];
            var total = resultCount && resultCount.metadataItems.filter(function (i) { return i.name === 'TotalCount'; })[0].count || 0;
            return { galleryExtensions: galleryExtensions, total: total };
        });
    };
    ExtensionGalleryService.prototype.download = function (extension) {
        var _this = this;
        return this.loadCompatibleVersion(extension).then(function (extension) {
            var url = extension.assets.download;
            var zipPath = path.join(os_1.tmpdir(), extension.id);
            var data = extensionTelemetry_1.getGalleryExtensionTelemetryData(extension);
            var startTime = new Date().getTime();
            var log = function (duration) { return _this.telemetryService.publicLog('galleryService:downloadVSIX', objects_1.assign(data, { duration: duration })); };
            return _this._getAsset({ url: url })
                .then(function (context) { return request_2.download(zipPath, context); })
                .then(function () { return log(new Date().getTime() - startTime); })
                .then(function () { return zipPath; });
        });
    };
    ExtensionGalleryService.prototype.getAsset = function (url) {
        return this._getAsset({ url: url });
    };
    ExtensionGalleryService.prototype.getAllDependencies = function (extension) {
        var _this = this;
        return this.loadCompatibleVersion(extension)
            .then(function (compatible) { return _this.getDependenciesReccursively(compatible.properties.dependencies, [], extension); });
    };
    ExtensionGalleryService.prototype.loadCompatibleVersion = function (extension) {
        var _this = this;
        if (extension.properties.engine && this.isEngineValid(extension.properties.engine)) {
            return winjs_base_1.TPromise.wrap(extension);
        }
        var query = new Query()
            .withFlags(Flags.IncludeVersions, Flags.IncludeFiles, Flags.IncludeVersionProperties)
            .withPage(1, 1)
            .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
            .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))
            .withAssetTypes(AssetType.Manifest, AssetType.VSIX)
            .withFilter(FilterType.ExtensionId, extension.id);
        return this.queryGallery(query).then(function (_a) {
            var galleryExtensions = _a.galleryExtensions;
            var rawExtension = galleryExtensions[0];
            if (!rawExtension) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('notFound', "Extension not found")));
            }
            return _this.getLastValidExtensionVersion(rawExtension, rawExtension.versions)
                .then(function (rawVersion) {
                extension.properties.dependencies = getDependencies(rawVersion);
                extension.properties.engine = getEngine(rawVersion);
                extension.assets.download = getAssetSource(rawVersion.files, AssetType.VSIX) + "?install=true";
                extension.version = rawVersion.version;
                return extension;
            });
        });
    };
    ExtensionGalleryService.prototype.loadDependencies = function (extensionNames) {
        var _this = this;
        var query = (_a = new Query()
            .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)
            .withPage(1, extensionNames.length)
            .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
            .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))
            .withAssetTypes(AssetType.Icon, AssetType.License, AssetType.Details, AssetType.Manifest, AssetType.VSIX)).withFilter.apply(_a, [FilterType.ExtensionName].concat(extensionNames));
        return this.queryGallery(query).then(function (result) {
            var dependencies = [];
            var ids = [];
            for (var _i = 0, _a = result.galleryExtensions; _i < _a.length; _i++) {
                var rawExtension = _a[_i];
                if (ids.indexOf(rawExtension.extensionId) === -1) {
                    dependencies.push(toExtension(rawExtension, _this.extensionsGalleryUrl));
                    ids.push(rawExtension.extensionId);
                }
            }
            return dependencies;
        });
        var _a;
    };
    ExtensionGalleryService.prototype.getDependenciesReccursively = function (toGet, result, root) {
        var _this = this;
        if (!toGet || !toGet.length) {
            return winjs_base_1.TPromise.wrap(result);
        }
        if (toGet.indexOf(root.publisher + "." + root.name) && result.indexOf(root) === -1) {
            result.push(root);
        }
        toGet = result.length ? toGet.filter(function (e) { return !ExtensionGalleryService.hasExtensionByName(result, e); }) : toGet;
        if (!toGet.length) {
            return winjs_base_1.TPromise.wrap(result);
        }
        return this.loadDependencies(toGet)
            .then(function (loadedDependencies) {
            var dependenciesSet = new set_1.ArraySet();
            for (var _i = 0, loadedDependencies_1 = loadedDependencies; _i < loadedDependencies_1.length; _i++) {
                var dep = loadedDependencies_1[_i];
                if (dep.properties.dependencies) {
                    dep.properties.dependencies.forEach(function (d) { return dependenciesSet.set(d); });
                }
            }
            result = arrays_1.distinct(result.concat(loadedDependencies), function (d) { return d.id; });
            var dependencies = dependenciesSet.elements.filter(function (d) { return !ExtensionGalleryService.hasExtensionByName(result, d); });
            return _this.getDependenciesReccursively(dependencies, result, root);
        });
    };
    /**
     * Always try with the `redirect=true` query string.
     * If that does not return 200, try without it.
     */
    ExtensionGalleryService.prototype._getAsset = function (options) {
        var _this = this;
        var parsedUrl = url.parse(options.url, true);
        parsedUrl.search = undefined;
        parsedUrl.query['redirect'] = 'true';
        return this.commonHeaders.then(function (headers) {
            headers = objects_1.assign({}, headers, options.headers || {});
            options = objects_1.assign({}, options, { headers: headers });
            var cdnUrl = url.format(parsedUrl);
            var cdnOptions = objects_1.assign({}, options, { url: cdnUrl });
            return _this.requestService.request(cdnOptions)
                .then(function (context) { return context.res.statusCode === 200 ? context : winjs_base_1.TPromise.wrapError('expected 200'); })
                .then(null, function (err) {
                _this.telemetryService.publicLog('galleryService:requestError', { cdn: true, message: errors_1.getErrorMessage(err) });
                _this.telemetryService.publicLog('galleryService:cdnFallback', { url: cdnUrl });
                return _this.requestService.request(options).then(null, function (err) {
                    _this.telemetryService.publicLog('galleryService:requestError', { cdn: false, message: errors_1.getErrorMessage(err) });
                    return winjs_base_1.TPromise.wrapError(err);
                });
            });
        });
    };
    ExtensionGalleryService.prototype.getLastValidExtensionVersion = function (extension, versions) {
        var version = this.getLastValidExtensionVersionFromProperties(extension, versions);
        if (version) {
            return version;
        }
        return this.getLastValidExtensionVersionReccursively(extension, versions);
    };
    ExtensionGalleryService.prototype.getLastValidExtensionVersionFromProperties = function (extension, versions) {
        for (var _i = 0, versions_1 = versions; _i < versions_1.length; _i++) {
            var version = versions_1[_i];
            var engine = getEngine(version);
            if (!engine) {
                return null;
            }
            if (this.isEngineValid(engine)) {
                return winjs_base_1.TPromise.wrap(version);
            }
        }
        return null;
    };
    ExtensionGalleryService.prototype.getLastValidExtensionVersionReccursively = function (extension, versions) {
        var _this = this;
        if (!versions.length) {
            return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('noCompatible', "Couldn't find a compatible version of {0} with this version of Code.", extension.displayName || extension.extensionName)));
        }
        var version = versions[0];
        var url = getAssetSource(version.files, AssetType.Manifest);
        var headers = { 'Accept-Encoding': 'gzip' };
        return this._getAsset({ url: url, headers: headers })
            .then(function (context) { return request_2.asJson(context); })
            .then(function (manifest) {
            var engine = manifest.engines.vscode;
            if (!_this.isEngineValid(engine)) {
                return _this.getLastValidExtensionVersionReccursively(extension, versions.slice(1));
            }
            version.properties = version.properties || [];
            version.properties.push({ key: PropertyType.Engine, value: manifest.engines.vscode });
            return version;
        });
    };
    ExtensionGalleryService.prototype.isEngineValid = function (engine) {
        // TODO@joao: discuss with alex '*' doesn't seem to be a valid engine version
        return engine === '*' || extensionValidator_1.isVersionValid(package_1.default.version, engine);
    };
    ExtensionGalleryService.hasExtensionByName = function (extensions, name) {
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var extension = extensions_1[_i];
            if (extension.publisher + "." + extension.name === name) {
                return true;
            }
        }
        return false;
    };
    __decorate([
        decorators_1.memoize
    ], ExtensionGalleryService.prototype, "commonHeaders", null);
    ExtensionGalleryService = __decorate([
        __param(0, request_1.IRequestService),
        __param(1, telemetry_1.ITelemetryService),
        __param(2, configuration_1.IConfigurationService)
    ], ExtensionGalleryService);
    return ExtensionGalleryService;
}());
exports.ExtensionGalleryService = ExtensionGalleryService;
