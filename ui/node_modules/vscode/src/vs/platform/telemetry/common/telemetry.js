/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var winjs_base_1 = require("vs/base/common/winjs.base");
var mime_1 = require("vs/base/common/mime");
var paths = require("vs/base/common/paths");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
exports.ITelemetryService = instantiation_1.createDecorator('telemetryService');
exports.defaultExperiments = {
    showNewUserWatermark: false,
    openUntitledFile: true
};
exports.NullTelemetryService = {
    _serviceBrand: undefined,
    _experiments: exports.defaultExperiments,
    publicLog: function (eventName, data) {
        return winjs_base_1.TPromise.as(null);
    },
    isOptedIn: true,
    getTelemetryInfo: function () {
        return winjs_base_1.TPromise.as({
            instanceId: 'someValue.instanceId',
            sessionId: 'someValue.sessionId',
            machineId: 'someValue.machineId'
        });
    },
    getExperiments: function () {
        return this._experiments;
    }
};
var beginGettingStartedExp = Date.UTC(2017, 0, 9);
var endGettingStartedExp = Date.UTC(2017, 0, 16);
function loadExperiments(contextService, storageService, configurationService) {
    var key = 'experiments.randomness';
    var valueString = storageService.get(key);
    if (!valueString) {
        valueString = Math.random().toString();
        storageService.store(key, valueString);
    }
    var random1 = parseFloat(valueString);
    var _a = splitRandom(random1), random2 = _a[0], showNewUserWatermark = _a[1];
    var _b = splitRandom(random2), random3 = _b[0], openUntitledFile = _b[1];
    var _c = splitRandom(random3), openGettingStarted = _c[1];
    var newUserDuration = 24 * 60 * 60 * 1000;
    var firstSessionDate = storageService.get('telemetry.firstSessionDate');
    var isNewUser = !firstSessionDate || Date.now() - Date.parse(firstSessionDate) < newUserDuration;
    if (!isNewUser || !!contextService.getWorkspace()) {
        showNewUserWatermark = exports.defaultExperiments.showNewUserWatermark;
        openUntitledFile = exports.defaultExperiments.openUntitledFile;
    }
    var isNewSession = !storageService.get('telemetry.lastSessionDate');
    var now = Date.now();
    if (!(isNewSession && now >= beginGettingStartedExp && now < endGettingStartedExp)) {
        openGettingStarted = undefined;
    }
    return applyOverrides(configurationService, {
        showNewUserWatermark: showNewUserWatermark,
        openUntitledFile: openUntitledFile,
        openGettingStarted: openGettingStarted
    });
}
exports.loadExperiments = loadExperiments;
function applyOverrides(configurationService, experiments) {
    var config = configurationService.getConfiguration('telemetry');
    var experimentsConfig = config && config.experiments || {};
    Object.keys(experiments).forEach(function (key) {
        if (key in experimentsConfig) {
            experiments[key] = experimentsConfig[key];
        }
    });
    return experiments;
}
exports.applyOverrides = applyOverrides;
function splitRandom(random) {
    var scaled = random * 2;
    var i = Math.floor(scaled);
    return [scaled - i, i === 1];
}
function combinedAppender() {
    var appenders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        appenders[_i] = arguments[_i];
    }
    return { log: function (e, d) { return appenders.forEach(function (a) { return a.log(e, d); }); } };
}
exports.combinedAppender = combinedAppender;
exports.NullAppender = { log: function () { return null; } };
// --- util
function anonymize(input) {
    if (!input) {
        return input;
    }
    var r = '';
    for (var i = 0; i < input.length; i++) {
        var ch = input[i];
        if (ch >= '0' && ch <= '9') {
            r += '0';
            continue;
        }
        if (ch >= 'a' && ch <= 'z') {
            r += 'a';
            continue;
        }
        if (ch >= 'A' && ch <= 'Z') {
            r += 'A';
            continue;
        }
        r += ch;
    }
    return r;
}
exports.anonymize = anonymize;
function telemetryURIDescriptor(uri) {
    var fsPath = uri && uri.fsPath;
    return fsPath ? { mimeType: mime_1.guessMimeTypes(fsPath).join(', '), ext: paths.extname(fsPath), path: anonymize(fsPath) } : {};
}
exports.telemetryURIDescriptor = telemetryURIDescriptor;
var configurationValueWhitelist = [
    'window.zoomLevel',
    'editor.fontSize',
    'editor.fontFamily',
    'editor.tabSize',
    'files.autoSave',
    'files.hotExit',
    'typescript.check.tscVersion',
    'editor.renderWhitespace',
    'editor.cursorBlinking',
    'editor.cursorStyle',
    'files.associations',
    'workbench.statusBar.visible',
    'editor.wrappingColumn',
    'editor.insertSpaces',
    'editor.renderIndentGuides',
    'files.trimTrailingWhitespace',
    'git.confirmSync',
    'editor.rulers',
    'workbench.sideBar.location',
    'editor.fontLigatures',
    'editor.wordWrap',
    'editor.lineHeight',
    'editor.detectIndentation',
    'editor.formatOnType',
    'editor.formatOnSave',
    'window.openFilesInNewWindow',
    'javascript.validate.enable',
    'editor.mouseWheelZoom',
    'typescript.check.workspaceVersion',
    'editor.fontWeight',
    'editor.scrollBeyondLastLine',
    'editor.lineNumbers',
    'editor.wrappingIndent',
    'editor.renderControlCharacters',
    'editor.autoClosingBrackets',
    'window.reopenFolders',
    'extensions.autoUpdate',
    'editor.tabCompletion',
    'files.eol',
    'explorer.openEditors.visible',
    'workbench.editor.enablePreview',
    'files.autoSaveDelay',
    'editor.roundedSelection',
    'editor.quickSuggestions',
    'editor.acceptSuggestionOnEnter',
    'workbench.editor.showTabs',
    'files.encoding',
    'editor.quickSuggestionsDelay',
    'editor.snippetSuggestions',
    'editor.selectionHighlight',
    'editor.glyphMargin',
    'php.validate.run',
    'editor.wordSeparators',
    'editor.mouseWheelScrollSensitivity',
    'editor.suggestOnTriggerCharacters',
    'git.enabled',
    'http.proxyStrictSSL',
    'terminal.integrated.fontFamily',
    'editor.overviewRulerLanes',
    'editor.wordBasedSuggestions',
    'editor.hideCursorInOverviewRuler',
    'editor.trimAutoWhitespace',
    'editor.folding',
    'workbench.editor.enablePreviewFromQuickOpen',
    'php.validate.enable',
    'editor.parameterHints',
];
function configurationTelemetry(telemetryService, configurationService) {
    return configurationService.onDidUpdateConfiguration(function (event) {
        if (event.source !== configuration_1.ConfigurationSource.Default) {
            telemetryService.publicLog('updateConfiguration', {
                configurationSource: configuration_1.ConfigurationSource[event.source],
                configurationKeys: flattenKeys(event.sourceConfig)
            });
            telemetryService.publicLog('updateConfigurationValues', {
                configurationSource: configuration_1.ConfigurationSource[event.source],
                configurationValues: flattenValues(event.sourceConfig, configurationValueWhitelist)
            });
        }
    });
}
exports.configurationTelemetry = configurationTelemetry;
function lifecycleTelemetry(telemetryService, lifecycleService) {
    return lifecycleService.onShutdown(function (event) {
        telemetryService.publicLog('shutdown', { reason: lifecycle_1.ShutdownReason[event] });
    });
}
exports.lifecycleTelemetry = lifecycleTelemetry;
function keybindingsTelemetry(telemetryService, keybindingService) {
    return keybindingService.onDidUpdateKeybindings(function (event) {
        if (event.source === keybinding_1.KeybindingSource.User && event.keybindings) {
            telemetryService.publicLog('updateKeybindings', {
                bindings: event.keybindings.map(function (binding) { return ({
                    key: binding.key,
                    command: binding.command,
                    when: binding.when,
                    args: binding.args ? true : undefined
                }); })
            });
        }
    });
}
exports.keybindingsTelemetry = keybindingsTelemetry;
function flattenKeys(value) {
    if (!value) {
        return [];
    }
    var result = [];
    flatKeys(result, '', value);
    return result;
}
function flatKeys(result, prefix, value) {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
        Object.keys(value)
            .forEach(function (key) { return flatKeys(result, prefix ? prefix + "." + key : key, value[key]); });
    }
    else {
        result.push(prefix);
    }
}
function flattenValues(value, keys) {
    if (!value) {
        return [];
    }
    return keys.reduce(function (array, key) {
        var v = key.split('.')
            .reduce(function (tmp, k) { return tmp && typeof tmp === 'object' ? tmp[k] : undefined; }, value);
        if (typeof v !== 'undefined') {
            array.push((_a = {}, _a[key] = v, _a));
        }
        return array;
        var _a;
    }, []);
}
