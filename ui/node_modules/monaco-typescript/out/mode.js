"use strict";
var winjs_base_1 = require("vs/base/common/winjs.base");
var standaloneLanguages_1 = require("vs/editor/browser/standalone/standaloneLanguages");
var modes_1 = require("vs/editor/common/modes");
'use strict';
var tokenization_1 = require('./tokenization');
var workerManager_1 = require('./workerManager');
var javaScriptWorker;
var typeScriptWorker;
function setupTypeScript(defaults) {
    typeScriptWorker = setupMode(defaults, 'typescript', tokenization_1.Language.TypeScript);
}
exports.setupTypeScript = setupTypeScript;
function setupJavaScript(defaults) {
    javaScriptWorker = setupMode(defaults, 'javascript', tokenization_1.Language.EcmaScript5);
}
exports.setupJavaScript = setupJavaScript;
function getJavaScriptWorker() {
    return new winjs_base_1.TPromise(function (resolve, reject) {
        if (!javaScriptWorker) {
            return reject("JavaScript not registered!");
        }
        resolve(javaScriptWorker);
    });
}
exports.getJavaScriptWorker = getJavaScriptWorker;
function getTypeScriptWorker() {
    return new winjs_base_1.TPromise(function (resolve, reject) {
        if (!typeScriptWorker) {
            return reject("TypeScript not registered!");
        }
        resolve(typeScriptWorker);
    });
}
exports.getTypeScriptWorker = getTypeScriptWorker;
function setupMode(defaults, modeId, language) {
    var disposables = [];
    var client = new workerManager_1.WorkerManager(modeId, defaults);
    disposables.push(client);
    var worker = function (first) {
        var more = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            more[_i - 1] = arguments[_i];
        }
        return client.getLanguageServiceWorker.apply(client, [first].concat(more));
    };
    // HACK: We only want syntax highlighting. We'll do all the other
    // work on the server.
    /*
    disposables.push(registerCompletionItemProvider(modeId, new languageFeatures.SuggestAdapter(worker)));
    disposables.push(registerSignatureHelpProvider(modeId, new languageFeatures.SignatureHelpAdapter(worker)));
    disposables.push(registerHoverProvider(modeId, new languageFeatures.QuickInfoAdapter(worker)));
    disposables.push(registerDocumentHighlightProvider(modeId, new languageFeatures.OccurrencesAdapter(worker)));
    disposables.push(registerDefinitionProvider(modeId, new languageFeatures.DefinitionAdapter(worker)));
    disposables.push(registerReferenceProvider(modeId, new languageFeatures.ReferenceAdapter(worker)));
    disposables.push(registerDocumentSymbolProvider(modeId, new languageFeatures.OutlineAdapter(worker)));
    disposables.push(registerDocumentRangeFormattingEditProvider(modeId, new languageFeatures.FormatAdapter(worker)));
    disposables.push(registerOnTypeFormattingEditProvider(modeId, new languageFeatures.FormatOnTypeAdapter(worker)));
    disposables.push(new languageFeatures.DiagnostcsAdapter(defaults, modeId, worker));
    */
    disposables.push(standaloneLanguages_1.setLanguageConfiguration(modeId, richEditConfiguration));
    disposables.push(standaloneLanguages_1.setTokensProvider(modeId, tokenization_1.createTokenizationSupport(language)));
    return worker;
}
var richEditConfiguration = {
    wordPattern: /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,
    comments: {
        lineComment: '//',
        blockComment: ['/*', '*/']
    },
    brackets: [
        ['{', '}'],
        ['[', ']'],
        ['(', ')']
    ],
    onEnterRules: [
        {
            // e.g. /** | */
            beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            afterText: /^\s*\*\/$/,
            action: { indentAction: modes_1.IndentAction.IndentOutdent, appendText: ' * ' }
        },
        {
            // e.g. /** ...|
            beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            action: { indentAction: modes_1.IndentAction.None, appendText: ' * ' }
        },
        {
            // e.g.  * ...|
            beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
            action: { indentAction: modes_1.IndentAction.None, appendText: '* ' }
        },
        {
            // e.g.  */|
            beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
            action: { indentAction: modes_1.IndentAction.None, removeText: 1 }
        }
    ],
    __electricCharacterSupport: {
        docComment: { scope: 'comment.doc', open: '/**', lineStart: ' * ', close: ' */' }
    },
    autoClosingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: '"', close: '"', notIn: ['string'] },
        { open: '\'', close: '\'', notIn: ['string', 'comment'] },
        { open: '`', close: '`' }
    ]
};
