diff --git a/ui/node_modules/vscode/src/vs/base/common/worker/simpleWorker.ts b/ui/node_modules/vscode/src/vs/base/common/worker/simpleWorker.ts
index 013d00a..026d2fe 100644
--- a/ui/node_modules/vscode/src/vs/base/common/worker/simpleWorker.ts
+++ b/ui/node_modules/vscode/src/vs/base/common/worker/simpleWorker.ts
@@ -167,7 +167,12 @@ export class SimpleWorkerClient<T> extends Disposable {
 		super();
 
 		let lazyProxyFulfill : (v:T)=>void = null;
-		let lazyProxyReject: (err:any)=>void = null;
+
+		// HACK: lazyProxyReject doesn't SEEM to do anything, but the
+		// call to it fails with 'Uncaught TypeError: lazyProxyReject
+		// is not a function' because the assignment to it doesn't get
+		// called for some reason. So, just make it a no-op.
+		let lazyProxyReject: (err:any)=>void = () => (void 0);
 
 		this._worker = this._register(workerFactory.create(
 			'vs/base/common/worker/simpleWorker',
diff --git a/ui/node_modules/vscode/src/vs/base/worker/defaultWorkerFactory.ts b/ui/node_modules/vscode/src/vs/base/worker/defaultWorkerFactory.ts
index 87d36dd..d44027f 100644
--- a/ui/node_modules/vscode/src/vs/base/worker/defaultWorkerFactory.ts
+++ b/ui/node_modules/vscode/src/vs/base/worker/defaultWorkerFactory.ts
@@ -10,7 +10,15 @@ import {logOnceWebWorkerWarning, IWorker, IWorkerCallback, IWorkerFactory} from
 import * as dom from 'vs/base/browser/dom';
 
 function defaultGetWorkerUrl(workerId:string, label:string): string {
-	return require.toUrl('./' + workerId) + '#' + label;
+	// HACK: Run the web worker from a webpack script that is in the
+	// bundle but that doesn't have its own separate URL. We must
+	// assign this before anything in vscode gets run, which is why we
+	// need to set it in here instead of in our own code.
+	//
+	// See http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string and
+	// http://stackoverflow.com/questions/5408406/web-workers-without-a-separate-javascript-file
+	// for more information about (and limitations of) this technique.
+	return require("worker?inline!vs/base/worker/workerMain");
 }
 var getWorkerUrl = flags.getCrossOriginWorkerScriptUrl || defaultGetWorkerUrl;
 
diff --git a/ui/node_modules/vscode/src/vs/platform/instantiation/common/instantiationService.ts b/ui/node_modules/vscode/src/vs/platform/instantiation/common/instantiationService.ts
index 2f23db4..a5650e9 100644
--- a/ui/node_modules/vscode/src/vs/platform/instantiation/common/instantiationService.ts
+++ b/ui/node_modules/vscode/src/vs/platform/instantiation/common/instantiationService.ts
@@ -83,37 +83,9 @@ export class InstantiationService implements IInstantiationService {
 
 		let canceledError: Error;
 
-		return new TPromise((c, e, p) => {
-			require([descriptor.moduleName], (_module?: any) => {
-				if (canceledError) {
-					e(canceledError);
-				}
-
-				if (!_module) {
-					return e(illegalArgument('module not found: ' + descriptor.moduleName));
-				}
-
-				let ctor: Function;
-				if (!descriptor.ctorName) {
-					ctor = _module;
-				} else {
-					ctor = _module[descriptor.ctorName];
-				}
-
-				if (typeof ctor !== 'function') {
-					return e(illegalArgument('not a function: ' + descriptor.ctorName || descriptor.moduleName));
-				}
-
-				try {
-					args.unshift.apply(args, descriptor.staticArguments()); // instead of spread in ctor call
-					c(this._createInstance(new SyncDescriptor<T>(ctor), args));
-				} catch (error) {
-					return e(error);
-				}
-			}, e);
-		}, () => {
-			canceledError = canceled();
-		});
+		// HACK: Remove an unused dynamic import that Webpack
+		// complains about.
+		throw new Error("require call is incompatible with webpack");
 	}
 
 	private _createInstance<T>(desc: SyncDescriptor<T>, args: any[]): T {
