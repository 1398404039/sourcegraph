import { CancellationToken } from "vs/base/common/cancellation";
import { default as URI } from "vs/base/common/uri";
import { TPromise } from "vs/base/common/winjs.base";
import { CompletionItem, CompletionItemProvider } from "vs/editor/browser/standalone/standaloneLanguages";
import { Position } from "vs/editor/common/core/position";
import { Range } from "vs/editor/common/core/range";
import { IPosition, IRange, IReadOnlyModel, ISingleEditOperation } from "vs/editor/common/editorCommon";
import { Definition, DocumentHighlight, DocumentHighlightProvider, DocumentRangeFormattingEditProvider, DocumentSymbolProvider, FormattingOptions, Hover, HoverProvider, Location, OnTypeFormattingEditProvider, ReferenceContext, ReferenceProvider, SignatureHelp, SignatureHelpProvider, SymbolInformation } from "vs/editor/common/modes";
import { LanguageServiceDefaultsImpl } from './monaco.contribution';
import * as ts from '../lib/typescriptServices';
import { TypeScriptWorker } from './worker';
export declare abstract class Adapter {
    protected _worker: (first: URI, ...more: URI[]) => TPromise<TypeScriptWorker>;
    constructor(_worker: (first: URI, ...more: URI[]) => TPromise<TypeScriptWorker>);
    protected _positionToOffset(uri: URI, position: IPosition): number;
    protected _offsetToPosition(uri: URI, offset: number): IPosition;
    protected _textSpanToRange(uri: URI, span: ts.TextSpan): IRange;
}
export declare class DiagnostcsAdapter extends Adapter {
    private _defaults;
    private _selector;
    private _disposables;
    private _listener;
    constructor(_defaults: LanguageServiceDefaultsImpl, _selector: string, worker: (first: URI, ...more: URI[]) => TPromise<TypeScriptWorker>);
    dispose(): void;
    private _doValidate(resource);
    private _convertDiagnostics(resource, diag);
}
export declare class SuggestAdapter extends Adapter implements CompletionItemProvider {
    readonly triggerCharacters: string[];
    provideCompletionItems(model: IReadOnlyModel, position: Position, token: CancellationToken): Thenable<CompletionItem[]>;
    resolveCompletionItem(item: CompletionItem, token: CancellationToken): Thenable<CompletionItem>;
    private static convertKind(kind);
}
export declare class SignatureHelpAdapter extends Adapter implements SignatureHelpProvider {
    signatureHelpTriggerCharacters: string[];
    provideSignatureHelp(model: IReadOnlyModel, position: Position, token: CancellationToken): Thenable<SignatureHelp>;
}
export declare class QuickInfoAdapter extends Adapter implements HoverProvider {
    provideHover(model: IReadOnlyModel, position: Position, token: CancellationToken): Thenable<Hover>;
}
export declare class OccurrencesAdapter extends Adapter implements DocumentHighlightProvider {
    provideDocumentHighlights(model: IReadOnlyModel, position: Position, token: CancellationToken): Thenable<DocumentHighlight[]>;
}
export declare class DefinitionAdapter extends Adapter {
    provideDefinition(model: IReadOnlyModel, position: Position, token: CancellationToken): Thenable<Definition>;
}
export declare class ReferenceAdapter extends Adapter implements ReferenceProvider {
    provideReferences(model: IReadOnlyModel, position: Position, context: ReferenceContext, token: CancellationToken): Thenable<Location[]>;
}
export declare class OutlineAdapter extends Adapter implements DocumentSymbolProvider {
    provideDocumentSymbols(model: IReadOnlyModel, token: CancellationToken): Thenable<SymbolInformation[]>;
}
export declare class Kind {
    static unknown: string;
    static keyword: string;
    static script: string;
    static module: string;
    static class: string;
    static interface: string;
    static type: string;
    static enum: string;
    static variable: string;
    static localVariable: string;
    static function: string;
    static localFunction: string;
    static memberFunction: string;
    static memberGetAccessor: string;
    static memberSetAccessor: string;
    static memberVariable: string;
    static constructorImplementation: string;
    static callSignature: string;
    static indexSignature: string;
    static constructSignature: string;
    static parameter: string;
    static typeParameter: string;
    static primitiveType: string;
    static label: string;
    static alias: string;
    static const: string;
    static let: string;
    static warning: string;
}
export declare abstract class FormatHelper extends Adapter {
    protected static _convertOptions(options: FormattingOptions): ts.FormatCodeOptions;
    protected _convertTextChanges(uri: URI, change: ts.TextChange): ISingleEditOperation;
}
export declare class FormatAdapter extends FormatHelper implements DocumentRangeFormattingEditProvider {
    provideDocumentRangeFormattingEdits(model: IReadOnlyModel, range: Range, options: FormattingOptions, token: CancellationToken): Thenable<ISingleEditOperation[]>;
}
export declare class FormatOnTypeAdapter extends FormatHelper implements OnTypeFormattingEditProvider {
    readonly autoFormatTriggerCharacters: string[];
    provideOnTypeFormattingEdits(model: IReadOnlyModel, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): Thenable<ISingleEditOperation[]>;
}
