/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var arrays = require("vs/base/common/arrays");
var fs = require("fs");
var path = require("path");
var crypto = require("crypto");
var platform = require("vs/base/common/platform");
var extfs = require("vs/base/node/extfs");
var uri_1 = require("vs/base/common/uri");
var environment_1 = require("vs/platform/environment/common/environment");
var winjs_base_1 = require("vs/base/common/winjs.base");
var BackupMainService = (function () {
    function BackupMainService(environmentService) {
        this.backupHome = environmentService.backupHome;
        this.workspacesJsonPath = environmentService.backupWorkspacesPath;
        this.mapWindowToBackupFolder = Object.create(null);
        this.loadSync();
    }
    BackupMainService.prototype.getWorkspaceBackupPaths = function () {
        return this.backups.folderWorkspaces.slice(0); // return a copy
    };
    BackupMainService.prototype.getEmptyWorkspaceBackupPaths = function () {
        return this.backups.emptyWorkspaces.slice(0); // return a copy
    };
    BackupMainService.prototype.getBackupPath = function (windowId) {
        if (!this.mapWindowToBackupFolder[windowId]) {
            throw new Error("Unknown backup workspace for window " + windowId);
        }
        return winjs_base_1.TPromise.as(path.join(this.backupHome, this.mapWindowToBackupFolder[windowId]));
    };
    BackupMainService.prototype.registerWindowForBackupsSync = function (windowId, isEmptyWorkspace, backupFolder, workspacePath) {
        // Generate a new folder if this is a new empty workspace
        if (isEmptyWorkspace && !backupFolder) {
            backupFolder = this.getRandomEmptyWorkspaceId();
        }
        this.mapWindowToBackupFolder[windowId] = isEmptyWorkspace ? backupFolder : this.getWorkspaceHash(workspacePath);
        this.pushBackupPathsSync(isEmptyWorkspace ? backupFolder : workspacePath, isEmptyWorkspace);
    };
    BackupMainService.prototype.pushBackupPathsSync = function (workspaceIdentifier, isEmptyWorkspace) {
        var array = isEmptyWorkspace ? this.backups.emptyWorkspaces : this.backups.folderWorkspaces;
        if (array.indexOf(workspaceIdentifier) === -1) {
            array.push(workspaceIdentifier);
            this.saveSync();
        }
        return workspaceIdentifier;
    };
    BackupMainService.prototype.removeBackupPathSync = function (workspaceIdentifier, isEmptyWorkspace) {
        var array = isEmptyWorkspace ? this.backups.emptyWorkspaces : this.backups.folderWorkspaces;
        if (!array) {
            return;
        }
        var index = array.indexOf(workspaceIdentifier);
        if (index === -1) {
            return;
        }
        array.splice(index, 1);
        this.saveSync();
    };
    BackupMainService.prototype.loadSync = function () {
        var backups;
        try {
            backups = JSON.parse(fs.readFileSync(this.workspacesJsonPath, 'utf8').toString()); // invalid JSON or permission issue can happen here
        }
        catch (error) {
            backups = Object.create(null);
        }
        // Ensure folderWorkspaces is a string[]
        if (backups.folderWorkspaces) {
            var fws = backups.folderWorkspaces;
            if (!Array.isArray(fws) || fws.some(function (f) { return typeof f !== 'string'; })) {
                backups.folderWorkspaces = [];
            }
        }
        else {
            backups.folderWorkspaces = [];
        }
        // Ensure emptyWorkspaces is a string[]
        if (backups.emptyWorkspaces) {
            var fws = backups.emptyWorkspaces;
            if (!Array.isArray(fws) || fws.some(function (f) { return typeof f !== 'string'; })) {
                backups.emptyWorkspaces = [];
            }
        }
        else {
            backups.emptyWorkspaces = [];
        }
        this.backups = backups;
        // Validate backup workspaces
        this.validateBackupWorkspaces(backups);
    };
    BackupMainService.prototype.sanitizeFolderWorkspaces = function (backups) {
        var _this = this;
        // Merge duplicates for folder workspaces, don't worry about cleaning them up as they will
        // be removed when there are no backups.
        backups.folderWorkspaces = arrays.distinct(backups.folderWorkspaces.map(function (w) { return _this.sanitizePath(w); }));
    };
    BackupMainService.prototype.validateBackupWorkspaces = function (backups) {
        var _this = this;
        var staleBackupWorkspaces = [];
        this.sanitizeFolderWorkspaces(backups);
        backups.folderWorkspaces.forEach(function (workspacePath) {
            var backupPath = path.join(_this.backupHome, _this.getWorkspaceHash(workspacePath));
            var hasBackups = _this.hasBackupsSync(backupPath);
            var missingWorkspace = hasBackups && !fs.existsSync(workspacePath);
            // If the folder has no backups, make sure to delete it
            // If the folder has backups, but the target workspace is missing, convert backups to empty ones
            if (!hasBackups || missingWorkspace) {
                var backupWorkspace = _this.sanitizePath(workspacePath);
                staleBackupWorkspaces.push({ workspaceIdentifier: uri_1.default.file(backupWorkspace).fsPath, backupPath: backupPath, isEmptyWorkspace: false });
                if (missingWorkspace) {
                    var identifier = _this.pushBackupPathsSync(_this.getRandomEmptyWorkspaceId(), true /* is empty workspace */);
                    var newEmptyWorkspaceBackupPath = path.join(path.dirname(backupPath), identifier);
                    try {
                        fs.renameSync(backupPath, newEmptyWorkspaceBackupPath);
                    }
                    catch (ex) {
                        console.error("Backup: Could not rename backup folder for missing workspace: " + ex.toString());
                        _this.removeBackupPathSync(identifier, true);
                    }
                }
            }
        });
        backups.emptyWorkspaces.forEach(function (backupFolder) {
            var backupPath = path.join(_this.backupHome, backupFolder);
            if (!_this.hasBackupsSync(backupPath)) {
                staleBackupWorkspaces.push({ workspaceIdentifier: backupFolder, backupPath: backupPath, isEmptyWorkspace: true });
            }
        });
        staleBackupWorkspaces.forEach(function (staleBackupWorkspace) {
            var backupPath = staleBackupWorkspace.backupPath, workspaceIdentifier = staleBackupWorkspace.workspaceIdentifier, isEmptyWorkspace = staleBackupWorkspace.isEmptyWorkspace;
            try {
                extfs.delSync(backupPath);
            }
            catch (ex) {
                console.error("Backup: Could not delete stale backup: " + ex.toString());
            }
            _this.removeBackupPathSync(workspaceIdentifier, isEmptyWorkspace);
        });
    };
    BackupMainService.prototype.hasBackupsSync = function (backupPath) {
        try {
            var backupSchemas = extfs.readdirSync(backupPath);
            if (backupSchemas.length === 0) {
                return false; // empty backups
            }
            return backupSchemas.some(function (backupSchema) {
                try {
                    return extfs.readdirSync(path.join(backupPath, backupSchema)).length > 0;
                }
                catch (error) {
                    return false; // invalid folder
                }
            });
        }
        catch (error) {
            return false; // backup path does not exist
        }
    };
    BackupMainService.prototype.saveSync = function () {
        try {
            // The user data directory must exist so only the Backup directory needs to be checked.
            if (!fs.existsSync(this.backupHome)) {
                fs.mkdirSync(this.backupHome);
            }
            fs.writeFileSync(this.workspacesJsonPath, JSON.stringify(this.backups));
        }
        catch (ex) {
            console.error("Backup: Could not save workspaces.json: " + ex.toString());
        }
    };
    BackupMainService.prototype.getRandomEmptyWorkspaceId = function () {
        return (Date.now() + Math.round(Math.random() * 1000)).toString();
    };
    BackupMainService.prototype.sanitizePath = function (p) {
        return platform.isLinux ? p : p.toLowerCase();
    };
    BackupMainService.prototype.getWorkspaceHash = function (workspacePath) {
        return crypto.createHash('md5').update(this.sanitizePath(workspacePath)).digest('hex');
    };
    return BackupMainService;
}());
BackupMainService = __decorate([
    __param(0, environment_1.IEnvironmentService)
], BackupMainService);
exports.BackupMainService = BackupMainService;
