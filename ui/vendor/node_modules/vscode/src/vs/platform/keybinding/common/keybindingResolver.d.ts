import { SimpleKeybinding, Keybinding } from 'vs/base/common/keyCodes';
import { ISimplifiedPlatform } from 'vs/platform/keybinding/common/keybindingLabels';
import { IKeybindingItem, IUserFriendlyKeybinding } from 'vs/platform/keybinding/common/keybinding';
import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
export interface IResolveResult {
    enterChord: SimpleKeybinding;
    commandId: string;
    commandArgs: any;
}
export interface IBoundCommands {
    [commandId: string]: boolean;
}
export declare class NormalizedKeybindingItem {
    _normalizedKeybindingItemBrand: void;
    readonly keybinding: Keybinding;
    readonly command: string;
    readonly actualCommand: string;
    readonly commandArgs: any;
    readonly when: ContextKeyExpr;
    readonly isDefault: boolean;
    static fromKeybindingItem(source: IKeybindingItem, isDefault: boolean): NormalizedKeybindingItem;
    constructor(keybinding: Keybinding, command: string, commandArgs: any, when: ContextKeyExpr, isDefault: boolean);
}
export declare class KeybindingResolver {
    private _defaultKeybindings;
    private _defaultBoundCommands;
    private _map;
    private _chords;
    private _lookupMap;
    /**
     * The value contains the keybinding or first part of a chord
     */
    private _lookupMapUnreachable;
    private _shouldWarnOnConflict;
    constructor(defaultKeybindings: NormalizedKeybindingItem[], overrides: NormalizedKeybindingItem[], shouldWarnOnConflict?: boolean);
    private static _isTargetedForRemoval(defaultKb, keybinding, command, when);
    static combine(defaults: NormalizedKeybindingItem[], rawOverrides: NormalizedKeybindingItem[]): NormalizedKeybindingItem[];
    private _addKeyPress(keypress, entry, item);
    /**
     * Returns true if `a` is completely covered by `b`.
     * Returns true if `b` is a more relaxed `a`.
     * Return true if (`a` === true implies `b` === true).
     */
    static whenIsEntirelyIncluded(inNormalizedForm: boolean, a: ContextKeyExpr, b: ContextKeyExpr): boolean;
    private static _push(map, key, value);
    private static _read(map, key);
    private _addToLookupMap(item);
    getDefaultBoundCommands(): IBoundCommands;
    getDefaultKeybindings(): string;
    lookupKeybinding(commandId: string): Keybinding[];
    resolve(context: any, currentChord: SimpleKeybinding, keypress: SimpleKeybinding): IResolveResult;
    private _findCommand(context, matches);
    static contextMatchesRules(context: any, rules: ContextKeyExpr): boolean;
}
export declare class OutputBuilder {
    private _lines;
    private _currentLine;
    write(str: string): void;
    writeLine(str?: string): void;
    toString(): string;
}
export declare class IOSupport {
    static writeKeybindingItem(out: OutputBuilder, item: NormalizedKeybindingItem): void;
    static readKeybindingItem(input: IUserFriendlyKeybinding, index: number): IKeybindingItem;
    static writeKeybinding(keybinding: Keybinding, Platform?: ISimplifiedPlatform): string;
    static readKeybinding(input: string, Platform?: ISimplifiedPlatform): number;
}
