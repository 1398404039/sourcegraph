/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var uri_1 = require('vs/base/common/uri');
var winjs = require('vs/base/common/winjs.base');
var beautifyHTML = require('vs/languages/lib/common/beautify-html');
var htmlTags = require('vs/languages/html/common/htmlTags');
var network = require('vs/base/common/network');
var modes = require('vs/editor/common/modes');
var strings = require('vs/base/common/strings');
var resourceService_1 = require('vs/editor/common/services/resourceService');
var htmlScanner_1 = require('vs/languages/html/common/htmlScanner');
var htmlTokenTypes_1 = require('vs/languages/html/common/htmlTokenTypes');
var htmlEmptyTagsShared_1 = require('vs/languages/html/common/htmlEmptyTagsShared');
var suggestSupport_1 = require('vs/editor/common/modes/supports/suggestSupport');
var paths = require('vs/base/common/paths');
var LinkDetectionState;
(function (LinkDetectionState) {
    LinkDetectionState[LinkDetectionState["LOOKING_FOR_HREF_OR_SRC"] = 1] = "LOOKING_FOR_HREF_OR_SRC";
    LinkDetectionState[LinkDetectionState["AFTER_HREF_OR_SRC"] = 2] = "AFTER_HREF_OR_SRC";
})(LinkDetectionState || (LinkDetectionState = {}));
var HTMLWorker = (function () {
    function HTMLWorker(modeId, resourceService) {
        this._modeId = modeId;
        this.resourceService = resourceService;
        this._tagProviders = [];
        this._tagProviders.push(htmlTags.getHTML5TagProvider());
        this.addCustomTagProviders(this._tagProviders);
        this._providerConfiguration = null;
    }
    HTMLWorker.prototype.addCustomTagProviders = function (providers) {
        providers.push(htmlTags.getAngularTagProvider());
        providers.push(htmlTags.getIonicTagProvider());
    };
    HTMLWorker.prototype.getTagProviders = function () {
        var _this = this;
        if (this._modeId !== 'html' || !this._providerConfiguration) {
            return this._tagProviders;
        }
        return this._tagProviders.filter(function (p) { return !!_this._providerConfiguration[p.getId()]; });
    };
    HTMLWorker.prototype.provideDocumentRangeFormattingEdits = function (resource, range, options) {
        return this.formatHTML(resource, range, options);
    };
    HTMLWorker.prototype.formatHTML = function (resource, range, options) {
        var model = this.resourceService.get(resource);
        var value = range ? model.getValueInRange(range) : model.getValue();
        var htmlOptions = {
            indent_size: options.insertSpaces ? options.tabSize : 1,
            indent_char: options.insertSpaces ? ' ' : '\t',
            wrap_line_length: this.getFormatOption('wrapLineLength', 120),
            unformatted: this.getTagsFormatOption('unformatted', void 0),
            indent_inner_html: this.getFormatOption('indentInnerHtml', false),
            preserve_newlines: this.getFormatOption('preserveNewLines', false),
            max_preserve_newlines: this.getFormatOption('maxPreserveNewLines', void 0),
            indent_handlebars: this.getFormatOption('indentHandlebars', false),
            end_with_newline: this.getFormatOption('endWithNewline', false),
            extra_liners: this.getTagsFormatOption('extraLiners', void 0),
        };
        var result = beautifyHTML.html_beautify(value, htmlOptions);
        return winjs.TPromise.as([{
                range: range,
                text: result
            }]);
    };
    HTMLWorker.prototype.getFormatOption = function (key, dflt) {
        if (this._formatSettings && this._formatSettings.hasOwnProperty(key)) {
            var value = this._formatSettings[key];
            if (value !== null) {
                return value;
            }
        }
        return dflt;
    };
    HTMLWorker.prototype.getTagsFormatOption = function (key, dflt) {
        var list = this.getFormatOption(key, null);
        if (typeof list === 'string') {
            if (list.length > 0) {
                return list.split(',').map(function (t) { return t.trim().toLowerCase(); });
            }
            return [];
        }
        return dflt;
    };
    HTMLWorker.prototype._doConfigure = function (options) {
        this._formatSettings = options && options.format;
        if (options && options.suggest) {
            this._providerConfiguration = options.suggest;
        }
        return winjs.TPromise.as(null);
    };
    HTMLWorker.prototype.findMatchingOpenTag = function (scanner) {
        var closedTags = {};
        var tagClosed = false;
        while (scanner.scanBack()) {
            if (htmlTokenTypes_1.isTag(scanner.getTokenType()) && !tagClosed) {
                var tag = scanner.getTokenContent();
                scanner.scanBack();
                if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_END) {
                    closedTags[tag] = (closedTags[tag] || 0) + 1;
                }
                else if (!htmlEmptyTagsShared_1.isEmptyElement(tag)) {
                    if (closedTags[tag]) {
                        closedTags[tag]--;
                    }
                    else {
                        return tag;
                    }
                }
            }
            else if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                tagClosed = scanner.getTokenContent() === '/>';
            }
        }
        return null;
    };
    HTMLWorker.prototype.collectTagSuggestions = function (scanner, position, suggestions) {
        var _this = this;
        var model = scanner.getModel();
        var currentLine = model.getLineContent(position.lineNumber);
        var contentAfter = currentLine.substr(position.column - 1);
        var closeTag = isWhiteSpace(contentAfter) || strings.startsWith(contentAfter, '<') ? '>' : '';
        var collectClosingTagSuggestion = function (overwriteBefore) {
            var endPosition = scanner.getTokenPosition();
            var matchingTag = _this.findMatchingOpenTag(scanner);
            if (matchingTag) {
                var suggestion = {
                    label: '/' + matchingTag,
                    insertText: '/' + matchingTag + closeTag,
                    overwriteBefore: overwriteBefore,
                    type: 'property'
                };
                suggestions.suggestions.push(suggestion);
                // use indent from start tag
                var startPosition = scanner.getTokenPosition();
                if (endPosition.lineNumber !== startPosition.lineNumber) {
                    var startIndent = model.getLineContent(startPosition.lineNumber).substring(0, startPosition.column - 1);
                    var endIndent = model.getLineContent(endPosition.lineNumber).substring(0, endPosition.column - 1);
                    if (isWhiteSpace(startIndent) && isWhiteSpace(endIndent)) {
                        suggestion.overwriteBefore = position.column - 1; // replace from start of line
                        suggestion.insertText = startIndent + '</' + matchingTag + closeTag;
                        suggestion.filterText = endIndent + '</' + matchingTag + closeTag;
                    }
                }
                return true;
            }
            return false;
        };
        if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_END && scanner.getTokenRange().endColumn === position.column) {
            var hasClose = collectClosingTagSuggestion(suggestions.currentWord.length + 1);
            if (!hasClose) {
                this.getTagProviders().forEach(function (provider) {
                    provider.collectTags(function (tag, label) {
                        suggestions.suggestions.push({
                            label: '/' + tag,
                            overwriteBefore: suggestions.currentWord.length + 1,
                            insertText: '/' + tag + closeTag,
                            type: 'property',
                            documentation: label,
                            filterText: '</' + tag + closeTag
                        });
                    });
                });
            }
        }
        else {
            collectClosingTagSuggestion(suggestions.currentWord.length);
            this.getTagProviders().forEach(function (provider) {
                provider.collectTags(function (tag, label) {
                    suggestions.suggestions.push({
                        label: tag,
                        insertText: tag,
                        type: 'property',
                        documentation: label,
                        overwriteBefore: suggestions.currentWord.length
                    });
                });
            });
        }
    };
    HTMLWorker.prototype.collectContentSuggestions = function (suggestions) {
        // disable the simple snippets in favor of the emmet templates
    };
    HTMLWorker.prototype.collectAttributeSuggestions = function (scanner, suggestions) {
        var parentTag = null;
        do {
            if (htmlTokenTypes_1.isTag(scanner.getTokenType())) {
                parentTag = scanner.getTokenContent();
                break;
            }
            if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                break;
            }
        } while (scanner.scanBack());
        this.getTagProviders().forEach(function (provider) {
            provider.collectAttributes(parentTag, function (attribute, type) {
                var codeSnippet = attribute;
                if (type !== 'v') {
                    codeSnippet = codeSnippet + '="{{}}"';
                }
                suggestions.suggestions.push({
                    label: attribute,
                    insertText: codeSnippet,
                    type: type === 'handler' ? 'function' : 'value',
                    overwriteBefore: suggestions.currentWord.length
                });
            });
        });
    };
    HTMLWorker.prototype.collectAttributeValueSuggestions = function (scanner, suggestions) {
        var needsQuotes = scanner.getTokenType() === htmlTokenTypes_1.DELIM_ASSIGN;
        var attribute = null;
        var parentTag = null;
        while (scanner.scanBack()) {
            if (scanner.getTokenType() === htmlTokenTypes_1.ATTRIB_NAME) {
                attribute = scanner.getTokenContent();
                break;
            }
        }
        while (scanner.scanBack()) {
            if (htmlTokenTypes_1.isTag(scanner.getTokenType())) {
                parentTag = scanner.getTokenContent();
                break;
            }
            if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                return;
            }
        }
        this.getTagProviders().forEach(function (provider) {
            provider.collectValues(parentTag, attribute, function (value) {
                suggestions.suggestions.push({
                    label: value,
                    insertText: needsQuotes ? '"' + value + '"' : value,
                    type: 'unit',
                    overwriteBefore: suggestions.currentWord.length
                });
            });
        });
    };
    HTMLWorker.prototype.provideCompletionItems = function (resource, position) {
        var model = this.resourceService.get(resource);
        var modeIdAtPosition = model.getModeIdAtPosition(position.lineNumber, position.column);
        if (modeIdAtPosition === this._modeId) {
            return this.suggestHTML(resource, position);
        }
    };
    HTMLWorker.prototype.suggestHTML = function (resource, position) {
        return this.doSuggest(resource, position).then(function (value) { return suggestSupport_1.filterSuggestions(value); });
    };
    HTMLWorker.prototype.doSuggest = function (resource, position) {
        var model = this.resourceService.get(resource), currentWord = model.getWordUntilPosition(position).word;
        var suggestions = {
            currentWord: currentWord,
            suggestions: [],
        };
        var scanner = htmlScanner_1.getScanner(model, position);
        switch (scanner.getTokenType()) {
            case htmlTokenTypes_1.DELIM_START:
            case htmlTokenTypes_1.DELIM_END:
                if (scanner.isOpenBrace()) {
                    this.collectTagSuggestions(scanner, position, suggestions);
                }
                else {
                    this.collectContentSuggestions(suggestions);
                }
                break;
            case htmlTokenTypes_1.ATTRIB_NAME:
                this.collectAttributeSuggestions(scanner, suggestions);
                break;
            case htmlTokenTypes_1.ATTRIB_VALUE:
                this.collectAttributeValueSuggestions(scanner, suggestions);
                break;
            case htmlTokenTypes_1.DELIM_ASSIGN:
                if (scanner.isAtTokenEnd()) {
                    this.collectAttributeValueSuggestions(scanner, suggestions);
                }
                break;
            case '':
                if (isWhiteSpace(scanner.getTokenContent()) && scanner.scanBack()) {
                    switch (scanner.getTokenType()) {
                        case htmlTokenTypes_1.ATTRIB_VALUE:
                        case htmlTokenTypes_1.ATTRIB_NAME:
                            this.collectAttributeSuggestions(scanner, suggestions);
                            break;
                        case htmlTokenTypes_1.DELIM_ASSIGN:
                            this.collectAttributeValueSuggestions(scanner, suggestions);
                            break;
                        case htmlTokenTypes_1.DELIM_START:
                        case htmlTokenTypes_1.DELIM_END:
                            if (scanner.isOpenBrace()) {
                                this.collectTagSuggestions(scanner, position, suggestions);
                            }
                            else {
                                this.collectContentSuggestions(suggestions);
                            }
                            break;
                        default:
                            if (htmlTokenTypes_1.isTag(scanner.getTokenType())) {
                                this.collectAttributeSuggestions(scanner, suggestions);
                            }
                    }
                }
                else {
                    this.collectContentSuggestions(suggestions);
                }
                break;
            default:
                if (htmlTokenTypes_1.isTag(scanner.getTokenType())) {
                    scanner.scanBack(); // one back to the end/start bracket
                    this.collectTagSuggestions(scanner, position, suggestions);
                }
        }
        return winjs.TPromise.as(suggestions);
    };
    HTMLWorker.prototype.findMatchingBracket = function (tagname, scanner) {
        if (htmlEmptyTagsShared_1.isEmptyElement(tagname)) {
            return null;
        }
        var tagCount = 0;
        scanner.scanBack(); // one back to the end/start bracket
        if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_END) {
            // find the opening tag
            var tagClosed = false;
            while (scanner.scanBack()) {
                if (htmlTokenTypes_1.isTag(scanner.getTokenType()) && scanner.getTokenContent() === tagname && !tagClosed) {
                    var range = scanner.getTokenRange();
                    scanner.scanBack(); // one back to the end/start bracket
                    if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                        if (tagCount === 0) {
                            return range;
                        }
                        else {
                            tagCount--;
                        }
                    }
                    else {
                        tagCount++;
                    }
                }
                else if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                    tagClosed = scanner.getTokenContent() === '/>';
                }
            }
        }
        else {
            var isTagEnd = false;
            while (scanner.scanForward()) {
                if (htmlTokenTypes_1.isTag(scanner.getTokenType()) && scanner.getTokenContent() === tagname) {
                    if (!isTagEnd) {
                        scanner.scanForward();
                        if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START && scanner.getTokenContent() === '/>') {
                            if (tagCount <= 0) {
                                return null;
                            }
                        }
                        else {
                            tagCount++;
                        }
                    }
                    else {
                        tagCount--;
                        if (tagCount <= 0) {
                            return scanner.getTokenRange();
                        }
                    }
                }
                else if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_START) {
                    isTagEnd = false;
                }
                else if (scanner.getTokenType() === htmlTokenTypes_1.DELIM_END) {
                    isTagEnd = true;
                }
            }
        }
        return null;
    };
    HTMLWorker.prototype.provideDocumentHighlights = function (resource, position, strict) {
        if (strict === void 0) { strict = false; }
        var model = this.resourceService.get(resource), wordAtPosition = model.getWordAtPosition(position), result = [];
        var scanner = htmlScanner_1.getScanner(model, position);
        if (htmlTokenTypes_1.isTag(scanner.getTokenType())) {
            var tagname = scanner.getTokenContent();
            result.push({
                range: scanner.getTokenRange(),
                kind: modes.DocumentHighlightKind.Read
            });
            var range = this.findMatchingBracket(tagname, scanner);
            if (range) {
                result.push({
                    range: range,
                    kind: modes.DocumentHighlightKind.Read
                });
            }
        }
        else {
            if (wordAtPosition) {
                var results = model.findMatches(wordAtPosition.word, false, false, true, true);
                for (var i = 0, len = results.length; i < len; i++) {
                    result.push({
                        range: results[i],
                        kind: modes.DocumentHighlightKind.Read
                    });
                }
            }
        }
        return winjs.TPromise.as(result);
    };
    HTMLWorker._stripQuotes = function (url) {
        return url
            .replace(/^'([^']+)'$/, function (substr, match1) { return match1; })
            .replace(/^"([^"]+)"$/, function (substr, match1) { return match1; });
    };
    HTMLWorker._getWorkspaceUrl = function (modelAbsoluteUri, rootAbsoluteUri, tokenContent) {
        tokenContent = HTMLWorker._stripQuotes(tokenContent);
        if (/^\s*javascript\:/i.test(tokenContent) || /^\s*\#/i.test(tokenContent)) {
            return null;
        }
        if (/^\s*https?:\/\//i.test(tokenContent) || /^\s*file:\/\//i.test(tokenContent)) {
            // Absolute link that needs no treatment
            return tokenContent.replace(/^\s*/g, '');
        }
        if (/^\s*\/\//i.test(tokenContent)) {
            // Absolute link (that does not name the protocol)
            var pickedScheme = network.Schemas.http;
            if (modelAbsoluteUri.scheme === network.Schemas.https) {
                pickedScheme = network.Schemas.https;
            }
            return pickedScheme + ':' + tokenContent.replace(/^\s*/g, '');
        }
        var modelPath = paths.dirname(modelAbsoluteUri.path);
        var alternativeResultPath = null;
        if (tokenContent.length > 0 && tokenContent.charAt(0) === '/') {
            alternativeResultPath = tokenContent;
        }
        else {
            alternativeResultPath = paths.join(modelPath, tokenContent);
            alternativeResultPath = alternativeResultPath.replace(/^(\/\.\.)+/, '');
        }
        var potentialResult = modelAbsoluteUri.with({ path: alternativeResultPath }).toString();
        var rootAbsoluteUrlStr = (rootAbsoluteUri ? rootAbsoluteUri.toString() : null);
        if (rootAbsoluteUrlStr && strings.startsWith(modelAbsoluteUri.toString(), rootAbsoluteUrlStr)) {
            // The `rootAbsoluteUrl` is set and matches our current model
            // We need to ensure that this `potentialResult` does not escape `rootAbsoluteUrl`
            var commonPrefixLength = strings.commonPrefixLength(rootAbsoluteUrlStr, potentialResult);
            if (strings.endsWith(rootAbsoluteUrlStr, '/')) {
                commonPrefixLength = potentialResult.lastIndexOf('/', commonPrefixLength) + 1;
            }
            return rootAbsoluteUrlStr + potentialResult.substr(commonPrefixLength);
        }
        return potentialResult;
    };
    HTMLWorker.prototype.createLink = function (modelAbsoluteUrl, rootAbsoluteUrl, tokenContent, lineNumber, startColumn, endColumn) {
        var workspaceUrl = HTMLWorker._getWorkspaceUrl(modelAbsoluteUrl, rootAbsoluteUrl, tokenContent);
        if (!workspaceUrl) {
            return null;
        }
        //		console.info('workspaceUrl: ' + workspaceUrl);
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: startColumn,
                endLineNumber: lineNumber,
                endColumn: endColumn
            },
            url: workspaceUrl
        };
    };
    HTMLWorker.prototype._computeHTMLLinks = function (model, modelAbsoluteUrl, workspaceResource) {
        var lineCount = model.getLineCount(), newLinks = [], state = LinkDetectionState.LOOKING_FOR_HREF_OR_SRC, lineNumber, lineContent, lineContentLength, tokens, tokenType, tokensLength, i, nextTokenEndIndex, tokenContent, link;
        var rootAbsoluteUrl = null;
        if (workspaceResource) {
            // The workspace can be null in the no folder opened case
            var strRootAbsoluteUrl = String(workspaceResource);
            if (strRootAbsoluteUrl.charAt(strRootAbsoluteUrl.length - 1) === '/') {
                rootAbsoluteUrl = uri_1.default.parse(strRootAbsoluteUrl);
            }
            else {
                rootAbsoluteUrl = uri_1.default.parse(strRootAbsoluteUrl + '/');
            }
        }
        for (lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
            lineContent = model.getLineContent(lineNumber);
            lineContentLength = lineContent.length;
            tokens = model.getLineTokens(lineNumber);
            for (i = 0, tokensLength = tokens.getTokenCount(); i < tokensLength; i++) {
                tokenType = tokens.getTokenType(i);
                switch (tokenType) {
                    case htmlTokenTypes_1.DELIM_ASSIGN:
                    case '':
                        break;
                    case htmlTokenTypes_1.ATTRIB_NAME:
                        nextTokenEndIndex = tokens.getTokenEndOffset(i);
                        tokenContent = lineContent.substring(tokens.getTokenStartOffset(i), nextTokenEndIndex).toLowerCase();
                        if (tokenContent === 'src' || tokenContent === 'href') {
                            state = LinkDetectionState.AFTER_HREF_OR_SRC;
                        }
                        else {
                            state = LinkDetectionState.LOOKING_FOR_HREF_OR_SRC;
                        }
                        break;
                    case htmlTokenTypes_1.ATTRIB_VALUE:
                        if (state === LinkDetectionState.AFTER_HREF_OR_SRC) {
                            nextTokenEndIndex = tokens.getTokenEndOffset(i);
                            tokenContent = lineContent.substring(tokens.getTokenStartOffset(i), nextTokenEndIndex);
                            link = this.createLink(modelAbsoluteUrl, rootAbsoluteUrl, tokenContent, lineNumber, tokens.getTokenStartOffset(i) + 2, nextTokenEndIndex);
                            if (link) {
                                newLinks.push(link);
                            }
                            state = LinkDetectionState.LOOKING_FOR_HREF_OR_SRC;
                        }
                    default:
                        if (htmlTokenTypes_1.isTag(tokenType)) {
                            state = LinkDetectionState.LOOKING_FOR_HREF_OR_SRC;
                        }
                        else if (state === LinkDetectionState.AFTER_HREF_OR_SRC) {
                            state = LinkDetectionState.LOOKING_FOR_HREF_OR_SRC;
                        }
                }
            }
        }
        return newLinks;
    };
    HTMLWorker.prototype.provideLinks = function (resource, workspaceResource) {
        var model = this.resourceService.get(resource);
        return winjs.TPromise.as(this._computeHTMLLinks(model, resource, workspaceResource));
    };
    HTMLWorker = __decorate([
        __param(1, resourceService_1.IResourceService)
    ], HTMLWorker);
    return HTMLWorker;
}());
exports.HTMLWorker = HTMLWorker;
function isWhiteSpace(s) {
    return /^\s*$/.test(s);
}
