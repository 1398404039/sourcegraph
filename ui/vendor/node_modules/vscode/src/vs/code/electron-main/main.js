/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var electron_1 = require("electron");
var objects_1 = require("vs/base/common/objects");
var platform = require("vs/base/common/platform");
var argv_1 = require("vs/platform/environment/node/argv");
var pfs_1 = require("vs/base/node/pfs");
var paths_1 = require("vs/code/electron-main/paths");
var windows_1 = require("vs/code/common/windows");
var windows_2 = require("vs/code/electron-main/windows");
var windows_3 = require("vs/platform/windows/common/windows");
var windowsIpc_1 = require("vs/platform/windows/common/windowsIpc");
var windowsService_1 = require("vs/platform/windows/electron-main/windowsService");
var lifecycle_1 = require("vs/code/electron-main/lifecycle");
var menus_1 = require("vs/code/electron-main/menus");
var shellEnv_1 = require("vs/code/electron-main/shellEnv");
var update_1 = require("vs/platform/update/common/update");
var updateIpc_1 = require("vs/platform/update/common/updateIpc");
var updateService_1 = require("vs/platform/update/electron-main/updateService");
var ipc_electron_main_1 = require("vs/base/parts/ipc/electron-main/ipc.electron-main");
var ipc_net_1 = require("vs/base/parts/ipc/node/ipc.net");
var winjs_base_1 = require("vs/base/common/winjs.base");
var gitIpc_1 = require("vs/workbench/parts/git/common/gitIpc");
var askpassService_1 = require("vs/workbench/parts/git/electron-main/askpassService");
var sharedProcess_1 = require("vs/code/electron-main/sharedProcess");
var launch_1 = require("./launch");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var instantiationService_1 = require("vs/platform/instantiation/common/instantiationService");
var serviceCollection_1 = require("vs/platform/instantiation/common/serviceCollection");
var descriptors_1 = require("vs/platform/instantiation/common/descriptors");
var log_1 = require("vs/code/electron-main/log");
var storage_1 = require("vs/code/electron-main/storage");
var backup_1 = require("vs/platform/backup/common/backup");
var backupIpc_1 = require("vs/platform/backup/common/backupIpc");
var backupMainService_1 = require("vs/platform/backup/electron-main/backupMainService");
var environment_1 = require("vs/platform/environment/common/environment");
var environmentService_1 = require("vs/platform/environment/node/environmentService");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var configurationService_1 = require("vs/platform/configuration/node/configurationService");
var request_1 = require("vs/platform/request/node/request");
var requestService_1 = require("vs/platform/request/electron-main/requestService");
var url_1 = require("vs/platform/url/common/url");
var urlIpc_1 = require("vs/platform/url/common/urlIpc");
var urlService_1 = require("vs/platform/url/electron-main/urlService");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var telemetryUtils_1 = require("vs/platform/telemetry/common/telemetryUtils");
var telemetryIpc_1 = require("vs/platform/telemetry/common/telemetryIpc");
var telemetryService_1 = require("vs/platform/telemetry/common/telemetryService");
var commonProperties_1 = require("vs/platform/telemetry/node/commonProperties");
var ipc_1 = require("vs/base/parts/ipc/common/ipc");
var product_1 = require("vs/platform/node/product");
var package_1 = require("vs/platform/node/package");
var fs = require("original-fs");
electron_1.ipcMain.on('vscode:fetchShellEnv', function (event, windowId) {
    var win = electron_1.BrowserWindow.fromId(windowId);
    shellEnv_1.getShellEnvironment().then(function (shellEnv) {
        win.webContents.send('vscode:acceptShellEnv', shellEnv);
    }, function (err) {
        win.webContents.send('vscode:acceptShellEnv', {});
        console.error('Error fetching shell env', err);
    });
});
function quit(accessor, errorOrMessage) {
    var logService = accessor.get(log_1.ILogService);
    var exitCode = 0;
    if (typeof errorOrMessage === 'string') {
        logService.log(errorOrMessage);
    }
    else if (errorOrMessage) {
        exitCode = 1; // signal error to the outside
        if (errorOrMessage.stack) {
            console.error(errorOrMessage.stack);
        }
        else {
            console.error('Startup error: ' + errorOrMessage.toString());
        }
    }
    process.exit(exitCode); // in main, process.exit === app.exit
}
// TODO@Joao wow this is huge, clean up!
function main(accessor, mainIpcServer, userEnv) {
    var instantiationService = accessor.get(instantiation_1.IInstantiationService);
    var logService = accessor.get(log_1.ILogService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    var lifecycleService = accessor.get(lifecycle_1.ILifecycleService);
    var configurationService = accessor.get(configuration_1.IConfigurationService);
    var storageService = accessor.get(storage_1.IStorageService);
    var windowsMainService;
    // We handle uncaught exceptions here to prevent electron from opening a dialog to the user
    process.on('uncaughtException', function (err) {
        if (err) {
            // take only the message and stack property
            var friendlyError = {
                message: err.message,
                stack: err.stack
            };
            // handle on client side
            if (windowsMainService) {
                windowsMainService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));
            }
        }
        console.error('[uncaught exception in main]: ' + err);
        if (err.stack) {
            console.error(err.stack);
        }
    });
    electron_1.ipcMain.on(commonProperties_1.machineIdIpcChannel, function (event, machineId) {
        logService.log('IPC#vscode-machineId');
        storageService.setItem(commonProperties_1.machineIdStorageKey, machineId);
    });
    logService.log('Starting VS Code in verbose mode');
    logService.log("from: " + environmentService.appRoot);
    logService.log('args:', environmentService.args);
    // Setup Windows mutex
    var windowsMutex = null;
    if (platform.isWindows) {
        try {
            var Mutex_1 = require.__$__nodeRequire('windows-mutex').Mutex;
            windowsMutex = new Mutex_1(product_1.default.win32MutexName);
        }
        catch (e) {
        }
    }
    // Register Main IPC services
    var askpassService = new askpassService_1.GitAskpassService();
    var askpassChannel = new gitIpc_1.AskpassChannel(askpassService);
    mainIpcServer.registerChannel('askpass', askpassChannel);
    // Create Electron IPC Server
    var electronIpcServer = new ipc_electron_main_1.Server();
    // Spawn shared process
    var sharedProcess = new sharedProcess_1.SharedProcess(environmentService, userEnv);
    var sharedProcessClient = sharedProcess.whenReady()
        .then(function () { return ipc_net_1.connect(environmentService.sharedIPCHandle, 'main'); });
    // Create a new service collection, because the telemetry service
    // requires a connection to shared process, which was only established
    // now.
    var services = new serviceCollection_1.ServiceCollection();
    services.set(update_1.IUpdateService, new descriptors_1.SyncDescriptor(updateService_1.UpdateService));
    services.set(windows_2.IWindowsMainService, new descriptors_1.SyncDescriptor(windows_2.WindowsManager));
    services.set(windows_3.IWindowsService, new descriptors_1.SyncDescriptor(windowsService_1.WindowsService, sharedProcess));
    services.set(launch_1.ILaunchService, new descriptors_1.SyncDescriptor(launch_1.LaunchService));
    if (environmentService.isBuilt && !environmentService.isExtensionDevelopment && !!product_1.default.enableTelemetry) {
        var channel = ipc_1.getDelayedChannel(sharedProcessClient.then(function (c) { return c.getChannel('telemetryAppender'); }));
        var appender = new telemetryIpc_1.TelemetryAppenderClient(channel);
        var commonProperties = commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version)
            .then(function (result) { return Object.defineProperty(result, 'common.machineId', {
            get: function () { return storageService.getItem(commonProperties_1.machineIdStorageKey); },
            enumerable: true
        }); });
        var piiPaths = [environmentService.appRoot, environmentService.extensionsPath];
        var config = { appender: appender, commonProperties: commonProperties, piiPaths: piiPaths };
        services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, config));
    }
    else {
        services.set(telemetry_1.ITelemetryService, telemetryUtils_1.NullTelemetryService);
    }
    var instantiationService2 = instantiationService.createChild(services);
    instantiationService2.invokeFunction(function (accessor) {
        // TODO@Joao: unfold this
        windowsMainService = accessor.get(windows_2.IWindowsMainService);
        // TODO@Joao: so ugly...
        windowsMainService.onWindowClose(function () {
            if (!platform.isMacintosh && windowsMainService.getWindowCount() === 0) {
                sharedProcess.dispose();
            }
        });
        // Register more Main IPC services
        var launchService = accessor.get(launch_1.ILaunchService);
        var launchChannel = new launch_1.LaunchChannel(launchService);
        mainIpcServer.registerChannel('launch', launchChannel);
        // Register more Electron IPC services
        var updateService = accessor.get(update_1.IUpdateService);
        var updateChannel = new updateIpc_1.UpdateChannel(updateService);
        electronIpcServer.registerChannel('update', updateChannel);
        var urlService = accessor.get(url_1.IURLService);
        var urlChannel = instantiationService2.createInstance(urlIpc_1.URLChannel, urlService);
        electronIpcServer.registerChannel('url', urlChannel);
        var backupService = accessor.get(backup_1.IBackupMainService);
        var backupChannel = instantiationService2.createInstance(backupIpc_1.BackupChannel, backupService);
        electronIpcServer.registerChannel('backup', backupChannel);
        var windowsService = accessor.get(windows_3.IWindowsService);
        var windowsChannel = new windowsIpc_1.WindowsChannel(windowsService);
        electronIpcServer.registerChannel('windows', windowsChannel);
        sharedProcessClient.done(function (client) { return client.registerChannel('windows', windowsChannel); });
        // Make sure we associate the program with the app user model id
        // This will help Windows to associate the running program with
        // any shortcut that is pinned to the taskbar and prevent showing
        // two icons in the taskbar for the same app.
        if (platform.isWindows && product_1.default.win32AppUserModelId) {
            electron_1.app.setAppUserModelId(product_1.default.win32AppUserModelId);
        }
        function dispose() {
            if (mainIpcServer) {
                mainIpcServer.dispose();
                mainIpcServer = null;
            }
            if (windowsMutex) {
                windowsMutex.release();
            }
            configurationService.dispose();
            sharedProcess.dispose();
        }
        // Dispose on app quit
        electron_1.app.on('will-quit', function () {
            logService.log('App#will-quit: disposing resources');
            dispose();
        });
        // Dispose on vscode:exit
        electron_1.ipcMain.on('vscode:exit', function (event, code) {
            logService.log('IPC#vscode:exit', code);
            dispose();
            process.exit(code); // in main, process.exit === app.exit
        });
        // Lifecycle
        lifecycleService.ready();
        // Propagate to clients
        windowsMainService.ready(userEnv);
        // Open our first window
        var context = !!process.env['VSCODE_CLI'] ? windows_1.OpenContext.CLI : windows_1.OpenContext.DESKTOP;
        if (environmentService.args['new-window'] && environmentService.args._.length === 0) {
            windowsMainService.open({ context: context, cli: environmentService.args, forceNewWindow: true, forceEmpty: true, initialStartup: true }); // new window if "-n" was used without paths
        }
        else if (global.macOpenFiles && global.macOpenFiles.length && (!environmentService.args._ || !environmentService.args._.length)) {
            windowsMainService.open({ context: windows_1.OpenContext.DOCK, cli: environmentService.args, pathsToOpen: global.macOpenFiles, initialStartup: true }); // mac: open-file event received on startup
        }
        else {
            windowsMainService.open({ context: context, cli: environmentService.args, forceNewWindow: environmentService.args['new-window'] || (!environmentService.args._.length && environmentService.args['unity-launch']), diffMode: environmentService.args.diff, initialStartup: true }); // default: read paths from cli
        }
        // Install Menu
        instantiationService2.createInstance(menus_1.VSCodeMenu);
        // Jump List
        windowsMainService.updateWindowsJumpList();
        windowsMainService.onRecentPathsChange(function () { return windowsMainService.updateWindowsJumpList(); });
        // Start shared process here
        sharedProcess.spawn();
    });
}
function setupIPC(accessor) {
    var logService = accessor.get(log_1.ILogService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    function allowSetForegroundWindow(service) {
        var promise = winjs_base_1.TPromise.as(null);
        if (platform.isWindows) {
            promise = service.getMainProcessId()
                .then(function (processId) {
                logService.log('Sending some foreground love to the running instance:', processId);
                try {
                    var allowSetForegroundWindow_1 = require.__$__nodeRequire('windows-foreground-love').allowSetForegroundWindow;
                    allowSetForegroundWindow_1(processId);
                }
                catch (e) {
                }
            });
        }
        return promise;
    }
    function setup(retry) {
        return ipc_net_1.serve(environmentService.mainIPCHandle).then(function (server) {
            if (platform.isMacintosh) {
                electron_1.app.dock.show(); // dock might be hidden at this case due to a retry
            }
            return server;
        }, function (err) {
            if (err.code !== 'EADDRINUSE') {
                return winjs_base_1.TPromise.wrapError(err);
            }
            // Since we are the second instance, we do not want to show the dock
            if (platform.isMacintosh) {
                electron_1.app.dock.hide();
            }
            // there's a running instance, let's connect to it
            return ipc_net_1.connect(environmentService.mainIPCHandle, 'main').then(function (client) {
                // Tests from CLI require to be the only instance currently (TODO@Ben support multiple instances and output)
                if (environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break) {
                    var msg = 'Running extension tests from the command line is currently only supported if no other instance of Code is running.';
                    console.error(msg);
                    client.dispose();
                    return winjs_base_1.TPromise.wrapError(msg);
                }
                logService.log('Sending env to running instance...');
                var channel = client.getChannel('launch');
                var service = new launch_1.LaunchChannelClient(channel);
                return allowSetForegroundWindow(service)
                    .then(function () { return service.start(environmentService.args, process.env); })
                    .then(function () { return client.dispose(); })
                    .then(function () { return winjs_base_1.TPromise.wrapError('Sent env to running instance. Terminating...'); });
            }, function (err) {
                if (!retry || platform.isWindows || err.code !== 'ECONNREFUSED') {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                // it happens on Linux and OS X that the pipe is left behind
                // let's delete it, since we can't connect to it
                // and the retry the whole thing
                try {
                    fs.unlinkSync(environmentService.mainIPCHandle);
                }
                catch (e) {
                    logService.log('Fatal error deleting obsolete instance handle', e);
                    return winjs_base_1.TPromise.wrapError(e);
                }
                return setup(false);
            });
        });
    }
    return setup(true);
}
function createPaths(environmentService) {
    var paths = [
        environmentService.appSettingsHome,
        environmentService.extensionsPath,
        environmentService.nodeCachedDataDir
    ];
    return winjs_base_1.TPromise.join(paths.map(function (p) { return pfs_1.mkdirp(p); }));
}
function createServices(args) {
    var services = new serviceCollection_1.ServiceCollection();
    services.set(environment_1.IEnvironmentService, new descriptors_1.SyncDescriptor(environmentService_1.EnvironmentService, args, process.execPath));
    services.set(log_1.ILogService, new descriptors_1.SyncDescriptor(log_1.MainLogService));
    services.set(lifecycle_1.ILifecycleService, new descriptors_1.SyncDescriptor(lifecycle_1.LifecycleService));
    services.set(storage_1.IStorageService, new descriptors_1.SyncDescriptor(storage_1.StorageService));
    services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));
    services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));
    services.set(url_1.IURLService, new descriptors_1.SyncDescriptor(urlService_1.URLService, args['open-url']));
    services.set(backup_1.IBackupMainService, new descriptors_1.SyncDescriptor(backupMainService_1.BackupMainService));
    return new instantiationService_1.InstantiationService(services, true);
}
function start() {
    var args;
    try {
        args = argv_1.parseMainProcessArgv(process.argv);
        args = paths_1.validatePaths(args);
    }
    catch (err) {
        console.error(err.message);
        process.exit(1);
        return;
    }
    var instantiationService = createServices(args);
    return instantiationService.invokeFunction(function (accessor) {
        var environmentService = accessor.get(environment_1.IEnvironmentService);
        var instanceEnv = {
            VSCODE_PID: String(process.pid),
            VSCODE_IPC_HOOK: environmentService.mainIPCHandle,
            VSCODE_NLS_CONFIG: process.env['VSCODE_NLS_CONFIG']
        };
        // Patch `process.env` with the instance's environment
        objects_1.assign(process.env, instanceEnv);
        return instantiationService.invokeFunction(function (a) { return createPaths(a.get(environment_1.IEnvironmentService)); })
            .then(function () { return instantiationService.invokeFunction(setupIPC); })
            .then(function (mainIpcServer) { return instantiationService.invokeFunction(main, mainIpcServer, instanceEnv); });
    }).done(null, function (err) { return instantiationService.invokeFunction(quit, err); });
}
start();
