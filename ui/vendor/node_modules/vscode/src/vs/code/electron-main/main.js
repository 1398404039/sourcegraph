/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var electron_1 = require("electron");
var objects_1 = require("vs/base/common/objects");
var platform = require("vs/base/common/platform");
var argv_1 = require("vs/platform/environment/node/argv");
var pfs_1 = require("vs/base/node/pfs");
var paths_1 = require("vs/code/electron-main/paths");
var windows_1 = require("vs/code/electron-main/windows");
var windows_2 = require("vs/platform/windows/common/windows");
var windowsIpc_1 = require("vs/platform/windows/common/windowsIpc");
var windowsService_1 = require("vs/platform/windows/electron-main/windowsService");
var lifecycle_1 = require("vs/code/electron-main/lifecycle");
var menus_1 = require("vs/code/electron-main/menus");
var update_1 = require("vs/platform/update/common/update");
var updateIpc_1 = require("vs/platform/update/common/updateIpc");
var updateService_1 = require("vs/platform/update/electron-main/updateService");
var ipc_electron_main_1 = require("vs/base/parts/ipc/electron-main/ipc.electron-main");
var ipc_net_1 = require("vs/base/parts/ipc/node/ipc.net");
var winjs_base_1 = require("vs/base/common/winjs.base");
var gitIpc_1 = require("vs/workbench/parts/git/common/gitIpc");
var askpassService_1 = require("vs/workbench/parts/git/electron-main/askpassService");
var sharedProcess_1 = require("vs/code/node/sharedProcess");
var launch_1 = require("./launch");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var instantiationService_1 = require("vs/platform/instantiation/common/instantiationService");
var serviceCollection_1 = require("vs/platform/instantiation/common/serviceCollection");
var descriptors_1 = require("vs/platform/instantiation/common/descriptors");
var log_1 = require("vs/code/electron-main/log");
var storage_1 = require("vs/code/electron-main/storage");
var backup_1 = require("vs/platform/backup/common/backup");
var backupIpc_1 = require("vs/platform/backup/common/backupIpc");
var backupMainService_1 = require("vs/platform/backup/electron-main/backupMainService");
var environment_1 = require("vs/platform/environment/common/environment");
var environmentService_1 = require("vs/platform/environment/node/environmentService");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var configurationService_1 = require("vs/platform/configuration/node/configurationService");
var request_1 = require("vs/platform/request/node/request");
var requestService_1 = require("vs/platform/request/node/requestService");
var uuid_1 = require("vs/base/common/uuid");
var url_1 = require("vs/platform/url/common/url");
var urlIpc_1 = require("vs/platform/url/common/urlIpc");
var urlService_1 = require("vs/platform/url/electron-main/urlService");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var telemetryIpc_1 = require("vs/platform/telemetry/common/telemetryIpc");
var telemetryService_1 = require("vs/platform/telemetry/common/telemetryService");
var commonProperties_1 = require("vs/platform/telemetry/node/commonProperties");
var ipc_1 = require("vs/base/parts/ipc/common/ipc");
var product_1 = require("vs/platform/product");
var package_1 = require("vs/platform/package");
var fs = require("original-fs");
var cp = require("child_process");
function quit(accessor, arg) {
    var logService = accessor.get(log_1.ILogService);
    var exitCode = 0;
    if (typeof arg === 'string') {
        logService.log(arg);
    }
    else {
        exitCode = 1; // signal error to the outside
        if (arg.stack) {
            console.error(arg.stack);
        }
        else {
            console.error('Startup error: ' + arg.toString());
        }
    }
    process.exit(exitCode); // in main, process.exit === app.exit
}
// TODO@Joao wow this is huge, clean up!
function main(accessor, mainIpcServer, userEnv) {
    var instantiationService = accessor.get(instantiation_1.IInstantiationService);
    var logService = accessor.get(log_1.ILogService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    var lifecycleService = accessor.get(lifecycle_1.ILifecycleService);
    var configurationService = accessor.get(configuration_1.IConfigurationService);
    var windowsMainService;
    // We handle uncaught exceptions here to prevent electron from opening a dialog to the user
    process.on('uncaughtException', function (err) {
        if (err) {
            // take only the message and stack property
            var friendlyError = {
                message: err.message,
                stack: err.stack
            };
            // handle on client side
            if (windowsMainService) {
                windowsMainService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));
            }
        }
        console.error('[uncaught exception in main]: ' + err);
        if (err.stack) {
            console.error(err.stack);
        }
    });
    logService.log('Starting VS Code in verbose mode');
    logService.log("from: " + environmentService.appRoot);
    logService.log('args:', environmentService.args);
    // Setup Windows mutex
    var windowsMutex = null;
    if (platform.isWindows) {
        try {
            var Mutex_1 = require.__$__nodeRequire('windows-mutex').Mutex;
            windowsMutex = new Mutex_1(product_1.default.win32MutexName);
        }
        catch (e) {
        }
    }
    // Register Main IPC services
    var askpassService = new askpassService_1.GitAskpassService();
    var askpassChannel = new gitIpc_1.AskpassChannel(askpassService);
    mainIpcServer.registerChannel('askpass', askpassChannel);
    // Create Electron IPC Server
    var electronIpcServer = new ipc_electron_main_1.Server();
    // Spawn shared process
    var initData = { args: environmentService.args };
    var options = {
        allowOutput: !environmentService.isBuilt || environmentService.verbose,
        debugPort: environmentService.isBuilt ? null : 5871
    };
    var sharedProcessDisposable;
    var sharedProcess = sharedProcess_1.spawnSharedProcess(initData, options).then(function (disposable) {
        sharedProcessDisposable = disposable;
        return ipc_net_1.connect(environmentService.sharedIPCHandle, 'main');
    });
    // Create a new service collection, because the telemetry service
    // requires a connection to shared process, which was only established
    // now.
    var services = new serviceCollection_1.ServiceCollection();
    services.set(update_1.IUpdateService, new descriptors_1.SyncDescriptor(updateService_1.UpdateService));
    services.set(windows_1.IWindowsMainService, new descriptors_1.SyncDescriptor(windows_1.WindowsManager));
    services.set(windows_2.IWindowsService, new descriptors_1.SyncDescriptor(windowsService_1.WindowsService));
    services.set(launch_1.ILaunchService, new descriptors_1.SyncDescriptor(launch_1.LaunchService));
    if (environmentService.isBuilt && !environmentService.isExtensionDevelopment && !!product_1.default.enableTelemetry) {
        var channel = ipc_1.getDelayedChannel(sharedProcess.then(function (c) { return c.getChannel('telemetryAppender'); }));
        var appender = new telemetryIpc_1.TelemetryAppenderClient(channel);
        var commonProperties = commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version);
        var piiPaths = [environmentService.appRoot, environmentService.extensionsPath];
        var config = { appender: appender, commonProperties: commonProperties, piiPaths: piiPaths };
        services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, config));
    }
    else {
        services.set(telemetry_1.ITelemetryService, telemetry_1.NullTelemetryService);
    }
    var instantiationService2 = instantiationService.createChild(services);
    instantiationService2.invokeFunction(function (accessor) {
        // TODO@Joao: unfold this
        windowsMainService = accessor.get(windows_1.IWindowsMainService);
        // Register more Main IPC services
        var launchService = accessor.get(launch_1.ILaunchService);
        var launchChannel = new launch_1.LaunchChannel(launchService);
        mainIpcServer.registerChannel('launch', launchChannel);
        // Register more Electron IPC services
        var updateService = accessor.get(update_1.IUpdateService);
        var updateChannel = new updateIpc_1.UpdateChannel(updateService);
        electronIpcServer.registerChannel('update', updateChannel);
        var urlService = accessor.get(url_1.IURLService);
        var urlChannel = instantiationService2.createInstance(urlIpc_1.URLChannel, urlService);
        electronIpcServer.registerChannel('url', urlChannel);
        var backupService = accessor.get(backup_1.IBackupMainService);
        var backupChannel = instantiationService2.createInstance(backupIpc_1.BackupChannel, backupService);
        electronIpcServer.registerChannel('backup', backupChannel);
        var windowsService = accessor.get(windows_2.IWindowsService);
        var windowsChannel = new windowsIpc_1.WindowsChannel(windowsService);
        electronIpcServer.registerChannel('windows', windowsChannel);
        sharedProcess.done(function (client) { return client.registerChannel('windows', windowsChannel); });
        // Make sure we associate the program with the app user model id
        // This will help Windows to associate the running program with
        // any shortcut that is pinned to the taskbar and prevent showing
        // two icons in the taskbar for the same app.
        if (platform.isWindows && product_1.default.win32AppUserModelId) {
            electron_1.app.setAppUserModelId(product_1.default.win32AppUserModelId);
        }
        function dispose() {
            if (mainIpcServer) {
                mainIpcServer.dispose();
                mainIpcServer = null;
            }
            if (sharedProcessDisposable) {
                sharedProcessDisposable.dispose();
            }
            if (windowsMutex) {
                windowsMutex.release();
            }
            configurationService.dispose();
        }
        // Dispose on app quit
        electron_1.app.on('will-quit', function () {
            logService.log('App#will-quit: disposing resources');
            dispose();
        });
        // Dispose on vscode:exit
        electron_1.ipcMain.on('vscode:exit', function (event, code) {
            logService.log('IPC#vscode:exit', code);
            dispose();
            process.exit(code); // in main, process.exit === app.exit
        });
        // Lifecycle
        lifecycleService.ready();
        // Propagate to clients
        windowsMainService.ready(userEnv);
        // Install Menu
        var menu = instantiationService2.createInstance(menus_1.VSCodeMenu);
        menu.ready();
        // Open our first window
        if (environmentService.args['new-window'] && environmentService.args._.length === 0) {
            windowsMainService.open({ cli: environmentService.args, forceNewWindow: true, forceEmpty: true, initialStartup: true }); // new window if "-n" was used without paths
        }
        else if (global.macOpenFiles && global.macOpenFiles.length && (!environmentService.args._ || !environmentService.args._.length)) {
            windowsMainService.open({ cli: environmentService.args, pathsToOpen: global.macOpenFiles, initialStartup: true }); // mac: open-file event received on startup
        }
        else {
            windowsMainService.open({ cli: environmentService.args, forceNewWindow: environmentService.args['new-window'], diffMode: environmentService.args.diff, initialStartup: true }); // default: read paths from cli
        }
    });
}
function setupIPC(accessor) {
    var logService = accessor.get(log_1.ILogService);
    var environmentService = accessor.get(environment_1.IEnvironmentService);
    function allowSetForegroundWindow(service) {
        var promise = winjs_base_1.TPromise.as(null);
        if (platform.isWindows) {
            promise = service.getMainProcessId()
                .then(function (processId) {
                logService.log('Sending some foreground love to the running instance:', processId);
                try {
                    var allowSetForegroundWindow_1 = require.__$__nodeRequire('windows-foreground-love').allowSetForegroundWindow;
                    allowSetForegroundWindow_1(processId);
                }
                catch (e) {
                }
            });
        }
        return promise;
    }
    function setup(retry) {
        return ipc_net_1.serve(environmentService.mainIPCHandle).then(function (server) {
            if (platform.isMacintosh) {
                electron_1.app.dock.show(); // dock might be hidden at this case due to a retry
            }
            return server;
        }, function (err) {
            if (err.code !== 'EADDRINUSE') {
                return winjs_base_1.TPromise.wrapError(err);
            }
            // Since we are the second instance, we do not want to show the dock
            if (platform.isMacintosh) {
                electron_1.app.dock.hide();
            }
            // there's a running instance, let's connect to it
            return ipc_net_1.connect(environmentService.mainIPCHandle, 'main').then(function (client) {
                // Tests from CLI require to be the only instance currently (TODO@Ben support multiple instances and output)
                if (environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break) {
                    var msg = 'Running extension tests from the command line is currently only supported if no other instance of Code is running.';
                    console.error(msg);
                    client.dispose();
                    return winjs_base_1.TPromise.wrapError(msg);
                }
                logService.log('Sending env to running instance...');
                var channel = client.getChannel('launch');
                var service = new launch_1.LaunchChannelClient(channel);
                return allowSetForegroundWindow(service)
                    .then(function () { return service.start(environmentService.args, process.env); })
                    .then(function () { return client.dispose(); })
                    .then(function () { return winjs_base_1.TPromise.wrapError('Sent env to running instance. Terminating...'); });
            }, function (err) {
                if (!retry || platform.isWindows || err.code !== 'ECONNREFUSED') {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                // it happens on Linux and OS X that the pipe is left behind
                // let's delete it, since we can't connect to it
                // and the retry the whole thing
                try {
                    fs.unlinkSync(environmentService.mainIPCHandle);
                }
                catch (e) {
                    logService.log('Fatal error deleting obsolete instance handle', e);
                    return winjs_base_1.TPromise.wrapError(e);
                }
                return setup(false);
            });
        });
    }
    return setup(true);
}
function getUnixShellEnvironment() {
    var promise = new winjs_base_1.TPromise(function (c, e) {
        var runAsNode = process.env['ELECTRON_RUN_AS_NODE'];
        var noAttach = process.env['ELECTRON_NO_ATTACH_CONSOLE'];
        var mark = uuid_1.generateUuid().replace(/-/g, '').substr(0, 12);
        var regex = new RegExp(mark + '(.*)' + mark);
        var env = objects_1.assign({}, process.env, {
            ELECTRON_RUN_AS_NODE: '1',
            ELECTRON_NO_ATTACH_CONSOLE: '1'
        });
        var command = "'" + process.execPath + "' -p '\"" + mark + "\" + JSON.stringify(process.env) + \"" + mark + "\"'";
        var child = cp.spawn(process.env.SHELL, ['-ilc', command], {
            detached: true,
            stdio: ['ignore', 'pipe', process.stderr],
            env: env
        });
        var buffers = [];
        child.on('error', function () { return c({}); });
        child.stdout.on('data', function (b) { return buffers.push(b); });
        child.on('close', function (code, signal) {
            if (code !== 0) {
                return e(new Error('Failed to get environment'));
            }
            var raw = Buffer.concat(buffers).toString('utf8');
            var match = regex.exec(raw);
            var rawStripped = match ? match[1] : '{}';
            try {
                var env_1 = JSON.parse(rawStripped);
                if (runAsNode) {
                    env_1['ELECTRON_RUN_AS_NODE'] = runAsNode;
                }
                else {
                    delete env_1['ELECTRON_RUN_AS_NODE'];
                }
                if (noAttach) {
                    env_1['ELECTRON_NO_ATTACH_CONSOLE'] = noAttach;
                }
                else {
                    delete env_1['ELECTRON_NO_ATTACH_CONSOLE'];
                }
                c(env_1);
            }
            catch (err) {
                e(err);
            }
        });
    });
    // swallow errors
    return promise.then(null, function () { return ({}); });
}
/**
 * We eed to get the environment from a user's shell.
 * This should only be done when Code itself is not launched
 * from within a shell.
 */
function getShellEnvironment() {
    if (process.env['VSCODE_CLI'] === '1') {
        return winjs_base_1.TPromise.as({});
    }
    if (platform.isWindows) {
        return winjs_base_1.TPromise.as({});
    }
    return getUnixShellEnvironment();
}
function createPaths(environmentService) {
    var paths = [
        environmentService.appSettingsHome,
        environmentService.userProductHome,
        environmentService.extensionsPath,
        environmentService.nodeCachedDataDir
    ];
    return winjs_base_1.TPromise.join(paths.map(function (p) { return pfs_1.mkdirp(p); }));
}
function createServices(args) {
    var services = new serviceCollection_1.ServiceCollection();
    services.set(environment_1.IEnvironmentService, new descriptors_1.SyncDescriptor(environmentService_1.EnvironmentService, args, process.execPath));
    services.set(log_1.ILogService, new descriptors_1.SyncDescriptor(log_1.MainLogService));
    services.set(lifecycle_1.ILifecycleService, new descriptors_1.SyncDescriptor(lifecycle_1.LifecycleService));
    services.set(storage_1.IStorageService, new descriptors_1.SyncDescriptor(storage_1.StorageService));
    services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));
    services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));
    services.set(url_1.IURLService, new descriptors_1.SyncDescriptor(urlService_1.URLService, args['open-url']));
    services.set(backup_1.IBackupMainService, new descriptors_1.SyncDescriptor(backupMainService_1.BackupMainService));
    return new instantiationService_1.InstantiationService(services, true);
}
function start() {
    var args;
    try {
        args = argv_1.parseMainProcessArgv(process.argv);
        args = paths_1.validatePaths(args);
    }
    catch (err) {
        console.error(err.message);
        process.exit(1);
        return;
    }
    var instantiationService = createServices(args);
    // On some platforms we need to manually read from the global environment variables
    // and assign them to the process environment (e.g. when doubleclick app on Mac)
    return getShellEnvironment().then(function (shellEnv) {
        // Patch `process.env` with the user's shell environment
        objects_1.assign(process.env, shellEnv);
        return instantiationService.invokeFunction(function (accessor) {
            var environmentService = accessor.get(environment_1.IEnvironmentService);
            var instanceEnv = {
                VSCODE_PID: String(process.pid),
                VSCODE_IPC_HOOK: environmentService.mainIPCHandle,
                VSCODE_SHARED_IPC_HOOK: environmentService.sharedIPCHandle,
                VSCODE_NLS_CONFIG: process.env['VSCODE_NLS_CONFIG']
            };
            // Patch `process.env` with the instance's environment
            objects_1.assign(process.env, instanceEnv);
            // Collect all environment patches to send to other processes
            var env = objects_1.assign({}, shellEnv, instanceEnv);
            return instantiationService.invokeFunction(function (a) { return createPaths(a.get(environment_1.IEnvironmentService)); })
                .then(function () { return instantiationService.invokeFunction(setupIPC); })
                .then(function (mainIpcServer) { return instantiationService.invokeFunction(main, mainIpcServer, env); });
        });
    }).done(null, function (err) { return instantiationService.invokeFunction(quit, err); });
}
start();
