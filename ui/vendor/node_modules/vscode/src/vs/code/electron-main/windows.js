/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var path = require("path");
var fs = require("original-fs");
var platform = require("vs/base/common/platform");
var nls = require("vs/nls");
var paths = require("vs/base/common/paths");
var types = require("vs/base/common/types");
var arrays = require("vs/base/common/arrays");
var objects_1 = require("vs/base/common/objects");
var backup_1 = require("vs/platform/backup/common/backup");
var strings_1 = require("vs/base/common/strings");
var environment_1 = require("vs/platform/environment/common/environment");
var storage_1 = require("vs/code/electron-main/storage");
var window_1 = require("vs/code/electron-main/window");
var electron_1 = require("electron");
var paths_1 = require("vs/code/electron-main/paths");
var lifecycle_1 = require("vs/code/electron-main/lifecycle");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var log_1 = require("vs/code/electron-main/log");
var labels_1 = require("vs/base/common/labels");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var windowsUtils_1 = require("vs/code/node/windowsUtils");
var event_1 = require("vs/base/common/event");
var product_1 = require("vs/platform/node/product");
var windows_1 = require("vs/code/common/windows");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var WindowError;
(function (WindowError) {
    WindowError[WindowError["UNRESPONSIVE"] = 0] = "UNRESPONSIVE";
    WindowError[WindowError["CRASHED"] = 1] = "CRASHED";
})(WindowError || (WindowError = {}));
var ReopenFoldersSetting = {
    ALL: 'all',
    ONE: 'one',
    NONE: 'none'
};
exports.IWindowsMainService = instantiation_1.createDecorator('windowsMainService');
var WindowsManager = (function () {
    function WindowsManager(logService, storageService, environmentService, lifecycleService, backupService, telemetryService, configurationService) {
        this.logService = logService;
        this.storageService = storageService;
        this.environmentService = environmentService;
        this.lifecycleService = lifecycleService;
        this.backupService = backupService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        this._onRecentPathsChange = new event_1.Emitter();
        this.onRecentPathsChange = this._onRecentPathsChange.event;
        this._onWindowReady = new event_1.Emitter();
        this.onWindowReady = this._onWindowReady.event;
        this._onWindowClose = new event_1.Emitter();
        this.onWindowClose = this._onWindowClose.event;
        this._onWindowReload = new event_1.Emitter();
        this.onWindowReload = this._onWindowReload.event;
        this._onPathsOpen = new event_1.Emitter();
        this.onPathsOpen = this._onPathsOpen.event;
    }
    WindowsManager.prototype.ready = function (initialUserEnv) {
        this.registerListeners();
        this.initialUserEnv = initialUserEnv;
        this.windowsState = this.storageService.getItem(WindowsManager.windowsStateStorageKey) || { openedFolders: [] };
    };
    WindowsManager.prototype.registerListeners = function () {
        var _this = this;
        electron_1.app.on('activate', function (event, hasVisibleWindows) {
            _this.logService.log('App#activate');
            // Mac only event: open new window when we get activated
            if (!hasVisibleWindows) {
                _this.openNewWindow(windows_1.OpenContext.DOCK);
            }
        });
        var macOpenFiles = [];
        var runningTimeout = null;
        electron_1.app.on('open-file', function (event, path) {
            _this.logService.log('App#open-file: ', path);
            event.preventDefault();
            // Keep in array because more might come!
            macOpenFiles.push(path);
            // Clear previous handler if any
            if (runningTimeout !== null) {
                clearTimeout(runningTimeout);
                runningTimeout = null;
            }
            // Handle paths delayed in case more are coming!
            runningTimeout = setTimeout(function () {
                _this.open({
                    context: windows_1.OpenContext.DOCK /* can also be opening from finder while app is running */,
                    cli: _this.environmentService.args,
                    pathsToOpen: macOpenFiles,
                    preferNewWindow: true /* dropping on the dock or opening from finder prefers to open in a new window */
                });
                macOpenFiles = [];
                runningTimeout = null;
            }, 100);
        });
        electron_1.ipcMain.on('vscode:workbenchLoaded', function (event, windowId) {
            _this.logService.log('IPC#vscode-workbenchLoaded');
            var win = _this.getWindowById(windowId);
            if (win) {
                win.setReady();
                // Event
                _this._onWindowReady.fire(win);
            }
        });
        electron_1.ipcMain.on('vscode:broadcast', function (event, windowId, target, broadcast) {
            if (broadcast.channel && !types.isUndefinedOrNull(broadcast.payload)) {
                _this.logService.log('IPC#vscode:broadcast', target, broadcast.channel, broadcast.payload);
                // Handle specific events on main side
                _this.onBroadcast(broadcast.channel, broadcast.payload);
                // Send to windows
                if (target) {
                    var otherWindowsWithTarget = WindowsManager.WINDOWS.filter(function (w) { return w.id !== windowId && typeof w.openedWorkspacePath === 'string'; });
                    var directTargetMatch = otherWindowsWithTarget.filter(function (w) { return _this.isPathEqual(target, w.openedWorkspacePath); });
                    var parentTargetMatch = otherWindowsWithTarget.filter(function (w) { return paths.isEqualOrParent(target, w.openedWorkspacePath); });
                    var targetWindow = directTargetMatch.length ? directTargetMatch[0] : parentTargetMatch[0]; // prefer direct match over parent match
                    if (targetWindow) {
                        targetWindow.send('vscode:broadcast', broadcast);
                    }
                }
                else {
                    _this.sendToAll('vscode:broadcast', broadcast, [windowId]);
                }
            }
        });
        // Update our windows state before quitting and before closing windows
        this.lifecycleService.onBeforeWindowClose(function (win) { return _this.onBeforeWindowClose(win); });
        this.lifecycleService.onBeforeQuit(function () { return _this.onBeforeQuit(); });
    };
    // Note that onBeforeQuit() and onBeforeWindowClose() are fired in different order depending on the OS:
    // - macOS: since the app will not quit when closing the last window, you will always first get
    //          the onBeforeQuit() event followed by N onbeforeWindowClose() events for each window
    // - other: on other OS, closing the last window will quit the app so the order depends on the
    //          user interaction: closing the last window will first trigger onBeforeWindowClose()
    //          and then onBeforeQuit(). Using the quit action however will first issue onBeforeQuit()
    //          and then onBeforeWindowClose().
    WindowsManager.prototype.onBeforeQuit = function () {
        var currentWindowsState = {
            openedFolders: [],
            lastPluginDevelopmentHostWindow: this.windowsState.lastPluginDevelopmentHostWindow,
            lastActiveWindow: this.lastClosedWindowState //will be set on Win/Linux if last window was closed, resulting in an exit
        };
        // 1.) Find a last active window (pick any other first window otherwise)
        if (!currentWindowsState.lastActiveWindow) {
            var activeWindow = this.getLastActiveWindow();
            if (!activeWindow || activeWindow.isExtensionDevelopmentHost) {
                activeWindow = WindowsManager.WINDOWS.filter(function (w) { return !w.isExtensionDevelopmentHost; })[0];
            }
            if (activeWindow) {
                currentWindowsState.lastActiveWindow = { workspacePath: activeWindow.openedWorkspacePath, uiState: activeWindow.serializeWindowState() };
            }
        }
        // 2.) Find extension host window
        var extensionHostWindow = WindowsManager.WINDOWS.filter(function (w) { return w.isExtensionDevelopmentHost && !w.isExtensionTestHost; })[0];
        if (extensionHostWindow) {
            currentWindowsState.lastPluginDevelopmentHostWindow = { workspacePath: extensionHostWindow.openedWorkspacePath, uiState: extensionHostWindow.serializeWindowState() };
        }
        // 3.) All windows with opened folders for N >= 2 to support reopenFolders: all or for auto update
        //
        // Carefull here: asking a window for its window state after it has been closed returns bogus values (width: 0, height: 0)
        // so if we ever want to persist the UI state of the last closed window (window count === 1), it has
        // to come from the stored lastClosedWindowState on Win/Linux at least
        if (this.getWindowCount() > 1) {
            currentWindowsState.openedFolders = WindowsManager.WINDOWS.filter(function (w) { return !!w.openedWorkspacePath && !w.isExtensionDevelopmentHost; }).map(function (w) {
                return {
                    workspacePath: w.openedWorkspacePath,
                    uiState: w.serializeWindowState()
                };
            });
        }
        // Persist
        this.storageService.setItem(WindowsManager.windowsStateStorageKey, currentWindowsState);
    };
    // See note on #onBeforeQuit() for details how these events are flowing
    WindowsManager.prototype.onBeforeWindowClose = function (win) {
        var _this = this;
        if (this.lifecycleService.isQuitRequested()) {
            return; // during quit, many windows close in parallel so let it be handled in the before-quit handler
        }
        // On Window close, update our stored UI state of this window
        var state = { workspacePath: win.openedWorkspacePath, uiState: win.serializeWindowState() };
        if (win.isExtensionDevelopmentHost && !win.isExtensionTestHost) {
            this.windowsState.lastPluginDevelopmentHostWindow = state; // do not let test run window state overwrite our extension development state
        }
        else if (!win.isExtensionDevelopmentHost && !!win.openedWorkspacePath) {
            this.windowsState.openedFolders.forEach(function (o) {
                if (_this.isPathEqual(o.workspacePath, win.openedWorkspacePath)) {
                    o.uiState = state.uiState;
                }
            });
        }
        // On Windows and Linux closing the last window will trigger quit. Since we are storing all UI state
        // before quitting, we need to remember the UI state of this window to be able to persist it.
        if (!platform.isMacintosh && this.getWindowCount() === 1) {
            this.lastClosedWindowState = state;
        }
    };
    WindowsManager.prototype.onBroadcast = function (event, payload) {
        // Theme changes
        if (event === 'vscode:changeColorTheme' && typeof payload === 'string') {
            this.storageService.setItem(window_1.VSCodeWindow.themeStorageKey, payload);
        }
    };
    WindowsManager.prototype.reload = function (win, cli) {
        var _this = this;
        // Only reload when the window has not vetoed this
        this.lifecycleService.unload(win, lifecycle_1.UnloadReason.RELOAD).done(function (veto) {
            if (!veto) {
                win.reload(cli);
                // Emit
                _this._onWindowReload.fire(win.id);
            }
        });
    };
    WindowsManager.prototype.open = function (openConfig) {
        var _this = this;
        var windowConfig = this.configurationService.getConfiguration('window');
        var iPathsToOpen;
        var usedWindows = [];
        // Find paths from provided paths if any
        if (openConfig.pathsToOpen && openConfig.pathsToOpen.length > 0) {
            iPathsToOpen = openConfig.pathsToOpen.map(function (pathToOpen) {
                var iPath = _this.toIPath(pathToOpen, false, openConfig.cli && openConfig.cli.goto);
                // Warn if the requested path to open does not exist
                if (!iPath) {
                    var options = {
                        title: product_1.default.nameLong,
                        type: 'info',
                        buttons: [nls.localize('ok', "OK")],
                        message: nls.localize('pathNotExistTitle', "Path does not exist"),
                        detail: nls.localize('pathNotExistDetail', "The path '{0}' does not seem to exist anymore on disk.", pathToOpen),
                        noLink: true
                    };
                    var activeWindow = electron_1.BrowserWindow.getFocusedWindow();
                    if (activeWindow) {
                        electron_1.dialog.showMessageBox(activeWindow, options);
                    }
                    else {
                        electron_1.dialog.showMessageBox(options);
                    }
                }
                return iPath;
            });
            // get rid of nulls
            iPathsToOpen = arrays.coalesce(iPathsToOpen);
            if (iPathsToOpen.length === 0) {
                return null; // indicate to outside that open failed
            }
        }
        else if (openConfig.forceEmpty) {
            iPathsToOpen = [Object.create(null)];
        }
        else {
            var ignoreFileNotFound = openConfig.cli._.length > 0; // we assume the user wants to create this file from command line
            iPathsToOpen = this.cliToPaths(openConfig.cli, ignoreFileNotFound);
        }
        var foldersToOpen = arrays.distinct(iPathsToOpen.filter(function (iPath) { return iPath.workspacePath && !iPath.filePath; }).map(function (iPath) { return iPath.workspacePath; }), function (folder) { return platform.isLinux ? folder : folder.toLowerCase(); }); // prevent duplicates
        var foldersToRestore = (openConfig.initialStartup && !openConfig.cli.extensionDevelopmentPath) ? this.backupService.getWorkspaceBackupPaths() : [];
        var filesToOpen = [];
        var filesToDiff = [];
        var emptyToOpen = iPathsToOpen.filter(function (iPath) { return !iPath.workspacePath && !iPath.filePath; });
        var emptyToRestore = (openConfig.initialStartup && !openConfig.cli.extensionDevelopmentPath) ? this.backupService.getEmptyWorkspaceBackupPaths() : [];
        var filesToCreate = iPathsToOpen.filter(function (iPath) { return !!iPath.filePath && iPath.createFilePath; });
        // Diff mode needs special care
        var candidates = iPathsToOpen.filter(function (iPath) { return !!iPath.filePath && !iPath.createFilePath; });
        if (openConfig.diffMode) {
            if (candidates.length === 2) {
                filesToDiff = candidates;
            }
            else {
                emptyToOpen = [Object.create(null)]; // improper use of diffMode, open empty
            }
            foldersToOpen = []; // diff is always in empty workspace
            foldersToRestore = []; // diff is always in empty workspace
            filesToCreate = []; // diff ignores other files that do not exist
        }
        else {
            filesToOpen = candidates;
        }
        // let the user settings override how folders are open in a new window or same window unless we are forced
        var openFolderInNewWindow = (openConfig.preferNewWindow || openConfig.forceNewWindow) && !openConfig.forceReuseWindow;
        if (!openConfig.forceNewWindow && !openConfig.forceReuseWindow && windowConfig && (windowConfig.openFoldersInNewWindow === 'on' || windowConfig.openFoldersInNewWindow === 'off')) {
            openFolderInNewWindow = (windowConfig.openFoldersInNewWindow === 'on');
        }
        // Handle files to open/diff or to create when we dont open a folder and we do not restore any folder/untitled from hot-exit
        if (!foldersToOpen.length && !foldersToRestore.length && !emptyToRestore.length && (filesToOpen.length > 0 || filesToCreate.length > 0 || filesToDiff.length > 0)) {
            // let the user settings override how files are open in a new window or same window unless we are forced (not for extension development though)
            var openFilesInNewWindow = void 0;
            if (openConfig.forceNewWindow || openConfig.forceReuseWindow) {
                openFilesInNewWindow = openConfig.forceNewWindow && !openConfig.forceReuseWindow;
            }
            else {
                if (openConfig.context === windows_1.OpenContext.DOCK) {
                    openFilesInNewWindow = true; // only on macOS do we allow to open files in a new window if this is triggered via DOCK context
                }
                if (!openConfig.cli.extensionDevelopmentPath && windowConfig && (windowConfig.openFilesInNewWindow === 'on' || windowConfig.openFilesInNewWindow === 'off')) {
                    openFilesInNewWindow = (windowConfig.openFilesInNewWindow === 'on');
                }
            }
            // Open Files in last instance if any and flag tells us so
            var fileToCheck = filesToOpen[0] || filesToCreate[0] || filesToDiff[0];
            var windowOrFolder = windowsUtils_1.findBestWindowOrFolder({
                windows: WindowsManager.WINDOWS,
                newWindow: openFilesInNewWindow,
                reuseWindow: openConfig.forceReuseWindow,
                context: openConfig.context,
                filePath: fileToCheck && fileToCheck.filePath,
                userHome: this.environmentService.userHome
            });
            if (windowOrFolder instanceof window_1.VSCodeWindow) {
                windowOrFolder.focus();
                var files_1 = { filesToOpen: filesToOpen, filesToCreate: filesToCreate, filesToDiff: filesToDiff }; // copy to object because they get reset shortly after
                windowOrFolder.ready().then(function (readyWindow) {
                    readyWindow.send('vscode:openFiles', files_1);
                });
                usedWindows.push(windowOrFolder);
            }
            else {
                var configuration = this.toConfiguration(openConfig, windowOrFolder, filesToOpen, filesToCreate, filesToDiff);
                var browserWindow = this.openInBrowserWindow(configuration, true /* new window */);
                usedWindows.push(browserWindow);
                openFolderInNewWindow = true; // any other folders to open must open in new window then
            }
            // Reset these because we handled them
            filesToOpen = [];
            filesToCreate = [];
            filesToDiff = [];
        }
        // Handle folders to open (instructed and to restore)
        var allFoldersToOpen = arrays.distinct(foldersToOpen.concat(foldersToRestore), function (folder) { return platform.isLinux ? folder : folder.toLowerCase(); }); // prevent duplicates
        if (allFoldersToOpen.length > 0) {
            // Check for existing instances
            var windowsOnWorkspacePath_1 = arrays.coalesce(allFoldersToOpen.map(function (folderToOpen) { return _this.findWindow(folderToOpen); }));
            if (windowsOnWorkspacePath_1.length > 0) {
                var browserWindow = windowsOnWorkspacePath_1[0];
                browserWindow.focus(); // just focus one of them
                var files_2 = { filesToOpen: filesToOpen, filesToCreate: filesToCreate, filesToDiff: filesToDiff }; // copy to object because they get reset shortly after
                browserWindow.ready().then(function (readyWindow) {
                    readyWindow.send('vscode:openFiles', files_2);
                });
                usedWindows.push(browserWindow);
                // Reset these because we handled them
                filesToOpen = [];
                filesToCreate = [];
                filesToDiff = [];
                openFolderInNewWindow = true; // any other folders to open must open in new window then
            }
            // Open remaining ones
            allFoldersToOpen.forEach(function (folderToOpen) {
                if (windowsOnWorkspacePath_1.some(function (win) { return _this.isPathEqual(win.openedWorkspacePath, folderToOpen); })) {
                    return; // ignore folders that are already open
                }
                var configuration = _this.toConfiguration(openConfig, folderToOpen, filesToOpen, filesToCreate, filesToDiff);
                var browserWindow = _this.openInBrowserWindow(configuration, openFolderInNewWindow, openFolderInNewWindow ? void 0 : openConfig.windowToUse);
                usedWindows.push(browserWindow);
                // Reset these because we handled them
                filesToOpen = [];
                filesToCreate = [];
                filesToDiff = [];
                openFolderInNewWindow = true; // any other folders to open must open in new window then
            });
        }
        // Handle empty
        if (emptyToRestore.length > 0) {
            emptyToRestore.forEach(function (emptyWorkspaceBackupFolder) {
                var configuration = _this.toConfiguration(openConfig, void 0, filesToOpen, filesToCreate, filesToDiff);
                var browserWindow = _this.openInBrowserWindow(configuration, true /* new window */, null, emptyWorkspaceBackupFolder);
                usedWindows.push(browserWindow);
                // Reset these because we handled them
                filesToOpen = [];
                filesToCreate = [];
                filesToDiff = [];
                openFolderInNewWindow = true; // any other folders to open must open in new window then
            });
        }
        else if (emptyToOpen.length > 0) {
            emptyToOpen.forEach(function () {
                var configuration = _this.toConfiguration(openConfig);
                var browserWindow = _this.openInBrowserWindow(configuration, openFolderInNewWindow, openFolderInNewWindow ? void 0 : openConfig.windowToUse);
                usedWindows.push(browserWindow);
                openFolderInNewWindow = true; // any other folders to open must open in new window then
            });
        }
        // Remember in recent document list (unless this opens for extension development)
        // Also do not add paths when files are opened for diffing, only if opened individually
        if (!usedWindows.some(function (w) { return w.isExtensionDevelopmentHost; }) && !openConfig.cli.diff) {
            var recentPaths_1 = [];
            iPathsToOpen.forEach(function (iPath) {
                if (iPath.filePath || iPath.workspacePath) {
                    electron_1.app.addRecentDocument(iPath.filePath || iPath.workspacePath);
                    recentPaths_1.push({ path: iPath.filePath || iPath.workspacePath, isFile: !!iPath.filePath });
                }
            });
            if (recentPaths_1.length) {
                this.addToRecentPathsList(recentPaths_1);
            }
        }
        // Emit events
        this._onPathsOpen.fire(iPathsToOpen);
        return arrays.distinct(usedWindows);
    };
    WindowsManager.prototype.addToRecentPathsList = function (paths) {
        if (!paths || !paths.length) {
            return;
        }
        var mru = this.getRecentPathsList();
        paths.forEach(function (p) {
            var path = p.path, isFile = p.isFile;
            if (isFile) {
                mru.files.unshift(path);
                mru.files = arrays.distinct(mru.files, function (f) { return platform.isLinux ? f : f.toLowerCase(); });
            }
            else {
                mru.folders.unshift(path);
                mru.folders = arrays.distinct(mru.folders, function (f) { return platform.isLinux ? f : f.toLowerCase(); });
            }
            // Make sure its bounded
            mru.folders = mru.folders.slice(0, WindowsManager.MAX_TOTAL_RECENT_ENTRIES);
            mru.files = mru.files.slice(0, WindowsManager.MAX_TOTAL_RECENT_ENTRIES);
        });
        this.storageService.setItem(WindowsManager.recentPathsListStorageKey, mru);
        this._onRecentPathsChange.fire();
    };
    WindowsManager.prototype.removeFromRecentPathsList = function (arg1) {
        var paths;
        if (Array.isArray(arg1)) {
            paths = arg1;
        }
        else {
            paths = [arg1];
        }
        var mru = this.getRecentPathsList();
        var update = false;
        paths.forEach(function (path) {
            var index = mru.files.indexOf(path);
            if (index >= 0) {
                mru.files.splice(index, 1);
                update = true;
            }
            index = mru.folders.indexOf(path);
            if (index >= 0) {
                mru.folders.splice(index, 1);
                update = true;
            }
        });
        if (update) {
            this.storageService.setItem(WindowsManager.recentPathsListStorageKey, mru);
            this._onRecentPathsChange.fire();
        }
    };
    WindowsManager.prototype.clearRecentPathsList = function () {
        this.storageService.setItem(WindowsManager.recentPathsListStorageKey, { folders: [], files: [] });
        electron_1.app.clearRecentDocuments();
        // Event
        this._onRecentPathsChange.fire();
    };
    WindowsManager.prototype.getRecentPathsList = function (workspacePath, filesToOpen) {
        var files;
        var folders;
        // Get from storage
        var storedRecents = this.storageService.getItem(WindowsManager.recentPathsListStorageKey);
        if (storedRecents) {
            files = storedRecents.files || [];
            folders = storedRecents.folders || [];
        }
        else {
            files = [];
            folders = [];
        }
        // Add currently files to open to the beginning if any
        if (filesToOpen) {
            files.unshift.apply(files, filesToOpen.map(function (f) { return f.filePath; }));
        }
        // Add current workspace path to beginning if set
        if (workspacePath) {
            folders.unshift(workspacePath);
        }
        // Clear those dupes
        files = arrays.distinct(files);
        folders = arrays.distinct(folders);
        return { files: files, folders: folders };
    };
    WindowsManager.prototype.getWindowUserEnv = function (openConfig) {
        return objects_1.assign({}, this.initialUserEnv, openConfig.userEnv || {});
    };
    WindowsManager.prototype.openExtensionDevelopmentHostWindow = function (openConfig) {
        var _this = this;
        // Reload an existing extension development host window on the same path
        // We currently do not allow more than one extension development window
        // on the same extension path.
        var res = WindowsManager.WINDOWS.filter(function (w) { return w.config && _this.isPathEqual(w.config.extensionDevelopmentPath, openConfig.cli.extensionDevelopmentPath); });
        if (res && res.length === 1) {
            this.reload(res[0], openConfig.cli);
            res[0].focus(); // make sure it gets focus and is restored
            return;
        }
        // Fill in previously opened workspace unless an explicit path is provided and we are not unit testing
        if (openConfig.cli._.length === 0 && !openConfig.cli.extensionTestsPath) {
            var workspaceToOpen = this.windowsState.lastPluginDevelopmentHostWindow && this.windowsState.lastPluginDevelopmentHostWindow.workspacePath;
            if (workspaceToOpen) {
                openConfig.cli._ = [workspaceToOpen];
            }
        }
        // Make sure we are not asked to open a path that is already opened
        if (openConfig.cli._.length > 0) {
            res = WindowsManager.WINDOWS.filter(function (w) { return w.openedWorkspacePath && openConfig.cli._.indexOf(w.openedWorkspacePath) >= 0; });
            if (res.length) {
                openConfig.cli._ = [];
            }
        }
        // Open it
        this.open({ context: openConfig.context, cli: openConfig.cli, forceNewWindow: true, forceEmpty: openConfig.cli._.length === 0, userEnv: openConfig.userEnv });
    };
    WindowsManager.prototype.toConfiguration = function (config, workspacePath, filesToOpen, filesToCreate, filesToDiff) {
        var configuration = objects_1.mixin({}, config.cli); // inherit all properties from CLI
        configuration.appRoot = this.environmentService.appRoot;
        configuration.execPath = process.execPath;
        configuration.userEnv = this.getWindowUserEnv(config);
        configuration.isInitialStartup = config.initialStartup;
        configuration.workspacePath = workspacePath;
        configuration.filesToOpen = filesToOpen;
        configuration.filesToCreate = filesToCreate;
        configuration.filesToDiff = filesToDiff;
        configuration.nodeCachedDataDir = this.environmentService.isBuilt && this.environmentService.nodeCachedDataDir;
        return configuration;
    };
    WindowsManager.prototype.toIPath = function (anyPath, ignoreFileNotFound, gotoLineMode) {
        if (!anyPath) {
            return null;
        }
        var parsedPath;
        if (gotoLineMode) {
            parsedPath = paths_1.parseLineAndColumnAware(anyPath);
            anyPath = parsedPath.path;
        }
        var candidate = path.normalize(anyPath);
        try {
            var candidateStat = fs.statSync(candidate);
            if (candidateStat) {
                return candidateStat.isFile() ?
                    {
                        filePath: candidate,
                        lineNumber: gotoLineMode ? parsedPath.line : void 0,
                        columnNumber: gotoLineMode ? parsedPath.column : void 0
                    } :
                    { workspacePath: candidate };
            }
        }
        catch (error) {
            this.removeFromRecentPathsList(candidate); // since file does not seem to exist anymore, remove from recent
            if (ignoreFileNotFound) {
                return { filePath: candidate, createFilePath: true }; // assume this is a file that does not yet exist
            }
        }
        return null;
    };
    WindowsManager.prototype.cliToPaths = function (cli, ignoreFileNotFound) {
        var _this = this;
        // Check for pass in candidate or last opened path
        var candidates = [];
        if (cli._.length > 0) {
            candidates = cli._;
        }
        else {
            var reopenFolders = void 0;
            if (this.lifecycleService.wasUpdated) {
                reopenFolders = ReopenFoldersSetting.ALL; // always reopen all folders when an update was applied
            }
            else {
                var windowConfig = this.configurationService.getConfiguration('window');
                reopenFolders = (windowConfig && windowConfig.reopenFolders) || ReopenFoldersSetting.ONE;
            }
            var lastActiveFolder = this.windowsState.lastActiveWindow && this.windowsState.lastActiveWindow.workspacePath;
            // Restore all
            if (reopenFolders === ReopenFoldersSetting.ALL) {
                var lastOpenedFolders = this.windowsState.openedFolders.map(function (o) { return o.workspacePath; });
                // If we have a last active folder, move it to the end
                if (lastActiveFolder) {
                    lastOpenedFolders.splice(lastOpenedFolders.indexOf(lastActiveFolder), 1);
                    lastOpenedFolders.push(lastActiveFolder);
                }
                candidates.push.apply(candidates, lastOpenedFolders);
            }
            else if (lastActiveFolder && (reopenFolders === ReopenFoldersSetting.ONE || reopenFolders !== ReopenFoldersSetting.NONE)) {
                candidates.push(lastActiveFolder);
            }
        }
        var iPaths = candidates.map(function (candidate) { return _this.toIPath(candidate, ignoreFileNotFound, cli.goto); }).filter(function (path) { return !!path; });
        if (iPaths.length > 0) {
            return iPaths;
        }
        // No path provided, return empty to open empty
        return [Object.create(null)];
    };
    WindowsManager.prototype.openInBrowserWindow = function (configuration, forceNewWindow, windowToUse, emptyWorkspaceBackupFolder) {
        var _this = this;
        var vscodeWindow;
        if (!forceNewWindow) {
            vscodeWindow = windowToUse || this.getLastActiveWindow();
            if (vscodeWindow) {
                vscodeWindow.focus();
            }
        }
        // New window
        if (!vscodeWindow) {
            var windowConfig = this.configurationService.getConfiguration('window');
            var state = this.getNewWindowState(configuration);
            // Window state is not from a previous session: only allow fullscreen if we inherit it or user wants fullscreen
            var allowFullscreen = void 0;
            if (state.hasDefaultState) {
                allowFullscreen = (windowConfig && windowConfig.newWindowDimensions && ['fullscreen', 'inherit'].indexOf(windowConfig.newWindowDimensions) >= 0);
            }
            else {
                allowFullscreen = this.lifecycleService.wasUpdated || (windowConfig && windowConfig.restoreFullscreen);
            }
            if (state.mode === window_1.WindowMode.Fullscreen && !allowFullscreen) {
                state.mode = window_1.WindowMode.Normal;
            }
            vscodeWindow = new window_1.VSCodeWindow({
                state: state,
                extensionDevelopmentPath: configuration.extensionDevelopmentPath,
                isExtensionTestHost: !!configuration.extensionTestsPath,
                titleBarStyle: windowConfig ? windowConfig.titleBarStyle : void 0
            }, this.logService, this.environmentService, this.configurationService, this.storageService);
            WindowsManager.WINDOWS.push(vscodeWindow);
            // Window Events
            vscodeWindow.win.webContents.removeAllListeners('devtools-reload-page'); // remove built in listener so we can handle this on our own
            vscodeWindow.win.webContents.on('devtools-reload-page', function () { return _this.reload(vscodeWindow); });
            vscodeWindow.win.webContents.on('crashed', function () { return _this.onWindowError(vscodeWindow, WindowError.CRASHED); });
            vscodeWindow.win.on('unresponsive', function () { return _this.onWindowError(vscodeWindow, WindowError.UNRESPONSIVE); });
            vscodeWindow.win.on('closed', function () { return _this.onWindowClosed(vscodeWindow); });
            // Lifecycle
            this.lifecycleService.registerWindow(vscodeWindow);
        }
        else {
            // Some configuration things get inherited if the window is being reused and we are
            // in extension development host mode. These options are all development related.
            var currentWindowConfig = vscodeWindow.config;
            if (!configuration.extensionDevelopmentPath && currentWindowConfig && !!currentWindowConfig.extensionDevelopmentPath) {
                configuration.extensionDevelopmentPath = currentWindowConfig.extensionDevelopmentPath;
                configuration.verbose = currentWindowConfig.verbose;
                configuration.debugBrkPluginHost = currentWindowConfig.debugBrkPluginHost;
                configuration.debugPluginHost = currentWindowConfig.debugPluginHost;
                configuration['extensions-dir'] = currentWindowConfig['extensions-dir'];
            }
        }
        // Only load when the window has not vetoed this
        this.lifecycleService.unload(vscodeWindow, lifecycle_1.UnloadReason.LOAD).done(function (veto) {
            if (!veto) {
                // Register window for backups
                if (!configuration.extensionDevelopmentPath) {
                    _this.backupService.registerWindowForBackupsSync(vscodeWindow.id, !configuration.workspacePath, emptyWorkspaceBackupFolder, configuration.workspacePath);
                }
                // Load it
                vscodeWindow.load(configuration);
            }
        });
        return vscodeWindow;
    };
    WindowsManager.prototype.getNewWindowState = function (configuration) {
        var _this = this;
        // extension development host Window - load from stored settings if any
        if (!!configuration.extensionDevelopmentPath && this.windowsState.lastPluginDevelopmentHostWindow) {
            return this.windowsState.lastPluginDevelopmentHostWindow.uiState;
        }
        // Known Folder - load from stored settings if any
        if (configuration.workspacePath) {
            var stateForWorkspace = this.windowsState.openedFolders.filter(function (o) { return _this.isPathEqual(o.workspacePath, configuration.workspacePath); }).map(function (o) { return o.uiState; });
            if (stateForWorkspace.length) {
                return stateForWorkspace[0];
            }
        }
        // First Window
        var lastActive = this.getLastActiveWindow();
        if (!lastActive && this.windowsState.lastActiveWindow) {
            return this.windowsState.lastActiveWindow.uiState;
        }
        //
        // In any other case, we do not have any stored settings for the window state, so we come up with something smart
        //
        // We want the new window to open on the same display that the last active one is in
        var displayToUse;
        var displays = electron_1.screen.getAllDisplays();
        // Single Display
        if (displays.length === 1) {
            displayToUse = displays[0];
        }
        else {
            // on mac there is 1 menu per window so we need to use the monitor where the cursor currently is
            if (platform.isMacintosh) {
                var cursorPoint = electron_1.screen.getCursorScreenPoint();
                displayToUse = electron_1.screen.getDisplayNearestPoint(cursorPoint);
            }
            // if we have a last active window, use that display for the new window
            if (!displayToUse && lastActive) {
                displayToUse = electron_1.screen.getDisplayMatching(lastActive.getBounds());
            }
            // fallback to primary display or first display
            if (!displayToUse) {
                displayToUse = electron_1.screen.getPrimaryDisplay() || displays[0];
            }
        }
        var state = window_1.defaultWindowState();
        state.x = displayToUse.bounds.x + (displayToUse.bounds.width / 2) - (state.width / 2);
        state.y = displayToUse.bounds.y + (displayToUse.bounds.height / 2) - (state.height / 2);
        // Check for newWindowDimensions setting and adjust accordingly
        var windowConfig = this.configurationService.getConfiguration('window');
        var ensureNoOverlap = true;
        if (windowConfig && windowConfig.newWindowDimensions) {
            if (windowConfig.newWindowDimensions === 'maximized') {
                state.mode = window_1.WindowMode.Maximized;
                ensureNoOverlap = false;
            }
            else if (windowConfig.newWindowDimensions === 'fullscreen') {
                state.mode = window_1.WindowMode.Fullscreen;
                ensureNoOverlap = false;
            }
            else if (windowConfig.newWindowDimensions === 'inherit' && lastActive) {
                var lastActiveState = lastActive.serializeWindowState();
                if (lastActiveState.mode === window_1.WindowMode.Fullscreen) {
                    state.mode = window_1.WindowMode.Fullscreen; // only take mode (fixes https://github.com/Microsoft/vscode/issues/19331)
                }
                else {
                    state = lastActiveState;
                }
                ensureNoOverlap = false;
            }
        }
        if (ensureNoOverlap) {
            state = this.ensureNoOverlap(state);
        }
        state.hasDefaultState = true; // flag as default state
        return state;
    };
    WindowsManager.prototype.ensureNoOverlap = function (state) {
        if (WindowsManager.WINDOWS.length === 0) {
            return state;
        }
        var existingWindowBounds = WindowsManager.WINDOWS.map(function (win) { return win.getBounds(); });
        while (existingWindowBounds.some(function (b) { return b.x === state.x || b.y === state.y; })) {
            state.x += 30;
            state.y += 30;
        }
        return state;
    };
    WindowsManager.prototype.openFileFolderPicker = function (forceNewWindow, data) {
        this.doPickAndOpen({ pickFolders: true, pickFiles: true, forceNewWindow: forceNewWindow }, 'openFileFolder', data);
    };
    WindowsManager.prototype.openFilePicker = function (forceNewWindow, path, window, data) {
        this.doPickAndOpen({ pickFiles: true, forceNewWindow: forceNewWindow, path: path, window: window }, 'openFile', data);
    };
    WindowsManager.prototype.openFolderPicker = function (forceNewWindow, window, data) {
        this.doPickAndOpen({ pickFolders: true, forceNewWindow: forceNewWindow, window: window }, 'openFolder', data);
    };
    WindowsManager.prototype.openAccessibilityOptions = function () {
        var win = new electron_1.BrowserWindow({
            alwaysOnTop: true,
            skipTaskbar: true,
            resizable: false,
            width: 450,
            height: 300,
            show: true,
            title: nls.localize('accessibilityOptionsWindowTitle', "Accessibility Options")
        });
        win.setMenuBarVisibility(false);
        win.loadURL('chrome://accessibility');
    };
    WindowsManager.prototype.doPickAndOpen = function (options, eventName, data) {
        var _this = this;
        this.getFileOrFolderPaths(options, function (paths) {
            var nOfPaths = paths ? paths.length : 0;
            if (nOfPaths) {
                _this.open({ context: windows_1.OpenContext.DIALOG, cli: _this.environmentService.args, pathsToOpen: paths, forceNewWindow: options.forceNewWindow });
            }
            _this.telemetryService.publicLog(eventName, __assign({}, data, { outcome: nOfPaths ? 'success' : 'canceled', nOfPaths: nOfPaths }));
        });
    };
    WindowsManager.prototype.getFileOrFolderPaths = function (options, clb) {
        var _this = this;
        var workingDir = options.path || this.storageService.getItem(WindowsManager.workingDirPickerStorageKey);
        var focussedWindow = options.window || this.getFocusedWindow();
        var pickerProperties;
        if (options.pickFiles && options.pickFolders) {
            pickerProperties = ['multiSelections', 'openDirectory', 'openFile', 'createDirectory'];
        }
        else {
            pickerProperties = ['multiSelections', options.pickFolders ? 'openDirectory' : 'openFile', 'createDirectory'];
        }
        electron_1.dialog.showOpenDialog(focussedWindow && focussedWindow.win, {
            defaultPath: workingDir,
            properties: pickerProperties
        }, function (paths) {
            if (paths && paths.length > 0) {
                // Remember path in storage for next time
                _this.storageService.setItem(WindowsManager.workingDirPickerStorageKey, path.dirname(paths[0]));
                // Return
                clb(paths);
            }
            else {
                clb(void (0));
            }
        });
    };
    WindowsManager.prototype.focusLastActive = function (cli, context) {
        var lastActive = this.getLastActiveWindow();
        if (lastActive) {
            lastActive.focus();
            return lastActive;
        }
        // No window - open new empty one
        var res = this.open({ context: context, cli: cli, forceEmpty: true });
        return res && res[0];
    };
    WindowsManager.prototype.getLastActiveWindow = function () {
        return windowsUtils_1.getLastActiveWindow(WindowsManager.WINDOWS);
    };
    WindowsManager.prototype.findWindow = function (workspacePath, filePath, extensionDevelopmentPath) {
        var _this = this;
        if (WindowsManager.WINDOWS.length) {
            // Sort the last active window to the front of the array of windows to test
            var windowsToTest = WindowsManager.WINDOWS.slice(0);
            var lastActiveWindow = this.getLastActiveWindow();
            if (lastActiveWindow) {
                windowsToTest.splice(windowsToTest.indexOf(lastActiveWindow), 1);
                windowsToTest.unshift(lastActiveWindow);
            }
            // Find it
            var res = windowsToTest.filter(function (w) {
                // match on workspace
                if (typeof w.openedWorkspacePath === 'string' && (_this.isPathEqual(w.openedWorkspacePath, workspacePath))) {
                    return true;
                }
                // match on file
                if (typeof w.openedFilePath === 'string' && _this.isPathEqual(w.openedFilePath, filePath)) {
                    return true;
                }
                // match on file path
                if (typeof w.openedWorkspacePath === 'string' && filePath && paths.isEqualOrParent(filePath, w.openedWorkspacePath)) {
                    return true;
                }
                // match on extension development path
                if (typeof extensionDevelopmentPath === 'string' && w.extensionDevelopmentPath === extensionDevelopmentPath) {
                    return true;
                }
                return false;
            });
            if (res && res.length) {
                return res[0];
            }
        }
        return null;
    };
    WindowsManager.prototype.openNewWindow = function (context) {
        this.open({ context: context, cli: this.environmentService.args, forceNewWindow: true, forceEmpty: true });
    };
    WindowsManager.prototype.sendToFocused = function (channel) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var focusedWindow = this.getFocusedWindow() || this.getLastActiveWindow();
        if (focusedWindow) {
            focusedWindow.sendWhenReady.apply(focusedWindow, [channel].concat(args));
        }
    };
    WindowsManager.prototype.sendToAll = function (channel, payload, windowIdsToIgnore) {
        WindowsManager.WINDOWS.forEach(function (w) {
            if (windowIdsToIgnore && windowIdsToIgnore.indexOf(w.id) >= 0) {
                return; // do not send if we are instructed to ignore it
            }
            w.sendWhenReady(channel, payload);
        });
    };
    WindowsManager.prototype.getFocusedWindow = function () {
        var win = electron_1.BrowserWindow.getFocusedWindow();
        if (win) {
            return this.getWindowById(win.id);
        }
        return null;
    };
    WindowsManager.prototype.getWindowById = function (windowId) {
        var res = WindowsManager.WINDOWS.filter(function (w) { return w.id === windowId; });
        if (res && res.length === 1) {
            return res[0];
        }
        return null;
    };
    WindowsManager.prototype.getWindows = function () {
        return WindowsManager.WINDOWS;
    };
    WindowsManager.prototype.getWindowCount = function () {
        return WindowsManager.WINDOWS.length;
    };
    WindowsManager.prototype.onWindowError = function (vscodeWindow, error) {
        var _this = this;
        console.error(error === WindowError.CRASHED ? '[VS Code]: render process crashed!' : '[VS Code]: detected unresponsive');
        // Unresponsive
        if (error === WindowError.UNRESPONSIVE) {
            electron_1.dialog.showMessageBox(vscodeWindow.win, {
                title: product_1.default.nameLong,
                type: 'warning',
                buttons: [nls.localize('reopen', "Reopen"), nls.localize('wait', "Keep Waiting"), nls.localize('close', "Close")],
                message: nls.localize('appStalled', "The window is no longer responding"),
                detail: nls.localize('appStalledDetail', "You can reopen or close the window or keep waiting."),
                noLink: true
            }, function (result) {
                if (result === 0) {
                    vscodeWindow.reload();
                }
                else if (result === 2) {
                    _this.onBeforeWindowClose(vscodeWindow); // 'close' event will not be fired on destroy(), so run it manually
                    vscodeWindow.win.destroy(); // make sure to destroy the window as it is unresponsive
                }
            });
        }
        else {
            electron_1.dialog.showMessageBox(vscodeWindow.win, {
                title: product_1.default.nameLong,
                type: 'warning',
                buttons: [nls.localize('reopen', "Reopen"), nls.localize('close', "Close")],
                message: nls.localize('appCrashed', "The window has crashed"),
                detail: nls.localize('appCrashedDetail', "We are sorry for the inconvenience! You can reopen the window to continue where you left off."),
                noLink: true
            }, function (result) {
                if (result === 0) {
                    vscodeWindow.reload();
                }
                else if (result === 1) {
                    _this.onBeforeWindowClose(vscodeWindow); // 'close' event will not be fired on destroy(), so run it manually
                    vscodeWindow.win.destroy(); // make sure to destroy the window as it has crashed
                }
            });
        }
    };
    WindowsManager.prototype.onWindowClosed = function (win) {
        // Tell window
        win.dispose();
        // Remove from our list so that Electron can clean it up
        var index = WindowsManager.WINDOWS.indexOf(win);
        WindowsManager.WINDOWS.splice(index, 1);
        // Emit
        this._onWindowClose.fire(win.id);
    };
    WindowsManager.prototype.isPathEqual = function (pathA, pathB) {
        if (pathA === pathB) {
            return true;
        }
        if (!pathA || !pathB) {
            return false;
        }
        pathA = path.normalize(pathA);
        pathB = path.normalize(pathB);
        if (pathA === pathB) {
            return true;
        }
        if (!platform.isLinux) {
            pathA = pathA.toLowerCase();
            pathB = pathB.toLowerCase();
        }
        return pathA === pathB;
    };
    WindowsManager.prototype.updateWindowsJumpList = function () {
        if (!platform.isWindows) {
            return; // only on windows
        }
        var jumpList = [];
        // Tasks
        jumpList.push({
            type: 'tasks',
            items: [
                {
                    type: 'task',
                    title: nls.localize('newWindow', "New Window"),
                    description: nls.localize('newWindowDesc', "Opens a new window"),
                    program: process.execPath,
                    args: '-n',
                    iconPath: process.execPath,
                    iconIndex: 0
                }
            ]
        });
        // Recent Folders
        if (this.getRecentPathsList().folders.length > 0) {
            // The user might have meanwhile removed items from the jump list and we have to respect that
            // so we need to update our list of recent paths with the choice of the user to not add them again
            // Also: Windows will not show our custom category at all if there is any entry which was removed
            // by the user! See https://github.com/Microsoft/vscode/issues/15052
            this.removeFromRecentPathsList(electron_1.app.getJumpListSettings().removedItems.map(function (r) { return strings_1.trim(r.args, '"'); }));
            // Add entries
            jumpList.push({
                type: 'custom',
                name: nls.localize('recentFolders', "Recent Folders"),
                items: this.getRecentPathsList().folders.slice(0, 7 /* limit number of entries here */).map(function (folder) {
                    return {
                        type: 'task',
                        title: path.basename(folder) || folder,
                        description: nls.localize('folderDesc', "{0} {1}", path.basename(folder), labels_1.getPathLabel(path.dirname(folder))),
                        program: process.execPath,
                        args: "\"" + folder + "\"",
                        iconPath: 'explorer.exe',
                        iconIndex: 0
                    };
                }).filter(function (i) { return !!i; })
            });
        }
        // Recent
        jumpList.push({
            type: 'recent' // this enables to show files in the "recent" category
        });
        try {
            electron_1.app.setJumpList(jumpList);
        }
        catch (error) {
            this.logService.log('#setJumpList', error); // since setJumpList is relatively new API, make sure to guard for errors
        }
    };
    WindowsManager.prototype.quit = function () {
        // If the user selected to exit from an extension development host window, do not quit, but just
        // close the window unless this is the last window that is opened.
        var vscodeWindow = this.getFocusedWindow();
        if (vscodeWindow && vscodeWindow.isExtensionDevelopmentHost && this.getWindowCount() > 1) {
            vscodeWindow.win.close();
        }
        else {
            setTimeout(function () {
                electron_1.app.quit();
            }, 10 /* delay to unwind callback stack (IPC) */);
        }
    };
    return WindowsManager;
}());
WindowsManager.MAX_TOTAL_RECENT_ENTRIES = 100;
WindowsManager.recentPathsListStorageKey = 'openedPathsList';
WindowsManager.workingDirPickerStorageKey = 'pickerWorkingDir';
WindowsManager.windowsStateStorageKey = 'windowsState';
WindowsManager.WINDOWS = [];
WindowsManager = __decorate([
    __param(0, log_1.ILogService),
    __param(1, storage_1.IStorageService),
    __param(2, environment_1.IEnvironmentService),
    __param(3, lifecycle_1.ILifecycleService),
    __param(4, backup_1.IBackupMainService),
    __param(5, telemetry_1.ITelemetryService),
    __param(6, configuration_1.IConfigurationService)
], WindowsManager);
exports.WindowsManager = WindowsManager;
