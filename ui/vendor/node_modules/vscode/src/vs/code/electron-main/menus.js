/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var platform = require("vs/base/common/platform");
var arrays = require("vs/base/common/arrays");
var environment_1 = require("vs/platform/environment/common/environment");
var electron_1 = require("electron");
var windows_1 = require("vs/code/electron-main/windows");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var storage_1 = require("vs/code/electron-main/storage");
var files_1 = require("vs/platform/files/common/files");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var update_1 = require("vs/platform/update/common/update");
var keybinding_1 = require("vs/base/common/keybinding");
var product_1 = require("vs/platform/product");
var async_1 = require("vs/base/common/async");
var VSCodeMenu = (function () {
    function VSCodeMenu(storageService, updateService, configurationService, windowsService, environmentService, telemetryService) {
        var _this = this;
        this.storageService = storageService;
        this.updateService = updateService;
        this.configurationService = configurationService;
        this.windowsService = windowsService;
        this.environmentService = environmentService;
        this.telemetryService = telemetryService;
        this.actionIdKeybindingRequests = [];
        this.extensionViewlets = [];
        this.mapResolvedKeybindingToActionId = Object.create(null);
        this.mapLastKnownKeybindingToActionId = this.storageService.getItem(VSCodeMenu.lastKnownKeybindingsMapStorageKey) || Object.create(null);
        this.menuUpdater = new async_1.RunOnceScheduler(function () { return _this.doUpdateMenu(); }, 0);
        this.onConfigurationUpdated(this.configurationService.getConfiguration());
    }
    VSCodeMenu.prototype.ready = function () {
        this.registerListeners();
        this.install();
    };
    VSCodeMenu.prototype.registerListeners = function () {
        var _this = this;
        // Keep flag when app quits
        electron_1.app.on('will-quit', function () {
            _this.isQuitting = true;
        });
        // Listen to some events from window service
        this.windowsService.onPathsOpen(function (paths) { return _this.updateMenu(); });
        this.windowsService.onRecentPathsChange(function (paths) { return _this.updateMenu(); });
        this.windowsService.onWindowClose(function (_) { return _this.onClose(_this.windowsService.getWindowCount()); });
        // Resolve keybindings when any first workbench is loaded
        this.windowsService.onWindowReady(function (win) { return _this.resolveKeybindings(win); });
        // Listen to resolved keybindings
        electron_1.ipcMain.on('vscode:keybindingsResolved', function (event, rawKeybindings) {
            var keybindings = [];
            try {
                keybindings = JSON.parse(rawKeybindings);
            }
            catch (error) {
            }
            // Fill hash map of resolved keybindings
            var needsMenuUpdate = false;
            keybindings.forEach(function (keybinding) {
                var accelerator = new keybinding_1.Keybinding(keybinding.binding)._toElectronAccelerator();
                if (accelerator) {
                    _this.mapResolvedKeybindingToActionId[keybinding.id] = accelerator;
                    if (_this.mapLastKnownKeybindingToActionId[keybinding.id] !== accelerator) {
                        needsMenuUpdate = true; // we only need to update when something changed!
                    }
                }
            });
            // A keybinding might have been unassigned, so we have to account for that too
            if (Object.keys(_this.mapLastKnownKeybindingToActionId).length !== Object.keys(_this.mapResolvedKeybindingToActionId).length) {
                needsMenuUpdate = true;
            }
            if (needsMenuUpdate) {
                _this.storageService.setItem(VSCodeMenu.lastKnownKeybindingsMapStorageKey, _this.mapResolvedKeybindingToActionId); // keep to restore instantly after restart
                _this.mapLastKnownKeybindingToActionId = _this.mapResolvedKeybindingToActionId; // update our last known map
                _this.updateMenu();
            }
        });
        // Listen to extension viewlets
        electron_1.ipcMain.on('vscode:extensionViewlets', function (event, rawExtensionViewlets) {
            var extensionViewlets = [];
            try {
                extensionViewlets = JSON.parse(rawExtensionViewlets);
            }
            catch (error) {
            }
            if (extensionViewlets.length) {
                _this.extensionViewlets = extensionViewlets;
                _this.updateMenu();
            }
        });
        // Update when auto save config changes
        this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config, true /* update menu if changed */); });
        // Listen to update service
        this.updateService.onStateChange(function () { return _this.updateMenu(); });
    };
    VSCodeMenu.prototype.onConfigurationUpdated = function (config, handleMenu) {
        var updateMenu = false;
        var newAutoSaveSetting = config && config.files && config.files.autoSave;
        if (newAutoSaveSetting !== this.currentAutoSaveSetting) {
            this.currentAutoSaveSetting = newAutoSaveSetting;
            updateMenu = true;
        }
        var newSidebarLocation = config && config.workbench && config.workbench.sideBar && config.workbench.sideBar.location || 'left';
        if (newSidebarLocation !== this.currentSidebarLocation) {
            this.currentSidebarLocation = newSidebarLocation;
            updateMenu = true;
        }
        var newStatusbarVisible = config && config.workbench && config.workbench.statusBar && config.workbench.statusBar.visible;
        if (typeof newStatusbarVisible !== 'boolean') {
            newStatusbarVisible = true;
        }
        if (newStatusbarVisible !== this.currentStatusbarVisible) {
            this.currentStatusbarVisible = newStatusbarVisible;
            updateMenu = true;
        }
        var newActivityBarVisible = config && config.workbench && config.workbench.activityBar && config.workbench.activityBar.visible;
        if (typeof newActivityBarVisible !== 'boolean') {
            newActivityBarVisible = true;
        }
        if (newActivityBarVisible !== this.currentActivityBarVisible) {
            this.currentActivityBarVisible = newActivityBarVisible;
            updateMenu = true;
        }
        if (handleMenu && updateMenu) {
            this.updateMenu();
        }
    };
    VSCodeMenu.prototype.resolveKeybindings = function (win) {
        if (this.keybindingsResolved) {
            return; // only resolve once
        }
        this.keybindingsResolved = true;
        // Resolve keybindings when workbench window is up
        if (this.actionIdKeybindingRequests.length) {
            win.send('vscode:resolveKeybindings', JSON.stringify(this.actionIdKeybindingRequests));
        }
    };
    VSCodeMenu.prototype.updateMenu = function () {
        this.menuUpdater.schedule(); // buffer multiple attempts to update the menu
    };
    VSCodeMenu.prototype.doUpdateMenu = function () {
        var _this = this;
        // Due to limitations in Electron, it is not possible to update menu items dynamically. The suggested
        // workaround from Electron is to set the application menu again.
        // See also https://github.com/electron/electron/issues/846
        //
        // Run delayed to prevent updating menu while it is open
        if (!this.isQuitting) {
            setTimeout(function () {
                if (!_this.isQuitting) {
                    _this.install();
                }
            }, 10 /* delay this because there is an issue with updating a menu when it is open */);
        }
    };
    VSCodeMenu.prototype.onClose = function (remainingWindowCount) {
        if (remainingWindowCount === 0 && platform.isMacintosh) {
            this.updateMenu();
        }
    };
    VSCodeMenu.prototype.install = function () {
        var _this = this;
        // Menus
        var menubar = new electron_1.Menu();
        // Mac: Application
        var macApplicationMenuItem;
        if (platform.isMacintosh) {
            var applicationMenu = new electron_1.Menu();
            macApplicationMenuItem = new electron_1.MenuItem({ label: product_1.default.nameShort, submenu: applicationMenu });
            this.setMacApplicationMenu(applicationMenu);
        }
        // File
        var fileMenu = new electron_1.Menu();
        var fileMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mFile', comment: ['&& denotes a mnemonic'] }, "&&File")), submenu: fileMenu });
        this.setFileMenu(fileMenu);
        // Edit
        var editMenu = new electron_1.Menu();
        var editMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mEdit', comment: ['&& denotes a mnemonic'] }, "&&Edit")), submenu: editMenu });
        this.setEditMenu(editMenu);
        // Selection
        var selectionMenu = new electron_1.Menu();
        var selectionMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mSelection', comment: ['&& denotes a mnemonic'] }, "&&Selection")), submenu: selectionMenu });
        this.setSelectionMenu(selectionMenu);
        // View
        var viewMenu = new electron_1.Menu();
        var viewMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mView', comment: ['&& denotes a mnemonic'] }, "&&View")), submenu: viewMenu });
        this.setViewMenu(viewMenu);
        // Goto
        var gotoMenu = new electron_1.Menu();
        var gotoMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mGoto', comment: ['&& denotes a mnemonic'] }, "&&Go")), submenu: gotoMenu });
        this.setGotoMenu(gotoMenu);
        // Mac: Window
        var macWindowMenuItem;
        if (platform.isMacintosh) {
            var windowMenu = new electron_1.Menu();
            macWindowMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize('mWindow', "Window")), submenu: windowMenu, role: 'window' });
            this.setMacWindowMenu(windowMenu);
        }
        // Help
        var helpMenu = new electron_1.Menu();
        var helpMenuItem = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'mHelp', comment: ['&& denotes a mnemonic'] }, "&&Help")), submenu: helpMenu, role: 'help' });
        this.setHelpMenu(helpMenu);
        // Menu Structure
        if (macApplicationMenuItem) {
            menubar.append(macApplicationMenuItem);
        }
        menubar.append(fileMenuItem);
        menubar.append(editMenuItem);
        menubar.append(selectionMenuItem);
        menubar.append(viewMenuItem);
        menubar.append(gotoMenuItem);
        if (macWindowMenuItem) {
            menubar.append(macWindowMenuItem);
        }
        menubar.append(helpMenuItem);
        electron_1.Menu.setApplicationMenu(menubar);
        // Dock Menu
        if (platform.isMacintosh && !this.appMenuInstalled) {
            this.appMenuInstalled = true;
            var dockMenu = new electron_1.Menu();
            dockMenu.append(new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miNewWindow', comment: ['&& denotes a mnemonic'] }, "&&New Window")), click: function () { return _this.windowsService.openNewWindow(); } }));
            electron_1.app.dock.setMenu(dockMenu);
        }
    };
    VSCodeMenu.prototype.setMacApplicationMenu = function (macApplicationMenu) {
        var _this = this;
        var about = new electron_1.MenuItem({ label: nls.localize('mAbout', "About {0}", product_1.default.nameLong), role: 'about' });
        var checkForUpdates = this.getUpdateMenuItems();
        var preferences = this.getPreferencesMenu();
        var hide = new electron_1.MenuItem({ label: nls.localize('mHide', "Hide {0}", product_1.default.nameLong), role: 'hide', accelerator: 'Command+H' });
        var hideOthers = new electron_1.MenuItem({ label: nls.localize('mHideOthers', "Hide Others"), role: 'hideothers', accelerator: 'Command+Alt+H' });
        var showAll = new electron_1.MenuItem({ label: nls.localize('mShowAll', "Show All"), role: 'unhide' });
        var quit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', { label: nls.localize('miQuit', "Quit {0}", product_1.default.nameLong), click: function () { return _this.windowsService.quit(); }, accelerator: this.getAccelerator('workbench.action.quit', 'Command+Q') }));
        var actions = [about];
        actions.push.apply(actions, checkForUpdates);
        actions.push.apply(actions, [
            __separator__(),
            preferences,
            __separator__(),
            hide,
            hideOthers,
            showAll,
            __separator__(),
            quit
        ]);
        actions.forEach(function (i) { return macApplicationMenu.append(i); });
    };
    VSCodeMenu.prototype.setFileMenu = function (fileMenu) {
        var _this = this;
        var hasNoWindows = (this.windowsService.getWindowCount() === 0);
        var newFile;
        if (hasNoWindows) {
            newFile = new electron_1.MenuItem(this.likeAction('workbench.action.files.newUntitledFile', { label: mnemonicLabel(nls.localize({ key: 'miNewFile', comment: ['&& denotes a mnemonic'] }, "&&New File")), click: function () { return _this.windowsService.openNewWindow(); } }));
        }
        else {
            newFile = this.createMenuItem(nls.localize({ key: 'miNewFile', comment: ['&& denotes a mnemonic'] }, "&&New File"), 'workbench.action.files.newUntitledFile');
        }
        var open = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFileFolder', { label: mnemonicLabel(nls.localize({ key: 'miOpen', comment: ['&& denotes a mnemonic'] }, "&&Open...")), click: function () { return _this.windowsService.openFileFolderPicker(); } }));
        var openFolder = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFolder', { label: mnemonicLabel(nls.localize({ key: 'miOpenFolder', comment: ['&& denotes a mnemonic'] }, "Open &&Folder...")), click: function () { return _this.windowsService.openFolderPicker(); } }));
        var openFile;
        if (hasNoWindows) {
            openFile = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFile', { label: mnemonicLabel(nls.localize({ key: 'miOpenFile', comment: ['&& denotes a mnemonic'] }, "&&Open File...")), click: function () { return _this.windowsService.openFilePicker(); } }));
        }
        else {
            openFile = this.createMenuItem(nls.localize({ key: 'miOpenFile', comment: ['&& denotes a mnemonic'] }, "&&Open File..."), 'workbench.action.files.openFile');
        }
        var openRecentMenu = new electron_1.Menu();
        this.setOpenRecentMenu(openRecentMenu);
        var openRecent = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miOpenRecent', comment: ['&& denotes a mnemonic'] }, "Open &&Recent")), submenu: openRecentMenu, enabled: openRecentMenu.items.length > 0 });
        var saveFile = this.createMenuItem(nls.localize({ key: 'miSave', comment: ['&& denotes a mnemonic'] }, "&&Save"), 'workbench.action.files.save', this.windowsService.getWindowCount() > 0);
        var saveFileAs = this.createMenuItem(nls.localize({ key: 'miSaveAs', comment: ['&& denotes a mnemonic'] }, "Save &&As..."), 'workbench.action.files.saveAs', this.windowsService.getWindowCount() > 0);
        var saveAllFiles = this.createMenuItem(nls.localize({ key: 'miSaveAll', comment: ['&& denotes a mnemonic'] }, "Save A&&ll"), 'workbench.action.files.saveAll', this.windowsService.getWindowCount() > 0);
        var autoSaveEnabled = [files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE].some(function (s) { return _this.currentAutoSaveSetting === s; });
        var autoSave = new electron_1.MenuItem(this.likeAction('vscode.toggleAutoSave', { label: mnemonicLabel(nls.localize('miAutoSave', "Auto Save")), type: 'checkbox', checked: autoSaveEnabled, enabled: this.windowsService.getWindowCount() > 0, click: function () { return _this.windowsService.sendToFocused('vscode.toggleAutoSave'); } }, false));
        var preferences = this.getPreferencesMenu();
        var newWindow = new electron_1.MenuItem(this.likeAction('workbench.action.newWindow', { label: mnemonicLabel(nls.localize({ key: 'miNewWindow', comment: ['&& denotes a mnemonic'] }, "&&New Window")), click: function () { return _this.windowsService.openNewWindow(); } }));
        var revertFile = this.createMenuItem(nls.localize({ key: 'miRevert', comment: ['&& denotes a mnemonic'] }, "Revert F&&ile"), 'workbench.action.files.revert', this.windowsService.getWindowCount() > 0);
        var closeWindow = new electron_1.MenuItem(this.likeAction('workbench.action.closeWindow', { label: mnemonicLabel(nls.localize({ key: 'miCloseWindow', comment: ['&& denotes a mnemonic'] }, "Close &&Window")), click: function () { return _this.windowsService.getLastActiveWindow().win.close(); }, enabled: this.windowsService.getWindowCount() > 0 }));
        var closeFolder = this.createMenuItem(nls.localize({ key: 'miCloseFolder', comment: ['&& denotes a mnemonic'] }, "Close &&Folder"), 'workbench.action.closeFolder');
        var closeEditor = this.createMenuItem(nls.localize({ key: 'miCloseEditor', comment: ['&& denotes a mnemonic'] }, "&&Close Editor"), 'workbench.action.closeActiveEditor');
        var exit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', { label: mnemonicLabel(nls.localize({ key: 'miExit', comment: ['&& denotes a mnemonic'] }, "E&&xit")), click: function () { return _this.windowsService.quit(); } }));
        arrays.coalesce([
            newFile,
            newWindow,
            __separator__(),
            platform.isMacintosh ? open : null,
            !platform.isMacintosh ? openFile : null,
            !platform.isMacintosh ? openFolder : null,
            openRecent,
            __separator__(),
            saveFile,
            saveFileAs,
            saveAllFiles,
            __separator__(),
            autoSave,
            __separator__(),
            !platform.isMacintosh ? preferences : null,
            !platform.isMacintosh ? __separator__() : null,
            revertFile,
            closeEditor,
            closeFolder,
            !platform.isMacintosh ? closeWindow : null,
            !platform.isMacintosh ? __separator__() : null,
            !platform.isMacintosh ? exit : null
        ]).forEach(function (item) { return fileMenu.append(item); });
    };
    VSCodeMenu.prototype.getPreferencesMenu = function () {
        var userSettings = this.createMenuItem(nls.localize({ key: 'miOpenSettings', comment: ['&& denotes a mnemonic'] }, "&&User Settings"), 'workbench.action.openGlobalSettings');
        var workspaceSettings = this.createMenuItem(nls.localize({ key: 'miOpenWorkspaceSettings', comment: ['&& denotes a mnemonic'] }, "&&Workspace Settings"), 'workbench.action.openWorkspaceSettings');
        var kebindingSettings = this.createMenuItem(nls.localize({ key: 'miOpenKeymap', comment: ['&& denotes a mnemonic'] }, "&&Keyboard Shortcuts"), 'workbench.action.openGlobalKeybindings');
        var keymapExtensions = this.createMenuItem(nls.localize({ key: 'miOpenKeymapExtensions', comment: ['&& denotes a mnemonic'] }, "&&Keymap Extensions"), 'workbench.extensions.action.showRecommendedKeymapExtensions');
        var snippetsSettings = this.createMenuItem(nls.localize({ key: 'miOpenSnippets', comment: ['&& denotes a mnemonic'] }, "User &&Snippets"), 'workbench.action.openSnippets');
        var colorThemeSelection = this.createMenuItem(nls.localize({ key: 'miSelectColorTheme', comment: ['&& denotes a mnemonic'] }, "&&Color Theme"), 'workbench.action.selectTheme');
        var iconThemeSelection = this.createMenuItem(nls.localize({ key: 'miSelectIconTheme', comment: ['&& denotes a mnemonic'] }, "File &&Icon Theme"), 'workbench.action.selectIconTheme');
        var preferencesMenu = new electron_1.Menu();
        preferencesMenu.append(userSettings);
        preferencesMenu.append(workspaceSettings);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(kebindingSettings);
        preferencesMenu.append(keymapExtensions);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(snippetsSettings);
        preferencesMenu.append(__separator__());
        preferencesMenu.append(colorThemeSelection);
        preferencesMenu.append(iconThemeSelection);
        return new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miPreferences', comment: ['&& denotes a mnemonic'] }, "&&Preferences")), submenu: preferencesMenu });
    };
    VSCodeMenu.prototype.setOpenRecentMenu = function (openRecentMenu) {
        var _this = this;
        openRecentMenu.append(this.createMenuItem(nls.localize({ key: 'miReopenClosedEditor', comment: ['&& denotes a mnemonic'] }, "&&Reopen Closed Editor"), 'workbench.action.reopenClosedEditor'));
        var _a = this.windowsService.getRecentPathsList(), folders = _a.folders, files = _a.files;
        // Folders
        if (folders.length > 0) {
            openRecentMenu.append(__separator__());
            for (var i = 0; i < VSCodeMenu.MAX_MENU_RECENT_ENTRIES && i < folders.length; i++) {
                openRecentMenu.append(this.createOpenRecentMenuItem(folders[i], 'openRecentFolder'));
            }
        }
        // Files
        if (files.length > 0) {
            openRecentMenu.append(__separator__());
            for (var i = 0; i < VSCodeMenu.MAX_MENU_RECENT_ENTRIES && i < files.length; i++) {
                openRecentMenu.append(this.createOpenRecentMenuItem(files[i], 'openRecentFile'));
            }
        }
        if (folders.length || files.length) {
            openRecentMenu.append(__separator__());
            openRecentMenu.append(new electron_1.MenuItem(this.likeAction('clearRecentlyOpened', { label: mnemonicLabel(nls.localize({ key: 'miClearItems', comment: ['&& denotes a mnemonic'] }, "&&Clear Items")), click: function () { return _this.windowsService.clearRecentPathsList(); } }, false)));
        }
    };
    VSCodeMenu.prototype.createOpenRecentMenuItem = function (path, actionId) {
        var _this = this;
        return new electron_1.MenuItem(this.likeAction(actionId, {
            label: unMnemonicLabel(path), click: function (menuItem, win, event) {
                var openInNewWindow = event && ((!platform.isMacintosh && event.ctrlKey) || (platform.isMacintosh && event.metaKey));
                var success = !!_this.windowsService.open({ cli: _this.environmentService.args, pathsToOpen: [path], forceNewWindow: openInNewWindow });
                if (!success) {
                    _this.windowsService.removeFromRecentPathsList(path);
                }
            }
        }, false));
    };
    VSCodeMenu.prototype.createRoleMenuItem = function (label, actionId, role) {
        var options = {
            label: mnemonicLabel(label),
            accelerator: this.getAccelerator(actionId),
            role: role,
            enabled: true
        };
        return new electron_1.MenuItem(options);
    };
    VSCodeMenu.prototype.setEditMenu = function (winLinuxEditMenu) {
        var undo;
        var redo;
        var cut;
        var copy;
        var paste;
        if (platform.isMacintosh) {
            undo = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"), 'undo', function (devTools) { return devTools.undo(); });
            redo = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"), 'redo', function (devTools) { return devTools.redo(); });
            cut = this.createRoleMenuItem(nls.localize({ key: 'miCut', comment: ['&& denotes a mnemonic'] }, "&&Cut"), 'editor.action.clipboardCutAction', 'cut');
            copy = this.createRoleMenuItem(nls.localize({ key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "C&&opy"), 'editor.action.clipboardCopyAction', 'copy');
            paste = this.createRoleMenuItem(nls.localize({ key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"), 'editor.action.clipboardPasteAction', 'paste');
        }
        else {
            undo = this.createMenuItem(nls.localize({ key: 'miUndo', comment: ['&& denotes a mnemonic'] }, "&&Undo"), 'undo');
            redo = this.createMenuItem(nls.localize({ key: 'miRedo', comment: ['&& denotes a mnemonic'] }, "&&Redo"), 'redo');
            cut = this.createMenuItem(nls.localize({ key: 'miCut', comment: ['&& denotes a mnemonic'] }, "&&Cut"), 'editor.action.clipboardCutAction');
            copy = this.createMenuItem(nls.localize({ key: 'miCopy', comment: ['&& denotes a mnemonic'] }, "C&&opy"), 'editor.action.clipboardCopyAction');
            paste = this.createMenuItem(nls.localize({ key: 'miPaste', comment: ['&& denotes a mnemonic'] }, "&&Paste"), 'editor.action.clipboardPasteAction');
        }
        var find = this.createMenuItem(nls.localize({ key: 'miFind', comment: ['&& denotes a mnemonic'] }, "&&Find"), 'actions.find');
        var replace = this.createMenuItem(nls.localize({ key: 'miReplace', comment: ['&& denotes a mnemonic'] }, "&&Replace"), 'editor.action.startFindReplaceAction');
        var findInFiles = this.createMenuItem(nls.localize({ key: 'miFindInFiles', comment: ['&& denotes a mnemonic'] }, "Find &&in Files"), 'workbench.action.findInFiles');
        var replaceInFiles = this.createMenuItem(nls.localize({ key: 'miReplaceInFiles', comment: ['&& denotes a mnemonic'] }, "Replace &&in Files"), 'workbench.action.replaceInFiles');
        var emmetExpandAbbreviation = this.createMenuItem(nls.localize({ key: 'miEmmetExpandAbbreviation', comment: ['&& denotes a mnemonic'] }, "Emmet: E&&xpand Abbreviation"), 'editor.emmet.action.expandAbbreviation');
        var showEmmetCommands = this.createMenuItem(nls.localize({ key: 'miShowEmmetCommands', comment: ['&& denotes a mnemonic'] }, "E&&mmet..."), 'workbench.action.showEmmetCommands');
        var toggleLineComment = this.createMenuItem(nls.localize({ key: 'miToggleLineComment', comment: ['&& denotes a mnemonic'] }, "&&Toggle Line Comment"), 'editor.action.commentLine');
        var toggleBlockComment = this.createMenuItem(nls.localize({ key: 'miToggleBlockComment', comment: ['&& denotes a mnemonic'] }, "Toggle &&Block Comment"), 'editor.action.blockComment');
        [
            undo,
            redo,
            __separator__(),
            cut,
            copy,
            paste,
            __separator__(),
            find,
            replace,
            __separator__(),
            findInFiles,
            replaceInFiles,
            __separator__(),
            toggleLineComment,
            toggleBlockComment,
            emmetExpandAbbreviation,
            showEmmetCommands
        ].forEach(function (item) { return winLinuxEditMenu.append(item); });
    };
    VSCodeMenu.prototype.setSelectionMenu = function (winLinuxEditMenu) {
        var insertCursorAbove = this.createMenuItem(nls.localize({ key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, "&&Add Cursor Above"), 'editor.action.insertCursorAbove');
        var insertCursorBelow = this.createMenuItem(nls.localize({ key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, "A&&dd Cursor Below"), 'editor.action.insertCursorBelow');
        var insertCursorAtEndOfEachLineSelected = this.createMenuItem(nls.localize({ key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, "Add C&&ursors to Line Ends"), 'editor.action.insertCursorAtEndOfEachLineSelected');
        var addSelectionToNextFindMatch = this.createMenuItem(nls.localize({ key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, "Add &&Next Occurrence"), 'editor.action.addSelectionToNextFindMatch');
        var addSelectionToPreviousFindMatch = this.createMenuItem(nls.localize({ key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, "Add P&&revious Occurrence"), 'editor.action.addSelectionToPreviousFindMatch');
        var selectHighlights = this.createMenuItem(nls.localize({ key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, "Select All &&Occurrences"), 'editor.action.selectHighlights');
        var copyLinesUp = this.createMenuItem(nls.localize({ key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, "&&Copy Line Up"), 'editor.action.copyLinesUpAction');
        var copyLinesDown = this.createMenuItem(nls.localize({ key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, "Co&&py Line Down"), 'editor.action.copyLinesDownAction');
        var moveLinesUp = this.createMenuItem(nls.localize({ key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, "Mo&&ve Line Up"), 'editor.action.moveLinesUpAction');
        var moveLinesDown = this.createMenuItem(nls.localize({ key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, "Move &&Line Down"), 'editor.action.moveLinesDownAction');
        var selectAll;
        if (platform.isMacintosh) {
            selectAll = this.createDevToolsAwareMenuItem(nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"), 'editor.action.selectAll', function (devTools) { return devTools.selectAll(); });
        }
        else {
            selectAll = this.createMenuItem(nls.localize({ key: 'miSelectAll', comment: ['&& denotes a mnemonic'] }, "&&Select All"), 'editor.action.selectAll');
        }
        var smartSelectGrow = this.createMenuItem(nls.localize({ key: 'miSmartSelectGrow', comment: ['&& denotes a mnemonic'] }, "&&Expand Selection"), 'editor.action.smartSelect.grow');
        var smartSelectshrink = this.createMenuItem(nls.localize({ key: 'miSmartSelectShrink', comment: ['&& denotes a mnemonic'] }, "&&Shrink Selection"), 'editor.action.smartSelect.shrink');
        [
            selectAll,
            smartSelectGrow,
            smartSelectshrink,
            __separator__(),
            copyLinesUp,
            copyLinesDown,
            moveLinesUp,
            moveLinesDown,
            __separator__(),
            insertCursorAbove,
            insertCursorBelow,
            insertCursorAtEndOfEachLineSelected,
            addSelectionToNextFindMatch,
            addSelectionToPreviousFindMatch,
            selectHighlights,
        ].forEach(function (item) { return winLinuxEditMenu.append(item); });
    };
    VSCodeMenu.prototype.setViewMenu = function (viewMenu) {
        var _this = this;
        var explorer = this.createMenuItem(nls.localize({ key: 'miViewExplorer', comment: ['&& denotes a mnemonic'] }, "&&Explorer"), 'workbench.view.explorer');
        var search = this.createMenuItem(nls.localize({ key: 'miViewSearch', comment: ['&& denotes a mnemonic'] }, "&&Search"), 'workbench.view.search');
        var git = this.createMenuItem(nls.localize({ key: 'miViewGit', comment: ['&& denotes a mnemonic'] }, "&&Git"), 'workbench.view.git');
        var debug = this.createMenuItem(nls.localize({ key: 'miViewDebug', comment: ['&& denotes a mnemonic'] }, "&&Debug"), 'workbench.view.debug');
        var extensions = this.createMenuItem(nls.localize({ key: 'miViewExtensions', comment: ['&& denotes a mnemonic'] }, "E&&xtensions"), 'workbench.view.extensions');
        var output = this.createMenuItem(nls.localize({ key: 'miToggleOutput', comment: ['&& denotes a mnemonic'] }, "&&Output"), 'workbench.action.output.toggleOutput');
        var debugConsole = this.createMenuItem(nls.localize({ key: 'miToggleDebugConsole', comment: ['&& denotes a mnemonic'] }, "De&&bug Console"), 'workbench.debug.action.toggleRepl');
        var integratedTerminal = this.createMenuItem(nls.localize({ key: 'miToggleIntegratedTerminal', comment: ['&& denotes a mnemonic'] }, "&&Integrated Terminal"), 'workbench.action.terminal.toggleTerminal');
        var problems = this.createMenuItem(nls.localize({ key: 'miMarker', comment: ['&& denotes a mnemonic'] }, "&&Problems"), 'workbench.actions.view.problems');
        var additionalViewlets;
        if (this.extensionViewlets.length) {
            var additionalViewletsMenu_1 = new electron_1.Menu();
            this.extensionViewlets.forEach(function (viewlet) {
                additionalViewletsMenu_1.append(_this.createMenuItem(viewlet.label, viewlet.id));
            });
            additionalViewlets = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miAdditionalViews', comment: ['&& denotes a mnemonic'] }, "Additional &&Views")), submenu: additionalViewletsMenu_1, enabled: true });
        }
        var commands = this.createMenuItem(nls.localize({ key: 'miCommandPalette', comment: ['&& denotes a mnemonic'] }, "&&Command Palette..."), 'workbench.action.showCommands');
        var fullscreen = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miToggleFullScreen', comment: ['&& denotes a mnemonic'] }, "Toggle &&Full Screen")), accelerator: this.getAccelerator('workbench.action.toggleFullScreen'), click: function () { return _this.windowsService.getLastActiveWindow().toggleFullScreen(); }, enabled: this.windowsService.getWindowCount() > 0 });
        var toggleZenMode = this.createMenuItem(nls.localize('miToggleZenMode', "Toggle Zen Mode"), 'workbench.action.toggleZenMode', this.windowsService.getWindowCount() > 0);
        var toggleMenuBar = this.createMenuItem(nls.localize({ key: 'miToggleMenuBar', comment: ['&& denotes a mnemonic'] }, "Toggle Menu &&Bar"), 'workbench.action.toggleMenuBar');
        var splitEditor = this.createMenuItem(nls.localize({ key: 'miSplitEditor', comment: ['&& denotes a mnemonic'] }, "Split &&Editor"), 'workbench.action.splitEditor');
        var toggleEditorLayout = this.createMenuItem(nls.localize({ key: 'miToggleEditorLayout', comment: ['&& denotes a mnemonic'] }, "Toggle Editor Group &&Layout"), 'workbench.action.toggleEditorGroupLayout');
        var toggleSidebar = this.createMenuItem(nls.localize({ key: 'miToggleSidebar', comment: ['&& denotes a mnemonic'] }, "&&Toggle Side Bar"), 'workbench.action.toggleSidebarVisibility');
        var moveSideBarLabel;
        if (this.currentSidebarLocation !== 'right') {
            moveSideBarLabel = nls.localize({ key: 'miMoveSidebarRight', comment: ['&& denotes a mnemonic'] }, "&&Move Side Bar Right");
        }
        else {
            moveSideBarLabel = nls.localize({ key: 'miMoveSidebarLeft', comment: ['&& denotes a mnemonic'] }, "&&Move Side Bar Left");
        }
        var moveSidebar = this.createMenuItem(moveSideBarLabel, 'workbench.action.toggleSidebarPosition');
        var togglePanel = this.createMenuItem(nls.localize({ key: 'miTogglePanel', comment: ['&& denotes a mnemonic'] }, "Toggle &&Panel"), 'workbench.action.togglePanel');
        var statusBarLabel;
        if (this.currentStatusbarVisible) {
            statusBarLabel = nls.localize({ key: 'miHideStatusbar', comment: ['&& denotes a mnemonic'] }, "&&Hide Status Bar");
        }
        else {
            statusBarLabel = nls.localize({ key: 'miShowStatusbar', comment: ['&& denotes a mnemonic'] }, "&&Show Status Bar");
        }
        var toggleStatusbar = this.createMenuItem(statusBarLabel, 'workbench.action.toggleStatusbarVisibility');
        var activityBarLabel;
        if (this.currentActivityBarVisible) {
            activityBarLabel = nls.localize({ key: 'miHideActivityBar', comment: ['&& denotes a mnemonic'] }, "Hide &&Activity Bar");
        }
        else {
            activityBarLabel = nls.localize({ key: 'miShowActivityBar', comment: ['&& denotes a mnemonic'] }, "Show &&Activity Bar");
        }
        var toggleActivtyBar = this.createMenuItem(activityBarLabel, 'workbench.action.toggleActivityBarVisibility');
        var toggleWordWrap = this.createMenuItem(nls.localize({ key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] }, "Toggle &&Word Wrap"), 'editor.action.toggleWordWrap');
        var toggleRenderWhitespace = this.createMenuItem(nls.localize({ key: 'miToggleRenderWhitespace', comment: ['&& denotes a mnemonic'] }, "Toggle &&Render Whitespace"), 'editor.action.toggleRenderWhitespace');
        var toggleRenderControlCharacters = this.createMenuItem(nls.localize({ key: 'miToggleRenderControlCharacters', comment: ['&& denotes a mnemonic'] }, "Toggle &&Control Characters"), 'editor.action.toggleRenderControlCharacter');
        var zoomIn = this.createMenuItem(nls.localize({ key: 'miZoomIn', comment: ['&& denotes a mnemonic'] }, "&&Zoom In"), 'workbench.action.zoomIn');
        var zoomOut = this.createMenuItem(nls.localize({ key: 'miZoomOut', comment: ['&& denotes a mnemonic'] }, "Zoom O&&ut"), 'workbench.action.zoomOut');
        var resetZoom = this.createMenuItem(nls.localize({ key: 'miZoomReset', comment: ['&& denotes a mnemonic'] }, "&&Reset Zoom"), 'workbench.action.zoomReset');
        arrays.coalesce([
            commands,
            __separator__(),
            explorer,
            search,
            git,
            debug,
            extensions,
            additionalViewlets,
            __separator__(),
            output,
            problems,
            debugConsole,
            integratedTerminal,
            __separator__(),
            fullscreen,
            toggleZenMode,
            platform.isWindows || platform.isLinux ? toggleMenuBar : void 0,
            __separator__(),
            splitEditor,
            toggleEditorLayout,
            moveSidebar,
            toggleSidebar,
            togglePanel,
            toggleStatusbar,
            toggleActivtyBar,
            __separator__(),
            toggleWordWrap,
            toggleRenderWhitespace,
            toggleRenderControlCharacters,
            __separator__(),
            zoomIn,
            zoomOut,
            resetZoom
        ]).forEach(function (item) { return viewMenu.append(item); });
    };
    VSCodeMenu.prototype.setGotoMenu = function (gotoMenu) {
        var back = this.createMenuItem(nls.localize({ key: 'miBack', comment: ['&& denotes a mnemonic'] }, "&&Back"), 'workbench.action.navigateBack');
        var forward = this.createMenuItem(nls.localize({ key: 'miForward', comment: ['&& denotes a mnemonic'] }, "&&Forward"), 'workbench.action.navigateForward');
        var switchEditorMenu = new electron_1.Menu();
        var nextEditor = this.createMenuItem(nls.localize({ key: 'miNextEditor', comment: ['&& denotes a mnemonic'] }, "&&Next Editor"), 'workbench.action.nextEditor');
        var previousEditor = this.createMenuItem(nls.localize({ key: 'miPreviousEditor', comment: ['&& denotes a mnemonic'] }, "&&Previous Editor"), 'workbench.action.previousEditor');
        var nextEditorInGroup = this.createMenuItem(nls.localize({ key: 'miNextEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Used Editor in Group"), 'workbench.action.openNextRecentlyUsedEditorInGroup');
        var previousEditorInGroup = this.createMenuItem(nls.localize({ key: 'miPreviousEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Used Editor in Group"), 'workbench.action.openPreviousRecentlyUsedEditorInGroup');
        [
            nextEditor,
            previousEditor,
            __separator__(),
            nextEditorInGroup,
            previousEditorInGroup
        ].forEach(function (item) { return switchEditorMenu.append(item); });
        var switchEditor = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miSwitchEditor', comment: ['&& denotes a mnemonic'] }, "Switch &&Editor")), submenu: switchEditorMenu, enabled: true });
        var switchGroupMenu = new electron_1.Menu();
        var focusFirstGroup = this.createMenuItem(nls.localize({ key: 'miFocusFirstGroup', comment: ['&& denotes a mnemonic'] }, "&&First Group"), 'workbench.action.focusFirstEditorGroup');
        var focusSecondGroup = this.createMenuItem(nls.localize({ key: 'miFocusSecondGroup', comment: ['&& denotes a mnemonic'] }, "&&Second Group"), 'workbench.action.focusSecondEditorGroup');
        var focusThirdGroup = this.createMenuItem(nls.localize({ key: 'miFocusThirdGroup', comment: ['&& denotes a mnemonic'] }, "&&Third Group"), 'workbench.action.focusThirdEditorGroup');
        var nextGroup = this.createMenuItem(nls.localize({ key: 'miNextGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Group"), 'workbench.action.focusNextGroup');
        var previousGroup = this.createMenuItem(nls.localize({ key: 'miPreviousGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Group"), 'workbench.action.focusPreviousGroup');
        [
            focusFirstGroup,
            focusSecondGroup,
            focusThirdGroup,
            __separator__(),
            nextGroup,
            previousGroup
        ].forEach(function (item) { return switchGroupMenu.append(item); });
        var switchGroup = new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miSwitchGroup', comment: ['&& denotes a mnemonic'] }, "Switch &&Group")), submenu: switchGroupMenu, enabled: true });
        var gotoFile = this.createMenuItem(nls.localize({ key: 'miGotoFile', comment: ['&& denotes a mnemonic'] }, "Go to &&File..."), 'workbench.action.quickOpen');
        var gotoSymbolInFile = this.createMenuItem(nls.localize({ key: 'miGotoSymbolInFile', comment: ['&& denotes a mnemonic'] }, "Go to &&Symbol in File..."), 'workbench.action.gotoSymbol');
        var gotoSymbolInWorkspace = this.createMenuItem(nls.localize({ key: 'miGotoSymbolInWorkspace', comment: ['&& denotes a mnemonic'] }, "Go to Symbol in &&Workspace..."), 'workbench.action.showAllSymbols');
        var gotoDefinition = this.createMenuItem(nls.localize({ key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, "Go to &&Definition"), 'editor.action.goToDeclaration');
        var gotoLine = this.createMenuItem(nls.localize({ key: 'miGotoLine', comment: ['&& denotes a mnemonic'] }, "Go to &&Line..."), 'workbench.action.gotoLine');
        [
            back,
            forward,
            __separator__(),
            switchEditor,
            switchGroup,
            __separator__(),
            gotoFile,
            gotoSymbolInFile,
            gotoSymbolInWorkspace,
            gotoDefinition,
            gotoLine
        ].forEach(function (item) { return gotoMenu.append(item); });
    };
    VSCodeMenu.prototype.setMacWindowMenu = function (macWindowMenu) {
        var minimize = new electron_1.MenuItem({ label: nls.localize('mMinimize', "Minimize"), role: 'minimize', accelerator: 'Command+M', enabled: this.windowsService.getWindowCount() > 0 });
        var close = new electron_1.MenuItem({ label: nls.localize('mClose', "Close"), role: 'close', accelerator: 'Command+W', enabled: this.windowsService.getWindowCount() > 0 });
        var bringAllToFront = new electron_1.MenuItem({ label: nls.localize('mBringToFront', "Bring All to Front"), role: 'front', enabled: this.windowsService.getWindowCount() > 0 });
        [
            minimize,
            close,
            __separator__(),
            bringAllToFront
        ].forEach(function (item) { return macWindowMenu.append(item); });
    };
    VSCodeMenu.prototype.toggleDevTools = function () {
        var w = this.windowsService.getFocusedWindow();
        if (w && w.win) {
            var contents = w.win.webContents;
            if (w.hasHiddenTitleBarStyle() && !w.win.isFullScreen() && !contents.isDevToolsOpened()) {
                contents.openDevTools({ mode: 'undocked' }); // due to https://github.com/electron/electron/issues/3647
            }
            else {
                contents.toggleDevTools();
            }
        }
    };
    VSCodeMenu.prototype.setHelpMenu = function (helpMenu) {
        var _this = this;
        var toggleDevToolsItem = new electron_1.MenuItem(this.likeAction('workbench.action.toggleDevTools', {
            label: mnemonicLabel(nls.localize({ key: 'miToggleDevTools', comment: ['&& denotes a mnemonic'] }, "&&Toggle Developer Tools")),
            click: function () { return _this.toggleDevTools(); },
            enabled: (this.windowsService.getWindowCount() > 0)
        }));
        var showAccessibilityOptions = new electron_1.MenuItem(this.likeAction('accessibilityOptions', {
            label: mnemonicLabel(nls.localize({ key: 'miAccessibilityOptions', comment: ['&& denotes a mnemonic'] }, "Accessibility &&Options")),
            accelerator: null,
            click: function () {
                _this.windowsService.openAccessibilityOptions();
            }
        }, false));
        var reportIssuesItem = null;
        if (product_1.default.reportIssueUrl) {
            var label = nls.localize({ key: 'miReportIssues', comment: ['&& denotes a mnemonic'] }, "Report &&Issues");
            if (this.windowsService.getWindowCount() > 0) {
                reportIssuesItem = this.createMenuItem(label, 'workbench.action.reportIssues');
            }
            else {
                reportIssuesItem = new electron_1.MenuItem({ label: mnemonicLabel(label), click: function () { return _this.openUrl(product_1.default.reportIssueUrl, 'openReportIssues'); } });
            }
        }
        var keyboardShortcutsUrl = platform.isLinux ? product_1.default.keyboardShortcutsUrlLinux : platform.isMacintosh ? product_1.default.keyboardShortcutsUrlMac : product_1.default.keyboardShortcutsUrlWin;
        arrays.coalesce([
            product_1.default.documentationUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miDocumentation', comment: ['&& denotes a mnemonic'] }, "&&Documentation")), click: function () { return _this.openUrl(product_1.default.documentationUrl, 'openDocumentationUrl'); } }) : null,
            product_1.default.releaseNotesUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miReleaseNotes', comment: ['&& denotes a mnemonic'] }, "&&Release Notes")), click: function () { return _this.windowsService.sendToFocused('vscode:runAction', 'update.showCurrentReleaseNotes'); } }) : null,
            (product_1.default.documentationUrl || product_1.default.releaseNotesUrl) ? __separator__() : null,
            keyboardShortcutsUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miKeyboardShortcuts', comment: ['&& denotes a mnemonic'] }, "&&Keyboard Shortcuts Reference")), click: function () { return _this.windowsService.sendToFocused('vscode:runAction', 'workbench.action.keybindingsReference'); } }) : null,
            product_1.default.introductoryVideosUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miIntroductoryVideos', comment: ['&& denotes a mnemonic'] }, "Introductory &&Videos")), click: function () { return _this.openUrl(product_1.default.introductoryVideosUrl, 'openIntroductoryVideosUrl'); } }) : null,
            (product_1.default.introductoryVideosUrl || keyboardShortcutsUrl) ? __separator__() : null,
            product_1.default.twitterUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miTwitter', comment: ['&& denotes a mnemonic'] }, "&&Join us on Twitter")), click: function () { return _this.openUrl(product_1.default.twitterUrl, 'openTwitterUrl'); } }) : null,
            product_1.default.requestFeatureUrl ? new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miUserVoice', comment: ['&& denotes a mnemonic'] }, "&&Search Feature Requests")), click: function () { return _this.openUrl(product_1.default.requestFeatureUrl, 'openUserVoiceUrl'); } }) : null,
            reportIssuesItem,
            (product_1.default.twitterUrl || product_1.default.requestFeatureUrl || product_1.default.reportIssueUrl) ? __separator__() : null,
            product_1.default.licenseUrl ? new electron_1.MenuItem({
                label: mnemonicLabel(nls.localize({ key: 'miLicense', comment: ['&& denotes a mnemonic'] }, "View &&License")), click: function () {
                    if (platform.language) {
                        var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                        _this.openUrl("" + product_1.default.licenseUrl + queryArgChar + "lang=" + platform.language, 'openLicenseUrl');
                    }
                    else {
                        _this.openUrl(product_1.default.licenseUrl, 'openLicenseUrl');
                    }
                }
            }) : null,
            product_1.default.privacyStatementUrl ? new electron_1.MenuItem({
                label: mnemonicLabel(nls.localize({ key: 'miPrivacyStatement', comment: ['&& denotes a mnemonic'] }, "&&Privacy Statement")), click: function () {
                    if (platform.language) {
                        var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                        _this.openUrl("" + product_1.default.privacyStatementUrl + queryArgChar + "lang=" + platform.language, 'openPrivacyStatement');
                    }
                    else {
                        _this.openUrl(product_1.default.privacyStatementUrl, 'openPrivacyStatement');
                    }
                }
            }) : null,
            (product_1.default.licenseUrl || product_1.default.privacyStatementUrl) ? __separator__() : null,
            toggleDevToolsItem,
            platform.isWindows && product_1.default.quality !== 'stable' ? showAccessibilityOptions : null
        ]).forEach(function (item) { return helpMenu.append(item); });
        if (!platform.isMacintosh) {
            var updateMenuItems = this.getUpdateMenuItems();
            if (updateMenuItems.length) {
                helpMenu.append(__separator__());
                updateMenuItems.forEach(function (i) { return helpMenu.append(i); });
            }
            helpMenu.append(__separator__());
            helpMenu.append(new electron_1.MenuItem({ label: mnemonicLabel(nls.localize({ key: 'miAbout', comment: ['&& denotes a mnemonic'] }, "&&About")), click: function () { return _this.openAboutDialog(); } }));
        }
    };
    VSCodeMenu.prototype.getUpdateMenuItems = function () {
        var _this = this;
        switch (this.updateService.state) {
            case update_1.State.Uninitialized:
                return [];
            case update_1.State.UpdateDownloaded:
                return [new electron_1.MenuItem({
                        label: nls.localize('miRestartToUpdate', "Restart To Update..."), click: function () {
                            _this.reportMenuActionTelemetry('RestartToUpdate');
                            _this.updateService.quitAndInstall();
                        }
                    })];
            case update_1.State.CheckingForUpdate:
                return [new electron_1.MenuItem({ label: nls.localize('miCheckingForUpdates', "Checking For Updates..."), enabled: false })];
            case update_1.State.UpdateAvailable:
                if (platform.isLinux) {
                    return [new electron_1.MenuItem({
                            label: nls.localize('miDownloadUpdate', "Download Available Update"), click: function () {
                                _this.updateService.quitAndInstall();
                            }
                        })];
                }
                var updateAvailableLabel = platform.isWindows
                    ? nls.localize('miDownloadingUpdate', "Downloading Update...")
                    : nls.localize('miInstallingUpdate', "Installing Update...");
                return [new electron_1.MenuItem({ label: updateAvailableLabel, enabled: false })];
            default:
                var result = [new electron_1.MenuItem({
                        label: nls.localize('miCheckForUpdates', "Check For Updates..."), click: function () { return setTimeout(function () {
                            _this.reportMenuActionTelemetry('CheckForUpdate');
                            _this.updateService.checkForUpdates(true);
                        }, 0); }
                    })];
                return result;
        }
    };
    VSCodeMenu.prototype.createMenuItem = function (arg1, arg2, arg3, arg4) {
        var _this = this;
        var label = mnemonicLabel(arg1);
        var click = (typeof arg2 === 'function') ? arg2 : function () { return _this.windowsService.sendToFocused('vscode:runAction', arg2); };
        var enabled = typeof arg3 === 'boolean' ? arg3 : this.windowsService.getWindowCount() > 0;
        var checked = typeof arg4 === 'boolean' ? arg4 : false;
        var actionId;
        if (typeof arg2 === 'string') {
            actionId = arg2;
        }
        var options = {
            label: label,
            accelerator: this.getAccelerator(actionId),
            click: click,
            enabled: enabled
        };
        if (checked) {
            options['type'] = 'checkbox';
            options['checked'] = checked;
        }
        return new electron_1.MenuItem(options);
    };
    VSCodeMenu.prototype.createDevToolsAwareMenuItem = function (label, actionId, devToolsFocusedFn) {
        var _this = this;
        return new electron_1.MenuItem({
            label: mnemonicLabel(label),
            accelerator: this.getAccelerator(actionId),
            enabled: this.windowsService.getWindowCount() > 0,
            click: function () {
                var windowInFocus = _this.windowsService.getFocusedWindow();
                if (!windowInFocus) {
                    return;
                }
                if (windowInFocus.win.webContents.isDevToolsFocused()) {
                    devToolsFocusedFn(windowInFocus.win.webContents.devToolsWebContents);
                }
                else {
                    _this.windowsService.sendToFocused('vscode:runAction', actionId);
                }
            }
        });
    };
    VSCodeMenu.prototype.likeAction = function (actionId, options, setAccelerator) {
        var _this = this;
        if (setAccelerator === void 0) { setAccelerator = !options.accelerator; }
        if (setAccelerator) {
            options.accelerator = this.getAccelerator(actionId);
        }
        var originalClick = options.click;
        options.click = function (item, window, event) {
            _this.reportMenuActionTelemetry(actionId);
            if (originalClick) {
                originalClick(item, window, event);
            }
        };
        return options;
    };
    VSCodeMenu.prototype.getAccelerator = function (actionId, fallback) {
        if (actionId) {
            var resolvedKeybinding = this.mapResolvedKeybindingToActionId[actionId];
            if (resolvedKeybinding) {
                return resolvedKeybinding; // keybinding is fully resolved
            }
            if (!this.keybindingsResolved) {
                this.actionIdKeybindingRequests.push(actionId); // keybinding needs to be resolved
            }
            var lastKnownKeybinding = this.mapLastKnownKeybindingToActionId[actionId];
            if (lastKnownKeybinding) {
                return lastKnownKeybinding; // return the last known keybining (chance of mismatch is very low unless it changed)
            }
        }
        return fallback;
    };
    VSCodeMenu.prototype.openAboutDialog = function () {
        var lastActiveWindow = this.windowsService.getFocusedWindow() || this.windowsService.getLastActiveWindow();
        electron_1.dialog.showMessageBox(lastActiveWindow && lastActiveWindow.win, {
            title: product_1.default.nameLong,
            type: 'info',
            message: product_1.default.nameLong,
            detail: nls.localize('aboutDetail', "\nVersion {0}\nCommit {1}\nDate {2}\nShell {3}\nRenderer {4}\nNode {5}", electron_1.app.getVersion(), product_1.default.commit || 'Unknown', product_1.default.date || 'Unknown', process.versions['electron'], process.versions['chrome'], process.versions['node']),
            buttons: [nls.localize('okButton', "OK")],
            noLink: true
        }, function (result) { return null; });
        this.reportMenuActionTelemetry('showAboutDialog');
    };
    VSCodeMenu.prototype.openUrl = function (url, id) {
        electron_1.shell.openExternal(url);
        this.reportMenuActionTelemetry(id);
    };
    VSCodeMenu.prototype.reportMenuActionTelemetry = function (id) {
        this.telemetryService.publicLog('workbenchActionExecuted', { id: id, from: 'menu' });
    };
    return VSCodeMenu;
}());
VSCodeMenu.lastKnownKeybindingsMapStorageKey = 'lastKnownKeybindings';
VSCodeMenu.MAX_MENU_RECENT_ENTRIES = 10;
VSCodeMenu = __decorate([
    __param(0, storage_1.IStorageService),
    __param(1, update_1.IUpdateService),
    __param(2, configuration_1.IConfigurationService),
    __param(3, windows_1.IWindowsMainService),
    __param(4, environment_1.IEnvironmentService),
    __param(5, telemetry_1.ITelemetryService)
], VSCodeMenu);
exports.VSCodeMenu = VSCodeMenu;
function __separator__() {
    return new electron_1.MenuItem({ type: 'separator' });
}
function mnemonicLabel(label) {
    if (platform.isMacintosh) {
        return label.replace(/\(&&\w\)|&&/g, ''); // no mnemonic support on mac
    }
    return label.replace(/&&/g, '&');
}
function unMnemonicLabel(label) {
    if (platform.isMacintosh) {
        return label; // no mnemonic support on mac
    }
    return label.replace(/&/g, '&&');
}
