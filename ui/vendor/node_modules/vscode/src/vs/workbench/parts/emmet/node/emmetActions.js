/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/// <reference path="emmet.d.ts" />
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var editorCommonExtensions_1 = require("vs/editor/common/editorCommonExtensions");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var TMGrammars_1 = require("vs/editor/node/textMate/TMGrammars");
var modeService_1 = require("vs/editor/common/services/modeService");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var editorAccessor_1 = require("vs/workbench/parts/emmet/node/editorAccessor");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var extensions_1 = require("vs/platform/extensions/common/extensions");
var message_1 = require("vs/platform/message/common/message");
var path = require("path");
var pfs = require("vs/base/node/pfs");
var severity_1 = require("vs/base/common/severity");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var GrammarContributions = (function () {
    function GrammarContributions(contributions) {
        if (GrammarContributions._grammars === null) {
            this.fillModeScopeMap(contributions);
        }
    }
    GrammarContributions.prototype.fillModeScopeMap = function (contributions) {
        GrammarContributions._grammars = {};
        contributions.forEach(function (contribution) {
            contribution.value.forEach(function (grammar) {
                if (grammar.language && grammar.scopeName) {
                    GrammarContributions._grammars[grammar.language] = grammar.scopeName;
                }
            });
        });
    };
    GrammarContributions.prototype.getGrammar = function (mode) {
        return GrammarContributions._grammars[mode];
    };
    return GrammarContributions;
}());
GrammarContributions._grammars = null;
var LazyEmmet = (function () {
    function LazyEmmet() {
        this._emmetPromise = null;
    }
    LazyEmmet.withConfiguredEmmet = function (configurationService, messageService, workspaceRoot, callback) {
        LazyEmmet.workspaceRoot = workspaceRoot;
        return LazyEmmet._INSTANCE.withEmmetPreferences(configurationService, messageService, callback);
    };
    LazyEmmet.prototype.withEmmetPreferences = function (configurationService, messageService, callback) {
        var _this = this;
        return this._loadEmmet().then(function (_emmet) {
            _this._messageService = messageService;
            _this._withEmmetPreferences(configurationService, _emmet, callback);
        }, function (e) {
            callback(null);
        });
    };
    LazyEmmet.prototype._loadEmmet = function () {
        if (!this._emmetPromise) {
            this._emmetPromise = new winjs_base_1.TPromise(function (c, e) {
                require(['emmet'], c, e);
            });
        }
        return this._emmetPromise;
    };
    LazyEmmet.prototype.updateEmmetPreferences = function (configurationService, _emmet) {
        var emmetPreferences = configurationService.getConfiguration().emmet;
        var loadEmmetSettings = function () {
            var syntaxProfiles = __assign({}, LazyEmmet.syntaxProfilesFromFile, emmetPreferences.syntaxProfiles);
            var preferences = __assign({}, LazyEmmet.preferencesFromFile, emmetPreferences.preferences);
            var snippets = LazyEmmet.snippetsFromFile;
            try {
                _emmet.loadPreferences(preferences);
                _emmet.loadProfiles(syntaxProfiles);
                _emmet.loadSnippets(snippets);
            }
            catch (err) {
            }
        };
        // Whether loading the files was a success or not, we load emmet with what we have
        return this.updateFromExtensionsPath(emmetPreferences.extensionsPath).then(loadEmmetSettings, function (err) {
            // Errors from all the promises used to fetch/read dir/files would bubble up here
            console.log(err);
            loadEmmetSettings();
        });
    };
    LazyEmmet.prototype.updateFromExtensionsPath = function (extPath) {
        var _this = this;
        if (extPath !== LazyEmmet.extensionsPath) {
            LazyEmmet.extensionsPath = extPath;
            LazyEmmet.snippetsFromFile = {};
            LazyEmmet.preferencesFromFile = {};
            LazyEmmet.syntaxProfilesFromFile = {};
            if (extPath && extPath.trim()) {
                var dirPath = path.isAbsolute(extPath) ? extPath : path.join(LazyEmmet.workspaceRoot, extPath);
                var snippetsPath_1 = path.join(dirPath, 'snippets.json');
                var syntaxProfilesPath_1 = path.join(dirPath, 'syntaxProfiles.json');
                var preferencesPath_1 = path.join(dirPath, 'preferences.json');
                return pfs.dirExists(dirPath).then(function (exists) {
                    if (exists) {
                        var snippetsPromise = _this.getEmmetCustomization(snippetsPath_1).then(function (value) { return LazyEmmet.snippetsFromFile = value; });
                        var profilesPromise = _this.getEmmetCustomization(syntaxProfilesPath_1).then(function (value) { return LazyEmmet.syntaxProfilesFromFile = value; });
                        var preferencesPromise = _this.getEmmetCustomization(preferencesPath_1).then(function (value) { return LazyEmmet.preferencesFromFile = value; });
                        return winjs_base_1.TPromise.join([snippetsPromise, profilesPromise, preferencesPromise]);
                    }
                    _this._messageService.show(severity_1.default.Error, "The path set in emmet.extensionsPath \"" + LazyEmmet.extensionsPath + "\" does not exist.");
                    return undefined;
                });
            }
        }
        return winjs_base_1.TPromise.as(void 0);
    };
    LazyEmmet.prototype.getEmmetCustomization = function (filePath) {
        var _this = this;
        return pfs.fileExists(filePath).then(function (fileExists) {
            if (fileExists) {
                return pfs.readFile(filePath).then(function (buff) {
                    var parsedData = {};
                    try {
                        parsedData = JSON.parse(buff.toString());
                    }
                    catch (err) {
                        _this._messageService.show(severity_1.default.Error, "Error while parsing \"" + filePath + "\": " + err);
                    }
                    return parsedData;
                });
            }
            return {};
        });
    };
    LazyEmmet.prototype._withEmmetPreferences = function (configurationService, _emmet, callback) {
        this.updateEmmetPreferences(configurationService, _emmet).then(function () {
            try {
                callback(_emmet);
            }
            finally {
                _emmet.resetUserData();
            }
        });
    };
    return LazyEmmet;
}());
LazyEmmet._INSTANCE = new LazyEmmet();
LazyEmmet.extensionsPath = '';
LazyEmmet.snippetsFromFile = {};
LazyEmmet.syntaxProfilesFromFile = {};
LazyEmmet.preferencesFromFile = {};
LazyEmmet.workspaceRoot = '';
var EmmetActionContext = (function () {
    function EmmetActionContext(editor, _emmet, editorAccessor) {
        this.editor = editor;
        this.emmet = _emmet;
        this.editorAccessor = editorAccessor;
    }
    return EmmetActionContext;
}());
exports.EmmetActionContext = EmmetActionContext;
var EmmetEditorAction = (function (_super) {
    __extends(EmmetEditorAction, _super);
    function EmmetEditorAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._lastGrammarContributions = null;
        _this._lastExtensionService = null;
        return _this;
    }
    EmmetEditorAction.prototype.noExpansionOccurred = function (editor) {
        // default do nothing
    };
    EmmetEditorAction.prototype._withGrammarContributions = function (extensionService) {
        if (this._lastExtensionService !== extensionService) {
            this._lastExtensionService = extensionService;
            this._lastGrammarContributions = extensionService.readExtensionPointContributions(TMGrammars_1.grammarsExtPoint).then(function (contributions) {
                return new GrammarContributions(contributions);
            });
        }
        return this._lastGrammarContributions;
    };
    EmmetEditorAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var configurationService = accessor.get(configuration_1.IConfigurationService);
        var instantiationService = accessor.get(instantiation_1.IInstantiationService);
        var extensionService = accessor.get(extensions_1.IExtensionService);
        var modeService = accessor.get(modeService_1.IModeService);
        var messageService = accessor.get(message_1.IMessageService);
        var contextService = accessor.get(workspace_1.IWorkspaceContextService);
        var workspaceRoot = contextService.getWorkspace() ? contextService.getWorkspace().resource.fsPath : '';
        return this._withGrammarContributions(extensionService).then(function (grammarContributions) {
            var editorAccessor = new editorAccessor_1.EditorAccessor(modeService, editor, configurationService.getConfiguration().emmet.syntaxProfiles, configurationService.getConfiguration().emmet.excludeLanguages, grammarContributions);
            if (!editorAccessor.isEmmetEnabledMode()) {
                _this.noExpansionOccurred(editor);
                return undefined;
            }
            return LazyEmmet.withConfiguredEmmet(configurationService, messageService, workspaceRoot, function (_emmet) {
                if (!_emmet) {
                    _this.noExpansionOccurred(editor);
                    return undefined;
                }
                editorAccessor.onBeforeEmmetAction();
                instantiationService.invokeFunction(function (accessor) {
                    _this.runEmmetAction(accessor, new EmmetActionContext(editor, _emmet, editorAccessor));
                });
                editorAccessor.onAfterEmmetAction();
            });
        });
    };
    return EmmetEditorAction;
}(editorCommonExtensions_1.EditorAction));
exports.EmmetEditorAction = EmmetEditorAction;
var BasicEmmetEditorAction = (function (_super) {
    __extends(BasicEmmetEditorAction, _super);
    function BasicEmmetEditorAction(id, label, alias, actionName, kbOpts) {
        var _this = _super.call(this, {
            id: id,
            label: label,
            alias: alias,
            precondition: editorCommon_1.EditorContextKeys.Writable,
            kbOpts: kbOpts
        }) || this;
        _this.emmetActionName = actionName;
        return _this;
    }
    BasicEmmetEditorAction.prototype.runEmmetAction = function (accessor, ctx) {
        var telemetryService = accessor.get(telemetry_1.ITelemetryService);
        try {
            if (!ctx.emmet.run(this.emmetActionName, ctx.editorAccessor)) {
                this.noExpansionOccurred(ctx.editor);
            }
            else if (this.emmetActionName === 'expand_abbreviation') {
                telemetryService.publicLog('emmetActionSucceeded', { action: this.emmetActionName });
            }
        }
        catch (err) {
            this.noExpansionOccurred(ctx.editor);
        }
    };
    return BasicEmmetEditorAction;
}(EmmetEditorAction));
exports.BasicEmmetEditorAction = BasicEmmetEditorAction;
