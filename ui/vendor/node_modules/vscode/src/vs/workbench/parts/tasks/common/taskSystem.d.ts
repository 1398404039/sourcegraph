import Severity from 'vs/base/common/severity';
import { TPromise } from 'vs/base/common/winjs.base';
import { TerminateResponse } from 'vs/base/common/processes';
import { IEventEmitter } from 'vs/base/common/eventEmitter';
import { ProblemMatcher } from 'vs/platform/markers/common/problemMatcher';
export declare enum TaskErrors {
    NotConfigured = 0,
    RunningTask = 1,
    NoBuildTask = 2,
    NoTestTask = 3,
    ConfigValidationError = 4,
    TaskNotFound = 5,
    NoValidTaskRunner = 6,
    UnknownError = 7,
}
export declare class TaskError {
    severity: Severity;
    message: string;
    code: TaskErrors;
    constructor(severity: Severity, message: string, code: TaskErrors);
}
export interface TelemetryEvent {
    trigger: string;
    command: string;
    success: boolean;
    exitCode?: number;
}
export declare namespace Triggers {
    let shortcut: string;
    let command: string;
}
export declare enum ShowOutput {
    Always = 0,
    Silent = 1,
    Never = 2,
}
export declare namespace ShowOutput {
    function fromString(value: string): ShowOutput;
}
export interface CommandOptions {
    /**
     * The current working directory of the executed program or shell.
     * If omitted VSCode's current workspace root is used.
     */
    cwd?: string;
    /**
     * The environment of the executed program or shell. If omitted
     * the parent process' environment is used.
     */
    env?: {
        [key: string]: string;
    };
}
export interface ShellConfiguration {
    /**
     * The shell executable.
     */
    executable: string;
    /**
     * The arguments to be passed to the shell executable.
     */
    args?: string[];
}
export declare namespace ShellConfiguration {
    function is(value: any): value is ShellConfiguration;
}
export interface CommandConfiguration {
    /**
     * The command to execute
     */
    name?: string;
    /**
     * Whether the command is a shell command or not
     */
    isShellCommand?: boolean | ShellConfiguration;
    /**
     * Additional command options.
     */
    options?: CommandOptions;
    /**
     * Command arguments.
     */
    args?: string[];
    /**
     * The task selector if needed.
     */
    taskSelector?: string;
    /**
     * Controls whether the executed command is printed to the output windows as well.
     */
    echo?: boolean;
}
export interface CommandBinding {
    /**
     * The command identifier the task is bound to.
     */
    identifier: string;
    /**
     * The title to use
     */
    title: string;
    /**
     * An optional category
     */
    category?: string;
}
/**
 * A task description
 */
export interface TaskDescription {
    /**
     * The task's internal id
     */
    id: string;
    /**
     * The task's name
     */
    name: string;
    /**
     * The task's identifier.
     */
    identifier: string;
    /**
     * The command configuration
     */
    command: CommandConfiguration;
    /**
     * Suppresses the task name when calling the task using the task runner.
     */
    suppressTaskName?: boolean;
    /**
     * Additional arguments passed to the command when this target is
     * invoked.
     */
    args?: string[];
    /**
     * Whether the task is a background task or not.
     */
    isBackground?: boolean;
    /**
     * Whether the task should prompt on close for confirmation if running.
     */
    promptOnClose?: boolean;
    /**
     * Controls whether the output of the running tasks is shown or not. Default
     * value is "always".
     */
    showOutput: ShowOutput;
    /**
     * The other tasks this task depends on.
     */
    dependsOn?: string[];
    /**
     * The problem watchers to use for this task
     */
    problemMatchers?: ProblemMatcher[];
}
/**
 * Describs the settings of a task runner
 */
export interface TaskRunnerConfiguration {
    /**
     * The inferred build tasks
     */
    buildTasks: string[];
    /**
     * The inferred test tasks;
     */
    testTasks: string[];
    /**
     * The configured tasks
     */
    tasks?: {
        [id: string]: TaskDescription;
    };
}
export interface ITaskSummary {
    /**
     * Exit code of the process.
     */
    exitCode?: number;
}
export declare enum TaskExecuteKind {
    Started = 1,
    Active = 2,
}
export interface ITaskExecuteResult {
    kind: TaskExecuteKind;
    promise: TPromise<ITaskSummary>;
    started?: {
        restartOnFileChanges?: string;
    };
    active?: {
        same: boolean;
        background: boolean;
    };
}
export declare namespace TaskSystemEvents {
    let Active: string;
    let Inactive: string;
}
export declare enum TaskType {
    SingleRun = 0,
    Watching = 1,
}
export interface TaskEvent {
    taskId?: string;
    taskName?: string;
    type?: TaskType;
}
export interface ITaskSystem extends IEventEmitter {
    build(): ITaskExecuteResult;
    rebuild(): ITaskExecuteResult;
    clean(): ITaskExecuteResult;
    runTest(): ITaskExecuteResult;
    run(taskIdentifier: string): ITaskExecuteResult;
    isActive(): TPromise<boolean>;
    isActiveSync(): boolean;
    canAutoTerminate(): boolean;
    terminate(): TPromise<TerminateResponse>;
    tasks(): TPromise<TaskDescription[]>;
}
