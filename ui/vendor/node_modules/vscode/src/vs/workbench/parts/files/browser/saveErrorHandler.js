/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var nls = require("vs/nls");
var errors = require("vs/base/common/errors");
var errorMessage_1 = require("vs/base/common/errorMessage");
var paths = require("vs/base/common/paths");
var actions_1 = require("vs/base/common/actions");
var uri_1 = require("vs/base/common/uri");
var baseEditor_1 = require("vs/workbench/browser/parts/editor/baseEditor");
var fileActions_1 = require("vs/workbench/parts/files/browser/fileActions");
var files_1 = require("vs/platform/files/common/files");
var environment_1 = require("vs/platform/environment/common/environment");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
var modeService_1 = require("vs/editor/common/services/modeService");
var modelService_1 = require("vs/editor/common/services/modelService");
var lifecycle_1 = require("vs/base/common/lifecycle");
var textFileEditorModel_1 = require("vs/workbench/services/textfile/common/textFileEditorModel");
var resolverService_1 = require("vs/editor/common/services/resolverService");
var editor_1 = require("vs/workbench/common/editor");
exports.CONFLICT_RESOLUTION_SCHEME = 'conflictResolution';
// A handler for save error happening with conflict resolution actions
var SaveErrorHandler = (function () {
    function SaveErrorHandler(messageService, textFileService, textModelResolverService, modelService, modeService, instantiationService) {
        this.messageService = messageService;
        this.textFileService = textFileService;
        this.textModelResolverService = textModelResolverService;
        this.modelService = modelService;
        this.modeService = modeService;
        this.instantiationService = instantiationService;
        this.messages = Object.create(null);
        this.toUnbind = [];
        // Register as text model content provider that supports to load a resource as it actually
        // is stored on disk as opposed to using the file:// scheme that will return a dirty buffer
        // if there is one.
        this.textModelResolverService.registerTextModelContentProvider(exports.CONFLICT_RESOLUTION_SCHEME, this);
        // Hook into model
        textFileEditorModel_1.TextFileEditorModel.setSaveErrorHandler(this);
        this.registerListeners();
    }
    SaveErrorHandler.prototype.provideTextContent = function (resource) {
        var _this = this;
        // Make sure our file from disk is resolved up to date
        return this.textFileService.resolveTextContent(uri_1.default.file(resource.fsPath)).then(function (content) {
            var codeEditorModel = _this.modelService.getModel(resource);
            if (!codeEditorModel) {
                codeEditorModel = _this.modelService.createModel(content.value, _this.modeService.getOrCreateModeByFilenameOrFirstLine(resource.fsPath), resource);
            }
            else {
                _this.modelService.updateModel(codeEditorModel, content.value);
            }
            return codeEditorModel;
        });
    };
    SaveErrorHandler.prototype.getId = function () {
        return 'vs.files.saveerrorhandler';
    };
    SaveErrorHandler.prototype.registerListeners = function () {
        var _this = this;
        this.toUnbind.push(this.textFileService.models.onModelSaved(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
        this.toUnbind.push(this.textFileService.models.onModelReverted(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
    };
    SaveErrorHandler.prototype.onFileSavedOrReverted = function (resource) {
        var hideMessage = this.messages[resource.toString()];
        if (hideMessage) {
            hideMessage();
            this.messages[resource.toString()] = void 0;
        }
    };
    SaveErrorHandler.prototype.onSaveError = function (error, model) {
        var _this = this;
        var message;
        var resource = model.getResource();
        // Dirty write prevention
        if (error.fileOperationResult === files_1.FileOperationResult.FILE_MODIFIED_SINCE) {
            message = this.instantiationService.createInstance(ResolveSaveConflictMessage, model, null);
        }
        else {
            var isReadonly = error.fileOperationResult === files_1.FileOperationResult.FILE_READ_ONLY;
            var actions = [];
            // Save As
            actions.push(new actions_1.Action('workbench.files.action.saveAs', fileActions_1.SaveFileAsAction.LABEL, null, true, function () {
                var saveAsAction = _this.instantiationService.createInstance(fileActions_1.SaveFileAsAction, fileActions_1.SaveFileAsAction.ID, fileActions_1.SaveFileAsAction.LABEL);
                saveAsAction.setResource(resource);
                saveAsAction.run().done(function () { return saveAsAction.dispose(); }, errors.onUnexpectedError);
                return winjs_base_1.TPromise.as(true);
            }));
            // Discard
            actions.push(new actions_1.Action('workbench.files.action.discard', nls.localize('discard', "Discard"), null, true, function () {
                var revertFileAction = _this.instantiationService.createInstance(fileActions_1.RevertFileAction, fileActions_1.RevertFileAction.ID, fileActions_1.RevertFileAction.LABEL);
                revertFileAction.setResource(resource);
                revertFileAction.run().done(function () { return revertFileAction.dispose(); }, errors.onUnexpectedError);
                return winjs_base_1.TPromise.as(true);
            }));
            // Retry
            if (isReadonly) {
                actions.push(new actions_1.Action('workbench.files.action.overwrite', nls.localize('overwrite', "Overwrite"), null, true, function () {
                    if (!model.isDisposed()) {
                        model.save({ overwriteReadonly: true }).done(null, errors.onUnexpectedError);
                    }
                    return winjs_base_1.TPromise.as(true);
                }));
            }
            else {
                actions.push(new actions_1.Action('workbench.files.action.retry', nls.localize('retry', "Retry"), null, true, function () {
                    var saveFileAction = _this.instantiationService.createInstance(fileActions_1.SaveFileAction, fileActions_1.SaveFileAction.ID, fileActions_1.SaveFileAction.LABEL);
                    saveFileAction.setResource(resource);
                    saveFileAction.run().done(function () { return saveFileAction.dispose(); }, errors.onUnexpectedError);
                    return winjs_base_1.TPromise.as(true);
                }));
            }
            // Cancel
            actions.push(message_1.CancelAction);
            var errorMessage = void 0;
            if (isReadonly) {
                errorMessage = nls.localize('readonlySaveError', "Failed to save '{0}': File is write protected. Select 'Overwrite' to remove protection.", paths.basename(resource.fsPath));
            }
            else {
                errorMessage = nls.localize('genericSaveError', "Failed to save '{0}': {1}", paths.basename(resource.fsPath), errorMessage_1.toErrorMessage(error, false));
            }
            message = {
                message: errorMessage,
                actions: actions
            };
        }
        // Show message and keep function to hide in case the file gets saved/reverted
        this.messages[model.getResource().toString()] = this.messageService.show(message_1.Severity.Error, message);
    };
    SaveErrorHandler.prototype.dispose = function () {
        this.toUnbind = lifecycle_1.dispose(this.toUnbind);
    };
    return SaveErrorHandler;
}());
SaveErrorHandler = __decorate([
    __param(0, message_1.IMessageService),
    __param(1, textfiles_1.ITextFileService),
    __param(2, resolverService_1.ITextModelResolverService),
    __param(3, modelService_1.IModelService),
    __param(4, modeService_1.IModeService),
    __param(5, instantiation_1.IInstantiationService)
], SaveErrorHandler);
exports.SaveErrorHandler = SaveErrorHandler;
var pendingResolveSaveConflictMessages = [];
function clearPendingResolveSaveConflictMessages() {
    while (pendingResolveSaveConflictMessages.length > 0) {
        pendingResolveSaveConflictMessages.pop()();
    }
}
// A message with action to resolve a save conflict
var ResolveSaveConflictMessage = (function () {
    function ResolveSaveConflictMessage(model, message, messageService, editorService, environmentService) {
        var _this = this;
        this.messageService = messageService;
        this.editorService = editorService;
        this.environmentService = environmentService;
        this.model = model;
        var resource = model.getResource();
        if (message) {
            this.message = message;
        }
        else {
            this.message = nls.localize('staleSaveError', "Failed to save '{0}': The content on disk is newer. Click on **Compare** to compare your version with the one on disk.", paths.basename(resource.fsPath));
        }
        this.actions = [
            new actions_1.Action('workbench.files.action.resolveConflict', nls.localize('compareChanges', "Compare"), null, true, function () {
                if (!_this.model.isDisposed()) {
                    var name_1 = paths.basename(resource.fsPath);
                    var editorLabel = nls.localize('saveConflictDiffLabel', "{0} (on disk) ↔ {1} (in {2}) - Resolve save conflict", name_1, name_1, _this.environmentService.appNameLong);
                    return _this.editorService.openEditor({ leftResource: uri_1.default.from({ scheme: exports.CONFLICT_RESOLUTION_SCHEME, path: resource.fsPath }), rightResource: resource, label: editorLabel, options: { pinned: true } }).then(function () {
                        // Inform user
                        pendingResolveSaveConflictMessages.push(_this.messageService.show(message_1.Severity.Info, nls.localize('userGuide', "Use the actions in the editor tool bar to either **undo** your changes or **overwrite** the content on disk with your changes")));
                    });
                }
                return winjs_base_1.TPromise.as(true);
            })
        ];
    }
    return ResolveSaveConflictMessage;
}());
ResolveSaveConflictMessage = __decorate([
    __param(2, message_1.IMessageService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, environment_1.IEnvironmentService)
], ResolveSaveConflictMessage);
// Accept changes to resolve a conflicting edit
var AcceptLocalChangesAction = (function (_super) {
    __extends(AcceptLocalChangesAction, _super);
    function AcceptLocalChangesAction(editorService, resolverService) {
        var _this = _super.call(this, 'workbench.files.action.acceptLocalChanges', nls.localize('acceptLocalChanges', "Use local changes and overwrite disk contents"), 'conflict-editor-action accept-changes') || this;
        _this.editorService = editorService;
        _this.resolverService = resolverService;
        return _this;
    }
    AcceptLocalChangesAction.prototype.run = function () {
        var _this = this;
        return this.resolverService.createModelReference(editor_1.toResource(this.input, { supportSideBySide: true })).then(function (reference) {
            var model = reference.object;
            var localModelValue = model.getValue();
            clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
            // revert to be able to save
            return model.revert().then(function () {
                // Restore user value
                model.textEditorModel.setValue(localModelValue);
                // Trigger save
                return model.save().then(function () {
                    // Reopen file input
                    return _this.editorService.openEditor({ resource: model.getResource() }, _this.position).then(function () {
                        // Clean up
                        _this.input.dispose();
                        reference.dispose();
                    });
                });
            });
        });
    };
    return AcceptLocalChangesAction;
}(baseEditor_1.EditorInputAction));
AcceptLocalChangesAction = __decorate([
    __param(0, editorService_1.IWorkbenchEditorService),
    __param(1, resolverService_1.ITextModelResolverService)
], AcceptLocalChangesAction);
exports.AcceptLocalChangesAction = AcceptLocalChangesAction;
// Revert changes to resolve a conflicting edit
var RevertLocalChangesAction = (function (_super) {
    __extends(RevertLocalChangesAction, _super);
    function RevertLocalChangesAction(editorService, resolverService) {
        var _this = _super.call(this, 'workbench.action.files.revert', nls.localize('revertLocalChanges', "Discard local changes and revert to content on disk"), 'conflict-editor-action revert-changes') || this;
        _this.editorService = editorService;
        _this.resolverService = resolverService;
        return _this;
    }
    RevertLocalChangesAction.prototype.run = function () {
        var _this = this;
        return this.resolverService.createModelReference(editor_1.toResource(this.input, { supportSideBySide: true })).then(function (reference) {
            var model = reference.object;
            clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
            // Revert on model
            return model.revert().then(function () {
                // Reopen file input
                return _this.editorService.openEditor({ resource: model.getResource() }, _this.position).then(function () {
                    // Clean up
                    _this.input.dispose();
                    reference.dispose();
                });
            });
        });
    };
    return RevertLocalChangesAction;
}(baseEditor_1.EditorInputAction));
RevertLocalChangesAction = __decorate([
    __param(0, editorService_1.IWorkbenchEditorService),
    __param(1, resolverService_1.ITextModelResolverService)
], RevertLocalChangesAction);
exports.RevertLocalChangesAction = RevertLocalChangesAction;
