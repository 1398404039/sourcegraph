/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var nls = require("vs/nls");
var lifecycle = require("vs/base/common/lifecycle");
var objects = require("vs/base/common/objects");
var DOM = require("vs/base/browser/dom");
var uri_1 = require("vs/base/common/uri");
var mime_1 = require("vs/base/common/mime");
var functional_1 = require("vs/base/common/functional");
var paths = require("vs/base/common/paths");
var errors = require("vs/base/common/errors");
var types_1 = require("vs/base/common/types");
var actions_1 = require("vs/base/common/actions");
var comparers = require("vs/base/common/comparers");
var inputBox_1 = require("vs/base/browser/ui/inputbox/inputBox");
var builder_1 = require("vs/base/browser/builder");
var platform_1 = require("vs/base/common/platform");
var glob = require("vs/base/common/glob");
var labels_1 = require("vs/workbench/browser/labels");
var actionBarRegistry_1 = require("vs/workbench/browser/actionBarRegistry");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var files_1 = require("vs/platform/files/common/files");
var fileActions_1 = require("vs/workbench/parts/files/browser/fileActions");
var tree_1 = require("vs/base/parts/tree/browser/tree");
var treeDnd_1 = require("vs/base/parts/tree/browser/treeDnd");
var treeDefaults_1 = require("vs/base/parts/tree/browser/treeDefaults");
var actionsRenderer_1 = require("vs/base/parts/tree/browser/actionsRenderer");
var explorerViewModel_1 = require("vs/workbench/parts/files/common/explorerViewModel");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var partService_1 = require("vs/workbench/services/part/common/partService");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
var progress_1 = require("vs/platform/progress/common/progress");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var actions_2 = require("vs/platform/actions/common/actions");
var menuItemActionItem_1 = require("vs/platform/actions/browser/menuItemActionItem");
var backup_1 = require("vs/workbench/services/backup/common/backup");
var resolverService_1 = require("vs/editor/common/services/resolverService");
var FileDataSource = (function () {
    function FileDataSource(progressService, messageService, fileService, partService, contextService) {
        this.progressService = progressService;
        this.messageService = messageService;
        this.fileService = fileService;
        this.partService = partService;
        this.contextService = contextService;
    }
    FileDataSource.prototype.getId = function (tree, stat) {
        return stat.getId();
    };
    FileDataSource.prototype.hasChildren = function (tree, stat) {
        return stat.isDirectory;
    };
    FileDataSource.prototype.getChildren = function (tree, stat) {
        var _this = this;
        // Return early if stat is already resolved
        if (stat.isDirectoryResolved) {
            return winjs_base_1.TPromise.as(stat.children);
        }
        else {
            // Resolve
            var promise = this.fileService.resolveFile(stat.resource, { resolveSingleChildDescendants: true }).then(function (dirStat) {
                // Convert to view model
                var modelDirStat = explorerViewModel_1.FileStat.create(dirStat);
                // Add children to folder
                for (var i = 0; i < modelDirStat.children.length; i++) {
                    stat.addChild(modelDirStat.children[i]);
                }
                stat.isDirectoryResolved = true;
                return stat.children;
            }, function (e) {
                _this.messageService.show(message_1.Severity.Error, e);
                return []; // we could not resolve any children because of an error
            });
            this.progressService.showWhile(promise, this.partService.isCreated() ? 800 : 3200 /* less ugly initial startup */);
            return promise;
        }
    };
    FileDataSource.prototype.getParent = function (tree, stat) {
        if (!stat) {
            return winjs_base_1.TPromise.as(null); // can be null if nothing selected in the tree
        }
        // Return if root reached
        if (this.contextService.hasWorkspace() && stat.resource.toString() === this.contextService.getWorkspace().resource.toString()) {
            return winjs_base_1.TPromise.as(null);
        }
        // Return if parent already resolved
        if (stat.parent) {
            return winjs_base_1.TPromise.as(stat.parent);
        }
        // We never actually resolve the parent from the disk for performance reasons. It wouldnt make
        // any sense to resolve parent by parent with requests to walk up the chain. Instead, the explorer
        // makes sure to properly resolve a deep path to a specific file and merges the result with the model.
        return winjs_base_1.TPromise.as(null);
    };
    return FileDataSource;
}());
FileDataSource = __decorate([
    __param(0, progress_1.IProgressService),
    __param(1, message_1.IMessageService),
    __param(2, files_1.IFileService),
    __param(3, partService_1.IPartService),
    __param(4, workspace_1.IWorkspaceContextService)
], FileDataSource);
exports.FileDataSource = FileDataSource;
var FileActionProvider = (function (_super) {
    __extends(FileActionProvider, _super);
    function FileActionProvider(state) {
        var _this = _super.call(this) || this;
        _this.state = state;
        return _this;
    }
    FileActionProvider.prototype.hasActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return false;
        }
        return _super.prototype.hasActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.getActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return winjs_base_1.TPromise.as([]);
        }
        return _super.prototype.getActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.hasSecondaryActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return false;
        }
        return _super.prototype.hasSecondaryActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.getSecondaryActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return winjs_base_1.TPromise.as([]);
        }
        return _super.prototype.getSecondaryActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.runAction = function (tree, stat, arg, context) {
        var _this = this;
        if (context === void 0) { context = {}; }
        context = objects.mixin({
            viewletState: this.state,
            stat: stat
        }, context);
        if (!types_1.isString(arg)) {
            var action = arg;
            if (action.enabled) {
                return action.run(context);
            }
            return null;
        }
        var id = arg;
        var promise = this.hasActions(tree, stat) ? this.getActions(tree, stat) : winjs_base_1.TPromise.as([]);
        return promise.then(function (actions) {
            for (var i = 0, len = actions.length; i < len; i++) {
                if (actions[i].id === id && actions[i].enabled) {
                    return actions[i].run(context);
                }
            }
            promise = _this.hasSecondaryActions(tree, stat) ? _this.getSecondaryActions(tree, stat) : winjs_base_1.TPromise.as([]);
            return promise.then(function (actions) {
                for (var i = 0, len = actions.length; i < len; i++) {
                    if (actions[i].id === id && actions[i].enabled) {
                        return actions[i].run(context);
                    }
                }
                return null;
            });
        });
    };
    return FileActionProvider;
}(actionBarRegistry_1.ContributableActionProvider));
exports.FileActionProvider = FileActionProvider;
var FileViewletState = (function () {
    function FileViewletState() {
        this._actionProvider = new FileActionProvider(this);
        this.editableStats = Object.create(null);
    }
    Object.defineProperty(FileViewletState.prototype, "actionProvider", {
        get: function () {
            return this._actionProvider;
        },
        enumerable: true,
        configurable: true
    });
    FileViewletState.prototype.getEditableData = function (stat) {
        return this.editableStats[stat.resource && stat.resource.toString()];
    };
    FileViewletState.prototype.setEditable = function (stat, editableData) {
        if (editableData) {
            this.editableStats[stat.resource && stat.resource.toString()] = editableData;
        }
    };
    FileViewletState.prototype.clearEditable = function (stat) {
        delete this.editableStats[stat.resource && stat.resource.toString()];
    };
    return FileViewletState;
}());
exports.FileViewletState = FileViewletState;
var ActionRunner = (function (_super) {
    __extends(ActionRunner, _super);
    function ActionRunner(state) {
        var _this = _super.call(this) || this;
        _this.viewletState = state;
        return _this;
    }
    ActionRunner.prototype.run = function (action, context) {
        return _super.prototype.run.call(this, action, { viewletState: this.viewletState });
    };
    return ActionRunner;
}(actions_1.ActionRunner));
exports.ActionRunner = ActionRunner;
// Explorer Renderer
var FileRenderer = (function (_super) {
    __extends(FileRenderer, _super);
    function FileRenderer(state, actionRunner, contextViewService, instantiationService) {
        var _this = _super.call(this, {
            actionProvider: state.actionProvider,
            actionRunner: actionRunner
        }) || this;
        _this.contextViewService = contextViewService;
        _this.instantiationService = instantiationService;
        _this.state = state;
        return _this;
    }
    FileRenderer.prototype.getContentHeight = function (tree, element) {
        return FileRenderer.ITEM_HEIGHT;
    };
    FileRenderer.prototype.renderContents = function (tree, stat, domElement, previousCleanupFn) {
        var el = builder_1.$(domElement).clearChildren();
        // File Rename/Add Input Field
        var editableData = this.state.getEditableData(stat);
        if (editableData) {
            return this.renderInputBox(el, tree, stat, editableData);
        }
        // Label
        return this.renderLabel(el, stat);
    };
    FileRenderer.prototype.renderLabel = function (container, stat) {
        var label = this.instantiationService.createInstance(labels_1.FileLabel, container.getHTMLElement(), void 0);
        var extraClasses = ['explorer-item'];
        label.setFile(stat.resource, { hidePath: true, isFolder: stat.isDirectory, extraClasses: extraClasses });
        return function () { return label.dispose(); };
    };
    FileRenderer.prototype.renderInputBox = function (container, tree, stat, editableData) {
        var _this = this;
        var label = this.instantiationService.createInstance(labels_1.FileLabel, container.getHTMLElement(), void 0);
        var extraClasses = ['explorer-item', 'explorer-item-edited'];
        var isFolder = stat.isDirectory || (stat instanceof explorerViewModel_1.NewStatPlaceholder && stat.isDirectoryPlaceholder());
        var labelOptions = { hidePath: true, hideLabel: true, isFolder: isFolder, extraClasses: extraClasses };
        label.setFile(stat.resource, labelOptions);
        // Input field (when creating a new file or folder or renaming)
        var inputBox = new inputBox_1.InputBox(label.element, this.contextViewService, {
            validationOptions: {
                validation: editableData.validator,
                showMessage: true
            },
            ariaLabel: nls.localize('fileInputAriaLabel', "Type file name. Press Enter to confirm or Escape to cancel.")
        });
        var parent = paths.dirname(stat.resource.fsPath);
        inputBox.onDidChange(function (value) {
            label.setFile(uri_1.default.file(paths.join(parent, value)), labelOptions); // update label icon while typing!
        });
        var value = stat.name || '';
        var lastDot = value.lastIndexOf('.');
        inputBox.value = value;
        inputBox.select({ start: 0, end: lastDot > 0 && !stat.isDirectory ? lastDot : value.length });
        inputBox.focus();
        var done = functional_1.once(function (commit) {
            tree.clearHighlight();
            if (commit && inputBox.value) {
                _this.state.actionProvider.runAction(tree, stat, editableData.action, { value: inputBox.value });
            }
            setTimeout(function () {
                tree.DOMFocus();
                lifecycle.dispose(toDispose);
            }, 0);
        });
        var toDispose = [
            inputBox,
            DOM.addStandardDisposableListener(inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {
                if (e.equals(3 /* Enter */)) {
                    if (inputBox.validate()) {
                        done(true);
                    }
                }
                else if (e.equals(9 /* Escape */)) {
                    done(false);
                }
            }),
            DOM.addDisposableListener(inputBox.inputElement, 'blur', function () {
                done(inputBox.isInputValid());
            }),
            label
        ];
        return function () { return done(true); };
    };
    return FileRenderer;
}(actionsRenderer_1.ActionsRenderer));
FileRenderer.ITEM_HEIGHT = 22;
FileRenderer = __decorate([
    __param(2, contextView_1.IContextViewService),
    __param(3, instantiation_1.IInstantiationService)
], FileRenderer);
exports.FileRenderer = FileRenderer;
// Explorer Accessibility Provider
var FileAccessibilityProvider = (function () {
    function FileAccessibilityProvider() {
    }
    FileAccessibilityProvider.prototype.getAriaLabel = function (tree, stat) {
        return nls.localize('filesExplorerViewerAriaLabel', "{0}, Files Explorer", stat.name);
    };
    return FileAccessibilityProvider;
}());
exports.FileAccessibilityProvider = FileAccessibilityProvider;
// Explorer Controller
var FileController = (function (_super) {
    __extends(FileController, _super);
    function FileController(state, editorService, contextMenuService, instantiationService, telemetryService, contextService, menuService, contextKeyService, keybindingService) {
        var _this = _super.call(this, { clickBehavior: treeDefaults_1.ClickBehavior.ON_MOUSE_UP /* do not change to not break DND */, keyboardSupport: false /* handled via IListService */ }) || this;
        _this.editorService = editorService;
        _this.contextMenuService = contextMenuService;
        _this.instantiationService = instantiationService;
        _this.telemetryService = telemetryService;
        _this.contextService = contextService;
        _this.keybindingService = keybindingService;
        _this.contributedContextMenu = menuService.createMenu(actions_2.MenuId.ExplorerContext, contextKeyService);
        _this.state = state;
        return _this;
    }
    FileController.prototype.onLeftClick = function (tree, stat, event, origin) {
        if (origin === void 0) { origin = 'mouse'; }
        var payload = { origin: origin };
        var isDoubleClick = (origin === 'mouse' && event.detail === 2);
        // Handle Highlight Mode
        if (tree.getHighlight()) {
            // Cancel Event
            event.preventDefault();
            event.stopPropagation();
            tree.clearHighlight(payload);
            return false;
        }
        // Handle root
        if (this.contextService.getWorkspace() && stat.resource.toString() === this.contextService.getWorkspace().resource.toString()) {
            tree.clearFocus(payload);
            tree.clearSelection(payload);
            return false;
        }
        // Cancel Event
        var isMouseDown = event && event.browserEvent && event.browserEvent.type === 'mousedown';
        if (!isMouseDown) {
            event.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
        }
        event.stopPropagation();
        // Set DOM focus
        tree.DOMFocus();
        // Expand / Collapse
        tree.toggleExpansion(stat);
        // Allow to unselect
        if (event.shiftKey && !(stat instanceof explorerViewModel_1.NewStatPlaceholder)) {
            var selection = tree.getSelection();
            if (selection && selection.length > 0 && selection[0] === stat) {
                tree.clearSelection(payload);
            }
        }
        else if (!(stat instanceof explorerViewModel_1.NewStatPlaceholder)) {
            var preserveFocus = !isDoubleClick;
            tree.setFocus(stat, payload);
            if (isDoubleClick) {
                event.preventDefault(); // focus moves to editor, we need to prevent default
            }
            tree.setSelection([stat], payload);
            if (!stat.isDirectory) {
                this.openEditor(stat, { preserveFocus: preserveFocus, sideBySide: event && (event.ctrlKey || event.metaKey), pinned: isDoubleClick });
            }
        }
        return true;
    };
    FileController.prototype.onContextMenu = function (tree, stat, event) {
        var _this = this;
        if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
            return false;
        }
        event.preventDefault();
        event.stopPropagation();
        tree.setFocus(stat);
        if (!this.state.actionProvider.hasSecondaryActions(tree, stat)) {
            return true;
        }
        var anchor = { x: event.posx + 1, y: event.posy };
        this.contextMenuService.showContextMenu({
            getAnchor: function () { return anchor; },
            getActions: function () {
                return _this.state.actionProvider.getSecondaryActions(tree, stat).then(function (actions) {
                    menuItemActionItem_1.fillInActions(_this.contributedContextMenu, stat.resource, actions);
                    return actions;
                });
            },
            getActionItem: this.state.actionProvider.getActionItem.bind(this.state.actionProvider, tree, stat),
            getKeyBinding: function (a) { return fileActions_1.keybindingForAction(a.id, _this.keybindingService); },
            getActionsContext: function (event) {
                return {
                    viewletState: _this.state,
                    stat: stat,
                    event: event
                };
            },
            onHide: function (wasCancelled) {
                if (wasCancelled) {
                    tree.DOMFocus();
                }
            }
        });
        return true;
    };
    FileController.prototype.openEditor = function (stat, options) {
        if (stat && !stat.isDirectory) {
            this.telemetryService.publicLog('workbenchActionExecuted', { id: 'workbench.files.openFile', from: 'explorer' });
            this.editorService.openEditor({ resource: stat.resource, options: options }, options.sideBySide).done(null, errors.onUnexpectedError);
        }
    };
    return FileController;
}(treeDefaults_1.DefaultController));
FileController = __decorate([
    __param(1, editorService_1.IWorkbenchEditorService),
    __param(2, contextView_1.IContextMenuService),
    __param(3, instantiation_1.IInstantiationService),
    __param(4, telemetry_1.ITelemetryService),
    __param(5, workspace_1.IWorkspaceContextService),
    __param(6, actions_2.IMenuService),
    __param(7, contextkey_1.IContextKeyService),
    __param(8, keybinding_1.IKeybindingService)
], FileController);
exports.FileController = FileController;
// Explorer Sorter
var FileSorter = (function () {
    function FileSorter() {
    }
    FileSorter.prototype.compare = function (tree, statA, statB) {
        if (statA.isDirectory && !statB.isDirectory) {
            return -1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
            return 1;
        }
        if (statA instanceof explorerViewModel_1.NewStatPlaceholder) {
            return -1;
        }
        if (statB instanceof explorerViewModel_1.NewStatPlaceholder) {
            return 1;
        }
        return comparers.compareFileNames(statA.name, statB.name);
    };
    return FileSorter;
}());
exports.FileSorter = FileSorter;
// Explorer Filter
var FileFilter = (function () {
    function FileFilter(contextService) {
        this.contextService = contextService;
        this.hiddenExpression = Object.create(null);
    }
    FileFilter.prototype.updateConfiguration = function (configuration) {
        var excludesConfig = (configuration && configuration.files && configuration.files.exclude) || Object.create(null);
        var needsRefresh = !objects.equals(this.hiddenExpression, excludesConfig);
        this.hiddenExpression = objects.clone(excludesConfig); // do not keep the config, as it gets mutated under our hoods
        return needsRefresh;
    };
    FileFilter.prototype.isVisible = function (tree, stat) {
        return this.doIsVisible(stat);
    };
    FileFilter.prototype.doIsVisible = function (stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return true; // always visible
        }
        // Workaround for O(N^2) complexity (https://github.com/Microsoft/vscode/issues/9962)
        var siblings = stat.parent && stat.parent.children && stat.parent.children;
        if (siblings && siblings.length > FileFilter.MAX_SIBLINGS_FILTER_THRESHOLD) {
            siblings = void 0;
        }
        // Hide those that match Hidden Patterns
        var siblingsFn = function () { return siblings && siblings.map(function (c) { return c.name; }); };
        if (glob.match(this.hiddenExpression, this.contextService.toWorkspaceRelativePath(stat.resource, true), siblingsFn)) {
            return false; // hidden through pattern
        }
        return true;
    };
    return FileFilter;
}());
FileFilter.MAX_SIBLINGS_FILTER_THRESHOLD = 2000;
FileFilter = __decorate([
    __param(0, workspace_1.IWorkspaceContextService)
], FileFilter);
exports.FileFilter = FileFilter;
// Explorer Drag And Drop Controller
var FileDragAndDrop = (function () {
    function FileDragAndDrop(messageService, contextService, progressService, fileService, configurationService, instantiationService, textFileService, textModelResolverService, backupFileService) {
        this.messageService = messageService;
        this.contextService = contextService;
        this.progressService = progressService;
        this.fileService = fileService;
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.textFileService = textFileService;
        this.textModelResolverService = textModelResolverService;
        this.backupFileService = backupFileService;
        this.toDispose = [];
        this.onConfigurationUpdated(configurationService.getConfiguration());
        this.registerListeners();
    }
    FileDragAndDrop.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config); }));
    };
    FileDragAndDrop.prototype.onConfigurationUpdated = function (config) {
        this.dropEnabled = config && config.explorer && config.explorer.enableDragAndDrop;
    };
    FileDragAndDrop.prototype.getDragURI = function (tree, stat) {
        if (stat.isDirectory) {
            return uri_1.default.from({ scheme: 'folder', path: stat.resource.fsPath }).toString(); // indicates that we are dragging a folder
        }
        return stat.resource.toString();
    };
    FileDragAndDrop.prototype.getDragLabel = function (tree, elements) {
        if (elements.length > 1) {
            return String(elements.length);
        }
        var stat = elements[0];
        return paths.basename(stat.resource.fsPath);
    };
    FileDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
        var sources = data.getData();
        var source = null;
        if (sources.length > 0) {
            source = sources[0];
        }
        // When dragging folders, make sure to collapse them to free up some space
        if (source && source.isDirectory && tree.isExpanded(source)) {
            tree.collapse(source, false);
        }
        // Native only: when a DownloadURL attribute is defined on the data transfer it is possible to
        // drag a file from the browser to the desktop and have it downloaded there.
        if (!(data instanceof treeDnd_1.DesktopDragAndDropData)) {
            if (source && !source.isDirectory) {
                originalEvent.dataTransfer.setData('DownloadURL', [mime_1.MIME_BINARY, source.name, source.resource.toString()].join(':'));
            }
        }
    };
    FileDragAndDrop.prototype.onDragOver = function (tree, data, target, originalEvent) {
        if (!this.dropEnabled) {
            return tree_1.DRAG_OVER_REJECT;
        }
        var isCopy = originalEvent && ((originalEvent.ctrlKey && !platform_1.isMacintosh) || (originalEvent.altKey && platform_1.isMacintosh));
        var fromDesktop = data instanceof treeDnd_1.DesktopDragAndDropData;
        // Desktop DND
        if (fromDesktop) {
            var dragData = data.getData();
            var types = dragData.types;
            var typesArray = [];
            for (var i = 0; i < types.length; i++) {
                typesArray.push(types[i]);
            }
            if (typesArray.length === 0 || !typesArray.some(function (type) { return type === 'Files'; })) {
                return tree_1.DRAG_OVER_REJECT;
            }
        }
        else if (data instanceof treeDnd_1.ExternalElementsDragAndDropData) {
            return tree_1.DRAG_OVER_REJECT;
        }
        else {
            var sources = data.getData();
            if (!Array.isArray(sources)) {
                return tree_1.DRAG_OVER_REJECT;
            }
            if (sources.some(function (source) {
                if (source instanceof explorerViewModel_1.NewStatPlaceholder) {
                    return true; // NewStatPlaceholders can not be moved
                }
                if (source.resource.toString() === target.resource.toString()) {
                    return true; // Can not move anything onto itself
                }
                if (!isCopy && files_1.isEqual(paths.dirname(source.resource.fsPath), target.resource.fsPath)) {
                    return true; // Can not move a file to the same parent unless we copy
                }
                if (paths.isEqualOrParent(target.resource.fsPath, source.resource.fsPath)) {
                    return true; // Can not move a parent folder into one of its children
                }
                return false;
            })) {
                return tree_1.DRAG_OVER_REJECT;
            }
        }
        // All
        if (target.isDirectory) {
            return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY(true) : tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN(true);
        }
        if (target.resource.toString() !== this.contextService.getWorkspace().resource.toString()) {
            return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP_COPY : tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP;
        }
        return tree_1.DRAG_OVER_REJECT;
    };
    FileDragAndDrop.prototype.drop = function (tree, data, target, originalEvent) {
        var _this = this;
        var promise = winjs_base_1.TPromise.as(null);
        // Desktop DND (Import file)
        if (data instanceof treeDnd_1.DesktopDragAndDropData) {
            var importAction = this.instantiationService.createInstance(fileActions_1.ImportFileAction, tree, target, null);
            promise = importAction.run({
                input: {
                    files: data.getData().files
                }
            });
        }
        else {
            var source_1 = data.getData()[0];
            var isCopy_1 = (originalEvent.ctrlKey && !platform_1.isMacintosh) || (originalEvent.altKey && platform_1.isMacintosh);
            promise = tree.expand(target).then(function () {
                // Reuse duplicate action if user copies
                if (isCopy_1) {
                    return _this.instantiationService.createInstance(fileActions_1.DuplicateFileAction, tree, source_1, target).run();
                }
                var dirtyMoved = [];
                // Success: load all files that are dirty again to restore their dirty contents
                // Error: discard any backups created during the process
                var onSuccess = function () { return winjs_base_1.TPromise.join(dirtyMoved.map(function (t) { return _this.textModelResolverService.createModelReference(t); })); };
                var onError = function (error, showError) {
                    if (showError) {
                        _this.messageService.show(message_1.Severity.Error, error);
                    }
                    return winjs_base_1.TPromise.join(dirtyMoved.map(function (d) { return _this.backupFileService.discardResourceBackup(d); }));
                };
                // 1. check for dirty files that are being moved and backup to new target
                var dirty = _this.textFileService.getDirty().filter(function (d) { return paths.isEqualOrParent(d.fsPath, source_1.resource.fsPath); });
                return winjs_base_1.TPromise.join(dirty.map(function (d) {
                    var moved;
                    // If the dirty file itself got moved, just reparent it to the target folder
                    if (files_1.isEqual(source_1.resource.fsPath, d.fsPath)) {
                        moved = uri_1.default.file(paths.join(target.resource.fsPath, source_1.name));
                    }
                    else {
                        moved = uri_1.default.file(paths.join(target.resource.fsPath, d.fsPath.substr(source_1.parent.resource.fsPath.length + 1)));
                    }
                    dirtyMoved.push(moved);
                    var model = _this.textFileService.models.get(d);
                    return _this.backupFileService.backupResource(moved, model.getValue(), model.getVersionId());
                }))
                    .then(function () { return _this.textFileService.revertAll(dirty, { soft: true /* do not attempt to load content from disk */ }); })
                    .then(function () {
                    var targetResource = uri_1.default.file(paths.join(target.resource.fsPath, source_1.name));
                    var didHandleConflict = false;
                    return _this.fileService.moveFile(source_1.resource, targetResource).then(null, function (error) {
                        // Conflict
                        if (error.fileOperationResult === files_1.FileOperationResult.FILE_MOVE_CONFLICT) {
                            didHandleConflict = true;
                            var confirm_1 = {
                                message: nls.localize('confirmOverwriteMessage', "'{0}' already exists in the destination folder. Do you want to replace it?", source_1.name),
                                detail: nls.localize('irreversible', "This action is irreversible!"),
                                primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Replace")
                            };
                            // Move with overwrite if the user confirms
                            if (_this.messageService.confirm(confirm_1)) {
                                var targetDirty = _this.textFileService.getDirty().filter(function (d) { return paths.isEqualOrParent(d.fsPath, targetResource.fsPath); });
                                // Make sure to revert all dirty in target first to be able to overwrite properly
                                return _this.textFileService.revertAll(targetDirty, { soft: true /* do not attempt to load content from disk */ }).then(function () {
                                    // Then continue to do the move operation
                                    return _this.fileService.moveFile(source_1.resource, targetResource, true).then(onSuccess, function (error) { return onError(error, true); });
                                });
                            }
                            return onError();
                        }
                        return onError(error, true);
                    });
                })
                    .then(onSuccess, onError);
            }, errors.onUnexpectedError);
        }
        this.progressService.showWhile(promise, 800);
        promise.done(null, errors.onUnexpectedError);
    };
    return FileDragAndDrop;
}());
FileDragAndDrop = __decorate([
    __param(0, message_1.IMessageService),
    __param(1, workspace_1.IWorkspaceContextService),
    __param(2, progress_1.IProgressService),
    __param(3, files_1.IFileService),
    __param(4, configuration_1.IConfigurationService),
    __param(5, instantiation_1.IInstantiationService),
    __param(6, textfiles_1.ITextFileService),
    __param(7, resolverService_1.ITextModelResolverService),
    __param(8, backup_1.IBackupFileService)
], FileDragAndDrop);
exports.FileDragAndDrop = FileDragAndDrop;
