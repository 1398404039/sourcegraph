/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require("./media/task.contribution.css");
require("vs/workbench/parts/tasks/browser/taskQuickOpen");
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var severity_1 = require("vs/base/common/severity");
var Objects = require("vs/base/common/objects");
var actions_1 = require("vs/base/common/actions");
var Dom = require("vs/base/browser/dom");
var lifecycle_1 = require("vs/base/common/lifecycle");
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var Builder = require("vs/base/browser/builder");
var Types = require("vs/base/common/types");
var glob_1 = require("vs/base/common/glob");
var platform_1 = require("vs/base/common/platform");
var processes_1 = require("vs/base/common/processes");
var strings = require("vs/base/common/strings");
var platform_2 = require("vs/platform/platform");
var lifecycle_2 = require("vs/platform/lifecycle/common/lifecycle");
var actions_2 = require("vs/platform/actions/common/actions");
var extensions_1 = require("vs/platform/instantiation/common/extensions");
var message_1 = require("vs/platform/message/common/message");
var markers_1 = require("vs/platform/markers/common/markers");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var files_1 = require("vs/platform/files/common/files");
var extensions_2 = require("vs/platform/extensions/common/extensions");
var commands_1 = require("vs/platform/commands/common/commands");
var keybindingsRegistry_1 = require("vs/platform/keybinding/common/keybindingsRegistry");
var modeService_1 = require("vs/editor/common/services/modeService");
var modelService_1 = require("vs/editor/common/services/modelService");
var jsonContributionRegistry = require("vs/platform/jsonschemas/common/jsonContributionRegistry");
var actionRegistry_1 = require("vs/workbench/common/actionRegistry");
var statusbar_1 = require("vs/workbench/browser/parts/statusbar/statusbar");
var quickopen_1 = require("vs/workbench/browser/quickopen");
var quickOpen_1 = require("vs/platform/quickOpen/common/quickOpen");
var panelService_1 = require("vs/workbench/services/panel/common/panelService");
var constants_1 = require("vs/workbench/parts/markers/common/constants");
var partService_1 = require("vs/workbench/services/part/common/partService");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var configurationResolver_1 = require("vs/workbench/services/configurationResolver/common/configurationResolver");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var output_1 = require("vs/workbench/parts/output/common/output");
var terminal_1 = require("vs/workbench/parts/terminal/common/terminal");
var taskSystem_1 = require("vs/workbench/parts/tasks/common/taskSystem");
var taskService_1 = require("vs/workbench/parts/tasks/common/taskService");
var taskTemplates_1 = require("vs/workbench/parts/tasks/common/taskTemplates");
var TaskConfig = require("vs/workbench/parts/tasks/common/taskConfiguration");
var processRunnerSystem_1 = require("vs/workbench/parts/tasks/node/processRunnerSystem");
var terminalTaskSystem_1 = require("./terminalTaskSystem");
var processRunnerDetector_1 = require("vs/workbench/parts/tasks/node/processRunnerDetector");
var environment_1 = require("vs/platform/environment/common/environment");
var $ = Builder.$;
var tasksCategory = nls.localize('tasksCategory', "Tasks");
var OpenTaskConfigurationAction = (function (_super) {
    __extends(OpenTaskConfigurationAction, _super);
    function OpenTaskConfigurationAction(id, label, configurationService, editorService, fileService, contextService, outputService, messageService, quickOpenService, environmentService, configurationResolverService) {
        var _this = _super.call(this, id, label) || this;
        _this.environmentService = environmentService;
        _this.configurationResolverService = configurationResolverService;
        _this.configurationService = configurationService;
        _this.editorService = editorService;
        _this.fileService = fileService;
        _this.contextService = contextService;
        _this.outputService = outputService;
        _this.messageService = messageService;
        _this.quickOpenService = quickOpenService;
        return _this;
    }
    OpenTaskConfigurationAction.prototype.run = function (event) {
        var _this = this;
        if (!this.contextService.hasWorkspace()) {
            this.messageService.show(severity_1.default.Info, nls.localize('ConfigureTaskRunnerAction.noWorkspace', 'Tasks are only available on a workspace folder.'));
            return winjs_base_1.TPromise.as(undefined);
        }
        var sideBySide = !!(event && (event.ctrlKey || event.metaKey));
        var configFileCreated = false;
        return this.fileService.resolveFile(this.contextService.toResource('.vscode/tasks.json')).then(function (success) {
            return success;
        }, function (err) {
            ;
            return _this.quickOpenService.pick(taskTemplates_1.templates, { placeHolder: nls.localize('ConfigureTaskRunnerAction.quickPick.template', 'Select a Task Runner') }).then(function (selection) {
                if (!selection) {
                    return undefined;
                }
                var contentPromise;
                if (selection.autoDetect) {
                    var outputChannel_1 = _this.outputService.getChannel(TaskService.OutputChannelId);
                    outputChannel_1.show(true);
                    outputChannel_1.append(nls.localize('ConfigureTaskRunnerAction.autoDetecting', 'Auto detecting tasks for {0}', selection.id) + '\n');
                    var detector = new processRunnerDetector_1.ProcessRunnerDetector(_this.fileService, _this.contextService, _this.configurationResolverService);
                    contentPromise = detector.detect(false, selection.id).then(function (value) {
                        var config = value.config;
                        if (value.stderr && value.stderr.length > 0) {
                            value.stderr.forEach(function (line) {
                                outputChannel_1.append(line + '\n');
                            });
                            _this.messageService.show(severity_1.default.Warning, nls.localize('ConfigureTaskRunnerAction.autoDetect', 'Auto detecting the task system failed. Using default template. Consult the task output for details.'));
                            return selection.content;
                        }
                        else if (config) {
                            if (value.stdout && value.stdout.length > 0) {
                                value.stdout.forEach(function (line) { return outputChannel_1.append(line + '\n'); });
                            }
                            var content = JSON.stringify(config, null, '\t');
                            content = [
                                '{',
                                '\t// See https://go.microsoft.com/fwlink/?LinkId=733558',
                                '\t// for the documentation about the tasks.json format',
                            ].join('\n') + content.substr(1);
                            return content;
                        }
                        else {
                            return selection.content;
                        }
                    });
                }
                else {
                    contentPromise = winjs_base_1.TPromise.as(selection.content);
                }
                return contentPromise.then(function (content) {
                    var editorConfig = _this.configurationService.getConfiguration();
                    if (editorConfig.editor.insertSpaces) {
                        content = content.replace(/(\n)(\t+)/g, function (_, s1, s2) { return s1 + strings.repeat(' ', s2.length * editorConfig.editor.tabSize); });
                    }
                    configFileCreated = true;
                    return _this.fileService.createFile(_this.contextService.toResource('.vscode/tasks.json'), content);
                });
            });
        }).then(function (stat) {
            if (!stat) {
                return undefined;
            }
            // // (2) Open editor with configuration file
            return _this.editorService.openEditor({
                resource: stat.resource,
                options: {
                    forceOpen: true,
                    pinned: configFileCreated // pin only if config file is created #8727
                }
            }, sideBySide);
        }, function (error) {
            throw new Error(nls.localize('ConfigureTaskRunnerAction.failed', "Unable to create the 'tasks.json' file inside the '.vscode' folder. Consult the task output for details."));
        });
    };
    return OpenTaskConfigurationAction;
}(actions_1.Action));
OpenTaskConfigurationAction = __decorate([
    __param(2, configuration_1.IConfigurationService),
    __param(3, editorService_1.IWorkbenchEditorService), __param(4, files_1.IFileService),
    __param(5, workspace_1.IWorkspaceContextService), __param(6, output_1.IOutputService),
    __param(7, message_1.IMessageService), __param(8, quickOpen_1.IQuickOpenService),
    __param(9, environment_1.IEnvironmentService),
    __param(10, configurationResolver_1.IConfigurationResolverService)
], OpenTaskConfigurationAction);
var ConfigureTaskRunnerAction = (function (_super) {
    __extends(ConfigureTaskRunnerAction, _super);
    function ConfigureTaskRunnerAction(id, label, configurationService, editorService, fileService, contextService, outputService, messageService, quickOpenService, environmentService, configurationResolverService) {
        return _super.call(this, id, label, configurationService, editorService, fileService, contextService, outputService, messageService, quickOpenService, environmentService, configurationResolverService) || this;
    }
    return ConfigureTaskRunnerAction;
}(OpenTaskConfigurationAction));
ConfigureTaskRunnerAction.ID = 'workbench.action.tasks.configureTaskRunner';
ConfigureTaskRunnerAction.TEXT = nls.localize('ConfigureTaskRunnerAction.label', "Configure Task Runner");
ConfigureTaskRunnerAction = __decorate([
    __param(2, configuration_1.IConfigurationService),
    __param(3, editorService_1.IWorkbenchEditorService), __param(4, files_1.IFileService),
    __param(5, workspace_1.IWorkspaceContextService), __param(6, output_1.IOutputService),
    __param(7, message_1.IMessageService), __param(8, quickOpen_1.IQuickOpenService),
    __param(9, environment_1.IEnvironmentService),
    __param(10, configurationResolver_1.IConfigurationResolverService)
], ConfigureTaskRunnerAction);
var ConfigureBuildTaskAction = (function (_super) {
    __extends(ConfigureBuildTaskAction, _super);
    function ConfigureBuildTaskAction(id, label, configurationService, editorService, fileService, contextService, outputService, messageService, quickOpenService, environmentService, configurationResolverService) {
        return _super.call(this, id, label, configurationService, editorService, fileService, contextService, outputService, messageService, quickOpenService, environmentService, configurationResolverService) || this;
    }
    return ConfigureBuildTaskAction;
}(OpenTaskConfigurationAction));
ConfigureBuildTaskAction.ID = 'workbench.action.tasks.configureBuildTask';
ConfigureBuildTaskAction.TEXT = nls.localize('ConfigureBuildTaskAction.label', "Configure Build Task");
ConfigureBuildTaskAction = __decorate([
    __param(2, configuration_1.IConfigurationService),
    __param(3, editorService_1.IWorkbenchEditorService), __param(4, files_1.IFileService),
    __param(5, workspace_1.IWorkspaceContextService), __param(6, output_1.IOutputService),
    __param(7, message_1.IMessageService), __param(8, quickOpen_1.IQuickOpenService),
    __param(9, environment_1.IEnvironmentService),
    __param(10, configurationResolver_1.IConfigurationResolverService)
], ConfigureBuildTaskAction);
var CloseMessageAction = (function (_super) {
    __extends(CloseMessageAction, _super);
    function CloseMessageAction() {
        return _super.call(this, CloseMessageAction.ID, CloseMessageAction.TEXT) || this;
    }
    CloseMessageAction.prototype.run = function () {
        if (this.closeFunction) {
            this.closeFunction();
        }
        return winjs_base_1.TPromise.as(undefined);
    };
    return CloseMessageAction;
}(actions_1.Action));
CloseMessageAction.ID = 'workbench.action.build.closeMessage';
CloseMessageAction.TEXT = nls.localize('CloseMessageAction.label', 'Close');
var ViewTerminalAction = (function (_super) {
    __extends(ViewTerminalAction, _super);
    function ViewTerminalAction(terminalService) {
        var _this = _super.call(this, ViewTerminalAction.ID, ViewTerminalAction.TEXT) || this;
        _this.terminalService = terminalService;
        return _this;
    }
    ViewTerminalAction.prototype.run = function () {
        this.terminalService.showPanel();
        return winjs_base_1.TPromise.as(undefined);
    };
    return ViewTerminalAction;
}(actions_1.Action));
ViewTerminalAction.ID = 'workbench.action.build.viewTerminal';
ViewTerminalAction.TEXT = nls.localize('ShowTerminalAction.label', 'View Terminal');
ViewTerminalAction = __decorate([
    __param(0, terminal_1.ITerminalService)
], ViewTerminalAction);
var StatusBarItem = (function () {
    function StatusBarItem(panelService, markerService, outputService, taskService, partService) {
        this.partService = partService;
        this.panelService = panelService;
        this.markerService = markerService;
        this.outputService = outputService;
        this.taskService = taskService;
        this.activeCount = 0;
    }
    StatusBarItem.prototype.render = function (container) {
        var _this = this;
        var callOnDispose = [], element = document.createElement('div'), 
        // icon = document.createElement('a'),
        progress = document.createElement('div'), label = document.createElement('a'), error = document.createElement('div'), warning = document.createElement('div'), info = document.createElement('div');
        Dom.addClass(element, 'task-statusbar-item');
        // dom.addClass(icon, 'task-statusbar-item-icon');
        // element.appendChild(icon);
        Dom.addClass(progress, 'task-statusbar-item-progress');
        element.appendChild(progress);
        progress.innerHTML = StatusBarItem.progressChars[0];
        $(progress).hide();
        Dom.addClass(label, 'task-statusbar-item-label');
        element.appendChild(label);
        element.title = nls.localize('problems', "Problems");
        Dom.addClass(error, 'task-statusbar-item-label-error');
        error.innerHTML = '0';
        label.appendChild(error);
        Dom.addClass(warning, 'task-statusbar-item-label-warning');
        warning.innerHTML = '0';
        label.appendChild(warning);
        Dom.addClass(info, 'task-statusbar-item-label-info');
        label.appendChild(info);
        $(info).hide();
        //		callOnDispose.push(dom.addListener(icon, 'click', (e:MouseEvent) => {
        //			this.outputService.showOutput(TaskService.OutputChannel, e.ctrlKey || e.metaKey, true);
        //		}));
        callOnDispose.push(Dom.addDisposableListener(label, 'click', function (e) {
            var panel = _this.panelService.getActivePanel();
            if (panel && panel.getId() === constants_1.default.MARKERS_PANEL_ID) {
                _this.partService.setPanelHidden(true);
            }
            else {
                _this.panelService.openPanel(constants_1.default.MARKERS_PANEL_ID, true);
            }
        }));
        var updateStatus = function (element, stats) {
            if (stats > 0) {
                element.innerHTML = stats.toString();
                $(element).show();
                return true;
            }
            else {
                $(element).hide();
                return false;
            }
        };
        var manyMarkers = nls.localize('manyMarkers', "99+");
        var updateLabel = function (stats) {
            error.innerHTML = stats.errors < 100 ? stats.errors.toString() : manyMarkers;
            warning.innerHTML = stats.warnings < 100 ? stats.warnings.toString() : manyMarkers;
            updateStatus(info, stats.infos);
        };
        this.markerService.onMarkerChanged(function (changedResources) {
            updateLabel(_this.markerService.getStatistics());
        });
        callOnDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Active, function () {
            _this.activeCount++;
            if (_this.activeCount === 1) {
                var index_1 = 1;
                var chars_1 = StatusBarItem.progressChars;
                progress.innerHTML = chars_1[0];
                _this.intervalToken = setInterval(function () {
                    progress.innerHTML = chars_1[index_1];
                    index_1++;
                    if (index_1 >= chars_1.length) {
                        index_1 = 0;
                    }
                }, 50);
                $(progress).show();
            }
        }));
        callOnDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Inactive, function (data) {
            // Since the exiting of the sub process is communicated async we can't order inactive and terminate events.
            // So try to treat them accordingly.
            if (_this.activeCount > 0) {
                _this.activeCount--;
                if (_this.activeCount === 0) {
                    $(progress).hide();
                    if (_this.intervalToken) {
                        clearInterval(_this.intervalToken);
                        _this.intervalToken = null;
                    }
                }
            }
        }));
        callOnDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Terminated, function () {
            if (_this.activeCount !== 0) {
                $(progress).hide();
                if (_this.intervalToken) {
                    clearInterval(_this.intervalToken);
                    _this.intervalToken = null;
                }
                _this.activeCount = 0;
            }
        }));
        container.appendChild(element);
        return {
            dispose: function () {
                callOnDispose = lifecycle_1.dispose(callOnDispose);
            }
        };
    };
    return StatusBarItem;
}());
StatusBarItem.progressChars = '|/-\\';
StatusBarItem = __decorate([
    __param(0, panelService_1.IPanelService),
    __param(1, markers_1.IMarkerService), __param(2, output_1.IOutputService),
    __param(3, taskService_1.ITaskService),
    __param(4, partService_1.IPartService)
], StatusBarItem);
var NullTaskSystem = (function (_super) {
    __extends(NullTaskSystem, _super);
    function NullTaskSystem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullTaskSystem.prototype.build = function () {
        return {
            kind: taskSystem_1.TaskExecuteKind.Started,
            promise: winjs_base_1.TPromise.as({})
        };
    };
    NullTaskSystem.prototype.rebuild = function () {
        return {
            kind: taskSystem_1.TaskExecuteKind.Started,
            promise: winjs_base_1.TPromise.as({})
        };
    };
    NullTaskSystem.prototype.clean = function () {
        return {
            kind: taskSystem_1.TaskExecuteKind.Started,
            promise: winjs_base_1.TPromise.as({})
        };
    };
    NullTaskSystem.prototype.runTest = function () {
        return {
            kind: taskSystem_1.TaskExecuteKind.Started,
            promise: winjs_base_1.TPromise.as({})
        };
    };
    NullTaskSystem.prototype.run = function (taskIdentifier) {
        return {
            kind: taskSystem_1.TaskExecuteKind.Started,
            promise: winjs_base_1.TPromise.as({})
        };
    };
    NullTaskSystem.prototype.isActive = function () {
        return winjs_base_1.TPromise.as(false);
    };
    NullTaskSystem.prototype.isActiveSync = function () {
        return false;
    };
    NullTaskSystem.prototype.canAutoTerminate = function () {
        return true;
    };
    NullTaskSystem.prototype.terminate = function () {
        return winjs_base_1.TPromise.as({ success: true });
    };
    NullTaskSystem.prototype.tasks = function () {
        return winjs_base_1.TPromise.as([]);
    };
    return NullTaskSystem;
}(eventEmitter_1.EventEmitter));
var TaskService = (function (_super) {
    __extends(TaskService, _super);
    function TaskService(modeService, configurationService, markerService, outputService, messageService, editorService, fileService, contextService, telemetryService, textFileService, lifecycleService, modelService, extensionService, quickOpenService, environmentService, configurationResolverService, terminalService) {
        var _this = _super.call(this) || this;
        _this.environmentService = environmentService;
        _this.configurationResolverService = configurationResolverService;
        _this.terminalService = terminalService;
        _this.modeService = modeService;
        _this.configurationService = configurationService;
        _this.markerService = markerService;
        _this.outputService = outputService;
        _this.messageService = messageService;
        _this.editorService = editorService;
        _this.fileService = fileService;
        _this.contextService = contextService;
        _this.telemetryService = telemetryService;
        _this.textFileService = textFileService;
        _this.modelService = modelService;
        _this.extensionService = extensionService;
        _this.quickOpenService = quickOpenService;
        _this._inTerminal = undefined;
        _this.taskSystemListeners = [];
        _this.clearTaskSystemPromise = false;
        _this.outputChannel = _this.outputService.getChannel(TaskService.OutputChannelId);
        _this.configurationService.onDidUpdateConfiguration(function () {
            // We don't have a task system yet. So nothing to do.
            if (!_this._taskSystemPromise && !_this._taskSystem) {
                return;
            }
            if (_this._inTerminal !== void 0) {
                var config = _this.configurationService.getConfiguration('tasks');
                var engine = TaskConfig.ExecutionEngine.from(config);
                if (_this._inTerminal && engine === TaskConfig.ExecutionEngine.OutputPanel || !_this._inTerminal && engine === TaskConfig.ExecutionEngine.Terminal) {
                    _this.messageService.show(severity_1.default.Info, nls.localize('TaskSystem.noHotSwap', 'Changing the task execution engine requires to restart VS Code. The change is ignored.'));
                }
            }
            _this.emit(taskService_1.TaskServiceEvents.ConfigChanged);
            if (_this._inTerminal) {
                _this.createConfiguration().then(function (config) {
                    if (!config) {
                        return;
                    }
                    if (_this._taskSystem) {
                        _this._taskSystem.setConfiguration(config);
                    }
                    else {
                        _this._taskSystem = null;
                        _this._taskSystemPromise = null;
                    }
                });
            }
            else {
                if (_this._taskSystem && _this._taskSystem.isActiveSync()) {
                    _this.clearTaskSystemPromise = true;
                }
                else {
                    _this._taskSystem = null;
                    _this._taskSystemPromise = null;
                }
                _this.disposeTaskSystemListeners();
            }
        });
        lifecycleService.onWillShutdown(function (event) { return event.veto(_this.beforeShutdown()); });
        _this.registerCommands();
        return _this;
    }
    TaskService.prototype.registerCommands = function () {
        var _this = this;
        commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.runTask', function (accessor, arg) {
            _this.runTaskCommand(accessor, arg);
        });
        commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.terminate', function (accessor, arg) {
            _this.runTerminateCommand();
        });
        commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.showLog', function () {
            if (!_this.canRunCommand()) {
                return;
            }
            _this.showOutput();
        });
        commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.build', function () {
            if (!_this.canRunCommand()) {
                return;
            }
            _this.build();
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerKeybindingRule({
            id: 'workbench.action.tasks.build',
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(),
            when: undefined,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 32 /* KEY_B */
        });
        commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.test', function () {
            if (!_this.canRunCommand()) {
                return;
            }
            _this.runTest();
        });
    };
    TaskService.prototype.log = function (value) {
        this.outputChannel.append(value + '\n');
    };
    TaskService.prototype.clearOutput = function () {
        this.outputChannel.clear();
    };
    TaskService.prototype.showOutput = function () {
        this.outputChannel.show(true);
    };
    TaskService.prototype.disposeTaskSystemListeners = function () {
        this.taskSystemListeners = lifecycle_1.dispose(this.taskSystemListeners);
    };
    TaskService.prototype.disposeFileChangesListener = function () {
        if (this.fileChangesListener) {
            this.fileChangesListener.dispose();
            this.fileChangesListener = null;
        }
    };
    Object.defineProperty(TaskService.prototype, "taskSystemPromise", {
        get: function () {
            var _this = this;
            if (!this._taskSystemPromise) {
                if (!this.contextService.hasWorkspace()) {
                    this._taskSystem = new NullTaskSystem();
                    this._taskSystemPromise = winjs_base_1.TPromise.as(this._taskSystem);
                }
                else {
                    var hasError_1 = false;
                    this._taskSystemPromise = winjs_base_1.TPromise.as(this.configurationService.getConfiguration('tasks')).then(function (config) {
                        var parseErrors = config ? config.$parseErrors : null;
                        if (parseErrors) {
                            var isAffected = false;
                            for (var i = 0; i < parseErrors.length; i++) {
                                if (/tasks\.json$/.test(parseErrors[i])) {
                                    isAffected = true;
                                    break;
                                }
                            }
                            if (isAffected) {
                                _this.outputChannel.append(nls.localize('TaskSystem.invalidTaskJson', 'Error: The content of the tasks.json file has syntax errors. Please correct them before executing a task.\n'));
                                _this.outputChannel.show(true);
                                return winjs_base_1.TPromise.wrapError({});
                            }
                        }
                        var configPromise;
                        if (config) {
                            var engine = TaskConfig.ExecutionEngine.from(config);
                            if (engine === TaskConfig.ExecutionEngine.OutputPanel && _this.hasDetectorSupport(config)) {
                                configPromise = new processRunnerDetector_1.ProcessRunnerDetector(_this.fileService, _this.contextService, _this.configurationResolverService, config).detect(true).then(function (value) {
                                    hasError_1 = _this.printStderr(value.stderr);
                                    var detectedConfig = value.config;
                                    if (!detectedConfig) {
                                        return config;
                                    }
                                    if (detectedConfig.command) {
                                        _this.telemetryService.publicLog(TaskService.autoDetectTelemetryName, {
                                            command: detectedConfig.command,
                                            full: false
                                        });
                                    }
                                    var result = Objects.clone(config);
                                    var configuredTasks = Object.create(null);
                                    if (!result.tasks) {
                                        if (detectedConfig.tasks) {
                                            result.tasks = detectedConfig.tasks;
                                        }
                                    }
                                    else {
                                        result.tasks.forEach(function (task) { return configuredTasks[task.taskName] = task; });
                                        detectedConfig.tasks.forEach(function (task) {
                                            if (!configuredTasks[task.taskName]) {
                                                result.tasks.push(task);
                                            }
                                        });
                                    }
                                    return result;
                                });
                            }
                            else {
                                configPromise = winjs_base_1.TPromise.as(config);
                            }
                        }
                        else {
                            configPromise = new processRunnerDetector_1.ProcessRunnerDetector(_this.fileService, _this.contextService, _this.configurationResolverService).detect(true).then(function (value) {
                                hasError_1 = _this.printStderr(value.stderr);
                                if (value.config && value.config.command) {
                                    _this.telemetryService.publicLog(TaskService.autoDetectTelemetryName, {
                                        command: value.config.command,
                                        full: true
                                    });
                                }
                                return value.config;
                            });
                        }
                        return configPromise.then(function (config) {
                            if (!config) {
                                _this._taskSystemPromise = null;
                                throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskSystem.noConfiguration', 'No task runner configured.'), taskSystem_1.TaskErrors.NotConfigured);
                            }
                            var result = null;
                            var parseResult = TaskConfig.parse(config, _this);
                            if (!parseResult.validationStatus.isOK()) {
                                _this.outputChannel.show(true);
                                hasError_1 = true;
                            }
                            if (parseResult.validationStatus.isFatal()) {
                                throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TaskSystem.fatalError', 'The provided task configuration has validation errors. See tasks output log for details.'), taskSystem_1.TaskErrors.ConfigValidationError);
                            }
                            if (parseResult.engine === TaskConfig.ExecutionEngine.OutputPanel) {
                                _this._inTerminal = false;
                                result = new processRunnerSystem_1.ProcessRunnerSystem(parseResult.configuration, _this.markerService, _this.modelService, _this.telemetryService, _this.outputService, _this.configurationResolverService, TaskService.OutputChannelId, hasError_1);
                            }
                            else if (parseResult.engine === TaskConfig.ExecutionEngine.Terminal) {
                                _this._inTerminal = true;
                                result = new terminalTaskSystem_1.TerminalTaskSystem(parseResult.configuration, _this.terminalService, _this.outputService, _this.markerService, _this.modelService, _this.configurationResolverService, _this.telemetryService, TaskService.OutputChannelId);
                            }
                            if (result === null) {
                                _this._taskSystemPromise = null;
                                throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskSystem.noBuildType', "No valid task runner configured. Supported task runners are 'service' and 'program'."), taskSystem_1.TaskErrors.NoValidTaskRunner);
                            }
                            _this.taskSystemListeners.push(result.addListener2(taskSystem_1.TaskSystemEvents.Active, function (event) { return _this.emit(taskService_1.TaskServiceEvents.Active, event); }));
                            _this.taskSystemListeners.push(result.addListener2(taskSystem_1.TaskSystemEvents.Inactive, function (event) { return _this.emit(taskService_1.TaskServiceEvents.Inactive, event); }));
                            _this._taskSystem = result;
                            return result;
                        }, function (err) {
                            _this.handleError(err);
                            return winjs_base_1.Promise.wrapError(err);
                        });
                    });
                }
            }
            return this._taskSystemPromise;
        },
        enumerable: true,
        configurable: true
    });
    TaskService.prototype.createConfiguration = function () {
        var _this = this;
        var config = this.configurationService.getConfiguration('tasks');
        var parseErrors = config ? config.$parseErrors : null;
        if (parseErrors) {
            var isAffected = false;
            for (var i = 0; i < parseErrors.length; i++) {
                if (/tasks\.json$/.test(parseErrors[i])) {
                    isAffected = true;
                    break;
                }
            }
            if (isAffected) {
                this.log(nls.localize('TaskSystem.invalidTaskJson', 'Error: The content of the tasks.json file has syntax errors. Please correct them before executing a task.\n'));
                this.showOutput();
                return winjs_base_1.TPromise.wrapError(undefined);
            }
        }
        var configPromise;
        if (config) {
            var engine = TaskConfig.ExecutionEngine.from(config);
            if (engine === TaskConfig.ExecutionEngine.OutputPanel && this.hasDetectorSupport(config)) {
                configPromise = new processRunnerDetector_1.ProcessRunnerDetector(this.fileService, this.contextService, this.configurationResolverService, config).detect(true).then(function (value) {
                    _this.printStderr(value.stderr);
                    var detectedConfig = value.config;
                    if (!detectedConfig) {
                        return config;
                    }
                    var result = Objects.clone(config);
                    var configuredTasks = Object.create(null);
                    if (!result.tasks) {
                        if (detectedConfig.tasks) {
                            result.tasks = detectedConfig.tasks;
                        }
                    }
                    else {
                        result.tasks.forEach(function (task) { return configuredTasks[task.taskName] = task; });
                        detectedConfig.tasks.forEach(function (task) {
                            if (!configuredTasks[task.taskName]) {
                                result.tasks.push(task);
                            }
                        });
                    }
                    return result;
                });
            }
            else {
                configPromise = winjs_base_1.TPromise.as(config);
            }
        }
        else {
            configPromise = new processRunnerDetector_1.ProcessRunnerDetector(this.fileService, this.contextService, this.configurationResolverService).detect(true).then(function (value) {
                _this.printStderr(value.stderr);
                return value.config;
            });
        }
        return configPromise.then(function (config) {
            if (!config) {
                return undefined;
            }
            var parseResult = TaskConfig.parse(config, _this);
            if (!parseResult.validationStatus.isOK()) {
                _this.showOutput();
            }
            if (parseResult.validationStatus.isFatal()) {
                _this.log(nls.localize('TaskSystem.configurationErrors', 'Error: the provided task configuration has validation errors and can\'t not be used. Please correct the errors first.'));
                return undefined;
            }
            return parseResult.configuration;
        });
    };
    TaskService.prototype.printStderr = function (stderr) {
        var _this = this;
        var result = false;
        if (stderr && stderr.length > 0) {
            stderr.forEach(function (line) {
                result = true;
                _this.outputChannel.append(line + '\n');
            });
            this.outputChannel.show(true);
        }
        return result;
    };
    TaskService.prototype.inTerminal = function () {
        return this._inTerminal !== void 0 && this._inTerminal;
    };
    TaskService.prototype.hasDetectorSupport = function (config) {
        if (!config.command) {
            return false;
        }
        return processRunnerDetector_1.ProcessRunnerDetector.supports(config.command);
    };
    TaskService.prototype.configureAction = function () {
        return new ConfigureTaskRunnerAction(ConfigureTaskRunnerAction.ID, ConfigureTaskRunnerAction.TEXT, this.configurationService, this.editorService, this.fileService, this.contextService, this.outputService, this.messageService, this.quickOpenService, this.environmentService, this.configurationResolverService);
    };
    TaskService.prototype.configureBuildTask = function () {
        return new ConfigureBuildTaskAction(ConfigureBuildTaskAction.ID, ConfigureBuildTaskAction.TEXT, this.configurationService, this.editorService, this.fileService, this.contextService, this.outputService, this.messageService, this.quickOpenService, this.environmentService, this.configurationResolverService);
    };
    TaskService.prototype.build = function () {
        return this.executeTarget(function (taskSystem) { return taskSystem.build(); });
    };
    TaskService.prototype.rebuild = function () {
        return this.executeTarget(function (taskSystem) { return taskSystem.rebuild(); });
    };
    TaskService.prototype.clean = function () {
        return this.executeTarget(function (taskSystem) { return taskSystem.clean(); });
    };
    TaskService.prototype.runTest = function () {
        return this.executeTarget(function (taskSystem) { return taskSystem.runTest(); });
    };
    TaskService.prototype.run = function (taskIdentifier) {
        return this.executeTarget(function (taskSystem) { return taskSystem.run(taskIdentifier); });
    };
    TaskService.prototype.executeTarget = function (fn) {
        var _this = this;
        return this.textFileService.saveAll().then(function (value) {
            return _this.configurationService.reloadConfiguration().then(function () {
                return _this.taskSystemPromise.
                    then(function (taskSystem) {
                    var executeResult = fn(taskSystem);
                    if (executeResult.kind === taskSystem_1.TaskExecuteKind.Active) {
                        var active = executeResult.active;
                        if (active.same && active.background) {
                            _this.messageService.show(severity_1.default.Info, nls.localize('TaskSystem.activeSame', 'The task is already active and in watch mode. To terminate the task use `F1 > terminate task`'));
                        }
                        else {
                            throw new taskSystem_1.TaskError(severity_1.default.Warning, nls.localize('TaskSystem.active', 'There is an active running task right now. Terminate it first before executing another task.'), taskSystem_1.TaskErrors.RunningTask);
                        }
                    }
                    return executeResult;
                }).
                    then(function (executeResult) {
                    if (executeResult.kind === taskSystem_1.TaskExecuteKind.Started) {
                        if (executeResult.started.restartOnFileChanges) {
                            var pattern_1 = executeResult.started.restartOnFileChanges;
                            _this.fileChangesListener = _this.fileService.onFileChanges(function (event) {
                                var needsRestart = event.changes.some(function (change) {
                                    return (change.type === files_1.FileChangeType.ADDED || change.type === files_1.FileChangeType.DELETED) && !!glob_1.match(pattern_1, change.resource.fsPath);
                                });
                                if (needsRestart) {
                                    _this.terminate().done(function () {
                                        // We need to give the child process a change to stop.
                                        platform_1.setTimeout(function () {
                                            _this.executeTarget(fn);
                                        }, 2000);
                                    });
                                }
                            });
                        }
                        return executeResult.promise.then(function (value) {
                            if (_this.clearTaskSystemPromise) {
                                _this._taskSystemPromise = null;
                                _this.clearTaskSystemPromise = false;
                            }
                            return value;
                        });
                    }
                    else {
                        return executeResult.promise;
                    }
                }, function (err) {
                    _this.handleError(err);
                });
            });
        });
    };
    TaskService.prototype.isActive = function () {
        if (this._taskSystemPromise) {
            return this.taskSystemPromise.then(function (taskSystem) { return taskSystem.isActive(); });
        }
        return winjs_base_1.TPromise.as(false);
    };
    TaskService.prototype.terminate = function () {
        var _this = this;
        if (this._taskSystemPromise) {
            return this.taskSystemPromise.then(function (taskSystem) {
                return taskSystem.terminate();
            }).then(function (response) {
                if (response.success) {
                    if (_this.clearTaskSystemPromise) {
                        _this._taskSystemPromise = null;
                        _this.clearTaskSystemPromise = false;
                    }
                    _this.emit(taskService_1.TaskServiceEvents.Terminated, {});
                    _this.disposeFileChangesListener();
                }
                return response;
            });
        }
        return winjs_base_1.TPromise.as({ success: true });
    };
    TaskService.prototype.tasks = function () {
        return this.taskSystemPromise.then(function (taskSystem) { return taskSystem.tasks(); });
    };
    TaskService.prototype.beforeShutdown = function () {
        var _this = this;
        if (this._taskSystem && this._taskSystem.isActiveSync()) {
            if (this._taskSystem.canAutoTerminate() || this.messageService.confirm({
                message: nls.localize('TaskSystem.runningTask', 'There is a task running. Do you want to terminate it?'),
                primaryButton: nls.localize({ key: 'TaskSystem.terminateTask', comment: ['&& denotes a mnemonic'] }, "&&Terminate Task")
            })) {
                return this._taskSystem.terminate().then(function (response) {
                    if (response.success) {
                        _this.emit(taskService_1.TaskServiceEvents.Terminated, {});
                        _this._taskSystem = null;
                        _this.disposeFileChangesListener();
                        _this.disposeTaskSystemListeners();
                        return false; // no veto
                    }
                    else if (response.code && response.code === processes_1.TerminateResponseCode.ProcessNotFound) {
                        return !_this.messageService.confirm({
                            message: nls.localize('TaskSystem.noProcess', 'The launched task doesn\'t exist anymore. If the task spawned background processes exiting VS Code might result in orphaned processes. To avoid this start the last background process with a wait flag.'),
                            primaryButton: nls.localize({ key: 'TaskSystem.exitAnyways', comment: ['&& denotes a mnemonic'] }, "&&Exit Anyways")
                        });
                    }
                    return true; // veto
                }, function (err) {
                    return true; // veto
                });
            }
            else {
                return true; // veto
            }
        }
        return false; // Nothing to do here
    };
    TaskService.prototype.getConfigureAction = function (code) {
        switch (code) {
            case taskSystem_1.TaskErrors.NoBuildTask:
                return this.configureBuildTask();
            default:
                return this.configureAction();
        }
    };
    TaskService.prototype.handleError = function (err) {
        var _this = this;
        var showOutput = true;
        if (err instanceof taskSystem_1.TaskError) {
            var buildError = err;
            var needsConfig = buildError.code === taskSystem_1.TaskErrors.NotConfigured || buildError.code === taskSystem_1.TaskErrors.NoBuildTask || buildError.code === taskSystem_1.TaskErrors.NoTestTask;
            var needsTerminate = buildError.code === taskSystem_1.TaskErrors.RunningTask;
            if (needsConfig || needsTerminate) {
                var closeAction = new CloseMessageAction();
                var action = needsConfig
                    ? this.getConfigureAction(buildError.code)
                    : new actions_1.Action('workbench.action.tasks.terminate', nls.localize('TerminateAction.label', "Terminate Running Task"), undefined, true, function () { _this.runTerminateCommand(); return winjs_base_1.TPromise.as(undefined); });
                closeAction.closeFunction = this.messageService.show(buildError.severity, { message: buildError.message, actions: [action, closeAction] });
            }
            else {
                this.messageService.show(buildError.severity, buildError.message);
            }
        }
        else if (err instanceof Error) {
            var error = err;
            this.messageService.show(severity_1.default.Error, error.message);
        }
        else if (Types.isString(err)) {
            this.messageService.show(severity_1.default.Error, err);
        }
        else {
            this.messageService.show(severity_1.default.Error, nls.localize('TaskSystem.unknownError', 'An error has occurred while running a task. See task log for details.'));
        }
        if (showOutput) {
            this.outputChannel.show(true);
        }
    };
    TaskService.prototype.canRunCommand = function () {
        if (!this.contextService.hasWorkspace()) {
            this.messageService.show(severity_1.default.Info, nls.localize('TaskService.noWorkspace', 'Tasks are only available on a workspace folder.'));
            return false;
        }
        return true;
    };
    TaskService.prototype.runTaskCommand = function (accessor, arg) {
        var _this = this;
        if (!this.canRunCommand()) {
            return;
        }
        if (Types.isString(arg)) {
            this.tasks().then(function (tasks) {
                for (var _i = 0, tasks_1 = tasks; _i < tasks_1.length; _i++) {
                    var task = tasks_1[_i];
                    if (task.identifier === arg) {
                        _this.run(task.id);
                    }
                }
            });
        }
        else {
            this.quickOpenService.show('task ');
        }
    };
    TaskService.prototype.runTerminateCommand = function () {
        var _this = this;
        if (!this.canRunCommand()) {
            return;
        }
        if (this.inTerminal()) {
            this.messageService.show(severity_1.default.Info, {
                message: nls.localize('TerminateAction.terminalSystem', 'The tasks are executed in the integrated terminal. Use the terminal to manage the tasks.'),
                actions: [new ViewTerminalAction(this.terminalService), new CloseMessageAction()]
            });
        }
        else {
            this.isActive().then(function (active) {
                if (active) {
                    _this.terminate().then(function (response) {
                        if (response.success) {
                            return undefined;
                        }
                        else if (response.code && response.code === processes_1.TerminateResponseCode.ProcessNotFound) {
                            _this.messageService.show(severity_1.default.Error, nls.localize('TerminateAction.noProcess', 'The launched process doesn\'t exist anymore. If the task spawned background tasks exiting VS Code might result in orphaned processes.'));
                            return undefined;
                        }
                        else {
                            return winjs_base_1.Promise.wrapError(nls.localize('TerminateAction.failed', 'Failed to terminate running task'));
                        }
                    });
                }
            });
        }
    };
    return TaskService;
}(eventEmitter_1.EventEmitter));
TaskService.autoDetectTelemetryName = 'taskServer.autoDetect';
TaskService.SERVICE_ID = 'taskService';
TaskService.OutputChannelId = 'tasks';
TaskService.OutputChannelLabel = nls.localize('tasks', "Tasks");
TaskService = __decorate([
    __param(0, modeService_1.IModeService), __param(1, configuration_1.IConfigurationService),
    __param(2, markers_1.IMarkerService), __param(3, output_1.IOutputService),
    __param(4, message_1.IMessageService), __param(5, editorService_1.IWorkbenchEditorService),
    __param(6, files_1.IFileService), __param(7, workspace_1.IWorkspaceContextService),
    __param(8, telemetry_1.ITelemetryService), __param(9, textfiles_1.ITextFileService),
    __param(10, lifecycle_2.ILifecycleService),
    __param(11, modelService_1.IModelService), __param(12, extensions_2.IExtensionService),
    __param(13, quickOpen_1.IQuickOpenService),
    __param(14, environment_1.IEnvironmentService),
    __param(15, configurationResolver_1.IConfigurationResolverService),
    __param(16, terminal_1.ITerminalService)
], TaskService);
var workbenchActionsRegistry = platform_2.Registry.as(actionRegistry_1.Extensions.WorkbenchActions);
workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ConfigureTaskRunnerAction, ConfigureTaskRunnerAction.ID, ConfigureTaskRunnerAction.TEXT), 'Tasks: Configure Task Runner', tasksCategory);
actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.showLog', title: nls.localize('ShowLogAction.label', "Show Task Log"), alias: 'Tasks: Show Task Log', category: tasksCategory });
actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.runTask', title: nls.localize('RunTaskAction.label', "Run Task"), alias: 'Tasks: Run Task', category: tasksCategory });
actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.terminate', title: nls.localize('TerminateAction.label', "Terminate Running Task"), alias: 'Tasks: Terminate Running Task', category: tasksCategory });
actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.build', title: nls.localize('BuildAction.label', "Run Build Task"), alias: 'Tasks: Run Build Task', category: tasksCategory });
actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.test', title: nls.localize('TestAction.label', "Run Test Task"), alias: 'Tasks: Run Test Task', category: tasksCategory });
// MenuRegistry.addCommand( { id: 'workbench.action.tasks.rebuild', title: nls.localize('RebuildAction.label', 'Run Rebuild Task'), category: tasksCategory });
// MenuRegistry.addCommand( { id: 'workbench.action.tasks.clean', title: nls.localize('CleanAction.label', 'Run Clean Task'), category: tasksCategory });
// Task Service
extensions_1.registerSingleton(taskService_1.ITaskService, TaskService);
// Register Quick Open
platform_2.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor('vs/workbench/parts/tasks/browser/taskQuickOpen', 'QuickOpenHandler', 'task ', nls.localize('taskCommands', "Run Task")));
// Status bar
var statusbarRegistry = platform_2.Registry.as(statusbar_1.Extensions.Statusbar);
statusbarRegistry.registerStatusbarItem(new statusbar_1.StatusbarItemDescriptor(StatusBarItem, statusbar_1.StatusbarAlignment.LEFT, 50 /* Medium Priority */));
// Output channel
var outputChannelRegistry = platform_2.Registry.as(output_1.Extensions.OutputChannels);
outputChannelRegistry.registerChannel(TaskService.OutputChannelId, TaskService.OutputChannelLabel);
// (<IWorkbenchContributionsRegistry>Registry.as(WorkbenchExtensions.Workbench)).registerWorkbenchContribution(TaskServiceParticipant);
// tasks.json validation
var schemaId = 'vscode://schemas/tasks';
var schema = {
    id: schemaId,
    description: 'Task definition file',
    type: 'object',
    default: {
        version: '0.1.0',
        command: 'myCommand',
        isShellCommand: false,
        args: [],
        showOutput: 'always',
        tasks: [
            {
                taskName: 'build',
                showOutput: 'silent',
                isBuildCommand: true,
                problemMatcher: ['$tsc', '$lessCompile']
            }
        ]
    }
};
var jsonSchema_v1_1 = require("./jsonSchema_v1");
var jsonSchema_v2_1 = require("./jsonSchema_v2");
schema.definitions = __assign({}, jsonSchema_v1_1.default.definitions, jsonSchema_v2_1.default.definitions);
schema.oneOf = jsonSchema_v1_1.default.oneOf.concat(jsonSchema_v2_1.default.oneOf);
var jsonRegistry = platform_2.Registry.as(jsonContributionRegistry.Extensions.JSONContribution);
jsonRegistry.registerSchema(schemaId, schema);
