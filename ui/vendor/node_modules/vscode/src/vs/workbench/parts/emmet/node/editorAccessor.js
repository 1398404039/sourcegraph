/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var strings = require("vs/base/common/strings");
var snippets = require("vs/editor/contrib/snippet/common/snippet");
var range_1 = require("vs/editor/common/core/range");
var snippetController_1 = require("vs/editor/contrib/snippet/common/snippetController");
var EditorAccessor = (function () {
    function EditorAccessor(languageIdentifierResolver, editor, syntaxProfiles, excludedLanguages, grammars) {
        this.emmetSupportedModes = ['html', 'css', 'xml', 'xsl', 'haml', 'jade', 'jsx', 'slim', 'scss', 'sass', 'less', 'stylus', 'styl', 'svg'];
        this._languageIdentifierResolver = languageIdentifierResolver;
        this._editor = editor;
        this._syntaxProfiles = syntaxProfiles;
        this._excludedLanguages = excludedLanguages;
        this._hasMadeEdits = false;
        this._grammars = grammars;
    }
    EditorAccessor.prototype.isEmmetEnabledMode = function () {
        return this.emmetSupportedModes.indexOf(this.getSyntax()) !== -1;
    };
    EditorAccessor.prototype.getSelectionRange = function () {
        var selection = this._editor.getSelection();
        return {
            start: this.getOffsetFromPosition(selection.getStartPosition()),
            end: this.getOffsetFromPosition(selection.getEndPosition())
        };
    };
    EditorAccessor.prototype.getCurrentLineRange = function () {
        var currentLine = this._editor.getSelection().startLineNumber;
        return {
            start: this.getOffsetFromPosition({ lineNumber: currentLine, column: 1 }),
            end: this.getOffsetFromPosition({ lineNumber: currentLine + 1, column: 1 })
        };
    };
    EditorAccessor.prototype.getCaretPos = function () {
        var selectionStart = this._editor.getSelection().getStartPosition();
        return this.getOffsetFromPosition(selectionStart);
    };
    EditorAccessor.prototype.setCaretPos = function (pos) {
        this.createSelection(pos);
    };
    EditorAccessor.prototype.getCurrentLine = function () {
        var selectionStart = this._editor.getSelection().getStartPosition();
        return this._editor.getModel().getLineContent(selectionStart.lineNumber);
    };
    EditorAccessor.prototype.onBeforeEmmetAction = function () {
        this._hasMadeEdits = false;
    };
    EditorAccessor.prototype.replaceContent = function (value, start, end, no_indent) {
        //console.log('value', value);
        var startPosition = this.getPositionFromOffset(start);
        var endPosition = this.getPositionFromOffset(end);
        // test if < or </ are located before or > after the replace range. Either replace these too, or block the expansion
        var currentLine = this._editor.getModel().getLineContent(startPosition.lineNumber).substr(0, startPosition.column - 1); // content before the replaced range
        var match = currentLine.match(/<[/]?$/);
        if (match) {
            if (strings.startsWith(value, match[0])) {
                startPosition = { lineNumber: startPosition.lineNumber, column: startPosition.column - match[0].length };
            }
            else {
                return; // ignore
            }
        }
        // test if > is located after the replace range. Either replace these too, or block the expansion
        if (this._editor.getModel().getLineContent(endPosition.lineNumber).substr(endPosition.column - 1, endPosition.column) === '>') {
            if (strings.endsWith(value, '>')) {
                endPosition = { lineNumber: endPosition.lineNumber, column: endPosition.column + 1 };
            }
            else {
                return; // ignore
            }
        }
        // If this is the first edit in this "transaction", push an undo stop before them
        if (!this._hasMadeEdits) {
            this._hasMadeEdits = true;
            this._editor.pushUndoStop();
        }
        var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        var codeSnippet = snippets.CodeSnippet.fromEmmet(value);
        snippetController_1.SnippetController.get(this._editor).runWithReplaceRange(codeSnippet, range);
    };
    EditorAccessor.prototype.onAfterEmmetAction = function () {
        // If there were any edits in this "transaction", push an undo stop after them
        if (this._hasMadeEdits) {
            this._editor.pushUndoStop();
        }
    };
    EditorAccessor.prototype.getContent = function () {
        return this._editor.getModel().getValue();
    };
    EditorAccessor.prototype.createSelection = function (startOffset, endOffset) {
        var startPosition = this.getPositionFromOffset(startOffset);
        var endPosition = null;
        if (!endOffset) {
            endPosition = startPosition;
        }
        else {
            endPosition = this.getPositionFromOffset(endOffset);
        }
        var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        this._editor.setSelection(range);
        this._editor.revealRange(range);
    };
    EditorAccessor.prototype.getSyntax = function () {
        return this.getSyntaxInternal(true);
    };
    EditorAccessor.prototype.getSyntaxInternal = function (overrideUsingProfiles) {
        var position = this._editor.getSelection().getStartPosition();
        this._editor.getModel().forceTokenization(position.lineNumber);
        var languageId = this._editor.getModel().getLanguageIdAtPosition(position.lineNumber, position.column);
        var language = this._languageIdentifierResolver.getLanguageIdentifier(languageId).language;
        var syntax = language.split('.').pop();
        if (this._excludedLanguages.indexOf(syntax) !== -1) {
            return '';
        }
        // user can overwrite the syntax using the emmet syntaxProfiles setting
        var profile = this.getSyntaxProfile(syntax);
        if (overrideUsingProfiles && profile && this.emmetSupportedModes.indexOf(profile) !== -1) {
            return profile;
        }
        if (this.emmetSupportedModes.indexOf(syntax) !== -1) {
            return syntax;
        }
        if (/\b(typescriptreact|javascriptreact|jsx-tags)\b/.test(syntax)) {
            return 'jsx';
        }
        if (syntax === 'sass-indented') {
            return 'sass';
        }
        syntax = this.checkParentMode(syntax);
        return syntax;
    };
    EditorAccessor.prototype.getSyntaxProfile = function (syntax) {
        var profile = this._syntaxProfiles[syntax];
        if (profile && typeof profile === 'string') {
            return profile;
        }
        return undefined;
    };
    EditorAccessor.prototype.checkParentMode = function (syntax) {
        var languageGrammar = this._grammars.getGrammar(syntax);
        if (!languageGrammar) {
            return syntax;
        }
        var languages = languageGrammar.split('.');
        if (languages.length < 2) {
            return syntax;
        }
        for (var i = 1; i < languages.length; i++) {
            var language = languages[languages.length - i];
            if (this.emmetSupportedModes.indexOf(language) !== -1) {
                return language;
            }
        }
        return syntax;
    };
    // If users have created their own output profile for current syntax as described
    // http://docs.emmet.io/customization/syntax-profiles/#create-your-own-profile
    // then we return the name of this profile. Else, we send null and
    // emmet is smart enough to guess the right output profile
    EditorAccessor.prototype.getProfileName = function () {
        var syntax = this.getSyntaxInternal(false);
        var profile = this._syntaxProfiles[syntax];
        if (profile && typeof profile !== 'string') {
            return syntax;
        }
        return null;
    };
    EditorAccessor.prototype.prompt = function (title) {
        //
    };
    EditorAccessor.prototype.getSelection = function () {
        var selection = this._editor.getSelection();
        var model = this._editor.getModel();
        var start = selection.getStartPosition();
        var end = selection.getEndPosition();
        var range = new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        return model.getValueInRange(range);
    };
    EditorAccessor.prototype.getFilePath = function () {
        return this._editor.getModel().uri.fsPath;
    };
    EditorAccessor.prototype.getPositionFromOffset = function (offset) {
        return this._editor.getModel().getPositionAt(offset);
    };
    EditorAccessor.prototype.getOffsetFromPosition = function (position) {
        return this._editor.getModel().getOffsetAt(position);
    };
    return EditorAccessor;
}());
exports.EditorAccessor = EditorAccessor;
