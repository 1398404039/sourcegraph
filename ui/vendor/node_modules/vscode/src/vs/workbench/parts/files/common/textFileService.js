/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var uri_1 = require('vs/base/common/uri');
var paths = require('vs/base/common/paths');
var DOM = require('vs/base/browser/dom');
var errors = require('vs/base/common/errors');
var objects = require('vs/base/common/objects');
var event_1 = require('vs/base/common/event');
var files_1 = require('vs/workbench/parts/files/common/files');
var editor_1 = require('vs/workbench/common/editor');
var lifecycle_1 = require('vs/platform/lifecycle/common/lifecycle');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var files_2 = require('vs/platform/files/common/files');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var lifecycle_2 = require('vs/base/common/lifecycle');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var groupService_1 = require('vs/workbench/services/group/common/groupService');
var untitledEditorService_1 = require('vs/workbench/services/untitled/common/untitledEditorService');
var binaryEditorModel_1 = require('vs/workbench/common/editor/binaryEditorModel');
var textFileEditorModelManager_1 = require('vs/workbench/parts/files/common/editors/textFileEditorModelManager');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
/**
 * The workbench file service implementation implements the raw file service spec and adds additional methods on top.
 *
 * It also adds diagnostics and logging around file system operations.
 */
var TextFileService = (function () {
    function TextFileService(lifecycleService, contextService, configurationService, telemetryService, editorGroupService, editorService, fileService, untitledEditorService, instantiationService) {
        this.lifecycleService = lifecycleService;
        this.contextService = contextService;
        this.configurationService = configurationService;
        this.telemetryService = telemetryService;
        this.editorGroupService = editorGroupService;
        this.editorService = editorService;
        this.fileService = fileService;
        this.untitledEditorService = untitledEditorService;
        this.instantiationService = instantiationService;
        this.toUnbind = [];
        this._onAutoSaveConfigurationChange = new event_1.Emitter();
        this.toUnbind.push(this._onAutoSaveConfigurationChange);
        this._onFilesAssociationChange = new event_1.Emitter();
        this.toUnbind.push(this._onFilesAssociationChange);
        this._models = this.instantiationService.createInstance(textFileEditorModelManager_1.TextFileEditorModelManager);
        var configuration = this.configurationService.getConfiguration();
        this.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;
        this.onConfigurationChange(configuration);
        this.telemetryService.publicLog('autoSave', this.getAutoSaveConfiguration());
        this.registerListeners();
    }
    Object.defineProperty(TextFileService.prototype, "models", {
        get: function () {
            return this._models;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileService.prototype, "onAutoSaveConfigurationChange", {
        get: function () {
            return this._onAutoSaveConfigurationChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileService.prototype, "onFilesAssociationChange", {
        get: function () {
            return this._onFilesAssociationChange.event;
        },
        enumerable: true,
        configurable: true
    });
    TextFileService.prototype.registerListeners = function () {
        var _this = this;
        // Lifecycle
        this.lifecycleService.onWillShutdown(function (event) { return event.veto(_this.beforeShutdown()); });
        this.lifecycleService.onShutdown(this.dispose, this);
        // Configuration changes
        this.toUnbind.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationChange(e.config); }));
        // Application & Editor focus change
        this.toUnbind.push(DOM.addDisposableListener(window, 'blur', function () { return _this.onWindowFocusLost(); }));
        this.toUnbind.push(DOM.addDisposableListener(window, 'blur', function () { return _this.onEditorFocusChanged(); }, true));
        this.toUnbind.push(this.editorGroupService.onEditorsChanged(function () { return _this.onEditorFocusChanged(); }));
    };
    TextFileService.prototype.beforeShutdown = function () {
        var _this = this;
        // Dirty files need treatment on shutdown
        if (this.getDirty().length) {
            // If auto save is enabled, save all files and then check again for dirty files
            if (this.getAutoSaveMode() !== files_1.AutoSaveMode.OFF) {
                return this.saveAll(false /* files only */).then(function () {
                    if (_this.getDirty().length) {
                        return _this.confirmBeforeShutdown(); // we still have dirty files around, so confirm normally
                    }
                    return false; // all good, no veto
                });
            }
            // Otherwise just confirm what to do
            return this.confirmBeforeShutdown();
        }
        return false; // no veto
    };
    TextFileService.prototype.confirmBeforeShutdown = function () {
        var confirm = this.confirmSave();
        // Save
        if (confirm === editor_1.ConfirmResult.SAVE) {
            return this.saveAll(true /* includeUntitled */).then(function (result) {
                if (result.results.some(function (r) { return !r.success; })) {
                    return true; // veto if some saves failed
                }
                return false; // no veto
            });
        }
        else if (confirm === editor_1.ConfirmResult.DONT_SAVE) {
            return false; // no veto
        }
        else if (confirm === editor_1.ConfirmResult.CANCEL) {
            return true; // veto
        }
    };
    TextFileService.prototype.onWindowFocusLost = function () {
        if (this.configuredAutoSaveOnWindowChange && this.isDirty()) {
            this.saveAll(void 0, files_1.SaveReason.WINDOW_CHANGE).done(null, errors.onUnexpectedError);
        }
    };
    TextFileService.prototype.onEditorFocusChanged = function () {
        if (this.configuredAutoSaveOnFocusChange && this.isDirty()) {
            this.saveAll(void 0, files_1.SaveReason.FOCUS_CHANGE).done(null, errors.onUnexpectedError);
        }
    };
    TextFileService.prototype.onConfigurationChange = function (configuration) {
        var wasAutoSaveEnabled = (this.getAutoSaveMode() !== files_1.AutoSaveMode.OFF);
        var autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || files_2.AutoSaveConfiguration.OFF;
        switch (autoSaveMode) {
            case files_2.AutoSaveConfiguration.AFTER_DELAY:
                this.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case files_2.AutoSaveConfiguration.ON_FOCUS_CHANGE:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = true;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case files_2.AutoSaveConfiguration.ON_WINDOW_CHANGE:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = true;
                break;
            default:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
        }
        // Emit as event
        this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
        // save all dirty when enabling auto save
        if (!wasAutoSaveEnabled && this.getAutoSaveMode() !== files_1.AutoSaveMode.OFF) {
            this.saveAll().done(null, errors.onUnexpectedError);
        }
        // Check for change in files associations
        var filesAssociation = configuration && configuration.files && configuration.files.associations;
        if (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {
            this.currentFilesAssociationConfig = filesAssociation;
            this._onFilesAssociationChange.fire();
        }
    };
    TextFileService.prototype.getDirty = function (resources) {
        var _this = this;
        // Collect files
        var dirty = this.getDirtyFileModels(resources).map(function (m) { return m.getResource(); });
        // Add untitled ones
        if (!resources) {
            dirty.push.apply(dirty, this.untitledEditorService.getDirty());
        }
        else {
            var dirtyUntitled = resources.map(function (r) { return _this.untitledEditorService.get(r); }).filter(function (u) { return u && u.isDirty(); }).map(function (u) { return u.getResource(); });
            dirty.push.apply(dirty, dirtyUntitled);
        }
        return dirty;
    };
    TextFileService.prototype.isDirty = function (resource) {
        // Check for dirty file
        if (this._models.getAll(resource).some(function (model) { return model.isDirty(); })) {
            return true;
        }
        // Check for dirty untitled
        return this.untitledEditorService.getDirty().some(function (dirty) { return !resource || dirty.toString() === resource.toString(); });
    };
    TextFileService.prototype.save = function (resource, options) {
        // touch resource if options tell so and file is not dirty
        if (options && options.force && resource.scheme === 'file' && !this.isDirty(resource)) {
            return this.fileService.touchFile(resource).then(function () { return true; });
        }
        return this.saveAll([resource]).then(function (result) { return result.results.length === 1 && result.results[0].success; });
    };
    TextFileService.prototype.saveAll = function (arg1, reason) {
        // get all dirty
        var toSave = [];
        if (Array.isArray(arg1)) {
            toSave = this.getDirty(arg1);
        }
        else {
            toSave = this.getDirty();
        }
        // split up between files and untitled
        var filesToSave = [];
        var untitledToSave = [];
        toSave.forEach(function (s) {
            if (s.scheme === 'file') {
                filesToSave.push(s);
            }
            else if ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === 'untitled') {
                untitledToSave.push(s);
            }
        });
        return this.doSaveAll(filesToSave, untitledToSave, reason);
    };
    TextFileService.prototype.doSaveAll = function (fileResources, untitledResources, reason) {
        var _this = this;
        // Handle files first that can just be saved
        return this.doSaveAllFiles(fileResources, reason).then(function (result) {
            // Preflight for untitled to handle cancellation from the dialog
            var targetsForUntitled = [];
            for (var i = 0; i < untitledResources.length; i++) {
                var untitled = _this.untitledEditorService.get(untitledResources[i]);
                if (untitled) {
                    var targetPath = void 0;
                    // Untitled with associated file path don't need to prompt
                    if (_this.untitledEditorService.hasAssociatedFilePath(untitled.getResource())) {
                        targetPath = untitled.getResource().fsPath;
                    }
                    else {
                        targetPath = _this.promptForPath(_this.suggestFileName(untitledResources[i]));
                        if (!targetPath) {
                            return winjs_base_1.TPromise.as({
                                results: fileResources.concat(untitledResources).map(function (r) {
                                    return {
                                        source: r
                                    };
                                })
                            });
                        }
                    }
                    targetsForUntitled.push(uri_1.default.file(targetPath));
                }
            }
            // Handle untitled
            var untitledSaveAsPromises = [];
            targetsForUntitled.forEach(function (target, index) {
                var untitledSaveAsPromise = _this.saveAs(untitledResources[index], target).then(function (uri) {
                    result.results.push({
                        source: untitledResources[index],
                        target: uri,
                        success: !!uri
                    });
                });
                untitledSaveAsPromises.push(untitledSaveAsPromise);
            });
            return winjs_base_1.TPromise.join(untitledSaveAsPromises).then(function () {
                return result;
            });
        });
    };
    TextFileService.prototype.doSaveAllFiles = function (arg1 /* URI[] */, reason) {
        var dirtyFileModels = this.getDirtyFileModels(Array.isArray(arg1) ? arg1 : void 0 /* Save All */);
        var mapResourceToResult = Object.create(null);
        dirtyFileModels.forEach(function (m) {
            mapResourceToResult[m.getResource().toString()] = {
                source: m.getResource()
            };
        });
        return winjs_base_1.TPromise.join(dirtyFileModels.map(function (model) {
            return model.save({ reason: reason }).then(function () {
                if (!model.isDirty()) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
            });
        })).then(function (r) {
            return {
                results: Object.keys(mapResourceToResult).map(function (k) { return mapResourceToResult[k]; })
            };
        });
    };
    TextFileService.prototype.getFileModels = function (arg1) {
        var _this = this;
        if (Array.isArray(arg1)) {
            var models_1 = [];
            arg1.forEach(function (resource) {
                models_1.push.apply(models_1, _this.getFileModels(resource));
            });
            return models_1;
        }
        return this._models.getAll(arg1);
    };
    TextFileService.prototype.getDirtyFileModels = function (arg1) {
        return this.getFileModels(arg1).filter(function (model) { return model.isDirty(); });
    };
    TextFileService.prototype.saveAs = function (resource, target) {
        // Get to target resource
        if (!target) {
            var dialogPath = resource.fsPath;
            if (resource.scheme === 'untitled') {
                dialogPath = this.suggestFileName(resource);
            }
            var pathRaw = this.promptForPath(dialogPath);
            if (pathRaw) {
                target = uri_1.default.file(pathRaw);
            }
        }
        if (!target) {
            return winjs_base_1.TPromise.as(null); // user canceled
        }
        // Just save if target is same as models own resource
        if (resource.toString() === target.toString()) {
            return this.save(resource).then(function () { return resource; });
        }
        // Do it
        return this.doSaveAs(resource, target);
    };
    TextFileService.prototype.doSaveAs = function (resource, target) {
        var _this = this;
        // Retrieve text model from provided resource if any
        var modelPromise = winjs_base_1.TPromise.as(null);
        if (resource.scheme === 'file') {
            modelPromise = winjs_base_1.TPromise.as(this._models.get(resource));
        }
        else if (resource.scheme === 'untitled') {
            var untitled = this.untitledEditorService.get(resource);
            if (untitled) {
                modelPromise = untitled.resolve();
            }
        }
        return modelPromise.then(function (model) {
            // We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)
            if (model) {
                return _this.doSaveTextFileAs(model, resource, target);
            }
            // Otherwise we can only copy
            return _this.fileService.copyFile(resource, target);
        }).then(function () {
            // Revert the source
            return _this.revert(resource).then(function () {
                // Done: return target
                return target;
            });
        });
    };
    TextFileService.prototype.doSaveTextFileAs = function (sourceModel, resource, target) {
        var _this = this;
        // create the target file empty if it does not exist already
        return this.fileService.resolveFile(target).then(function (stat) { return stat; }, function () { return null; }).then(function (stat) { return stat || _this.fileService.createFile(target); }).then(function (stat) {
            // resolve a model for the file (which can be binary if the file is not a text file)
            return _this.editorService.resolveEditorModel({ resource: target }).then(function (targetModel) {
                // binary model: delete the file and run the operation again
                if (targetModel instanceof binaryEditorModel_1.BinaryEditorModel) {
                    return _this.fileService.del(target).then(function () { return _this.doSaveTextFileAs(sourceModel, resource, target); });
                }
                // text model: take over encoding and model value from source model
                targetModel.updatePreferredEncoding(sourceModel.getEncoding());
                targetModel.textEditorModel.setValue(sourceModel.getValue());
                // save model
                return targetModel.save();
            });
        });
    };
    TextFileService.prototype.suggestFileName = function (untitledResource) {
        var workspace = this.contextService.getWorkspace();
        if (workspace) {
            return uri_1.default.file(paths.join(workspace.resource.fsPath, this.untitledEditorService.get(untitledResource).suggestFileName())).fsPath;
        }
        return this.untitledEditorService.get(untitledResource).suggestFileName();
    };
    TextFileService.prototype.revert = function (resource, force) {
        return this.revertAll([resource], force).then(function (result) { return result.results.length === 1 && result.results[0].success; });
    };
    TextFileService.prototype.revertAll = function (resources, force) {
        var _this = this;
        // Revert files first
        return this.doRevertAllFiles(resources, force).then(function (operation) {
            // Revert untitled
            var reverted = _this.untitledEditorService.revertAll(resources);
            reverted.forEach(function (res) { return operation.results.push({ source: res, success: true }); });
            return operation;
        });
    };
    TextFileService.prototype.doRevertAllFiles = function (resources, force) {
        var fileModels = force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);
        var mapResourceToResult = Object.create(null);
        fileModels.forEach(function (m) {
            mapResourceToResult[m.getResource().toString()] = {
                source: m.getResource()
            };
        });
        return winjs_base_1.TPromise.join(fileModels.map(function (model) {
            return model.revert().then(function () {
                if (!model.isDirty()) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
            }, function (error) {
                // FileNotFound means the file got deleted meanwhile, so still record as successful revert
                if (error.fileOperationResult === files_2.FileOperationResult.FILE_NOT_FOUND) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
                else {
                    return winjs_base_1.TPromise.wrapError(error);
                }
            });
        })).then(function (r) {
            return {
                results: Object.keys(mapResourceToResult).map(function (k) { return mapResourceToResult[k]; })
            };
        });
    };
    TextFileService.prototype.getAutoSaveMode = function () {
        if (this.configuredAutoSaveOnFocusChange) {
            return files_1.AutoSaveMode.ON_FOCUS_CHANGE;
        }
        if (this.configuredAutoSaveOnWindowChange) {
            return files_1.AutoSaveMode.ON_WINDOW_CHANGE;
        }
        if (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {
            return this.configuredAutoSaveDelay <= 1000 ? files_1.AutoSaveMode.AFTER_SHORT_DELAY : files_1.AutoSaveMode.AFTER_LONG_DELAY;
        }
        return files_1.AutoSaveMode.OFF;
    };
    TextFileService.prototype.getAutoSaveConfiguration = function () {
        return {
            autoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : void 0,
            autoSaveFocusChange: this.configuredAutoSaveOnFocusChange,
            autoSaveApplicationChange: this.configuredAutoSaveOnWindowChange
        };
    };
    TextFileService.prototype.dispose = function () {
        this.toUnbind = lifecycle_2.dispose(this.toUnbind);
        // Clear all caches
        this._models.clear();
    };
    TextFileService = __decorate([
        __param(0, lifecycle_1.ILifecycleService),
        __param(1, workspace_1.IWorkspaceContextService),
        __param(2, configuration_1.IConfigurationService),
        __param(3, telemetry_1.ITelemetryService),
        __param(4, groupService_1.IEditorGroupService),
        __param(5, editorService_1.IWorkbenchEditorService),
        __param(6, files_2.IFileService),
        __param(7, untitledEditorService_1.IUntitledEditorService),
        __param(8, instantiation_1.IInstantiationService)
    ], TextFileService);
    return TextFileService;
}());
exports.TextFileService = TextFileService;
