/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var git_1 = require("vs/workbench/parts/git/common/git");
var unscopedGitService_1 = require("vs/workbench/parts/git/node/unscopedGitService");
var gitServices_1 = require("vs/workbench/parts/git/browser/gitServices");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var output_1 = require("vs/workbench/parts/output/common/output");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var environment_1 = require("vs/platform/environment/common/environment");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var ipc_1 = require("vs/base/parts/ipc/common/ipc");
var ipc_cp_1 = require("vs/base/parts/ipc/node/ipc.cp");
var gitIpc_1 = require("vs/workbench/parts/git/common/gitIpc");
var rawGitService_1 = require("vs/workbench/parts/git/node/rawGitService");
var uri_1 = require("vs/base/common/uri");
var child_process_1 = require("child_process");
var path_1 = require("path");
var storage_1 = require("vs/platform/storage/common/storage");
var pfs_1 = require("vs/base/node/pfs");
var files_1 = require("vs/platform/files/common/files");
function parseVersion(raw) {
    return raw.replace(/^git version /, '');
}
function findSpecificGit(path) {
    return new winjs_base_1.TPromise(function (c, e) {
        var buffers = [];
        var child = child_process_1.spawn(path, ['--version']);
        child.stdout.on('data', function (b) { return buffers.push(b); });
        child.on('error', e);
        child.on('exit', function (code) { return code ? e(new Error('Not found')) : c({ path: path, version: parseVersion(Buffer.concat(buffers).toString('utf8').trim()) }); });
    });
}
function findGitDarwin() {
    return new winjs_base_1.TPromise(function (c, e) {
        child_process_1.exec('which git', function (err, gitPathBuffer) {
            if (err) {
                return e('git not found');
            }
            var path = gitPathBuffer.toString().replace(/^\s+|\s+$/g, '');
            function getVersion(path) {
                // make sure git executes
                child_process_1.exec('git --version', function (err, stdout) {
                    if (err) {
                        return e('git not found');
                    }
                    return c({ path: path, version: parseVersion(stdout.toString('utf8').trim()) });
                });
            }
            if (path !== '/usr/bin/git') {
                return getVersion(path);
            }
            // must check if XCode is installed
            child_process_1.exec('xcode-select -p', function (err) {
                if (err && err.code === 2) {
                    // git is not installed, and launching /usr/bin/git
                    // will prompt the user to install it
                    return e('git not found');
                }
                getVersion(path);
            });
        });
    });
}
function findSystemGitWin32(base) {
    if (!base) {
        return winjs_base_1.TPromise.wrapError('Not found');
    }
    return findSpecificGit(path_1.join(base, 'Git', 'cmd', 'git.exe'));
}
function findGitHubGitWin32() {
    var github = path_1.join(process.env['LOCALAPPDATA'], 'GitHub');
    return pfs_1.readdir(github).then(function (children) {
        var git = children.filter(function (child) { return /^PortableGit/.test(child); })[0];
        if (!git) {
            return winjs_base_1.TPromise.wrapError('Not found');
        }
        return findSpecificGit(path_1.join(github, git, 'cmd', 'git.exe'));
    });
}
function findGitWin32() {
    return findSystemGitWin32(process.env['ProgramW6432'])
        .then(null, function () { return findSystemGitWin32(process.env['ProgramFiles(x86)']); })
        .then(null, function () { return findSystemGitWin32(process.env['ProgramFiles']); })
        .then(null, function () { return findSpecificGit('git'); })
        .then(null, function () { return findGitHubGitWin32(); });
}
function findGit(hint) {
    var first = hint ? findSpecificGit(hint) : winjs_base_1.TPromise.wrapError(null);
    return first.then(null, function () {
        switch (process.platform) {
            case 'darwin': return findGitDarwin();
            case 'win32': return findGitWin32();
            default: return findSpecificGit('git');
        }
    });
}
var DisabledRawGitService = (function (_super) {
    __extends(DisabledRawGitService, _super);
    function DisabledRawGitService() {
        return _super.call(this, null) || this;
    }
    DisabledRawGitService.prototype.serviceState = function () {
        return winjs_base_1.TPromise.as(git_1.RawServiceState.Disabled);
    };
    return DisabledRawGitService;
}(rawGitService_1.RawGitService));
function createRemoteRawGitService(gitPath, execPath, workspaceRoot, encoding, verbose) {
    var promise = winjs_base_1.TPromise.timeout(0) // free event loop cos finding git costs
        .then(function () { return findGit(gitPath); })
        .then(function (_a) {
        var path = _a.path, version = _a.version;
        var client = new ipc_cp_1.Client(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, {
            serverName: 'Git',
            timeout: 1000 * 60,
            args: [path, workspaceRoot, encoding, execPath, version],
            env: {
                ELECTRON_RUN_AS_NODE: 1,
                PIPE_LOGGING: 'true',
                AMD_ENTRYPOINT: 'vs/workbench/parts/git/node/gitApp',
                VERBOSE_LOGGING: String(verbose)
            }
        });
        return client.getChannel('git');
    })
        .then(null, function () { return new gitIpc_1.UnavailableGitChannel(); });
    var channel = ipc_1.getNextTickChannel(ipc_1.getDelayedChannel(promise));
    return new gitIpc_1.GitChannelClient(channel);
}
function createRawGitService(gitPath, execPath, workspaceRoot, encoding, verbose) {
    var requirePromise = new winjs_base_1.TPromise(function (c, e) {
        return require(['vs/workbench/parts/git/node/rawGitServiceBootstrap'], c, e);
    });
    var servicePromise = requirePromise.then(function (_a) {
        var createRawGitService = _a.createRawGitService;
        return findGit(gitPath)
            .then(function (_a) {
            var path = _a.path, version = _a.version;
            return createRawGitService(path, workspaceRoot, encoding, execPath, version);
        })
            .then(null, function () { return new rawGitService_1.RawGitService(null); });
    });
    return new rawGitService_1.DelayedRawGitService(servicePromise);
}
function createUnscopedRawGitService(gitPath, execPath, encoding) {
    var promise = findGit(gitPath)
        .then(function (_a) {
        var path = _a.path, version = _a.version;
        return new unscopedGitService_1.UnscopedGitService(path, version, encoding, execPath);
    })
        .then(null, function () { return new rawGitService_1.RawGitService(null); });
    return new rawGitService_1.DelayedRawGitService(promise);
}
var ElectronGitService = (function (_super) {
    __extends(ElectronGitService, _super);
    function ElectronGitService(instantiationService, fileService, messageService, editorService, outputService, textFileService, contextService, lifecycleService, storageService, environmentService, configurationService) {
        var _this = this;
        var conf = configurationService.getConfiguration('git');
        var filesConf = configurationService.getConfiguration('files');
        var workspace = contextService.getWorkspace();
        var gitPath = conf.path || null;
        var encoding = (filesConf && filesConf.encoding) || 'utf8';
        var verbose = !environmentService.isBuilt || environmentService.verbose;
        var raw;
        if (!conf.enabled) {
            raw = new DisabledRawGitService();
        }
        else if (!workspace) {
            raw = createUnscopedRawGitService(gitPath, environmentService.execPath, encoding);
        }
        else {
            var workspaceRoot = workspace.resource.fsPath;
            if (ElectronGitService.USE_REMOTE_PROCESS_SERVICE) {
                raw = createRemoteRawGitService(gitPath, environmentService.execPath, workspaceRoot, encoding, verbose);
            }
            else {
                raw = createRawGitService(gitPath, environmentService.execPath, workspaceRoot, encoding, verbose);
            }
        }
        _this = _super.call(this, raw, instantiationService, fileService, messageService, editorService, outputService, textFileService, contextService, lifecycleService, storageService, configurationService) || this;
        return _this;
    }
    return ElectronGitService;
}(gitServices_1.GitService));
ElectronGitService.USE_REMOTE_PROCESS_SERVICE = true;
ElectronGitService = __decorate([
    __param(0, instantiation_1.IInstantiationService),
    __param(1, files_1.IFileService),
    __param(2, message_1.IMessageService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, output_1.IOutputService),
    __param(5, textfiles_1.ITextFileService),
    __param(6, workspace_1.IWorkspaceContextService),
    __param(7, lifecycle_1.ILifecycleService),
    __param(8, storage_1.IStorageService),
    __param(9, environment_1.IEnvironmentService),
    __param(10, configuration_1.IConfigurationService)
], ElectronGitService);
exports.ElectronGitService = ElectronGitService;
