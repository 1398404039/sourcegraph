/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var fs = require("fs");
var path = require("path");
var nls = require("vs/nls");
var Objects = require("vs/base/common/objects");
var Types = require("vs/base/common/types");
var Platform = require("vs/base/common/platform");
var Async = require("vs/base/common/async");
var winjs_base_1 = require("vs/base/common/winjs.base");
var severity_1 = require("vs/base/common/severity");
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var lifecycle_1 = require("vs/base/common/lifecycle");
var TPath = require("vs/base/common/paths");
var problemCollectors_1 = require("vs/workbench/parts/tasks/common/problemCollectors");
var taskSystem_1 = require("vs/workbench/parts/tasks/common/taskSystem");
var TerminalDecoder = (function () {
    function TerminalDecoder() {
    }
    TerminalDecoder.prototype.write = function (data) {
        var result = [];
        var value = this.remaining
            ? this.remaining + data.replace(TerminalDecoder.ANSI_CONTROL_SEQUENCE, '')
            : data.replace(TerminalDecoder.ANSI_CONTROL_SEQUENCE, '');
        if (value.length < 1) {
            return result;
        }
        var start = 0;
        var ch;
        while (start < value.length && ((ch = value.charCodeAt(start)) === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */)) {
            start++;
        }
        var idx = start;
        while (idx < value.length) {
            ch = value.charCodeAt(idx);
            if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                result.push(value.substring(start, idx));
                idx++;
                while (idx < value.length && ((ch = value.charCodeAt(idx)) === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */)) {
                    idx++;
                }
                start = idx;
            }
            else {
                idx++;
            }
        }
        this.remaining = start < value.length ? value.substr(start) : null;
        return result;
    };
    TerminalDecoder.prototype.end = function () {
        return this.remaining;
    };
    return TerminalDecoder;
}());
// See https://en.wikipedia.org/wiki/ANSI_escape_code & http://stackoverflow.com/questions/25189651/how-to-remove-ansi-control-chars-vt100-from-a-java-string &
// https://www.npmjs.com/package/strip-ansi
TerminalDecoder.ANSI_CONTROL_SEQUENCE = /\x1b[[()#;?]*(?:\d{1,4}(?:;\d{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
var TerminalTaskSystem = (function (_super) {
    __extends(TerminalTaskSystem, _super);
    function TerminalTaskSystem(configuration, terminalService, outputService, markerService, modelService, configurationResolverService, telemetryService, outputChannelId) {
        var _this = _super.call(this) || this;
        _this.terminalService = terminalService;
        _this.outputService = outputService;
        _this.markerService = markerService;
        _this.modelService = modelService;
        _this.configurationResolverService = configurationResolverService;
        _this.telemetryService = telemetryService;
        _this.setConfiguration(configuration);
        _this.outputChannel = _this.outputService.getChannel(outputChannelId);
        _this.activeTasks = Object.create(null);
        _this.terminals = Object.create(null);
        _this.idleTaskTerminals = Object.create(null);
        return _this;
    }
    TerminalTaskSystem.prototype.setConfiguration = function (configuration) {
        var _this = this;
        this.configuration = configuration;
        this.identifier2Task = Object.create(null);
        Object.keys(this.configuration.tasks).forEach(function (key) {
            var task = _this.configuration.tasks[key];
            _this.identifier2Task[task.identifier] = task;
        });
    };
    TerminalTaskSystem.prototype.log = function (value) {
        this.outputChannel.append(value + '\n');
    };
    TerminalTaskSystem.prototype.showOutput = function () {
        this.outputChannel.show(true);
    };
    TerminalTaskSystem.prototype.build = function () {
        if (this.configuration.buildTasks.length === 0) {
            throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TerminalTaskSystem.noBuildTask', 'No build task defined in tasks.json'), taskSystem_1.TaskErrors.NoBuildTask);
        }
        return this.run(this.configuration.buildTasks[0], taskSystem_1.Triggers.shortcut);
    };
    TerminalTaskSystem.prototype.rebuild = function () {
        throw new Error('Task - Rebuild: not implemented yet');
    };
    TerminalTaskSystem.prototype.clean = function () {
        throw new Error('Task - Clean: not implemented yet');
    };
    TerminalTaskSystem.prototype.runTest = function () {
        if (this.configuration.testTasks.length === 0) {
            throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TerminalTaskSystem.noTestTask', 'No test task defined in tasks.json'), taskSystem_1.TaskErrors.NoTestTask);
        }
        return this.run(this.configuration.testTasks[0], taskSystem_1.Triggers.shortcut);
    };
    TerminalTaskSystem.prototype.run = function (taskIdentifier, trigger) {
        if (trigger === void 0) { trigger = taskSystem_1.Triggers.command; }
        var task = this.configuration.tasks[taskIdentifier];
        if (!task) {
            throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TerminalTaskSystem.noTask', 'Task \'{0}\' not found', taskIdentifier), taskSystem_1.TaskErrors.TaskNotFound);
        }
        var terminalData = this.activeTasks[task.id];
        if (terminalData && terminalData.promise) {
            if (task.showOutput === taskSystem_1.ShowOutput.Always) {
                terminalData.terminal.setVisible(true);
            }
            return { kind: taskSystem_1.TaskExecuteKind.Active, active: { same: true, background: task.isBackground }, promise: terminalData.promise };
        }
        try {
            return { kind: taskSystem_1.TaskExecuteKind.Started, started: {}, promise: this.executeTask(Object.create(null), task, trigger) };
        }
        catch (error) {
            if (error instanceof taskSystem_1.TaskError) {
                throw error;
            }
            else if (error instanceof Error) {
                this.log(error.message);
                throw new taskSystem_1.TaskError(severity_1.default.Error, error.message, taskSystem_1.TaskErrors.UnknownError);
            }
            else {
                this.log(error.toString());
                throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem.unknownError', 'A unknown error has occurred while executing a task. See task output log for details.'), taskSystem_1.TaskErrors.UnknownError);
            }
        }
    };
    TerminalTaskSystem.prototype.isActive = function () {
        return winjs_base_1.TPromise.as(this.isActiveSync());
    };
    TerminalTaskSystem.prototype.isActiveSync = function () {
        return Object.keys(this.activeTasks).length > 0;
    };
    TerminalTaskSystem.prototype.canAutoTerminate = function () {
        var _this = this;
        return Object.keys(this.activeTasks).every(function (key) { return !_this.configuration.tasks[key].promptOnClose; });
    };
    TerminalTaskSystem.prototype.terminate = function () {
        var _this = this;
        Object.keys(this.activeTasks).forEach(function (key) {
            var data = _this.activeTasks[key];
            data.terminal.dispose();
        });
        this.activeTasks = Object.create(null);
        return winjs_base_1.TPromise.as({ success: true });
    };
    TerminalTaskSystem.prototype.tasks = function () {
        var _this = this;
        var result;
        if (!this.configuration || !this.configuration.tasks) {
            result = [];
        }
        else {
            result = Object.keys(this.configuration.tasks).map(function (key) { return _this.configuration.tasks[key]; });
        }
        return winjs_base_1.TPromise.as(result);
    };
    TerminalTaskSystem.prototype.executeTask = function (startedTasks, task, trigger) {
        var _this = this;
        var promises = [];
        if (task.dependsOn) {
            task.dependsOn.forEach(function (identifier) {
                var task = _this.identifier2Task[identifier];
                if (task) {
                    var promise = startedTasks[task.id];
                    if (!promise) {
                        promise = _this.executeTask(startedTasks, task, trigger);
                        startedTasks[task.id] = promise;
                    }
                    promises.push(promise);
                }
            });
        }
        if (task.command) {
            return winjs_base_1.TPromise.join(promises).then(function (summaries) {
                for (var _i = 0, summaries_1 = summaries; _i < summaries_1.length; _i++) {
                    var summary = summaries_1[_i];
                    if (summary.exitCode !== 0) {
                        return { exitCode: summary.exitCode };
                    }
                }
                return _this.executeCommand(task, trigger);
            });
        }
        else {
            return winjs_base_1.TPromise.join(promises).then(function (summaries) {
                for (var _i = 0, summaries_2 = summaries; _i < summaries_2.length; _i++) {
                    var summary = summaries_2[_i];
                    if (summary.exitCode !== 0) {
                        return { exitCode: summary.exitCode };
                    }
                }
                return { exitCode: 0 };
            });
        }
    };
    TerminalTaskSystem.prototype.executeCommand = function (task, trigger) {
        var _this = this;
        var terminal = undefined;
        var executedCommand = undefined;
        var promise = undefined;
        if (task.isBackground) {
            promise = new winjs_base_1.TPromise(function (resolve, reject) {
                var watchingProblemMatcher = new problemCollectors_1.WatchingProblemCollector(_this.resolveMatchers(task.problemMatchers), _this.markerService, _this.modelService);
                var toUnbind = [];
                var event = { taskId: task.id, taskName: task.name, type: taskSystem_1.TaskType.Watching };
                var eventCounter = 0;
                toUnbind.push(watchingProblemMatcher.addListener2(problemCollectors_1.ProblemCollectorEvents.WatchingBeginDetected, function () {
                    eventCounter++;
                    _this.emit(taskSystem_1.TaskSystemEvents.Active, event);
                }));
                toUnbind.push(watchingProblemMatcher.addListener2(problemCollectors_1.ProblemCollectorEvents.WatchingEndDetected, function () {
                    eventCounter--;
                    _this.emit(taskSystem_1.TaskSystemEvents.Inactive, event);
                }));
                watchingProblemMatcher.aboutToStart();
                var delayer = null;
                var decoder = new TerminalDecoder();
                _a = _this.createTerminal(task), terminal = _a[0], executedCommand = _a[1];
                var onData = terminal.onData(function (data) {
                    decoder.write(data).forEach(function (line) {
                        watchingProblemMatcher.processLine(line);
                        if (delayer === null) {
                            delayer = new Async.Delayer(3000);
                        }
                        delayer.trigger(function () {
                            watchingProblemMatcher.forceDelivery();
                            delayer = null;
                        });
                    });
                });
                var onExit = terminal.onExit(function (exitCode) {
                    onData.dispose();
                    onExit.dispose();
                    delete _this.activeTasks[task.id];
                    if (_this.primaryTerminal && _this.primaryTerminal.terminal === terminal) {
                        _this.primaryTerminal.busy = false;
                    }
                    _this.idleTaskTerminals[task.id] = terminal.id.toString();
                    watchingProblemMatcher.dispose();
                    toUnbind = lifecycle_1.dispose(toUnbind);
                    toUnbind = null;
                    for (var i = 0; i < eventCounter; i++) {
                        _this.emit(taskSystem_1.TaskSystemEvents.Inactive, event);
                    }
                    eventCounter = 0;
                    if (exitCode && exitCode === 1 && watchingProblemMatcher.numberOfMatches === 0 && task.showOutput !== taskSystem_1.ShowOutput.Never) {
                        _this.terminalService.setActiveInstance(terminal);
                        _this.terminalService.showPanel(false);
                    }
                    resolve({ exitCode: exitCode });
                });
                var _a;
            });
        }
        else {
            promise = new winjs_base_1.TPromise(function (resolve, reject) {
                _a = _this.createTerminal(task), terminal = _a[0], executedCommand = _a[1];
                _this.emit(taskSystem_1.TaskSystemEvents.Active, event);
                var decoder = new TerminalDecoder();
                var startStopProblemMatcher = new problemCollectors_1.StartStopProblemCollector(_this.resolveMatchers(task.problemMatchers), _this.markerService, _this.modelService);
                var onData = terminal.onData(function (data) {
                    decoder.write(data).forEach(function (line) {
                        startStopProblemMatcher.processLine(line);
                    });
                });
                var onExit = terminal.onExit(function (exitCode) {
                    onData.dispose();
                    onExit.dispose();
                    delete _this.activeTasks[task.id];
                    if (_this.primaryTerminal && _this.primaryTerminal.terminal === terminal) {
                        _this.primaryTerminal.busy = false;
                    }
                    _this.idleTaskTerminals[task.id] = terminal.id.toString();
                    startStopProblemMatcher.processLine(decoder.end());
                    startStopProblemMatcher.done();
                    startStopProblemMatcher.dispose();
                    _this.emit(taskSystem_1.TaskSystemEvents.Inactive, event);
                    resolve({ exitCode: exitCode });
                });
                var _a;
            });
        }
        this.terminalService.setActiveInstance(terminal);
        if (task.showOutput === taskSystem_1.ShowOutput.Always) {
            this.terminalService.showPanel(false);
        }
        this.activeTasks[task.id] = { terminal: terminal, promise: promise };
        return promise.then(function (summary) {
            try {
                var telemetryEvent = {
                    trigger: trigger,
                    command: _this.getSanitizedCommand(executedCommand),
                    success: true,
                    exitCode: summary.exitCode
                };
                _this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);
            }
            catch (error) {
            }
            return summary;
        }, function (error) {
            try {
                var telemetryEvent = {
                    trigger: trigger,
                    command: _this.getSanitizedCommand(executedCommand),
                    success: false
                };
                _this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);
            }
            catch (error) {
            }
            return winjs_base_1.TPromise.wrapError(error);
        });
    };
    TerminalTaskSystem.prototype.createTerminal = function (task) {
        var _this = this;
        var options = this.resolveOptions(task.command.options);
        var _a = this.resolveCommandAndArgs(task), command = _a.command, args = _a.args;
        var terminalName = nls.localize('TerminalTaskSystem.terminalName', 'Task - {0}', task.name);
        var waitOnExit = task.showOutput !== taskSystem_1.ShowOutput.Never || !task.isBackground;
        var shellLaunchConfig = undefined;
        if (task.command.isShellCommand) {
            if (Platform.isWindows && ((options.cwd && TPath.isUNC(options.cwd)) || (!options.cwd && TPath.isUNC(process.cwd())))) {
                throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem', 'Can\'t execute a shell command on an UNC drive.'), taskSystem_1.TaskErrors.UnknownError);
            }
            shellLaunchConfig = { name: terminalName, executable: null, args: null, waitOnExit: waitOnExit };
            var shellSpecified = false;
            if (taskSystem_1.ShellConfiguration.is(task.command.isShellCommand)) {
                shellLaunchConfig.executable = task.command.isShellCommand.executable;
                shellSpecified = true;
                if (task.command.isShellCommand.args) {
                    shellLaunchConfig.args = task.command.isShellCommand.args.slice();
                }
                else {
                    shellLaunchConfig.args = [];
                }
            }
            else {
                this.terminalService.configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig);
            }
            var shellArgs_1 = shellLaunchConfig.args.slice(0);
            var toAdd = [];
            var commandLine = args && args.length > 0 ? command + " " + args.join(' ') : "" + command;
            if (Platform.isWindows) {
                var basename = path.basename(shellLaunchConfig.executable).toLowerCase();
                if (basename === 'powershell.exe') {
                    if (!shellSpecified) {
                        toAdd.push('-Command');
                    }
                }
                else {
                    if (!shellSpecified) {
                        toAdd.push('/d', '/c');
                    }
                }
            }
            else {
                if (!shellSpecified) {
                    toAdd.push('-c');
                }
            }
            toAdd.forEach(function (element) {
                if (!shellArgs_1.some(function (arg) { return arg.toLowerCase() === element; })) {
                    shellArgs_1.push(element);
                }
            });
            shellArgs_1.push(commandLine);
            shellLaunchConfig.args = shellArgs_1;
        }
        else {
            var cwd = options && options.cwd ? options.cwd : process.cwd();
            // On Windows executed process must be described absolute. Since we allowed command without an
            // absolute path (e.g. "command": "node") we need to find the executable in the CWD or PATH.
            var executable = Platform.isWindows && !task.command.isShellCommand ? this.findExecutable(command, cwd) : command;
            shellLaunchConfig = {
                name: terminalName,
                executable: executable,
                args: args,
                waitOnExit: waitOnExit
            };
        }
        if (options.cwd) {
            shellLaunchConfig.cwd = options.cwd;
        }
        if (options.env) {
            var env_1 = Object.create(null);
            Object.keys(process.env).forEach(function (key) {
                env_1[key] = process.env[key];
            });
            Object.keys(options.env).forEach(function (key) {
                env_1[key] = options.env[key];
            });
            shellLaunchConfig.env = env_1;
        }
        var terminalId = this.idleTaskTerminals[task.id];
        if (terminalId) {
            var taskTerminal = this.terminals[terminalId];
            if (taskTerminal) {
                delete this.idleTaskTerminals[task.id];
                taskTerminal.terminal.reuseTerminal(shellLaunchConfig);
                return [taskTerminal.terminal, command];
            }
        }
        if (this.primaryTerminal && !this.primaryTerminal.busy) {
            this.primaryTerminal.terminal.reuseTerminal(shellLaunchConfig);
            this.primaryTerminal.busy = true;
            return [this.primaryTerminal.terminal, command];
        }
        var result = this.terminalService.createInstance(shellLaunchConfig);
        var key = result.id.toString();
        result.onDisposed(function (terminal) {
            var terminalData = _this.terminals[key];
            if (terminalData) {
                delete _this.terminals[key];
                delete _this.idleTaskTerminals[terminalData.lastTask];
            }
            if (_this.primaryTerminal && _this.primaryTerminal.terminal === terminal) {
                _this.primaryTerminal = undefined;
            }
        });
        this.terminals[key] = { terminal: result, lastTask: task.id };
        if (!task.isBackground && !this.primaryTerminal) {
            this.primaryTerminal = { terminal: result, busy: true };
        }
        return [result, command];
    };
    TerminalTaskSystem.prototype.resolveCommandAndArgs = function (task) {
        // First we need to use the command args:
        var args = task.command.args ? task.command.args.slice() : [];
        // We need to first pass the task name
        if (!task.suppressTaskName) {
            if (task.command.taskSelector) {
                args.push(task.command.taskSelector + task.name);
            }
            else {
                args.push(task.name);
            }
        }
        // And then additional arguments
        if (task.args) {
            args = args.concat(task.args);
        }
        args = this.resolveVariables(args);
        var command = this.resolveVariable(task.command.name);
        return { command: command, args: args };
    };
    TerminalTaskSystem.prototype.findExecutable = function (command, cwd) {
        // If we have an absolute path then we take it.
        if (path.isAbsolute(command)) {
            return command;
        }
        var dir = path.dirname(command);
        if (dir !== '.') {
            // We have a directory. So leave the command as is.
            return command;
        }
        // We have a simple file name. We get the path variable from the env
        // and try to find the executable on the path.
        if (!process.env.PATH) {
            return command;
        }
        var paths = process.env.PATH.split(path.delimiter);
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var pathEntry = paths_1[_i];
            // The path entry is absolute.
            var fullPath = void 0;
            if (path.isAbsolute(pathEntry)) {
                fullPath = path.join(pathEntry, command);
            }
            else {
                fullPath = path.join(cwd, pathEntry, command);
            }
            if (fs.existsSync(fullPath)) {
                return fullPath;
            }
            var withExtension = fullPath + '.com';
            if (fs.existsSync(withExtension)) {
                return withExtension;
            }
            withExtension = fullPath + '.exe';
            if (fs.existsSync(withExtension)) {
                return withExtension;
            }
        }
        return command;
    };
    TerminalTaskSystem.prototype.resolveVariables = function (value) {
        var _this = this;
        return value.map(function (s) { return _this.resolveVariable(s); });
    };
    TerminalTaskSystem.prototype.resolveMatchers = function (values) {
        var _this = this;
        if (values.length === 0) {
            return values;
        }
        var result = [];
        values.forEach(function (matcher) {
            if (!matcher.filePrefix) {
                result.push(matcher);
            }
            else {
                var copy = Objects.clone(matcher);
                copy.filePrefix = _this.resolveVariable(copy.filePrefix);
                result.push(copy);
            }
        });
        return result;
    };
    TerminalTaskSystem.prototype.resolveVariable = function (value) {
        return this.configurationResolverService.resolve(value);
    };
    TerminalTaskSystem.prototype.resolveOptions = function (options) {
        var _this = this;
        var result = { cwd: this.resolveVariable(options.cwd) };
        if (options.env) {
            result.env = Object.create(null);
            Object.keys(options.env).forEach(function (key) {
                var value = options.env[key];
                if (Types.isString(value)) {
                    result.env[key] = _this.resolveVariable(value);
                }
                else {
                    result.env[key] = value.toString();
                }
            });
        }
        return result;
    };
    TerminalTaskSystem.prototype.ensureDoubleQuotes = function (value) {
        if (TerminalTaskSystem.doubleQuotes.test(value)) {
            return {
                value: '"' + value + '"',
                quoted: true
            };
        }
        else {
            return {
                value: value,
                quoted: value.length > 0 && value[0] === '"' && value[value.length - 1] === '"'
            };
        }
    };
    TerminalTaskSystem.prototype.getSanitizedCommand = function (cmd) {
        var result = cmd.toLowerCase();
        var index = result.lastIndexOf(path.sep);
        if (index !== -1) {
            result = result.substring(index + 1);
        }
        if (TerminalTaskSystem.WellKnowCommands[result]) {
            return result;
        }
        return 'other';
    };
    return TerminalTaskSystem;
}(eventEmitter_1.EventEmitter));
TerminalTaskSystem.TelemetryEventName = 'taskService';
TerminalTaskSystem.doubleQuotes = /^[^"].* .*[^"]$/;
TerminalTaskSystem.WellKnowCommands = {
    'ant': true,
    'cmake': true,
    'eslint': true,
    'gradle': true,
    'grunt': true,
    'gulp': true,
    'jake': true,
    'jenkins': true,
    'jshint': true,
    'make': true,
    'maven': true,
    'msbuild': true,
    'msc': true,
    'nmake': true,
    'npm': true,
    'rake': true,
    'tsc': true,
    'xbuild': true
};
exports.TerminalTaskSystem = TerminalTaskSystem;
