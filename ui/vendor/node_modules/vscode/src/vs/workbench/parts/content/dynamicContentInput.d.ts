import { TPromise } from 'vs/base/common/winjs.base';
import { EditorInput, EditorModel, ITextEditorModel } from 'vs/workbench/common/editor';
import URI from 'vs/base/common/uri';
import { IReference } from 'vs/base/common/lifecycle';
import { ITextModelResolverService } from 'vs/editor/common/services/resolverService';
import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
import { ILifecycleService } from 'vs/platform/lifecycle/common/lifecycle';
export declare class DynamicContentModel extends EditorModel {
    private mainRef;
    private snippetRefs;
    constructor(mainRef: IReference<ITextEditorModel>, snippetRefs: IReference<ITextEditorModel>[]);
    readonly main: ITextEditorModel;
    readonly snippets: ITextEditorModel[];
    dispose(): void;
}
export declare class DynamicContentInput extends EditorInput {
    private name;
    private description;
    private resource;
    private staticContent;
    private telemetryFrom;
    readonly onReady: (container: HTMLElement) => void;
    private telemetryService;
    private textModelResolverService;
    static ID: string;
    private disposables;
    private promise;
    private resolveTime;
    private maxTopScroll;
    private maxBottomScroll;
    constructor(name: string, description: string, resource: URI, staticContent: string, telemetryFrom: string, onReady: (container: HTMLElement) => void, telemetryService: ITelemetryService, lifecycleService: ILifecycleService, textModelResolverService: ITextModelResolverService);
    getResource(): URI;
    getTypeId(): string;
    getName(): string;
    getDescription(): string;
    getTelemetryFrom(): string;
    getTelemetryDescriptor(): {
        [key: string]: any;
    };
    resolve(refresh?: boolean): TPromise<DynamicContentModel>;
    matches(otherInput: any): boolean;
    dispose(): void;
    relativeScrollPosition(topScroll: number, bottomScroll: number): void;
    private resolveTelemetry();
    private disposeTelemetry(reason?);
}
