/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var errors = require("vs/base/common/errors");
var winjs_base_1 = require("vs/base/common/winjs.base");
var async_1 = require("vs/base/common/async");
var lifecycle = require("vs/base/common/lifecycle");
var env = require("vs/base/common/platform");
var json_1 = require("vs/base/common/json");
var actions_1 = require("vs/base/common/actions");
var wordHelper_1 = require("vs/editor/common/model/wordHelper");
var editorBrowserExtensions_1 = require("vs/editor/browser/editorBrowserExtensions");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var codeEditorService_1 = require("vs/editor/common/services/codeEditorService");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var commands_1 = require("vs/platform/commands/common/commands");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var debugHover_1 = require("vs/workbench/parts/debug/electron-browser/debugHover");
var debugActions_1 = require("vs/workbench/parts/debug/browser/debugActions");
var debug_1 = require("vs/workbench/parts/debug/common/debug");
var breakpointWidget_1 = require("vs/workbench/parts/debug/browser/breakpointWidget");
var exceptionWidget_1 = require("vs/workbench/parts/debug/browser/exceptionWidget");
var preferencesWidgets_1 = require("vs/workbench/parts/preferences/browser/preferencesWidgets");
var listService_1 = require("vs/platform/list/browser/listService");
var HOVER_DELAY = 300;
var LAUNCH_JSON_REGEX = /launch\.json$/;
var REMOVE_INLINE_VALUES_DELAY = 100;
var INLINE_VALUE_DECORATION_KEY = 'inlinevaluedecoration';
var MAX_NUM_INLINE_VALUES = 100; // JS Global scope can have 700+ entries. We want to limit ourselves for perf reasons
var MAX_INLINE_DECORATOR_LENGTH = 150; // Max string length of each inline decorator when debugging. If exceeded ... is added
var MAX_TOKENIZATION_LINE_LEN = 500; // If line is too long, then inline values for the line are skipped
var DebugEditorContribution = DebugEditorContribution_1 = (function () {
    function DebugEditorContribution(editor, debugService, contextMenuService, instantiationService, contextKeyService, commandService, codeEditorService, telemetryService, listService, configurationService) {
        var _this = this;
        this.editor = editor;
        this.debugService = debugService;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
        this.commandService = commandService;
        this.codeEditorService = codeEditorService;
        this.telemetryService = telemetryService;
        this.configurationService = configurationService;
        this.breakpointHintDecoration = [];
        this.hoverWidget = new debugHover_1.DebugHoverWidget(this.editor, this.debugService, listService, this.instantiationService);
        this.toDispose = [];
        this.showHoverScheduler = new async_1.RunOnceScheduler(function () { return _this.showHover(_this.hoverRange, false); }, HOVER_DELAY);
        this.hideHoverScheduler = new async_1.RunOnceScheduler(function () { return _this.hoverWidget.hide(); }, HOVER_DELAY);
        this.removeInlineValuesScheduler = new async_1.RunOnceScheduler(function () { return _this.editor.removeDecorations(INLINE_VALUE_DECORATION_KEY); }, REMOVE_INLINE_VALUES_DELAY);
        this.registerListeners();
        this.breakpointWidgetVisible = debug_1.CONTEXT_BREAKPOINT_WIDGET_VISIBLE.bindTo(contextKeyService);
        this.updateConfigurationWidgetVisibility();
        this.codeEditorService.registerDecorationType(INLINE_VALUE_DECORATION_KEY, {});
        this.toggleExceptionWidget();
    }
    DebugEditorContribution.prototype.getContextMenuActions = function (breakpoint, uri, lineNumber) {
        var _this = this;
        var actions = [];
        if (breakpoint) {
            actions.push(this.instantiationService.createInstance(debugActions_1.RemoveBreakpointAction, debugActions_1.RemoveBreakpointAction.ID, debugActions_1.RemoveBreakpointAction.LABEL));
            actions.push(this.instantiationService.createInstance(debugActions_1.EditConditionalBreakpointAction, debugActions_1.EditConditionalBreakpointAction.ID, debugActions_1.EditConditionalBreakpointAction.LABEL, this.editor, lineNumber));
            if (breakpoint.enabled) {
                actions.push(this.instantiationService.createInstance(debugActions_1.DisableBreakpointAction, debugActions_1.DisableBreakpointAction.ID, debugActions_1.DisableBreakpointAction.LABEL));
            }
            else {
                actions.push(this.instantiationService.createInstance(debugActions_1.EnableBreakpointAction, debugActions_1.EnableBreakpointAction.ID, debugActions_1.EnableBreakpointAction.LABEL));
            }
        }
        else {
            actions.push(new actions_1.Action('addBreakpoint', nls.localize('addBreakpoint', "Add Breakpoint"), null, true, function () { return _this.debugService.addBreakpoints(uri, [{ lineNumber: lineNumber }]); }));
            actions.push(this.instantiationService.createInstance(debugActions_1.AddConditionalBreakpointAction, debugActions_1.AddConditionalBreakpointAction.ID, debugActions_1.AddConditionalBreakpointAction.LABEL, this.editor, lineNumber));
        }
        return winjs_base_1.TPromise.as(actions);
    };
    DebugEditorContribution.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.editor.onMouseDown(function (e) {
            if (e.target.type !== editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN || e.target.detail) {
                return;
            }
            var canSetBreakpoints = _this.debugService.getConfigurationManager().canSetBreakpointsIn(_this.editor.getModel());
            var lineNumber = e.target.position.lineNumber;
            var uri = _this.editor.getModel().uri;
            if (e.event.rightButton || (env.isMacintosh && e.event.leftButton && e.event.ctrlKey)) {
                if (!canSetBreakpoints) {
                    return;
                }
                var anchor_1 = { x: e.event.posx + 1, y: e.event.posy };
                var breakpoint_1 = _this.debugService.getModel().getBreakpoints().filter(function (bp) { return bp.lineNumber === lineNumber && bp.uri.toString() === uri.toString(); }).pop();
                _this.contextMenuService.showContextMenu({
                    getAnchor: function () { return anchor_1; },
                    getActions: function () { return _this.getContextMenuActions(breakpoint_1, uri, lineNumber); },
                    getActionsContext: function () { return breakpoint_1; }
                });
            }
            else {
                var breakpoints = _this.debugService.getModel().getBreakpoints()
                    .filter(function (bp) { return bp.uri.toString() === uri.toString() && bp.lineNumber === lineNumber; });
                if (breakpoints.length) {
                    breakpoints.forEach(function (bp) { return _this.debugService.removeBreakpoints(bp.getId()); });
                }
                else if (canSetBreakpoints) {
                    _this.debugService.addBreakpoints(uri, [{ lineNumber: lineNumber }]);
                }
            }
        }));
        this.toDispose.push(this.editor.onMouseMove(function (e) {
            var showBreakpointHintAtLineNumber = -1;
            if (e.target.type === editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN && _this.debugService.getConfigurationManager().canSetBreakpointsIn(_this.editor.getModel())) {
                if (!e.target.detail) {
                    // is not after last line
                    showBreakpointHintAtLineNumber = e.target.position.lineNumber;
                }
            }
            _this.ensureBreakpointHintDecoration(showBreakpointHintAtLineNumber);
        }));
        this.toDispose.push(this.editor.onMouseLeave(function (e) {
            _this.ensureBreakpointHintDecoration(-1);
        }));
        this.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame(function (sf) { return _this.onFocusStackFrame(sf); }));
        // hover listeners & hover widget
        this.toDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
        this.toDispose.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
        this.toDispose.push(this.editor.onMouseLeave(function (e) {
            var rect = _this.hoverWidget.getDomNode().getBoundingClientRect();
            // Only hide the hover widget if the editor mouse leave event is outside the hover widget #3528
            if (e.event.posx < rect.left || e.event.posx > rect.right || e.event.posy < rect.top || e.event.posy > rect.bottom) {
                _this.hideHoverWidget();
            }
        }));
        this.toDispose.push(this.editor.onKeyDown(function (e) { return _this.onKeyDown(e); }));
        this.toDispose.push(this.editor.onDidChangeModelContent(function () {
            _this.wordToLineNumbersMap = null;
        }));
        this.toDispose.push(this.editor.onDidChangeModel(function () {
            var sf = _this.debugService.getViewModel().focusedStackFrame;
            var model = _this.editor.getModel();
            _this.editor.updateOptions({ hover: !sf || !model || model.uri.toString() !== sf.source.uri.toString() });
            _this.closeBreakpointWidget();
            _this.toggleExceptionWidget();
            _this.hideHoverWidget();
            _this.updateConfigurationWidgetVisibility();
            _this.wordToLineNumbersMap = null;
            _this.updateInlineDecorations(sf);
        }));
        this.toDispose.push(this.editor.onDidScrollChange(function () { return _this.hideHoverWidget; }));
    };
    DebugEditorContribution.prototype.getId = function () {
        return debug_1.EDITOR_CONTRIBUTION_ID;
    };
    DebugEditorContribution.prototype.showHover = function (range, focus) {
        var sf = this.debugService.getViewModel().focusedStackFrame;
        var model = this.editor.getModel();
        if (sf && model && sf.source.uri.toString() === model.uri.toString()) {
            return this.hoverWidget.showAt(range, focus);
        }
        return undefined;
    };
    DebugEditorContribution.prototype.ensureBreakpointHintDecoration = function (showBreakpointHintAtLineNumber) {
        var newDecoration = [];
        if (showBreakpointHintAtLineNumber !== -1) {
            newDecoration.push({
                options: DebugEditorContribution_1.BREAKPOINT_HELPER_DECORATION,
                range: {
                    startLineNumber: showBreakpointHintAtLineNumber,
                    startColumn: 1,
                    endLineNumber: showBreakpointHintAtLineNumber,
                    endColumn: 1
                }
            });
        }
        this.breakpointHintDecoration = this.editor.deltaDecorations(this.breakpointHintDecoration, newDecoration);
    };
    DebugEditorContribution.prototype.onFocusStackFrame = function (sf) {
        var model = this.editor.getModel();
        if (model && sf && sf.source.uri.toString() === model.uri.toString()) {
            this.editor.updateOptions({ hover: false });
        }
        else {
            this.editor.updateOptions({ hover: true });
            this.hideHoverWidget();
        }
        // Handling exception
        this.toggleExceptionWidget();
        this.updateInlineDecorations(sf);
    };
    DebugEditorContribution.prototype.hideHoverWidget = function () {
        if (!this.hideHoverScheduler.isScheduled() && this.hoverWidget.isVisible()) {
            this.hideHoverScheduler.schedule();
        }
        this.showHoverScheduler.cancel();
    };
    // hover business
    DebugEditorContribution.prototype.onEditorMouseDown = function (mouseEvent) {
        if (mouseEvent.target.type === editorCommon_1.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === debugHover_1.DebugHoverWidget.ID) {
            return;
        }
        this.hideHoverWidget();
    };
    DebugEditorContribution.prototype.onEditorMouseMove = function (mouseEvent) {
        if (this.debugService.state !== debug_1.State.Stopped) {
            return;
        }
        var targetType = mouseEvent.target.type;
        var stopKey = env.isMacintosh ? 'metaKey' : 'ctrlKey';
        if (targetType === editorCommon_1.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === debugHover_1.DebugHoverWidget.ID && !mouseEvent.event[stopKey]) {
            // mouse moved on top of debug hover widget
            return;
        }
        if (targetType === editorCommon_1.MouseTargetType.CONTENT_TEXT) {
            if (!mouseEvent.target.range.equalsRange(this.hoverRange)) {
                this.hoverRange = mouseEvent.target.range;
                this.showHoverScheduler.schedule();
            }
        }
        else {
            this.hideHoverWidget();
        }
    };
    DebugEditorContribution.prototype.onKeyDown = function (e) {
        var stopKey = env.isMacintosh ? 57 /* Meta */ : 5 /* Ctrl */;
        if (e.keyCode !== stopKey) {
            // do not hide hover when Ctrl/Meta is pressed
            this.hideHoverWidget();
        }
    };
    // end hover business
    // breakpoint widget
    DebugEditorContribution.prototype.showBreakpointWidget = function (lineNumber) {
        if (this.breakpointWidget) {
            this.breakpointWidget.dispose();
        }
        this.breakpointWidget = this.instantiationService.createInstance(breakpointWidget_1.BreakpointWidget, this.editor, lineNumber);
        this.breakpointWidget.show({ lineNumber: lineNumber, column: 1 }, 2);
        this.breakpointWidgetVisible.set(true);
    };
    DebugEditorContribution.prototype.closeBreakpointWidget = function () {
        if (this.breakpointWidget) {
            this.breakpointWidget.dispose();
            this.breakpointWidget = null;
            this.breakpointWidgetVisible.reset();
            this.editor.focus();
        }
    };
    // exception widget
    DebugEditorContribution.prototype.toggleExceptionWidget = function () {
        // Toggles exception widget based on the state of the current editor model and debug stack frame
        var model = this.editor.getModel();
        var focusedSf = this.debugService.getViewModel().focusedStackFrame;
        var callStack = focusedSf ? focusedSf.thread.getCallStack() : null;
        if (!model || !focusedSf || !callStack || callStack.length === 0) {
            this.closeExceptionWidget();
            return;
        }
        // First call stack frame is the frame where exception has been thrown
        var exceptionSf = callStack[0];
        var sameUri = exceptionSf.source.uri.toString() === model.uri.toString();
        if (this.exceptionWidget && !sameUri) {
            this.closeExceptionWidget();
        }
        else if (focusedSf.thread.stoppedDetails.reason === 'exception' && sameUri) {
            this.showExceptionWidget(exceptionSf.lineNumber, exceptionSf.column);
        }
    };
    DebugEditorContribution.prototype.showExceptionWidget = function (lineNumber, column) {
        if (this.exceptionWidget) {
            this.exceptionWidget.dispose();
        }
        this.exceptionWidget = this.instantiationService.createInstance(exceptionWidget_1.ExceptionWidget, this.editor, lineNumber);
        this.exceptionWidget.show({ lineNumber: lineNumber, column: column }, 0);
    };
    DebugEditorContribution.prototype.closeExceptionWidget = function () {
        if (this.exceptionWidget) {
            this.exceptionWidget.dispose();
            this.exceptionWidget = null;
        }
    };
    // configuration widget
    DebugEditorContribution.prototype.updateConfigurationWidgetVisibility = function () {
        var _this = this;
        var model = this.editor.getModel();
        if (model && LAUNCH_JSON_REGEX.test(model.uri.toString())) {
            this.configurationWidget = this.instantiationService.createInstance(preferencesWidgets_1.FloatingClickWidget, this.editor, nls.localize('addConfiguration', "Add Configuration..."), null);
            this.configurationWidget.render();
            this.toDispose.push(this.configurationWidget.onClick(function () { return _this.addLaunchConfiguration().done(undefined, errors.onUnexpectedError); }));
        }
        else if (this.configurationWidget) {
            this.configurationWidget.dispose();
        }
    };
    DebugEditorContribution.prototype.addLaunchConfiguration = function () {
        var _this = this;
        this.telemetryService.publicLog('debug/addLaunchConfiguration');
        var configurationsPosition;
        var model = this.editor.getModel();
        var depthInArray = 0;
        var lastProperty;
        json_1.visit(model.getValue(), {
            onObjectProperty: function (property, offset, length) {
                lastProperty = property;
            },
            onArrayBegin: function (offset, length) {
                if (lastProperty === 'configurations' && depthInArray === 0) {
                    configurationsPosition = model.getPositionAt(offset);
                }
                depthInArray++;
            },
            onArrayEnd: function () {
                depthInArray--;
            }
        });
        this.editor.focus();
        if (!configurationsPosition) {
            return this.commandService.executeCommand('editor.action.triggerSuggest');
        }
        var insertLineAfter = function (lineNumber) {
            if (_this.editor.getModel().getLineLastNonWhitespaceColumn(lineNumber + 1) === 0) {
                _this.editor.setSelection(new selection_1.Selection(lineNumber + 1, Number.MAX_VALUE, lineNumber + 1, Number.MAX_VALUE));
                return winjs_base_1.TPromise.as(null);
            }
            _this.editor.setSelection(new selection_1.Selection(lineNumber, Number.MAX_VALUE, lineNumber, Number.MAX_VALUE));
            return _this.commandService.executeCommand('editor.action.insertLineAfter');
        };
        return insertLineAfter(configurationsPosition.lineNumber).then(function () { return _this.commandService.executeCommand('editor.action.triggerSuggest'); });
    };
    // Inline Decorations
    DebugEditorContribution.prototype.updateInlineDecorations = function (stackFrame) {
        var _this = this;
        var model = this.editor.getModel();
        if (!this.configurationService.getConfiguration('debug').inlineValues ||
            !model || !stackFrame || model.uri.toString() !== stackFrame.source.uri.toString()) {
            if (!this.removeInlineValuesScheduler.isScheduled()) {
                this.removeInlineValuesScheduler.schedule();
            }
            return;
        }
        this.removeInlineValuesScheduler.cancel();
        stackFrame.getMostSpecificScopes(new range_1.Range(stackFrame.lineNumber, stackFrame.column, stackFrame.lineNumber, stackFrame.column))
            .then(function (scopes) { return winjs_base_1.TPromise.join(scopes.map(function (scope) { return scope.getChildren()
            .then(function (children) {
            var range = new range_1.Range(0, 0, stackFrame.lineNumber, stackFrame.column);
            if (scope.range) {
                range = range.setStartPosition(scope.range.startLineNumber, scope.range.startColumn);
            }
            return _this.createInlineValueDecorationsInsideRange(children, range);
        }); })).then(function (decorationsPerScope) {
            var allDecorations = decorationsPerScope.reduce(function (previous, current) { return previous.concat(current); }, []);
            _this.editor.setDecorations(INLINE_VALUE_DECORATION_KEY, allDecorations);
        }); });
    };
    DebugEditorContribution.prototype.createInlineValueDecorationsInsideRange = function (expressions, range) {
        var _this = this;
        var nameValueMap = new Map();
        for (var _i = 0, expressions_1 = expressions; _i < expressions_1.length; _i++) {
            var expr = expressions_1[_i];
            nameValueMap.set(expr.name, expr.value);
            // Limit the size of map. Too large can have a perf impact
            if (nameValueMap.size >= MAX_NUM_INLINE_VALUES) {
                break;
            }
        }
        var lineToNamesMap = new Map();
        var wordToPositionsMap = this.getWordToPositionsMap();
        // Compute unique set of names on each line
        nameValueMap.forEach(function (value, name) {
            if (wordToPositionsMap.has(name)) {
                for (var _i = 0, _a = wordToPositionsMap.get(name); _i < _a.length; _i++) {
                    var position = _a[_i];
                    if (range.containsPosition(position)) {
                        if (!lineToNamesMap.has(position.lineNumber)) {
                            lineToNamesMap.set(position.lineNumber, []);
                        }
                        if (lineToNamesMap.get(position.lineNumber).indexOf(name) === -1) {
                            lineToNamesMap.get(position.lineNumber).push(name);
                        }
                    }
                }
            }
        });
        var decorations = [];
        // Compute decorators for each line
        lineToNamesMap.forEach(function (names, line) {
            var contentText = names.map(function (name) { return name + " = " + nameValueMap.get(name); }).join(', ');
            decorations.push(_this.createInlineValueDecoration(line, contentText));
        });
        return decorations;
    };
    DebugEditorContribution.prototype.createInlineValueDecoration = function (lineNumber, contentText) {
        // If decoratorText is too long, trim and add ellipses. This could happen for minified files with everything on a single line
        if (contentText.length > MAX_INLINE_DECORATOR_LENGTH) {
            contentText = contentText.substr(0, MAX_INLINE_DECORATOR_LENGTH) + '...';
        }
        return {
            range: {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: 1073741824 /* MAX_SAFE_SMALL_INTEGER */,
                endColumn: 1073741824 /* MAX_SAFE_SMALL_INTEGER */
            },
            renderOptions: {
                after: {
                    contentText: contentText,
                    backgroundColor: 'rgba(255, 200, 0, 0.2)',
                    margin: '10px'
                },
                dark: {
                    after: {
                        color: 'rgba(255, 255, 255, 0.5)',
                    }
                },
                light: {
                    after: {
                        color: 'rgba(0, 0, 0, 0.5)',
                    }
                }
            }
        };
    };
    DebugEditorContribution.prototype.getWordToPositionsMap = function () {
        if (!this.wordToLineNumbersMap) {
            this.wordToLineNumbersMap = new Map();
            var model = this.editor.getModel();
            // For every word in every line, map its ranges for fast lookup
            for (var lineNumber = 1, len = model.getLineCount(); lineNumber <= len; ++lineNumber) {
                var lineContent = model.getLineContent(lineNumber);
                // If line is too long then skip the line
                if (lineContent.length > MAX_TOKENIZATION_LINE_LEN) {
                    continue;
                }
                model.forceTokenization(lineNumber);
                var lineTokens = model.getLineTokens(lineNumber);
                for (var token = lineTokens.firstToken(); !!token; token = token.next()) {
                    var tokenStr = lineContent.substring(token.startOffset, token.endOffset);
                    // Token is a word and not a comment
                    if (token.tokenType === 0 /* Other */) {
                        wordHelper_1.DEFAULT_WORD_REGEXP.lastIndex = 0; // We assume tokens will usually map 1:1 to words if they match
                        var wordMatch = wordHelper_1.DEFAULT_WORD_REGEXP.exec(tokenStr);
                        if (wordMatch) {
                            var word = wordMatch[0];
                            if (!this.wordToLineNumbersMap.has(word)) {
                                this.wordToLineNumbersMap.set(word, []);
                            }
                            this.wordToLineNumbersMap.get(word).push({ lineNumber: lineNumber, column: token.startOffset });
                        }
                    }
                }
            }
        }
        return this.wordToLineNumbersMap;
    };
    DebugEditorContribution.prototype.dispose = function () {
        if (this.breakpointWidget) {
            this.breakpointWidget.dispose();
        }
        if (this.hoverWidget) {
            this.hoverWidget.dispose();
        }
        if (this.configurationWidget) {
            this.configurationWidget.dispose();
        }
        this.toDispose = lifecycle.dispose(this.toDispose);
    };
    return DebugEditorContribution;
}());
DebugEditorContribution.BREAKPOINT_HELPER_DECORATION = {
    glyphMarginClassName: 'debug-breakpoint-hint-glyph',
    stickiness: editorCommon_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
};
DebugEditorContribution = DebugEditorContribution_1 = __decorate([
    editorBrowserExtensions_1.editorContribution,
    __param(1, debug_1.IDebugService),
    __param(2, contextView_1.IContextMenuService),
    __param(3, instantiation_1.IInstantiationService),
    __param(4, contextkey_1.IContextKeyService),
    __param(5, commands_1.ICommandService),
    __param(6, codeEditorService_1.ICodeEditorService),
    __param(7, telemetry_1.ITelemetryService),
    __param(8, listService_1.IListService),
    __param(9, configuration_1.IConfigurationService)
], DebugEditorContribution);
exports.DebugEditorContribution = DebugEditorContribution;
var DebugEditorContribution_1;
