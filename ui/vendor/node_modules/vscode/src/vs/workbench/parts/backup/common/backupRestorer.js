/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var uri_1 = require("vs/base/common/uri");
var winjs_base_1 = require("vs/base/common/winjs.base");
var untitledEditorService_1 = require("vs/workbench/services/untitled/common/untitledEditorService");
var environment_1 = require("vs/platform/environment/common/environment");
var partService_1 = require("vs/workbench/services/part/common/partService");
var errors = require("vs/base/common/errors");
var backup_1 = require("vs/workbench/services/backup/common/backup");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var resolverService_1 = require("vs/editor/common/services/resolverService");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var editor_1 = require("vs/platform/editor/common/editor");
var BackupRestorer = (function () {
    function BackupRestorer(untitledEditorService, environmentService, partService, editorService, backupFileService, textModelResolverService, groupService) {
        this.untitledEditorService = untitledEditorService;
        this.environmentService = environmentService;
        this.partService = partService;
        this.editorService = editorService;
        this.backupFileService = backupFileService;
        this.textModelResolverService = textModelResolverService;
        this.groupService = groupService;
        this.restoreBackups();
    }
    BackupRestorer.prototype.restoreBackups = function () {
        var _this = this;
        if (!this.environmentService.isExtensionDevelopment) {
            this.partService.joinCreation().then(function () {
                _this.doRestoreBackups().done(null, errors.onUnexpectedError);
            });
        }
    };
    BackupRestorer.prototype.doRestoreBackups = function () {
        var _this = this;
        // Find all files and untitled with backups
        return this.backupFileService.getWorkspaceFileBackups().then(function (backups) {
            // Resolve backups that are opened in stacks model
            return _this.doResolveOpenedBackups(backups).then(function (unresolved) {
                // Some failed to restore or were not opened at all so we open and resolve them manually
                if (unresolved.length > 0) {
                    return _this.doOpenEditors(unresolved).then(function () { return _this.doResolveOpenedBackups(unresolved); });
                }
                return undefined;
            });
        });
    };
    BackupRestorer.prototype.doResolveOpenedBackups = function (backups) {
        var _this = this;
        var stacks = this.groupService.getStacksModel();
        var restorePromises = [];
        var unresolved = [];
        backups.forEach(function (backup) {
            if (stacks.isOpen(backup)) {
                if (backup.scheme === 'file') {
                    restorePromises.push(_this.textModelResolverService.createModelReference(backup).then(null, function () { return unresolved.push(backup); }));
                }
                else if (backup.scheme === 'untitled') {
                    restorePromises.push(_this.untitledEditorService.get(backup).resolve().then(null, function () { return unresolved.push(backup); }));
                }
            }
            else {
                unresolved.push(backup);
            }
        });
        return winjs_base_1.TPromise.join(restorePromises).then(function () { return unresolved; }, function () { return unresolved; });
    };
    BackupRestorer.prototype.doOpenEditors = function (inputs) {
        var _this = this;
        var stacks = this.groupService.getStacksModel();
        var hasOpenedEditors = stacks.groups.length > 0;
        return winjs_base_1.TPromise.join(inputs.map(function (resource) { return _this.createInput(resource); })).then(function (inputs) {
            var openEditorsArgs = inputs.map(function (input, index) {
                return { input: input, options: { pinned: true, preserveFocus: true, inactive: index > 0 || hasOpenedEditors }, position: editor_1.Position.ONE };
            });
            // Open all remaining backups as editors and resolve them to load their backups
            return _this.editorService.openEditors(openEditorsArgs).then(function () { return void 0; });
        });
    };
    BackupRestorer.prototype.createInput = function (resource) {
        if (resource.scheme === 'untitled' && !BackupRestorer.UNTITLED_REGEX.test(resource.fsPath)) {
            // TODO@Ben debt: instead of guessing if an untitled file has an associated file path or not
            // this information should be provided by the backup service and stored as meta data within
            return winjs_base_1.TPromise.as(this.untitledEditorService.createOrGet(uri_1.default.file(resource.fsPath)));
        }
        return this.editorService.createInput({ resource: resource });
    };
    BackupRestorer.prototype.getId = function () {
        return 'vs.backup.backupRestorer';
    };
    return BackupRestorer;
}());
BackupRestorer.UNTITLED_REGEX = /Untitled-\d+/;
BackupRestorer = __decorate([
    __param(0, untitledEditorService_1.IUntitledEditorService),
    __param(1, environment_1.IEnvironmentService),
    __param(2, partService_1.IPartService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, backup_1.IBackupFileService),
    __param(5, resolverService_1.ITextModelResolverService),
    __param(6, groupService_1.IEditorGroupService)
], BackupRestorer);
exports.BackupRestorer = BackupRestorer;
