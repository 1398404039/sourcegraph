/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls_1 = require("vs/nls");
var platform = require("vs/base/common/platform");
var winjs_base_1 = require("vs/base/common/winjs.base");
var lifecycle_1 = require("vs/base/common/lifecycle");
var actions_1 = require("vs/base/common/actions");
var errors_1 = require("vs/base/common/errors");
var mime = require("vs/base/common/mime");
var paths = require("vs/base/common/paths");
var event_1 = require("vs/base/common/event");
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var git_1 = require("vs/workbench/parts/git/common/git");
var gitModel_1 = require("vs/workbench/parts/git/common/gitModel");
var gitEditorInputs_1 = require("vs/workbench/parts/git/browser/gitEditorInputs");
var gitOperations_1 = require("vs/workbench/parts/git/browser/gitOperations");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var files_1 = require("vs/platform/files/common/files");
var async_1 = require("vs/base/common/async");
var severity_1 = require("vs/base/common/severity");
var output_1 = require("vs/workbench/parts/output/common/output");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var lifecycle_2 = require("vs/platform/lifecycle/common/lifecycle");
var uri_1 = require("vs/base/common/uri");
var storage_1 = require("vs/platform/storage/common/storage");
var event_2 = require("vs/base/browser/event");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
function toReadablePath(path) {
    if (!platform.isWindows) {
        return path;
    }
    return path.replace(/\//g, '\\');
}
var EditorInputCache = (function () {
    function EditorInputCache(gitService, instantiationService, fileService, editorService, editorGroupService, contextService) {
        var _this = this;
        this.instantiationService = instantiationService;
        this.fileService = fileService;
        this.editorService = editorService;
        this.editorGroupService = editorGroupService;
        this.contextService = contextService;
        this.gitService = gitService;
        this.cache = {};
        this.toDispose = [];
        this.toDispose.push(this.gitService.getModel().addListener2('fileStatus:dispose', function (fileStatus) { return _this.onFileStatusDispose(fileStatus); }));
    }
    EditorInputCache.prototype.getInput = function (status) {
        var result = this.cache[status.getId()];
        if (result) {
            return result;
        }
        result = this.createInput(status);
        this.cache[status.getId()] = result;
        return result;
    };
    EditorInputCache.prototype.createInput = function (status) {
        var _this = this;
        return winjs_base_1.TPromise.join([this.createLeftInput(status), this.createRightInput(status)]).then(function (result) {
            var leftInput = result[0];
            var rightInput = result[1];
            var fileSegment;
            var folderSegment;
            if (status.getStatus() === git_1.Status.INDEX_RENAMED) {
                var pathComponents = status.getRename().split('/');
                fileSegment = pathComponents[pathComponents.length - 1];
                folderSegment = toReadablePath(pathComponents.slice(0, pathComponents.length - 1).join('/'));
            }
            else {
                var pathComponents = status.getPathComponents();
                fileSegment = pathComponents[pathComponents.length - 1];
                folderSegment = toReadablePath(pathComponents.slice(0, pathComponents.length - 1).join('/'));
            }
            if (!leftInput) {
                if (!rightInput) {
                    var error = new Error(nls_1.localize('cantOpen', "Can't open this git resource."));
                    error.gitErrorCode = git_1.GitErrorCodes.CantOpenResource;
                    return winjs_base_1.TPromise.wrapError(error);
                }
                return winjs_base_1.TPromise.as(rightInput);
            }
            switch (status.getStatus()) {
                case git_1.Status.INDEX_MODIFIED:
                    return winjs_base_1.TPromise.as(new gitEditorInputs_1.GitIndexDiffEditorInput(nls_1.localize('gitIndexChanges', "{0} (index) ↔ {1}", fileSegment, fileSegment), nls_1.localize('gitIndexChangesDesc', "{0} - Changes on index", folderSegment), leftInput, rightInput, status));
                case git_1.Status.INDEX_RENAMED:
                    return winjs_base_1.TPromise.as(new gitEditorInputs_1.GitIndexDiffEditorInput(nls_1.localize('gitIndexChangesRenamed', "{0} ← {1}", status.getRename(), status.getPath()), nls_1.localize('gitIndexChangesRenamedDesc', "{0} - Renamed - Changes on index", folderSegment), leftInput, rightInput, status));
                case git_1.Status.MODIFIED:
                    return winjs_base_1.TPromise.as(new gitEditorInputs_1.GitWorkingTreeDiffEditorInput(nls_1.localize('workingTreeChanges', "{0} (HEAD) ↔ {1}", fileSegment, fileSegment), nls_1.localize('workingTreeChangesDesc', "{0} - Changes on working tree", folderSegment), leftInput, rightInput, status));
                default:
                    return winjs_base_1.TPromise.as(new gitEditorInputs_1.GitDiffEditorInput(nls_1.localize('gitMergeChanges', "{0} (merge) ↔ {1}", fileSegment, fileSegment), nls_1.localize('gitMergeChangesDesc', "{0} - Merge changes", folderSegment), leftInput, rightInput, status));
            }
        }).then(function (editorInput) {
            var onceDispose = event_1.once(editorInput.onDispose);
            onceDispose(function () {
                delete _this.cache[status.getId()];
            });
            return editorInput;
        }, function (errs) {
            return winjs_base_1.TPromise.wrapError(Array.isArray(errs) ? errs[0] || errs[1] : errs);
        });
    };
    EditorInputCache.prototype.createLeftInput = function (status) {
        var path = status.getPath();
        var model = this.gitService.getModel();
        switch (status.getStatus()) {
            case git_1.Status.INDEX_MODIFIED:
            case git_1.Status.INDEX_RENAMED:
                return this.gitService.show(path, status, 'HEAD', status.getMimetype());
            case git_1.Status.MODIFIED:
                var indexStatus = model.getStatus().find(path, git_1.StatusType.INDEX);
                if (indexStatus && indexStatus.getStatus() === git_1.Status.INDEX_RENAMED) {
                    return this.gitService.show(indexStatus.getRename(), status, '~', status.getMimetype());
                }
                if (indexStatus) {
                    return this.gitService.show(path, status, '~', status.getMimetype());
                }
                return this.gitService.show(path, status, 'HEAD', status.getMimetype());
            default:
                return winjs_base_1.TPromise.as(null);
        }
    };
    EditorInputCache.prototype.createRightInput = function (status) {
        var model = this.gitService.getModel();
        var path = status.getPath();
        var resource = uri_1.default.file(paths.join(model.getRepositoryRoot(), path));
        switch (status.getStatus()) {
            case git_1.Status.INDEX_MODIFIED:
            case git_1.Status.INDEX_ADDED:
            case git_1.Status.INDEX_COPIED:
                return this.gitService.show(path, status, '~', status.getMimetype());
            case git_1.Status.INDEX_RENAMED:
                return this.gitService.show(status.getRename(), status, '~', status.getMimetype());
            case git_1.Status.INDEX_DELETED:
            case git_1.Status.DELETED:
                return this.gitService.show(path, status, 'HEAD', status.getMimetype());
            case git_1.Status.MODIFIED:
            case git_1.Status.UNTRACKED:
            case git_1.Status.IGNORED:
                var indexStatus = model.getStatus().find(path, git_1.StatusType.INDEX);
                if (indexStatus && indexStatus.getStatus() === git_1.Status.INDEX_RENAMED) {
                    resource = uri_1.default.file(paths.join(model.getRepositoryRoot(), indexStatus.getRename()));
                }
                return this.editorService.createInput({ resource: resource });
            case git_1.Status.BOTH_MODIFIED:
                return this.editorService.createInput({ resource: resource });
            default:
                return winjs_base_1.TPromise.as(null);
        }
    };
    EditorInputCache.prototype.onFileStatusDispose = function (fileStatus) {
        var _this = this;
        var id = fileStatus.getId();
        var editorInputPromise = this.cache[id];
        if (editorInputPromise) {
            editorInputPromise.done(function (editorInput) { _this.eventuallyDispose(editorInput); });
        }
    };
    /**
     * If the disposed status is the same as this input's status, we must try to dispose the input.
     * But we should not do it while the input is still open. This method will eventually call dispose
     * when the editor input goes out of the visible editors.
     */
    EditorInputCache.prototype.eventuallyDispose = function (editorInput) {
        var _this = this;
        if (!this.maybeDispose(editorInput)) {
            var listener = this.editorGroupService.onEditorsChanged(function () {
                if (_this.maybeDispose(editorInput)) {
                    listener.dispose();
                }
            });
        }
    };
    EditorInputCache.prototype.maybeDispose = function (editorInput) {
        if (!editorInput.isDirty() && !this.editorService.getVisibleEditors().some(function (editor) { return editor.input && editor.input.matches(editorInput); })) {
            editorInput.dispose();
            return true;
        }
        return false;
    };
    EditorInputCache.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.cache).forEach(function (key) {
            _this.cache[key].done(function (editorInput) { editorInput.dispose(); });
            delete _this.cache[key];
        });
        this.toDispose = lifecycle_1.dispose(this.toDispose);
    };
    return EditorInputCache;
}());
EditorInputCache = __decorate([
    __param(1, instantiation_1.IInstantiationService),
    __param(2, files_1.IFileService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, groupService_1.IEditorGroupService),
    __param(5, workspace_1.IWorkspaceContextService)
], EditorInputCache);
var AutoFetcher = (function () {
    function AutoFetcher(gitService, // gitService passed as argument, not by injection
        messageService, editorService, configurationService, instantiationService) {
        var _this = this;
        this._state = git_1.AutoFetcherState.Disabled;
        this.gitService = gitService;
        this.messageService = messageService;
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.currentRequest = null;
        this.timeout = AutoFetcher.MIN_TIMEOUT;
        this.toDispose = [];
        this.toDispose.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfiguration(e.config.git); }));
        this.onConfiguration(configurationService.getConfiguration('git'));
    }
    Object.defineProperty(AutoFetcher.prototype, "state", {
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    AutoFetcher.prototype.onConfiguration = function (config) {
        if (config.autofetch === false) {
            this.disable();
        }
        else {
            this.enable();
        }
    };
    AutoFetcher.prototype.enable = function () {
        var _this = this;
        if (this._state !== git_1.AutoFetcherState.Disabled) {
            return;
        }
        this.gitServiceStateDisposable = this.gitService.addListener2(git_1.ServiceEvents.STATE_CHANGED, function (e) { return _this.onGitServiceStateChange(e); });
        this._state = git_1.AutoFetcherState.Active;
        this.onGitServiceStateChange(this.gitService.getState());
    };
    AutoFetcher.prototype.disable = function () {
        if (this.gitServiceStateDisposable) {
            this.gitServiceStateDisposable.dispose();
            this.gitServiceStateDisposable = null;
        }
        this.deactivate();
        this._state = git_1.AutoFetcherState.Disabled;
    };
    AutoFetcher.prototype.onGitServiceStateChange = function (state) {
        if (state === git_1.ServiceState.OK) {
            this.activate();
        }
        else {
            this.deactivate();
        }
    };
    AutoFetcher.prototype.activate = function () {
        if (this.currentRequest) {
            this.currentRequest.cancel();
        }
        this._state = git_1.AutoFetcherState.Active;
        this.loop();
    };
    AutoFetcher.prototype.deactivate = function () {
        if (!this.currentRequest) {
            return;
        }
        this._state = git_1.AutoFetcherState.Inactive;
        this.currentRequest.cancel();
        this.currentRequest = null;
    };
    AutoFetcher.prototype.loop = function () {
        var _this = this;
        this._state = git_1.AutoFetcherState.Fetching;
        var model = this.gitService.getModel();
        var remotes = model ? model.getRemotes() : [];
        if (remotes.length === 0) {
            this.timeout = AutoFetcher.MIN_TIMEOUT;
            this.currentRequest = winjs_base_1.TPromise.as(null);
        }
        else {
            this.currentRequest = this.gitService.fetch().then(function () {
                _this.timeout = AutoFetcher.MIN_TIMEOUT;
            }, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                else if (err.gitErrorCode === git_1.GitErrorCodes.AuthenticationFailed) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                else {
                    _this.timeout = Math.min(Math.round(_this.timeout * 1.2), AutoFetcher.MAX_TIMEOUT); // backoff
                }
                return undefined;
            });
        }
        this.currentRequest.then(function () {
            _this._state = git_1.AutoFetcherState.Active;
            _this.currentRequest = winjs_base_1.TPromise.timeout(_this.timeout);
            return _this.currentRequest;
        }).then(function () { return _this.loop(); }, function (err) { return _this.deactivate(); });
    };
    AutoFetcher.prototype.dispose = function () {
        this.disable();
    };
    return AutoFetcher;
}());
AutoFetcher.MIN_TIMEOUT = 2 * 60 * 1000; // every two minutes
AutoFetcher.MAX_TIMEOUT = 5 * 60 * 1000; // every five minutes
AutoFetcher = __decorate([
    __param(1, message_1.IMessageService),
    __param(2, editorService_1.IWorkbenchEditorService),
    __param(3, configuration_1.IConfigurationService),
    __param(4, instantiation_1.IInstantiationService)
], AutoFetcher);
exports.AutoFetcher = AutoFetcher;
var IgnoreOldGitStorageKey = 'settings.workspace.git.ignoreOld';
var GitService = (function (_super) {
    __extends(GitService, _super);
    function GitService(raw, instantiationService, fileService, messageService, editorService, outputService, textFileService, contextService, lifecycleService, storageService, configurationService) {
        var _this = _super.call(this) || this;
        _this.fileService = fileService;
        _this.configurationService = configurationService;
        _this.isStatusPending = false;
        _this.instantiationService = instantiationService;
        _this.messageService = messageService;
        _this.editorService = editorService;
        _this.textFileService = textFileService;
        _this.outputService = outputService;
        _this.contextService = contextService;
        _this.lifecycleService = lifecycleService;
        _this.raw = raw;
        _this.state = git_1.ServiceState.NotInitialized;
        _this.operations = [];
        _this.model = new gitModel_1.Model();
        _this.toDispose = [];
        _this.needsRefresh = false;
        _this.statusDelayer = new async_1.ThrottledDelayer(500);
        _this.reactiveStatusDelayer = new async_1.PeriodThrottledDelayer(500, 10000);
        _this.autoFetcher = _this.instantiationService.createInstance(AutoFetcher, _this);
        _this._allowHugeRepositories = false;
        _this.registerListeners();
        _this.inputCache = _this.instantiationService.createInstance(EditorInputCache, _this);
        _this.triggerAutoStatus(true); // trigger initial status
        if (!storageService.getBoolean(IgnoreOldGitStorageKey, storage_1.StorageScope.GLOBAL, false)) {
            _this.raw.serviceState().done(function (state) {
                if (state !== git_1.RawServiceState.OK) {
                    return undefined;
                }
                return _this.raw.getVersion().then(function (version) {
                    var match = /^(\d+)\.\d+\.\d+/.exec(version || '');
                    var major = match && parseInt(match[1]);
                    if (major && major < 2) {
                        messageService.show(severity_1.default.Warning, {
                            message: nls_1.localize('updateGit', "You seem to have git {0} installed. Code works best with git >=2.0.0.", version),
                            actions: [
                                new actions_1.Action('downloadLatest', nls_1.localize('download', "Download"), '', true, function () {
                                    window.open('https://git-scm.com/');
                                    return null;
                                }),
                                new actions_1.Action('neverShowAgain', nls_1.localize('neverShowAgain', "Don't show again"), null, true, function () {
                                    storageService.store(IgnoreOldGitStorageKey, true, storage_1.StorageScope.GLOBAL);
                                    return null;
                                }),
                                message_1.CloseAction
                            ]
                        });
                    }
                });
            });
        }
        return _this;
    }
    Object.defineProperty(GitService.prototype, "allowHugeRepositories", {
        get: function () { return this._allowHugeRepositories; },
        set: function (value) {
            this._allowHugeRepositories = value;
            if (value && this.state === git_1.ServiceState.Huge) {
                this.transition(git_1.ServiceState.OK);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GitService.prototype, "onOutput", {
        get: function () { return this.raw.onOutput; },
        enumerable: true,
        configurable: true
    });
    GitService.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));
        this.toDispose.push(this.textFileService.models.onModelSaved(function (e) { return _this.onTextFileChange(e); }));
        this.toDispose.push(this.textFileService.models.onModelReverted(function (e) { return _this.onTextFileChange(e); }));
        this.toDispose.push(this.configurationService.onDidUpdateConfiguration(function () {
            if (_this._allowHugeRepositories) {
                return;
            }
            var config = _this.configurationService.getConfiguration('git');
            _this._allowHugeRepositories = config.allowLargeRepositories;
            if (_this._allowHugeRepositories) {
                _this.triggerAutoStatus();
            }
        }));
        this.lifecycleService.onShutdown(this.dispose, this);
        var focusEvent = event_2.domEvent(window, 'focus');
        this.toDispose.push(focusEvent(function () {
            if (_this.isStatusPending) {
                _this.triggerAutoStatus();
            }
        }));
    };
    GitService.prototype.onTextFileChange = function (e) {
        var shouldTriggerStatus = paths.basename(e.resource.fsPath) === '.gitignore';
        if (!shouldTriggerStatus) {
            return;
        }
        this.triggerAutoStatus();
    };
    GitService.prototype.onFileChanges = function (e) {
        var _this = this;
        var isIdle = this.isIdle();
        var shouldTriggerStatus = e.changes.some(function (c) {
            var workspacePath = _this.contextService.toWorkspaceRelativePath(c.resource);
            if (!workspacePath) {
                return false; // ignore out of workspace files
            }
            // for .gitindex, the service must be idle
            if ('.git/index' === workspacePath) {
                return isIdle;
            }
            // for anything other that .git*
            if (!/^\.git/.test(workspacePath)) {
                return true;
            }
            // added or deleted .git folder
            if (workspacePath === '.git') {
                return c.type === files_1.FileChangeType.ADDED || c.type === files_1.FileChangeType.DELETED;
            }
            return ['.git/index.lock', '.git/FETCH_HEAD', '.gitignore', '.gitmodules'].indexOf(workspacePath) === -1;
        });
        if (!shouldTriggerStatus) {
            return;
        }
        this.triggerAutoStatus();
    };
    GitService.prototype.onGitServiceOperationEnd = function (e) {
        if (e.operation.id === git_1.ServiceOperations.COMMAND) {
            this.triggerAutoStatus();
        }
    };
    GitService.prototype.getState = function () {
        return this.state;
    };
    GitService.prototype.getModel = function () {
        return this.model;
    };
    GitService.prototype.status = function () {
        var _this = this;
        return this.statusDelayer.trigger(function () { return _this._status(); });
    };
    GitService.prototype._status = function () {
        var _this = this;
        var config = this.configurationService.getConfiguration('git');
        if (this._allowHugeRepositories || config.allowLargeRepositories) {
            return this.run(git_1.ServiceOperations.STATUS, function () { return _this.raw.status(); });
        }
        if (this.state === git_1.ServiceState.Huge) {
            return winjs_base_1.TPromise.as(this.model);
        }
        return this.raw.statusCount().then(function (count) {
            if (count > 5000 && !_this._allowHugeRepositories) {
                _this.transition(git_1.ServiceState.Huge);
                return winjs_base_1.TPromise.as(_this.model);
            }
            return _this.run(git_1.ServiceOperations.STATUS, function () { return _this.raw.status(); });
        });
    };
    GitService.prototype.triggerAutoStatus = function (force) {
        var _this = this;
        if (force === void 0) { force = false; }
        this.isStatusPending = true;
        if (!document.hasFocus() && !force) {
            return;
        }
        this.isStatusPending = false;
        var config = this.configurationService.getConfiguration('git');
        if (!config.autorefresh) {
            return;
        }
        this.reactiveStatusDelayer.trigger(function () { return _this.status(); }).done(null, function (e) {
            if (errors_1.isPromiseCanceledError(e)) {
                return;
            }
            _this.messageService.show(severity_1.default.Error, e);
        });
    };
    GitService.prototype.init = function () {
        var _this = this;
        return this.run(git_1.ServiceOperations.INIT, function () { return _this.raw.init(); });
    };
    GitService.prototype.add = function (files) {
        var _this = this;
        return this.run(git_1.ServiceOperations.ADD, function () { return _this.raw.add(GitService.toPaths(files)); });
    };
    GitService.prototype.stage = function (filePath, content) {
        var _this = this;
        return this.run(git_1.ServiceOperations.STAGE, function () { return _this.raw.stage(filePath, content); });
    };
    GitService.prototype.branch = function (name, checkout) {
        var _this = this;
        if (checkout === void 0) { checkout = false; }
        return this.run(git_1.ServiceOperations.BRANCH, function () { return _this.raw.branch(name, checkout); });
    };
    GitService.prototype.checkout = function (treeish, files) {
        var _this = this;
        if (treeish === void 0) { treeish = ''; }
        if (files === void 0) { files = null; }
        return this.run(git_1.ServiceOperations.CHECKOUT, function () { return _this.raw.checkout(treeish, GitService.toPaths(files)); });
    };
    GitService.prototype.clean = function (files) {
        var _this = this;
        return this.run(git_1.ServiceOperations.CLEAN, function () { return _this.raw.clean(files.map(function (s) { return s.getPath(); })); });
    };
    GitService.prototype.undo = function () {
        var _this = this;
        return this.run(git_1.ServiceOperations.UNDO, function () { return _this.raw.undo(); });
    };
    GitService.prototype.reset = function (treeish, hard) {
        var _this = this;
        return this.run(git_1.ServiceOperations.RESET, function () { return _this.raw.reset(treeish, hard); });
    };
    GitService.prototype.revertFiles = function (treeish, files) {
        var _this = this;
        return this.run(git_1.ServiceOperations.REVERT, function () { return _this.raw.revertFiles(treeish, (files || []).map(function (s) { return s.getPath(); })); });
    };
    GitService.prototype.fetch = function () {
        var _this = this;
        return this.run(git_1.ServiceOperations.BACKGROUND_FETCH, function () { return _this.raw.fetch(); });
    };
    GitService.prototype.pull = function (rebase) {
        var _this = this;
        return this.run(git_1.ServiceOperations.PULL, function () { return _this.raw.pull(rebase); });
    };
    GitService.prototype.push = function (remote, name, options) {
        var _this = this;
        return this.run(git_1.ServiceOperations.PUSH, function () { return _this.raw.push(remote, name, options); });
    };
    GitService.prototype.sync = function (rebase) {
        var _this = this;
        var head = this.model.getHEAD();
        var isAhead = head && head.upstream && !!head.ahead;
        if (!isAhead) {
            return this.run(git_1.ServiceOperations.SYNC, function () { return _this.raw.pull(rebase); });
        }
        else {
            return this.run(git_1.ServiceOperations.SYNC, function () { return _this.raw.sync(); });
        }
    };
    GitService.prototype.commit = function (message, amend, stage, signoff) {
        var _this = this;
        if (amend === void 0) { amend = false; }
        if (stage === void 0) { stage = false; }
        if (signoff === void 0) { signoff = false; }
        return this.run(git_1.ServiceOperations.COMMIT, function () { return _this.raw.commit(message, amend, stage, signoff); });
    };
    GitService.prototype.getCommitTemplate = function () {
        return this.raw.getCommitTemplate();
    };
    GitService.prototype.getCommit = function (ref) {
        return this.raw.getCommit(ref);
    };
    GitService.prototype.detectMimetypes = function (path, treeish) {
        if (treeish === void 0) { treeish = '~'; }
        return this.raw.detectMimetypes(path, treeish);
    };
    GitService.prototype.clone = function (url, parentPath) {
        var _this = this;
        return this.raw.clone(url, parentPath)
            .then(null, function (e) { return _this.wrapGitError(e); });
    };
    GitService.prototype.run = function (operationId, fn) {
        var _this = this;
        return this.raw.serviceState().then(function (state) {
            if (state === git_1.RawServiceState.GitNotFound) {
                _this.transition(git_1.ServiceState.NoGit);
                return winjs_base_1.TPromise.as(null);
            }
            else if (state === git_1.RawServiceState.Disabled) {
                _this.transition(git_1.ServiceState.Disabled);
                return winjs_base_1.TPromise.as(null);
            }
            else {
                return _this._run(operationId, fn);
            }
        });
    };
    GitService.prototype._run = function (operationId, fn) {
        var _this = this;
        var operation = new gitOperations_1.GitOperation(operationId, fn);
        this.operations.push(operation);
        this.emit(git_1.ServiceEvents.OPERATION_START, operation);
        this.emit(git_1.ServiceEvents.OPERATION, operation);
        var onDone = function (error) {
            if (error === void 0) { error = null; }
            var index = _this.operations.indexOf(operation);
            if (index > -1) {
                _this.operations.splice(index, 1);
            }
            var e = { operation: operation, error: error };
            _this.emit(git_1.ServiceEvents.OPERATION_END, e);
            _this.onGitServiceOperationEnd(e);
            _this.emit(git_1.ServiceEvents.OPERATION, operation);
        };
        return operation.run().then(function (status) {
            _this.model.update(status);
            onDone();
            if (status) {
                _this.transition(status.state === null || status.state === undefined ? git_1.ServiceState.OK : status.state);
            }
            else {
                _this.transition(git_1.ServiceState.NotARepo);
            }
            return _this.model;
        }, function (e) {
            onDone(e);
            if (errors_1.isPromiseCanceledError(e)) {
                return winjs_base_1.TPromise.wrapError(e);
            }
            var gitErrorCode = e.gitErrorCode || null;
            if (gitErrorCode === git_1.GitErrorCodes.NotAtRepositoryRoot) {
                _this.transition(git_1.ServiceState.NotAtRepoRoot);
                return winjs_base_1.TPromise.as(_this.model);
            }
            _this.emit(git_1.ServiceEvents.ERROR, e);
            _this.transition(git_1.ServiceState.OK);
            if (gitErrorCode === git_1.GitErrorCodes.NoUserNameConfigured || gitErrorCode === git_1.GitErrorCodes.NoUserEmailConfigured) {
                _this.messageService.show(severity_1.default.Warning, nls_1.localize('configureUsernameEmail', "Please configure your git user name and e-mail."));
                return winjs_base_1.TPromise.as(null);
            }
            else if (gitErrorCode === git_1.GitErrorCodes.BadConfigFile) {
                _this.messageService.show(severity_1.default.Error, nls_1.localize('badConfigFile', "Git {0}", e.message));
                return winjs_base_1.TPromise.as(null);
            }
            else if (gitErrorCode === git_1.GitErrorCodes.UnmergedChanges) {
                _this.messageService.show(severity_1.default.Warning, nls_1.localize('unmergedChanges', "You should first resolve the unmerged changes before committing your changes."));
                return winjs_base_1.TPromise.as(null);
            }
            return _this.wrapGitError(e);
        });
    };
    GitService.prototype.wrapGitError = function (e) {
        var _this = this;
        var gitErrorCode = e.gitErrorCode || null;
        var showOutputAction = new actions_1.Action('show.gitOutput', nls_1.localize('showOutput', "Show Output"), null, true, function () { return _this.outputService.getChannel('Git').show(); });
        var cancelAction = new actions_1.Action('close.message', nls_1.localize('cancel', "Cancel"), null, true, function () { return winjs_base_1.TPromise.as(true); });
        var error = errors_1.create(nls_1.localize('checkNativeConsole', "There was an issue running a git operation. Please review the output or use a console to check the state of your repository."), { actions: [cancelAction, showOutputAction] });
        error.gitErrorCode = gitErrorCode;
        error.stdout = e.stdout;
        error.stderr = e.stderr;
        return winjs_base_1.TPromise.wrapError(error);
    };
    GitService.prototype.transition = function (state) {
        var oldState = this.state;
        this.state = state;
        if (state !== oldState) {
            this.emit(git_1.ServiceEvents.STATE_CHANGED, state);
        }
    };
    GitService.prototype.buffer = function (path, treeish) {
        if (treeish === void 0) { treeish = '~'; }
        return this.raw.show(path, treeish);
    };
    GitService.prototype.show = function (path, status, treeish, mimetype) {
        var _this = this;
        if (treeish === void 0) { treeish = '~'; }
        if (mimetype === void 0) { mimetype = 'text/plain'; }
        return this.detectMimetypes(path, treeish).then(function (mimetypes) {
            var pathComponents = status.getPathComponents();
            var fileSegment = pathComponents[pathComponents.length - 1];
            var folderSegment = toReadablePath(pathComponents.slice(0, pathComponents.length - 1).join('/'));
            var label;
            var description;
            if (treeish === '~') {
                label = nls_1.localize('changesFromIndex', "{0} (index)", fileSegment);
                description = nls_1.localize('changesFromIndexDesc', "{0} - Changes on index", folderSegment);
            }
            else {
                label = nls_1.localize('changesFromTree', "{0} ({1})", fileSegment, treeish);
                description = nls_1.localize('changesFromTreeDesc', "{0} - Changes on {1}", folderSegment, treeish);
            }
            if (mime.isUnspecific(mimetypes)) {
                mimetypes = mime.guessMimeTypes(path); // guess from path if our detection did not yield results
            }
            // Binary: our story is weak here for binary files on the index. Since we run natively, we do not have a way currently
            // to e.g. show images as binary inside the renderer because images need to be served through a URL to show. We could revisit this by
            // allowing to use data URLs for resource inputs to render them. However, this would mean potentially loading a large file into memory
            //
            // Our solution now is to detect binary files and immediately return an input that is flagged as binary unknown mime type.
            if (mime.isBinaryMime(mime.guessMimeTypes(path)) || mimetypes.indexOf(mime.MIME_BINARY) >= 0) {
                return winjs_base_1.TPromise.wrapError(new Error('The resource seems to be binary and cannot be displayed'));
            }
            // Text
            return winjs_base_1.TPromise.as(_this.instantiationService.createInstance(gitEditorInputs_1.NativeGitIndexStringEditorInput, label, description, mimetypes.join(', '), status, path, treeish));
        });
    };
    GitService.prototype.getInput = function (status) {
        var _this = this;
        return this.inputCache.getInput(status).then(null, function (err) {
            if (err.gitErrorCode = git_1.GitErrorCodes.CantOpenResource) {
                _this.messageService.show(severity_1.default.Warning, nls_1.localize('cantOpenResource', "Can't open this git resource."));
                return winjs_base_1.TPromise.as(null);
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    };
    GitService.prototype.isInitialized = function () {
        return this.state === git_1.ServiceState.OK;
    };
    GitService.prototype.isIdle = function () {
        return this.isInitialized() && !this.operations.some(function (op) { return op.id !== git_1.ServiceOperations.BACKGROUND_FETCH; });
    };
    GitService.prototype.getRunningOperations = function () {
        return this.operations;
    };
    GitService.prototype.getAutoFetcher = function () {
        return this.autoFetcher;
    };
    GitService.toPaths = function (files) {
        if (!files) {
            return null;
        }
        return files.map(function (status) {
            /*	In the case that a file was renamed in the index and (changed || deleted) in the
                working tree, we must use its new name, running the checkout command.
            */
            switch (status.getStatus()) {
                case git_1.Status.MODIFIED:
                case git_1.Status.DELETED:
                    if (status.getRename()) {
                        return status.getRename();
                    }
                default:
                    return status.getPath();
            }
        });
    };
    GitService.prototype.dispose = function () {
        this.emit(git_1.ServiceEvents.DISPOSE);
        if (this.model) {
            this.model.dispose();
            this.model = null;
        }
        _super.prototype.dispose.call(this);
    };
    return GitService;
}(eventEmitter_1.EventEmitter));
GitService = __decorate([
    __param(1, instantiation_1.IInstantiationService),
    __param(2, files_1.IFileService),
    __param(3, message_1.IMessageService),
    __param(4, editorService_1.IWorkbenchEditorService),
    __param(5, output_1.IOutputService),
    __param(6, textfiles_1.ITextFileService),
    __param(7, workspace_1.IWorkspaceContextService),
    __param(8, lifecycle_2.ILifecycleService),
    __param(9, storage_1.IStorageService),
    __param(10, configuration_1.IConfigurationService)
], GitService);
exports.GitService = GitService;
