/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var nls = require("vs/nls");
var Objects = require("vs/base/common/objects");
var Platform = require("vs/base/common/platform");
var Types = require("vs/base/common/types");
var UUID = require("vs/base/common/uuid");
var parsers_1 = require("vs/base/common/parsers");
var problemMatcher_1 = require("vs/platform/markers/common/problemMatcher");
var TaskSystem = require("./taskSystem");
/**
 * Defines the problem handling strategy
 */
var ProblemHandling = (function () {
    function ProblemHandling() {
    }
    return ProblemHandling;
}());
/**
 * Cleans all problems for the owner defined in the
 * error pattern.
 */
ProblemHandling.clean = 'cleanMatcherMatchers';
exports.ProblemHandling = ProblemHandling;
var ProblemMatcherKind;
(function (ProblemMatcherKind) {
    ProblemMatcherKind[ProblemMatcherKind["Unknown"] = 0] = "Unknown";
    ProblemMatcherKind[ProblemMatcherKind["String"] = 1] = "String";
    ProblemMatcherKind[ProblemMatcherKind["ProblemMatcher"] = 2] = "ProblemMatcher";
    ProblemMatcherKind[ProblemMatcherKind["Array"] = 3] = "Array";
})(ProblemMatcherKind || (ProblemMatcherKind = {}));
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
function mergeProperty(target, source, key) {
    if (source[key] !== void 0) {
        target[key] = source[key];
    }
}
function fillProperty(target, source, key) {
    if (target[key] === void 0 && source[key] !== void 0) {
        target[key] = source[key];
    }
}
var CommandOptions;
(function (CommandOptions) {
    function from(options, context) {
        var result = {};
        if (options.cwd !== void 0) {
            if (Types.isString(options.cwd)) {
                result.cwd = options.cwd;
            }
            else {
                context.validationStatus.state = parsers_1.ValidationState.Warning;
                context.logger.log(nls.localize('ConfigurationParser.invalidCWD', 'Warning: options.cwd must be of type string. Ignoring value {0}\n', options.cwd));
            }
        }
        if (options.env !== void 0) {
            result.env = Objects.clone(options.env);
        }
        return isEmpty(result) ? undefined : result;
    }
    CommandOptions.from = from;
    function isEmpty(value) {
        return !value || value.cwd === void 0 && value.env === void 0;
    }
    CommandOptions.isEmpty = isEmpty;
    function merge(target, source) {
        if (isEmpty(source)) {
            return target;
        }
        if (isEmpty(target)) {
            return source;
        }
        mergeProperty(target, source, 'cwd');
        if (target.env === void 0) {
            target.env = source.env;
        }
        else if (source.env !== void 0) {
            var env_1 = Object.create(null);
            Object.keys(target.env).forEach(function (key) { return env_1[key] = target.env[key]; });
            Object.keys(source.env).forEach(function (key) { return env_1[key = source.env[key]]; });
            target.env = env_1;
        }
        return target;
    }
    CommandOptions.merge = merge;
    function fillDefaults(value) {
        if (value && Object.isFrozen(value)) {
            return value;
        }
        if (value === void 0) {
            value = {};
        }
        if (value.cwd === void 0) {
            value.cwd = '${workspaceRoot}';
        }
        return value;
    }
    CommandOptions.fillDefaults = fillDefaults;
    function freeze(value) {
        Object.freeze(value);
        if (value.env) {
            Object.freeze(value.env);
        }
    }
    CommandOptions.freeze = freeze;
})(CommandOptions || (CommandOptions = {}));
var ShellConfiguration;
(function (ShellConfiguration) {
    function is(value) {
        var candidate = value;
        return candidate && Types.isString(candidate.executable) && (candidate.args === void 0 || Types.isStringArray(candidate.args));
    }
    ShellConfiguration.is = is;
    function from(config, context) {
        if (!is(config)) {
            return undefined;
        }
        var result = { executable: config.executable };
        if (config.args !== void 0) {
            result.args = config.args.slice();
        }
        return result;
    }
    ShellConfiguration.from = from;
    function isEmpty(value) {
        return !value || value.executable === void 0 && (value.args === void 0 || value.args.length === 0);
    }
    ShellConfiguration.isEmpty = isEmpty;
    function merge(target, source) {
        if (isEmpty(source)) {
            return target;
        }
        if (isEmpty(target)) {
            return source;
        }
        mergeProperty(target, source, 'executable');
        mergeProperty(target, source, 'args');
        return target;
    }
    ShellConfiguration.merge = merge;
    function fillDefaults(value) {
    }
    ShellConfiguration.fillDefaults = fillDefaults;
    function freeze(value) {
        if (!value) {
            return;
        }
        Object.freeze(value);
    }
    ShellConfiguration.freeze = freeze;
})(ShellConfiguration || (ShellConfiguration = {}));
var CommandConfiguration;
(function (CommandConfiguration) {
    function from(config, context) {
        var result = fromBase(config, context);
        var osConfig = undefined;
        if (config.windows && Platform.platform === Platform.Platform.Windows) {
            osConfig = fromBase(config.windows, context);
        }
        else if (config.osx && Platform.platform === Platform.Platform.Mac) {
            osConfig = fromBase(config.osx, context);
        }
        else if (config.linux && Platform.platform === Platform.Platform.Linux) {
            osConfig = fromBase(config.linux, context);
        }
        if (osConfig) {
            result = merge(result, osConfig);
        }
        fillDefaults(result);
        return isEmpty(result) ? undefined : result;
    }
    CommandConfiguration.from = from;
    function fromBase(config, context) {
        var result = {};
        if (Types.isString(config.command)) {
            result.name = config.command;
        }
        if (Types.isBoolean(config.isShellCommand)) {
            result.isShellCommand = config.isShellCommand;
        }
        else if (ShellConfiguration.is(config.isShellCommand)) {
            result.isShellCommand = ShellConfiguration.from(config.isShellCommand, context);
            if (!context.isTermnial) {
                context.validationStatus.state = parsers_1.ValidationState.Warning;
                context.logger.log(nls.localize('ConfigurationParser.noShell', 'Warning: shell configuration is only supported when executing tasks in the terminal.'));
            }
        }
        else if (config.isShellCommand !== void 0) {
            result.isShellCommand = !!config.isShellCommand;
        }
        if (config.args !== void 0) {
            if (Types.isStringArray(config.args)) {
                result.args = config.args.slice(0);
            }
            else {
                context.validationStatus.state = parsers_1.ValidationState.Fatal;
                context.logger.log(nls.localize('ConfigurationParser.noargs', 'Error: command arguments must be an array of strings. Provided value is:\n{0}', config.args ? JSON.stringify(config.args, undefined, 4) : 'undefined'));
            }
        }
        if (config.options !== void 0) {
            result.options = CommandOptions.from(config.options, context);
        }
        if (Types.isBoolean(config.echoCommand)) {
            result.echo = config.echoCommand;
        }
        if (Types.isString(config.taskSelector)) {
            result.taskSelector = config.taskSelector;
        }
        return isEmpty(result) ? undefined : result;
    }
    function isEmpty(value) {
        return !value || value.name === void 0 && value.isShellCommand === void 0 && value.args === void 0 && CommandOptions.isEmpty(value.options) && value.echo === void 0;
    }
    CommandConfiguration.isEmpty = isEmpty;
    function onlyEcho(value) {
        return value && value.echo !== void 0 && value.name === void 0 && value.isShellCommand === void 0 && value.args === void 0 && CommandOptions.isEmpty(value.options);
    }
    CommandConfiguration.onlyEcho = onlyEcho;
    function merge(target, source) {
        if (isEmpty(source)) {
            return target;
        }
        if (isEmpty(target)) {
            return source;
        }
        mergeProperty(target, source, 'name');
        // Merge isShellCommand
        if (target.isShellCommand === void 0) {
            target.isShellCommand = source.isShellCommand;
        }
        if (Types.isBoolean(target.isShellCommand) && Types.isBoolean(source.isShellCommand)) {
            mergeProperty(target, source, 'isShellCommand');
        }
        else if (ShellConfiguration.is(target.isShellCommand) && ShellConfiguration.is(source.isShellCommand)) {
            ShellConfiguration.merge(target.isShellCommand, source.isShellCommand);
        }
        else if (Types.isBoolean(target.isShellCommand) && ShellConfiguration.is(source.isShellCommand)) {
            target.isShellCommand = source.isShellCommand;
        }
        mergeProperty(target, source, 'echo');
        mergeProperty(target, source, 'taskSelector');
        if (source.args !== void 0) {
            if (target.args === void 0) {
                target.args = source.args;
            }
            else {
                target.args = target.args.concat(source.args);
            }
        }
        target.options = CommandOptions.merge(target.options, source.options);
        return target;
    }
    CommandConfiguration.merge = merge;
    function fillDefaults(value) {
        if (!value || Object.isFrozen(value)) {
            return;
        }
        if (value.name !== void 0 && value.isShellCommand === void 0) {
            value.isShellCommand = false;
        }
        if (value.echo === void 0) {
            value.echo = false;
        }
        if (value.args === void 0) {
            value.args = EMPTY_ARRAY;
        }
        if (!isEmpty(value)) {
            value.options = CommandOptions.fillDefaults(value.options);
        }
    }
    CommandConfiguration.fillDefaults = fillDefaults;
    function freeze(value) {
        Object.freeze(value);
        if (value.args) {
            Object.freeze(value.args);
        }
        if (value.options) {
            CommandOptions.freeze(value.options);
        }
        if (ShellConfiguration.is(value.isShellCommand)) {
            ShellConfiguration.freeze(value.isShellCommand);
        }
    }
    CommandConfiguration.freeze = freeze;
})(CommandConfiguration || (CommandConfiguration = {}));
var ProblemMatcherConverter;
(function (ProblemMatcherConverter) {
    function namedFrom(declares, context) {
        var result = Object.create(null);
        if (!Types.isArray(declares)) {
            return result;
        }
        declares.forEach(function (value) {
            var namedProblemMatcher = (new problemMatcher_1.ProblemMatcherParser(problemMatcher_1.registry, context.logger, context.validationStatus)).parse(value);
            if (problemMatcher_1.isNamedProblemMatcher(namedProblemMatcher)) {
                result[namedProblemMatcher.name] = namedProblemMatcher;
            }
            else {
                context.validationStatus.state = parsers_1.ValidationState.Error;
                context.logger.log(nls.localize('ConfigurationParser.noName', 'Error: Problem Matcher in declare scope must have a name:\n{0}\n', JSON.stringify(value, undefined, 4)));
            }
        });
        return result;
    }
    ProblemMatcherConverter.namedFrom = namedFrom;
    function from(config, context) {
        var result = [];
        if (config === void 0) {
            return result;
        }
        var kind = getProblemMatcherKind(config);
        if (kind === ProblemMatcherKind.Unknown) {
            context.validationStatus.state = parsers_1.ValidationState.Warning;
            context.logger.log(nls.localize('ConfigurationParser.unknownMatcherKind', 'Warning: the defined problem matcher is unknown. Supported types are string | ProblemMatcher | (string | ProblemMatcher)[].\n{0}\n', JSON.stringify(config, null, 4)));
            return result;
        }
        else if (kind === ProblemMatcherKind.String || kind === ProblemMatcherKind.ProblemMatcher) {
            var matcher = resolveProblemMatcher(config, context);
            if (matcher) {
                result.push(matcher);
            }
        }
        else if (kind === ProblemMatcherKind.Array) {
            var problemMatchers = config;
            problemMatchers.forEach(function (problemMatcher) {
                var matcher = resolveProblemMatcher(problemMatcher, context);
                if (matcher) {
                    result.push(matcher);
                }
            });
        }
        return result;
    }
    ProblemMatcherConverter.from = from;
    function getProblemMatcherKind(value) {
        if (Types.isString(value)) {
            return ProblemMatcherKind.String;
        }
        else if (Types.isArray(value)) {
            return ProblemMatcherKind.Array;
        }
        else if (!Types.isUndefined(value)) {
            return ProblemMatcherKind.ProblemMatcher;
        }
        else {
            return ProblemMatcherKind.Unknown;
        }
    }
    function resolveProblemMatcher(value, context) {
        if (Types.isString(value)) {
            var variableName = value;
            if (variableName.length > 1 && variableName[0] === '$') {
                variableName = variableName.substring(1);
                var global_1 = problemMatcher_1.registry.get(variableName);
                if (global_1) {
                    return Objects.clone(global_1);
                }
                var localProblemMatcher = context.namedProblemMatchers[variableName];
                if (localProblemMatcher) {
                    localProblemMatcher = Objects.clone(localProblemMatcher);
                    // remove the name
                    delete localProblemMatcher.name;
                    return localProblemMatcher;
                }
            }
            context.validationStatus.state = parsers_1.ValidationState.Error;
            context.logger.log(nls.localize('ConfigurationParser.invalidVaraibleReference', 'Error: Invalid problemMatcher reference: {0}\n', value));
            return undefined;
        }
        else {
            var json = value;
            return new problemMatcher_1.ProblemMatcherParser(problemMatcher_1.registry, context.logger, context.validationStatus).parse(json);
        }
    }
})(ProblemMatcherConverter || (ProblemMatcherConverter = {}));
var CommandBinding;
(function (CommandBinding) {
    function isEmpty(value) {
        return !value || value.identifier === void 0 && value.title === void 0 && value.category === void 0;
    }
    CommandBinding.isEmpty = isEmpty;
    function from(binding, context) {
        if (!binding) {
            return undefined;
        }
        if (!Types.isString(binding.identifier)) {
            context.validationStatus.state = parsers_1.ValidationState.Warning;
            context.logger.log(nls.localize('noCommandId', 'Warning: a command binding must defined an identifier. Ignoring binding.'));
            return undefined;
        }
        var result = {
            identifier: binding.identifier,
            title: ''
        };
        if (Types.isString(binding.category)) {
            result.category = binding.category;
        }
        return result;
    }
    CommandBinding.from = from;
})(CommandBinding || (CommandBinding = {}));
var TaskDescription;
(function (TaskDescription) {
    function isEmpty(value) {
        return !value || !value.tasks || Object.keys(value.tasks).length === 0;
    }
    TaskDescription.isEmpty = isEmpty;
    function from(tasks, globals, context) {
        if (!tasks) {
            return undefined;
        }
        var parsedTasks = Object.create(null);
        var defaultBuildTask = { id: null, exact: -1 };
        var defaultTestTask = { id: null, exact: -1 };
        tasks.forEach(function (externalTask) {
            var taskName = externalTask.taskName;
            if (!taskName) {
                context.validationStatus.state = parsers_1.ValidationState.Fatal;
                context.logger.log(nls.localize('ConfigurationParser.noTaskName', 'Error: tasks must provide a taskName property. The task will be ignored.\n{0}\n', JSON.stringify(externalTask, null, 4)));
                return;
            }
            var problemMatchers = ProblemMatcherConverter.from(externalTask.problemMatcher, context);
            var command = externalTask.command !== void 0
                ? CommandConfiguration.from(externalTask, context)
                : externalTask.echoCommand !== void 0 ? { echo: !!externalTask.echoCommand } : undefined;
            var identifer = Types.isString(externalTask.identifier) ? externalTask.identifier : taskName;
            var task = {
                id: UUID.generateUuid(),
                name: taskName,
                identifier: identifer,
                command: command,
                showOutput: undefined
            };
            if (externalTask.command === void 0 && Types.isStringArray(externalTask.args)) {
                task.args = externalTask.args.slice();
            }
            if (externalTask.isWatching !== void 0) {
                task.isBackground = !!externalTask.isWatching;
            }
            if (externalTask.isBackground !== void 0) {
                task.isBackground = !!externalTask.isBackground;
            }
            if (externalTask.promptOnClose !== void 0) {
                task.promptOnClose = !!externalTask.promptOnClose;
            }
            if (Types.isString(externalTask.showOutput)) {
                task.showOutput = TaskSystem.ShowOutput.fromString(externalTask.showOutput);
            }
            if (externalTask.command !== void 0) {
                // if the task has its own command then we suppress the
                // task name by default.
                task.suppressTaskName = true;
            }
            else if (externalTask.suppressTaskName !== void 0) {
                task.suppressTaskName = !!externalTask.suppressTaskName;
            }
            if (externalTask.dependsOn !== void 0) {
                if (Types.isString(externalTask.dependsOn)) {
                    task.dependsOn = [externalTask.dependsOn];
                }
                else if (Types.isStringArray(externalTask.dependsOn)) {
                    task.dependsOn = externalTask.dependsOn.slice();
                }
            }
            if (problemMatchers) {
                task.problemMatchers = problemMatchers;
            }
            mergeGlobals(task, globals);
            fillDefaults(task);
            var addTask = true;
            if (context.isTermnial && task.command && task.command.name && task.command.isShellCommand && task.command.args && task.command.args.length > 0) {
                if (hasUnescapedSpaces(task.command.name) || task.command.args.some(hasUnescapedSpaces)) {
                    context.validationStatus.state = parsers_1.ValidationState.Warning;
                    context.logger.log(nls.localize('taskConfiguration.shellArgs', 'Warning: the task \'{0}\' is a shell command and either the command name or one of its arguments has unescaped spaces. To ensure correct command line quoting please merge args into the command.', task.name));
                }
            }
            if (context.isTermnial) {
                if ((task.command === void 0 || task.command.name === void 0) && (task.dependsOn === void 0 || task.dependsOn.length === 0)) {
                    context.validationStatus.state = parsers_1.ValidationState.Error;
                    context.logger.log(nls.localize('taskConfiguration.noCommandOrDependsOn', 'Error: the task \'{0}\' neither specifies a command or a dependsOn property. The task will be ignored. Its definition is:\n{1}', task.name, JSON.stringify(externalTask, undefined, 4)));
                    addTask = false;
                }
            }
            else {
                if (task.command === void 0 || task.command.name === void 0) {
                    context.validationStatus.state = parsers_1.ValidationState.Warning;
                    context.logger.log(nls.localize('taskConfiguration.noCommand', 'Error: the task \'{0}\' doesn\'t define a command. The task will be ignored. Its definition is:\n{1}', task.name, JSON.stringify(externalTask, undefined, 4)));
                    addTask = false;
                }
            }
            if (addTask) {
                parsedTasks[task.id] = task;
                if (!Types.isUndefined(externalTask.isBuildCommand) && externalTask.isBuildCommand && defaultBuildTask.exact < 2) {
                    defaultBuildTask.id = task.id;
                    defaultBuildTask.exact = 2;
                }
                else if (taskName === 'build' && defaultBuildTask.exact < 2) {
                    defaultBuildTask.id = task.id;
                    defaultBuildTask.exact = 1;
                }
                if (!Types.isUndefined(externalTask.isTestCommand) && externalTask.isTestCommand && defaultTestTask.exact < 2) {
                    defaultTestTask.id = task.id;
                    defaultTestTask.exact = 2;
                }
                else if (taskName === 'test' && defaultTestTask.exact < 2) {
                    defaultTestTask.id = task.id;
                    defaultTestTask.exact = 1;
                }
            }
        });
        var buildTask;
        if (defaultBuildTask.exact > 0) {
            buildTask = defaultBuildTask.id;
        }
        var testTask;
        if (defaultTestTask.exact > 0) {
            testTask = defaultTestTask.id;
        }
        var result = { tasks: parsedTasks, buildTask: buildTask, testTask: testTask };
        return isEmpty(result) ? undefined : result;
    }
    TaskDescription.from = from;
    function merge(target, source) {
        if (isEmpty(source)) {
            return target;
        }
        if (isEmpty(target)) {
            return source;
        }
        if (source.tasks) {
            // Tasks are keyed by ID but we need to merge by name
            var targetNames_1 = Object.create(null);
            Object.keys(target.tasks).forEach(function (key) {
                var task = target.tasks[key];
                targetNames_1[task.name] = task.id;
            });
            var sourceNames_1 = Object.create(null);
            Object.keys(source.tasks).forEach(function (key) {
                var task = source.tasks[key];
                sourceNames_1[task.name] = task.id;
            });
            Object.keys(sourceNames_1).forEach(function (taskName) {
                var targetId = targetNames_1[taskName];
                var sourceId = sourceNames_1[taskName];
                // Same name exists globally
                if (targetId) {
                    delete target.tasks[targetId];
                }
                target.tasks[sourceId] = source.tasks[sourceId];
            });
        }
        fillProperty(target, source, 'buildTask');
        fillProperty(target, source, 'testTask');
        return target;
    }
    TaskDescription.merge = merge;
    function mergeGlobals(task, globals) {
        // We only merge a command from a global definition if there is no dependsOn
        if (task.dependsOn === void 0) {
            if (CommandConfiguration.isEmpty(task.command) && !CommandConfiguration.isEmpty(globals.command) && globals.command.name !== void 0) {
                task.command = globals.command;
            }
            if (CommandConfiguration.onlyEcho(task.command)) {
                // The globals can have a echo set which would override the local echo
                // Saves the need of a additional fill method. But might be necessary
                // at some point.
                var oldEcho = task.command.echo;
                CommandConfiguration.merge(task.command, globals.command);
                task.command.echo = oldEcho;
            }
        }
        // promptOnClose is inferred from isBackground if available
        if (task.promptOnClose === void 0 && task.isBackground === void 0 && globals.promptOnClose !== void 0) {
            task.promptOnClose = globals.promptOnClose;
        }
        if (task.suppressTaskName === void 0 && globals.suppressTaskName !== void 0) {
            task.suppressTaskName = globals.suppressTaskName;
        }
        if (task.showOutput === void 0 && globals.showOutput !== void 0) {
            task.showOutput = globals.showOutput;
        }
    }
    TaskDescription.mergeGlobals = mergeGlobals;
    function fillDefaults(task) {
        CommandConfiguration.fillDefaults(task.command);
        if (task.args === void 0 && task.command === void 0) {
            task.args = EMPTY_ARRAY;
        }
        if (task.suppressTaskName === void 0) {
            task.suppressTaskName = false;
        }
        if (task.promptOnClose === void 0) {
            task.promptOnClose = task.isBackground !== void 0 ? !task.isBackground : true;
        }
        if (task.isBackground === void 0) {
            task.isBackground = false;
        }
        if (task.showOutput === void 0) {
            task.showOutput = TaskSystem.ShowOutput.Always;
        }
        if (task.problemMatchers === void 0) {
            task.problemMatchers = EMPTY_ARRAY;
        }
    }
    TaskDescription.fillDefaults = fillDefaults;
    function hasUnescapedSpaces(value) {
        if (Platform.isWindows) {
            if (value.length >= 2 && value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
                return false;
            }
            return value.indexOf(' ') !== -1;
        }
        else {
            if (value.length >= 2 && ((value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') || (value.charAt(0) === '\'' && value.charAt(value.length - 1) === '\''))) {
                return false;
            }
            for (var i = 0; i < value.length; i++) {
                var ch = value.charAt(i);
                if (ch === ' ') {
                    if (i === 0 || value.charAt(i) !== '\\') {
                        return true;
                    }
                }
            }
            return false;
        }
    }
})(TaskDescription || (TaskDescription = {}));
var Globals;
(function (Globals) {
    function from(config, context) {
        var result = fromBase(config, context);
        var osGlobals = undefined;
        if (config.windows && Platform.platform === Platform.Platform.Windows) {
            osGlobals = fromBase(config.windows, context);
        }
        else if (config.osx && Platform.platform === Platform.Platform.Mac) {
            osGlobals = fromBase(config.osx, context);
        }
        else if (config.linux && Platform.platform === Platform.Platform.Linux) {
            osGlobals = fromBase(config.linux, context);
        }
        if (osGlobals) {
            result = Globals.merge(result, osGlobals);
        }
        Globals.fillDefaults(result);
        var command = CommandConfiguration.from(config, context);
        if (command) {
            result.command = command;
        }
        Globals.freeze(result);
        return result;
    }
    Globals.from = from;
    function fromBase(config, context) {
        var result = {};
        if (Types.isString(config.showOutput)) {
            result.showOutput = TaskSystem.ShowOutput.fromString(config.showOutput);
        }
        if (config.suppressTaskName !== void 0) {
            result.suppressTaskName = !!config.suppressTaskName;
        }
        if (config.promptOnClose !== void 0) {
            result.promptOnClose = !!config.promptOnClose;
        }
        return result;
    }
    Globals.fromBase = fromBase;
    function isEmpty(value) {
        return !value || value.command === void 0 && value.promptOnClose === void 0 && value.showOutput === void 0 && value.suppressTaskName === void 0;
    }
    Globals.isEmpty = isEmpty;
    function merge(target, source) {
        if (isEmpty(source)) {
            return target;
        }
        if (isEmpty(target)) {
            return source;
        }
        mergeProperty(target, source, 'promptOnClose');
        mergeProperty(target, source, 'suppressTaskName');
        mergeProperty(target, source, 'showOutput');
        return target;
    }
    Globals.merge = merge;
    function fillDefaults(value) {
        if (!value) {
            return;
        }
        if (value.suppressTaskName === void 0) {
            value.suppressTaskName = false;
        }
        if (value.showOutput === void 0) {
            value.showOutput = TaskSystem.ShowOutput.Always;
        }
        if (value.promptOnClose === void 0) {
            value.promptOnClose = true;
        }
    }
    Globals.fillDefaults = fillDefaults;
    function freeze(value) {
        Object.freeze(value);
        if (value.command) {
            CommandConfiguration.freeze(value.command);
        }
    }
    Globals.freeze = freeze;
})(Globals || (Globals = {}));
var ExecutionEngine;
(function (ExecutionEngine) {
    ExecutionEngine[ExecutionEngine["Unknown"] = 0] = "Unknown";
    ExecutionEngine[ExecutionEngine["Terminal"] = 1] = "Terminal";
    ExecutionEngine[ExecutionEngine["OutputPanel"] = 2] = "OutputPanel";
})(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
(function (ExecutionEngine) {
    function from(config) {
        return isTerminalConfig(config)
            ? ExecutionEngine.Terminal
            : isRunnerConfig(config)
                ? ExecutionEngine.OutputPanel
                : ExecutionEngine.Unknown;
    }
    ExecutionEngine.from = from;
    function isRunnerConfig(config) {
        return (!config._runner || config._runner === 'program') && (config.version === '0.1.0' || !config.version);
    }
    function isTerminalConfig(config) {
        return config._runner === 'terminal' || config.version === '2.0.0';
    }
})(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
var ConfigurationParser = (function () {
    function ConfigurationParser(logger) {
        this.logger = logger;
        this.validationStatus = new parsers_1.ValidationStatus();
    }
    ConfigurationParser.prototype.run = function (fileConfig) {
        var engine = ExecutionEngine.from(fileConfig);
        if (engine === ExecutionEngine.Terminal) {
            this.logger.clearOutput();
        }
        var context = { logger: this.logger, validationStatus: this.validationStatus, namedProblemMatchers: undefined, isTermnial: engine === ExecutionEngine.Terminal };
        return {
            validationStatus: this.validationStatus,
            configuration: this.createTaskRunnerConfiguration(fileConfig, context),
            engine: engine
        };
    };
    ConfigurationParser.prototype.createTaskRunnerConfiguration = function (fileConfig, context) {
        var globals = Globals.from(fileConfig, context);
        if (context.validationStatus.isFatal()) {
            return undefined;
        }
        context.namedProblemMatchers = ProblemMatcherConverter.namedFrom(fileConfig.declares, context);
        var globalTasks;
        if (fileConfig.windows && Platform.platform === Platform.Platform.Windows) {
            globalTasks = TaskDescription.from(fileConfig.windows.tasks, globals, context);
        }
        else if (fileConfig.osx && Platform.platform === Platform.Platform.Mac) {
            globalTasks = TaskDescription.from(fileConfig.osx.tasks, globals, context);
        }
        else if (fileConfig.linux && Platform.platform === Platform.Platform.Linux) {
            globalTasks = TaskDescription.from(fileConfig.linux.tasks, globals, context);
        }
        var taskConfig;
        if (fileConfig.tasks) {
            taskConfig = TaskDescription.from(fileConfig.tasks, globals, context);
        }
        taskConfig = TaskDescription.merge(taskConfig, globalTasks);
        if (TaskDescription.isEmpty(taskConfig)) {
            var tasks = Object.create(null);
            var buildTask = void 0;
            if (globals.command && globals.command.name) {
                var matchers = ProblemMatcherConverter.from(fileConfig.problemMatcher, context);
                ;
                var isBackground = fileConfig.isBackground ? !!fileConfig.isBackground : fileConfig.isWatching ? !!fileConfig.isWatching : undefined;
                var task = {
                    id: UUID.generateUuid(),
                    name: globals.command.name,
                    identifier: globals.command.name,
                    command: undefined,
                    isBackground: isBackground,
                    showOutput: undefined,
                    suppressTaskName: true,
                    problemMatchers: matchers
                };
                TaskDescription.mergeGlobals(task, globals);
                TaskDescription.fillDefaults(task);
                tasks[task.id] = task;
                buildTask = task.id;
            }
            taskConfig = {
                tasks: tasks,
                buildTask: buildTask
            };
        }
        return {
            tasks: taskConfig.tasks,
            buildTasks: taskConfig.buildTask ? [taskConfig.buildTask] : [],
            testTasks: taskConfig.testTask ? [taskConfig.testTask] : []
        };
    };
    return ConfigurationParser;
}());
function parse(configuration, logger) {
    return (new ConfigurationParser(logger)).run(configuration);
}
exports.parse = parse;
