/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var lifecycle = require("vs/base/common/lifecycle");
var mime_1 = require("vs/base/common/mime");
var event_1 = require("vs/base/common/event");
var paths = require("vs/base/common/paths");
var uuid_1 = require("vs/base/common/uuid");
var uri_1 = require("vs/base/common/uri");
var actions_1 = require("vs/base/common/actions");
var arrays_1 = require("vs/base/common/arrays");
var types_1 = require("vs/base/common/types");
var errors = require("vs/base/common/errors");
var severity_1 = require("vs/base/common/severity");
var winjs_base_1 = require("vs/base/common/winjs.base");
var aria = require("vs/base/browser/ui/aria/aria");
var ipc_cp_1 = require("vs/base/parts/ipc/node/ipc.cp");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var markers_1 = require("vs/platform/markers/common/markers");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
var extensions_1 = require("vs/platform/extensions/common/extensions");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var files_1 = require("vs/platform/files/common/files");
var event_2 = require("vs/platform/event/common/event");
var message_1 = require("vs/platform/message/common/message");
var windows_1 = require("vs/platform/windows/common/windows");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var telemetryService_1 = require("vs/platform/telemetry/common/telemetryService");
var telemetryIpc_1 = require("vs/platform/telemetry/common/telemetryIpc");
var storage_1 = require("vs/platform/storage/common/storage");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var editor_1 = require("vs/workbench/common/editor");
var debug = require("vs/workbench/parts/debug/common/debug");
var rawDebugSession_1 = require("vs/workbench/parts/debug/electron-browser/rawDebugSession");
var debugModel_1 = require("vs/workbench/parts/debug/common/debugModel");
var debugEditorInputs_1 = require("vs/workbench/parts/debug/browser/debugEditorInputs");
var debugViewModel_1 = require("vs/workbench/parts/debug/common/debugViewModel");
var debugactions = require("vs/workbench/parts/debug/browser/debugActions");
var debugConfigurationManager_1 = require("vs/workbench/parts/debug/node/debugConfigurationManager");
var debugSource_1 = require("vs/workbench/parts/debug/common/debugSource");
var markersPanelActions_1 = require("vs/workbench/parts/markers/browser/markersPanelActions");
var taskService_1 = require("vs/workbench/parts/tasks/common/taskService");
var taskSystem_1 = require("vs/workbench/parts/tasks/common/taskSystem");
var files_2 = require("vs/workbench/parts/files/common/files");
var viewlet_1 = require("vs/workbench/services/viewlet/browser/viewlet");
var panelService_1 = require("vs/workbench/services/panel/common/panelService");
var partService_1 = require("vs/workbench/services/part/common/partService");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var windowService_1 = require("vs/workbench/services/window/electron-browser/windowService");
var extensionHost_1 = require("vs/workbench/electron-browser/extensionHost");
var DEBUG_BREAKPOINTS_KEY = 'debug.breakpoint';
var DEBUG_BREAKPOINTS_ACTIVATED_KEY = 'debug.breakpointactivated';
var DEBUG_FUNCTION_BREAKPOINTS_KEY = 'debug.functionbreakpoint';
var DEBUG_EXCEPTION_BREAKPOINTS_KEY = 'debug.exceptionbreakpoint';
var DEBUG_WATCH_EXPRESSIONS_KEY = 'debug.watchexpressions';
var DEBUG_SELECTED_CONFIG_NAME_KEY = 'debug.selectedconfigname';
var DebugService = (function () {
    function DebugService(storageService, editorService, textFileService, viewletService, panelService, fileService, messageService, partService, windowsService, windowService, telemetryService, contextService, contextKeyService, editorGroupService, eventService, lifecycleService, instantiationService, extensionService, markerService, taskService, configurationService) {
        this.storageService = storageService;
        this.editorService = editorService;
        this.textFileService = textFileService;
        this.viewletService = viewletService;
        this.panelService = panelService;
        this.fileService = fileService;
        this.messageService = messageService;
        this.partService = partService;
        this.windowsService = windowsService;
        this.windowService = windowService;
        this.telemetryService = telemetryService;
        this.contextService = contextService;
        this.editorGroupService = editorGroupService;
        this.instantiationService = instantiationService;
        this.extensionService = extensionService;
        this.markerService = markerService;
        this.taskService = taskService;
        this.configurationService = configurationService;
        this.toDispose = [];
        this.toDisposeOnSessionEnd = {};
        this.breakpointsToSendOnResourceSaved = {};
        this._onDidChangeState = new event_1.Emitter();
        this.sessionStates = {};
        this.configurationManager = this.instantiationService.createInstance(debugConfigurationManager_1.ConfigurationManager);
        this.inDebugMode = debug.CONTEXT_IN_DEBUG_MODE.bindTo(contextKeyService);
        this.model = new debugModel_1.Model(this.loadBreakpoints(), this.storageService.getBoolean(DEBUG_BREAKPOINTS_ACTIVATED_KEY, storage_1.StorageScope.WORKSPACE, true), this.loadFunctionBreakpoints(), this.loadExceptionBreakpoints(), this.loadWatchExpressions());
        this.toDispose.push(this.model);
        this.viewModel = new debugViewModel_1.ViewModel(this.storageService.get(DEBUG_SELECTED_CONFIG_NAME_KEY, storage_1.StorageScope.WORKSPACE, null));
        this.registerListeners(eventService, lifecycleService);
    }
    DebugService.prototype.registerListeners = function (eventService, lifecycleService) {
        var _this = this;
        this.toDispose.push(eventService.addListener2(files_1.EventType.FILE_CHANGES, function (e) { return _this.onFileChanges(e); }));
        if (this.taskService) {
            this.toDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Active, function (e) {
                _this.lastTaskEvent = e;
            }));
            this.toDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Inactive, function (e) {
                if (e.type === taskService_1.TaskType.SingleRun) {
                    _this.lastTaskEvent = null;
                }
            }));
            this.toDispose.push(this.taskService.addListener2(taskService_1.TaskServiceEvents.Terminated, function (e) {
                _this.lastTaskEvent = null;
            }));
        }
        lifecycleService.onShutdown(this.store, this);
        lifecycleService.onShutdown(this.dispose, this);
        this.toDispose.push(this.windowService.onBroadcast(this.onBroadcast, this));
    };
    DebugService.prototype.onBroadcast = function (broadcast) {
        // attach: PH is ready to be attached to
        // TODO@Isidor this is a hack to just get any 'extensionHost' session.
        // Optimally the broadcast would contain the id of the session
        // We are only intersted if we have an active debug session for extensionHost
        var session = this.model.getProcesses().map(function (p) { return p.session; }).filter(function (s) { return s.configuration.type === 'extensionHost'; }).pop();
        if (broadcast.channel === extensionHost_1.EXTENSION_ATTACH_BROADCAST_CHANNEL) {
            this.rawAttach(session, broadcast.payload.port);
            return;
        }
        if (broadcast.channel === extensionHost_1.EXTENSION_TERMINATE_BROADCAST_CHANNEL) {
            this.onSessionEnd(session);
            return;
        }
        // from this point on we require an active session
        if (!session) {
            return;
        }
        // a plugin logged output, show it inside the REPL
        if (broadcast.channel === extensionHost_1.EXTENSION_LOG_BROADCAST_CHANNEL) {
            var extensionOutput = broadcast.payload;
            var sev = extensionOutput.severity === 'warn' ? severity_1.default.Warning : extensionOutput.severity === 'error' ? severity_1.default.Error : severity_1.default.Info;
            var args = [];
            try {
                var parsed_1 = JSON.parse(extensionOutput.arguments);
                args.push.apply(args, Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
            }
            catch (error) {
                args.push(extensionOutput.arguments);
            }
            // add output for each argument logged
            var simpleVals = [];
            for (var i = 0; i < args.length; i++) {
                var a = args[i];
                // undefined gets printed as 'undefined'
                if (typeof a === 'undefined') {
                    simpleVals.push('undefined');
                }
                else if (a === null) {
                    simpleVals.push('null');
                }
                else if (types_1.isObject(a) || Array.isArray(a)) {
                    // flush any existing simple values logged
                    if (simpleVals.length) {
                        this.model.appendToRepl(simpleVals.join(' ') + '\n', sev);
                        simpleVals = [];
                    }
                    // show object
                    this.model.appendToRepl(new debugModel_1.OutputNameValueElement(a.prototype, a, nls.localize('snapshotObj', "Only primitive values are shown for this object.")), sev);
                }
                else if (typeof a === 'string') {
                    var buf = '';
                    for (var j = 0, len = a.length; j < len; j++) {
                        if (a[j] === '%' && (a[j + 1] === 's' || a[j + 1] === 'i' || a[j + 1] === 'd')) {
                            i++; // read over substitution
                            buf += !types_1.isUndefinedOrNull(args[i]) ? args[i] : ''; // replace
                            j++; // read over directive
                        }
                        else {
                            buf += a[j];
                        }
                    }
                    simpleVals.push(buf);
                }
                else {
                    simpleVals.push(a);
                }
            }
            // flush simple values
            if (simpleVals.length) {
                this.model.appendToRepl(simpleVals.join(' ') + '\n', sev);
            }
        }
    };
    DebugService.prototype.registerSessionListeners = function (process, session) {
        var _this = this;
        this.toDisposeOnSessionEnd[session.getId()].push(session);
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidInitialize(function (event) {
            aria.status(nls.localize('debuggingStarted', "Debugging started."));
            var sendConfigurationDone = function () {
                if (session && session.configuration.capabilities.supportsConfigurationDoneRequest) {
                    return session.configurationDone().done(null, function (e) {
                        // Disconnect the debug session on configuration done error #10596
                        if (session) {
                            session.disconnect().done(null, errors.onUnexpectedError);
                        }
                        _this.messageService.show(severity_1.default.Error, e.message);
                    });
                }
            };
            _this.sendAllBreakpoints(process).then(sendConfigurationDone, sendConfigurationDone)
                .done(function () { return _this.fetchThreads(session); }, errors.onUnexpectedError);
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidStop(function (event) {
            _this.setStateAndEmit(session.getId(), debug.State.Stopped);
            var threadId = event.body.threadId;
            session.threads().then(function (response) {
                if (!response || !response.body || !response.body.threads) {
                    return;
                }
                var rawThread = response.body.threads.filter(function (t) { return t.id === threadId; }).pop();
                _this.model.rawUpdate({
                    sessionId: session.getId(),
                    thread: rawThread,
                    threadId: threadId,
                    stoppedDetails: event.body,
                    allThreadsStopped: event.body.allThreadsStopped
                });
                var thread = process && process.getThread(threadId);
                if (thread) {
                    thread.fetchCallStack().then(function (callStack) {
                        if (callStack.length > 0) {
                            // focus first stack frame from top that has source location
                            var stackFrameToFocus = arrays_1.first(callStack, function (sf) { return sf.source && sf.source.available; }, callStack[0]);
                            _this.focusStackFrameAndEvaluate(stackFrameToFocus).done(null, errors.onUnexpectedError);
                            _this.windowService.getWindow().focus();
                            aria.alert(nls.localize('debuggingPaused', "Debugging paused, reason {0}, {1} {2}", event.body.reason, stackFrameToFocus.source ? stackFrameToFocus.source.name : '', stackFrameToFocus.lineNumber));
                            return _this.openOrRevealSource(stackFrameToFocus.source, stackFrameToFocus.lineNumber, false, false);
                        }
                        else {
                            _this.focusStackFrameAndEvaluate(null).done(null, errors.onUnexpectedError);
                        }
                    });
                }
            }, errors.onUnexpectedError);
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidThread(function (event) {
            if (event.body.reason === 'started') {
                _this.fetchThreads(session).done(undefined, errors.onUnexpectedError);
            }
            else if (event.body.reason === 'exited') {
                _this.model.clearThreads(session.getId(), true, event.body.threadId);
            }
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidTerminateDebugee(function (event) {
            aria.status(nls.localize('debuggingStopped', "Debugging stopped."));
            if (session && session.getId() === event.body.sessionId) {
                if (event.body && typeof event.body.restart === 'boolean' && event.body.restart) {
                    _this.restartProcess(process).done(null, function (err) { return _this.messageService.show(severity_1.default.Error, err.message); });
                }
                else {
                    session.disconnect().done(null, errors.onUnexpectedError);
                }
            }
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidContinued(function (event) {
            _this.transitionToRunningState(session, event.body.allThreadsContinued ? undefined : event.body.threadId);
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidOutput(function (event) {
            if (event.body && event.body.category === 'telemetry') {
                // only log telemetry events from debug adapter if the adapter provided the telemetry key
                // and the user opted in telemetry
                if (_this.customTelemetryService && _this.telemetryService.isOptedIn) {
                    _this.customTelemetryService.publicLog(event.body.output, event.body.data);
                }
            }
            else if (event.body && typeof event.body.output === 'string' && event.body.output.length > 0) {
                if (event.body.variablesReference) {
                    var container = new debugModel_1.ExpressionContainer(process, event.body.variablesReference, uuid_1.generateUuid());
                    container.getChildren().then(function (children) {
                        children.forEach(function (child) {
                            // Since we can not display multiple trees in a row, we are displaying these variables one after the other (ignoring their names)
                            child.name = null;
                            _this.model.appendToRepl(child, null);
                        });
                    });
                }
                else {
                    var outputSeverity = event.body.category === 'stderr' ? severity_1.default.Error : event.body.category === 'console' ? severity_1.default.Warning : severity_1.default.Info;
                    _this.model.appendToRepl(event.body.output, outputSeverity);
                }
            }
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidBreakpoint(function (event) {
            var id = event.body && event.body.breakpoint ? event.body.breakpoint.id : undefined;
            var breakpoint = _this.model.getBreakpoints().filter(function (bp) { return bp.idFromAdapter === id; }).pop();
            if (breakpoint) {
                _this.model.updateBreakpoints((_a = {}, _a[breakpoint.getId()] = event.body.breakpoint, _a));
            }
            else {
                var functionBreakpoint = _this.model.getFunctionBreakpoints().filter(function (bp) { return bp.idFromAdapter === id; }).pop();
                if (functionBreakpoint) {
                    _this.model.updateFunctionBreakpoints((_b = {}, _b[functionBreakpoint.getId()] = event.body.breakpoint, _b));
                }
            }
            var _a, _b;
        }));
        this.toDisposeOnSessionEnd[session.getId()].push(session.onDidExitAdapter(function (event) {
            // 'Run without debugging' mode VSCode must terminate the extension host. More details: #3905
            if (session && session.configuration.type === 'extensionHost' && _this.sessionStates[session.getId()] === debug.State.RunningNoDebug) {
                _this.windowsService.closeExtensionHostWindow(_this.contextService.getWorkspace().resource.fsPath);
            }
            if (session && session.getId() === event.body.sessionId) {
                _this.onSessionEnd(session);
            }
        }));
    };
    DebugService.prototype.fetchThreads = function (session) {
        var _this = this;
        return session.threads().then(function (response) {
            if (response && response.body && response.body.threads) {
                response.body.threads.forEach(function (thread) {
                    return _this.model.rawUpdate({
                        sessionId: session.getId(),
                        threadId: thread.id,
                        thread: thread
                    });
                });
            }
        });
    };
    DebugService.prototype.loadBreakpoints = function () {
        var result;
        try {
            result = JSON.parse(this.storageService.get(DEBUG_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map(function (breakpoint) {
                return new debugModel_1.Breakpoint(uri_1.default.parse(breakpoint.uri.external || breakpoint.source.uri.external), breakpoint.lineNumber, breakpoint.enabled, breakpoint.condition, breakpoint.hitCondition);
            });
        }
        catch (e) { }
        return result || [];
    };
    DebugService.prototype.loadFunctionBreakpoints = function () {
        var result;
        try {
            result = JSON.parse(this.storageService.get(DEBUG_FUNCTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map(function (fb) {
                return new debugModel_1.FunctionBreakpoint(fb.name, fb.enabled, fb.hitCondition);
            });
        }
        catch (e) { }
        return result || [];
    };
    DebugService.prototype.loadExceptionBreakpoints = function () {
        var result;
        try {
            result = JSON.parse(this.storageService.get(DEBUG_EXCEPTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map(function (exBreakpoint) {
                return new debugModel_1.ExceptionBreakpoint(exBreakpoint.filter || exBreakpoint.name, exBreakpoint.label, exBreakpoint.enabled);
            });
        }
        catch (e) { }
        return result || [];
    };
    DebugService.prototype.loadWatchExpressions = function () {
        var result;
        try {
            result = JSON.parse(this.storageService.get(DEBUG_WATCH_EXPRESSIONS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map(function (watchStoredData) {
                return new debugModel_1.Expression(watchStoredData.name, watchStoredData.id);
            });
        }
        catch (e) { }
        return result || [];
    };
    Object.defineProperty(DebugService.prototype, "state", {
        get: function () {
            if (!this.contextService.getWorkspace()) {
                return debug.State.Disabled;
            }
            var focusedProcess = this.viewModel.focusedProcess;
            if (focusedProcess) {
                return this.sessionStates[focusedProcess.getId()];
            }
            var processes = this.model.getProcesses();
            if (processes.length > 0) {
                return this.sessionStates[processes[0].getId()];
            }
            return debug.State.Inactive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugService.prototype, "onDidChangeState", {
        get: function () {
            return this._onDidChangeState.event;
        },
        enumerable: true,
        configurable: true
    });
    DebugService.prototype.setStateAndEmit = function (sessionId, newState) {
        this.sessionStates[sessionId] = newState;
        this._onDidChangeState.fire();
    };
    Object.defineProperty(DebugService.prototype, "enabled", {
        get: function () {
            return !!this.contextService.getWorkspace();
        },
        enumerable: true,
        configurable: true
    });
    DebugService.prototype.focusStackFrameAndEvaluate = function (focusedStackFrame, process) {
        var processes = this.model.getProcesses();
        if (!process) {
            process = focusedStackFrame ? focusedStackFrame.thread.process : processes.length ? processes[0] : null;
        }
        this.viewModel.setFocusedStackFrame(focusedStackFrame, process);
        this._onDidChangeState.fire();
        return this.model.evaluateWatchExpressions(this.viewModel.focusedProcess, this.viewModel.focusedStackFrame);
    };
    DebugService.prototype.enableOrDisableBreakpoints = function (enable, breakpoint) {
        if (breakpoint) {
            this.model.setEnablement(breakpoint, enable);
            if (breakpoint instanceof debugModel_1.Breakpoint) {
                return this.sendBreakpoints(breakpoint.uri);
            }
            else if (breakpoint instanceof debugModel_1.FunctionBreakpoint) {
                return this.sendFunctionBreakpoints();
            }
            return this.sendExceptionBreakpoints();
        }
        this.model.enableOrDisableAllBreakpoints(enable);
        return this.sendAllBreakpoints();
    };
    DebugService.prototype.addBreakpoints = function (uri, rawBreakpoints) {
        this.model.addBreakpoints(uri, rawBreakpoints);
        rawBreakpoints.forEach(function (rbp) { return aria.status(nls.localize('breakpointAdded', "Added breakpoint, line {0}, file {1}", rbp.lineNumber, uri.fsPath)); });
        return this.sendBreakpoints(uri);
    };
    DebugService.prototype.removeBreakpoints = function (id) {
        var _this = this;
        var toRemove = this.model.getBreakpoints().filter(function (bp) { return !id || bp.getId() === id; });
        toRemove.forEach(function (bp) { return aria.status(nls.localize('breakpointRemoved', "Removed breakpoint, line {0}, file {1}", bp.lineNumber, bp.uri.fsPath)); });
        var urisToClear = arrays_1.distinct(toRemove, function (bp) { return bp.uri.toString(); }).map(function (bp) { return bp.uri; });
        this.model.removeBreakpoints(toRemove);
        return winjs_base_1.TPromise.join(urisToClear.map(function (uri) { return _this.sendBreakpoints(uri); }));
    };
    DebugService.prototype.setBreakpointsActivated = function (activated) {
        this.model.setBreakpointsActivated(activated);
        return this.sendAllBreakpoints();
    };
    DebugService.prototype.addFunctionBreakpoint = function () {
        this.model.addFunctionBreakpoint('');
    };
    DebugService.prototype.renameFunctionBreakpoint = function (id, newFunctionName) {
        this.model.updateFunctionBreakpoints((_a = {}, _a[id] = { name: newFunctionName }, _a));
        return this.sendFunctionBreakpoints();
        var _a;
    };
    DebugService.prototype.removeFunctionBreakpoints = function (id) {
        this.model.removeFunctionBreakpoints(id);
        return this.sendFunctionBreakpoints();
    };
    DebugService.prototype.addReplExpression = function (name) {
        var _this = this;
        this.telemetryService.publicLog('debugService/addReplExpression');
        return this.model.addReplExpression(this.viewModel.focusedProcess, this.viewModel.focusedStackFrame, name)
            .then(function () { return _this.focusStackFrameAndEvaluate(_this.viewModel.focusedStackFrame); });
    };
    DebugService.prototype.removeReplExpressions = function () {
        this.model.removeReplExpressions();
    };
    DebugService.prototype.addWatchExpression = function (name) {
        return this.model.addWatchExpression(this.viewModel.focusedProcess, this.viewModel.focusedStackFrame, name);
    };
    DebugService.prototype.renameWatchExpression = function (id, newName) {
        var _this = this;
        return this.model.renameWatchExpression(this.viewModel.focusedProcess, this.viewModel.focusedStackFrame, id, newName)
            .then(function () { return _this.focusStackFrameAndEvaluate(_this.viewModel.focusedStackFrame); });
    };
    DebugService.prototype.moveWatchExpression = function (id, position) {
        this.model.moveWatchExpression(id, position);
    };
    DebugService.prototype.removeWatchExpressions = function (id) {
        this.model.removeWatchExpressions(id);
    };
    DebugService.prototype.createProcess = function (configurationOrName) {
        var _this = this;
        if (this.model.getProcesses().length === 0) {
            // Repl shouldn't be cleared if a process is already running since the repl is shared.
            this.removeReplExpressions();
        }
        var sessionId = uuid_1.generateUuid();
        this.setStateAndEmit(sessionId, debug.State.Initializing);
        return this.textFileService.saveAll() // make sure all dirty files are saved
            .then(function () { return _this.configurationService.reloadConfiguration() // make sure configuration is up to date
            .then(function () { return _this.extensionService.onReady()
            .then(function () {
            var compound = typeof configurationOrName === 'string' ? _this.configurationManager.getCompound(configurationOrName) : null;
            if (compound) {
                if (!compound.configurations) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls.localize('compoundMustHaveConfigurationNames', "Compound must have \"configurationNames\" attribute set in order to start multiple configurations.")));
                }
                return winjs_base_1.TPromise.join(compound.configurations.map(function (name) { return _this.createProcess(name); }));
            }
            return _this.configurationManager.getConfiguration(configurationOrName).then(function (configuration) {
                if (!configuration) {
                    return _this.configurationManager.openConfigFile(false).then(function (openend) {
                        if (openend) {
                            _this.messageService.show(severity_1.default.Info, nls.localize('NewLaunchConfig', "Please set up the launch configuration file for your application."));
                        }
                    });
                }
                if (!_this.configurationManager.getAdapter(configuration.type)) {
                    return configuration.type ? winjs_base_1.TPromise.wrapError(new Error(nls.localize('debugTypeNotSupported', "Configured debug type '{0}' is not supported.", configuration.type)))
                        : winjs_base_1.TPromise.wrapError(errors.create(nls.localize('debugTypeMissing', "Missing property 'type' for the chosen launch configuration."), { actions: [_this.instantiationService.createInstance(debugactions.ConfigureAction, debugactions.ConfigureAction.ID, debugactions.ConfigureAction.LABEL), message_1.CloseAction] }));
                }
                return _this.runPreLaunchTask(configuration.preLaunchTask).then(function (taskSummary) {
                    var errorCount = configuration.preLaunchTask ? _this.markerService.getStatistics().errors : 0;
                    var successExitCode = taskSummary && taskSummary.exitCode === 0;
                    var failureExitCode = taskSummary && taskSummary.exitCode !== undefined && taskSummary.exitCode !== 0;
                    if (successExitCode || (errorCount === 0 && !failureExitCode)) {
                        return _this.doCreateProcess(sessionId, configuration);
                    }
                    _this.messageService.show(severity_1.default.Error, {
                        message: errorCount > 1 ? nls.localize('preLaunchTaskErrors', "Build errors have been detected during preLaunchTask '{0}'.", configuration.preLaunchTask) :
                            errorCount === 1 ? nls.localize('preLaunchTaskError', "Build error has been detected during preLaunchTask '{0}'.", configuration.preLaunchTask) :
                                nls.localize('preLaunchTaskExitCode', "The preLaunchTask '{0}' terminated with exit code {1}.", configuration.preLaunchTask, taskSummary.exitCode),
                        actions: [
                            new actions_1.Action('debug.continue', nls.localize('debugAnyway', "Debug Anyway"), null, true, function () {
                                _this.messageService.hideAll();
                                return _this.doCreateProcess(sessionId, configuration);
                            }),
                            _this.instantiationService.createInstance(markersPanelActions_1.ToggleMarkersPanelAction, markersPanelActions_1.ToggleMarkersPanelAction.ID, markersPanelActions_1.ToggleMarkersPanelAction.LABEL),
                            message_1.CloseAction
                        ]
                    });
                }, function (err) {
                    if (err.code !== taskSystem_1.TaskErrors.NotConfigured) {
                        throw err;
                    }
                    _this.messageService.show(err.severity, {
                        message: err.message,
                        actions: [_this.taskService.configureAction(), message_1.CloseAction]
                    });
                });
            });
        }); }); });
    };
    DebugService.prototype.doCreateProcess = function (sessionId, configuration) {
        var _this = this;
        return this.telemetryService.getTelemetryInfo().then(function (info) {
            var telemetryInfo = Object.create(null);
            telemetryInfo['common.vscodemachineid'] = info.machineId;
            telemetryInfo['common.vscodesessionid'] = info.sessionId;
            return telemetryInfo;
        }).then(function (data) {
            var adapter = _this.configurationManager.getAdapter(configuration.type);
            var aiKey = adapter.aiKey, type = adapter.type;
            var publisher = adapter.extensionDescription.publisher;
            _this.customTelemetryService = null;
            var client;
            if (aiKey) {
                client = new ipc_cp_1.Client(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, {
                    serverName: 'Debug Telemetry',
                    timeout: 1000 * 60 * 5,
                    args: [publisher + "." + type, JSON.stringify(data), aiKey],
                    env: {
                        ELECTRON_RUN_AS_NODE: 1,
                        PIPE_LOGGING: 'true',
                        AMD_ENTRYPOINT: 'vs/workbench/parts/debug/node/telemetryApp'
                    }
                });
                var channel = client.getChannel('telemetryAppender');
                var appender = new telemetryIpc_1.TelemetryAppenderClient(channel);
                _this.customTelemetryService = new telemetryService_1.TelemetryService({ appender: appender }, _this.configurationService);
            }
            var session = _this.instantiationService.createInstance(rawDebugSession_1.RawDebugSession, sessionId, configuration.debugServer, adapter, _this.customTelemetryService);
            var process = _this.model.addProcess(configuration.name, session);
            if (_this.model.getProcesses().length > 1) {
                _this.viewModel.setMultiProcessView(true);
            }
            if (!_this.viewModel.focusedProcess) {
                _this.viewModel.setFocusedStackFrame(null, process);
                _this._onDidChangeState.fire();
            }
            _this.toDisposeOnSessionEnd[session.getId()] = [];
            if (client) {
                _this.toDisposeOnSessionEnd[session.getId()].push(client);
            }
            _this.registerSessionListeners(process, session);
            return session.initialize({
                adapterID: configuration.type,
                pathFormat: 'path',
                linesStartAt1: true,
                columnsStartAt1: true,
                supportsVariableType: true,
                supportsVariablePaging: true,
                supportsRunInTerminalRequest: true // #10574
            }).then(function (result) {
                if (session.disconnected) {
                    return winjs_base_1.TPromise.wrapError(new Error(nls.localize('debugAdapterCrash', "Debug adapter process has terminated unexpectedly")));
                }
                _this.model.setExceptionBreakpoints(session.configuration.capabilities.exceptionBreakpointFilters);
                return configuration.request === 'attach' ? session.attach(configuration) : session.launch(configuration);
            }).then(function (result) {
                if (session.disconnected) {
                    return winjs_base_1.TPromise.as(null);
                }
                if (configuration.internalConsoleOptions === 'openOnSessionStart' || (!_this.viewModel.changedWorkbenchViewState && configuration.internalConsoleOptions !== 'neverOpen')) {
                    _this.panelService.openPanel(debug.REPL_ID, false).done(undefined, errors.onUnexpectedError);
                }
                if (!_this.viewModel.changedWorkbenchViewState && _this.partService.isVisible(partService_1.Parts.SIDEBAR_PART)) {
                    // We only want to change the workbench view state on the first debug session #5738 and if the side bar is not hidden
                    _this.viewModel.changedWorkbenchViewState = true;
                    _this.viewletService.openViewlet(debug.VIEWLET_ID);
                }
                // Do not change status bar to orange if we are just running without debug.
                if (!configuration.noDebug) {
                    _this.partService.addClass('debugging');
                }
                _this.extensionService.activateByEvent("onDebug:" + configuration.type).done(null, errors.onUnexpectedError);
                _this.inDebugMode.set(true);
                _this.transitionToRunningState(session);
                _this.telemetryService.publicLog('debugSessionStart', {
                    type: configuration.type,
                    breakpointCount: _this.model.getBreakpoints().length,
                    exceptionBreakpoints: _this.model.getExceptionBreakpoints(),
                    watchExpressionsCount: _this.model.getWatchExpressions().length,
                    extensionName: adapter.extensionDescription.publisher + "." + adapter.extensionDescription.name,
                    isBuiltin: adapter.extensionDescription.isBuiltin
                });
            }).then(undefined, function (error) {
                if (error instanceof Error && error.message === 'Canceled') {
                    // Do not show 'canceled' error messages to the user #7906
                    return winjs_base_1.TPromise.as(null);
                }
                _this.telemetryService.publicLog('debugMisconfiguration', { type: configuration ? configuration.type : undefined });
                _this.setStateAndEmit(session.getId(), debug.State.Inactive);
                if (!session.disconnected) {
                    session.disconnect().done(null, errors.onUnexpectedError);
                }
                // Show the repl if some error got logged there #5870
                if (_this.model.getReplElements().length > 0) {
                    _this.panelService.openPanel(debug.REPL_ID, false).done(undefined, errors.onUnexpectedError);
                }
                var configureAction = _this.instantiationService.createInstance(debugactions.ConfigureAction, debugactions.ConfigureAction.ID, debugactions.ConfigureAction.LABEL);
                var actions = (error.actions && error.actions.length) ? error.actions.concat([configureAction]) : [message_1.CloseAction, configureAction];
                return winjs_base_1.TPromise.wrapError(errors.create(error.message, { actions: actions }));
            });
        });
    };
    DebugService.prototype.runPreLaunchTask = function (taskName) {
        var _this = this;
        if (!taskName) {
            return winjs_base_1.TPromise.as(null);
        }
        // run a task before starting a debug session
        return this.taskService.tasks().then(function (descriptions) {
            var filteredTasks = descriptions.filter(function (task) { return task.name === taskName; });
            if (filteredTasks.length !== 1) {
                return winjs_base_1.TPromise.wrapError(errors.create(nls.localize('DebugTaskNotFound', "Could not find the preLaunchTask \'{0}\'.", taskName), {
                    actions: [
                        _this.instantiationService.createInstance(debugactions.ConfigureAction, debugactions.ConfigureAction.ID, debugactions.ConfigureAction.LABEL),
                        _this.taskService.configureAction(),
                        message_1.CloseAction
                    ]
                }));
            }
            // task is already running - nothing to do.
            if (_this.lastTaskEvent && _this.lastTaskEvent.taskName === taskName) {
                return winjs_base_1.TPromise.as(null);
            }
            if (_this.lastTaskEvent) {
                // there is a different task running currently.
                return winjs_base_1.TPromise.wrapError(errors.create(nls.localize('differentTaskRunning', "There is a task {0} running. Can not run pre launch task {1}.", _this.lastTaskEvent.taskName, taskName)));
            }
            // no task running, execute the preLaunchTask.
            var taskPromise = _this.taskService.run(filteredTasks[0].id).then(function (result) {
                _this.lastTaskEvent = null;
                return result;
            }, function (err) {
                _this.lastTaskEvent = null;
            });
            if (filteredTasks[0].isWatching) {
                return new winjs_base_1.TPromise(function (c, e) { return _this.taskService.addOneTimeDisposableListener(taskService_1.TaskServiceEvents.Inactive, function () { return c(null); }); });
            }
            return taskPromise;
        });
    };
    DebugService.prototype.rawAttach = function (session, port) {
        var _this = this;
        if (session) {
            return session.attach({ port: port });
        }
        var sessionId = uuid_1.generateUuid();
        this.setStateAndEmit(sessionId, debug.State.Initializing);
        return this.configurationManager.getConfiguration(this.viewModel.selectedConfigurationName).then(function (config) {
            config.request = 'attach';
            config.port = port;
            _this.doCreateProcess(sessionId, config);
        });
    };
    DebugService.prototype.restartProcess = function (process) {
        var _this = this;
        if (!process) {
            return this.createProcess(this.viewModel.selectedConfigurationName);
        }
        if (process.session.configuration.capabilities.supportsRestartRequest) {
            return process.session.custom('restart', null);
        }
        return process.session.disconnect(true).then(function () {
            return new winjs_base_1.TPromise(function (c, e) {
                setTimeout(function () {
                    _this.createProcess(process.name).then(function () { return c(null); }, function (err) { return e(err); });
                }, 300);
            });
        });
    };
    DebugService.prototype.onSessionEnd = function (session) {
        var bpsExist = this.model.getBreakpoints().length > 0;
        this.telemetryService.publicLog('debugSessionStop', {
            type: session.configuration.type,
            success: session.emittedStopped || !bpsExist,
            sessionLengthInSeconds: session.getLengthInSeconds(),
            breakpointCount: this.model.getBreakpoints().length,
            watchExpressionsCount: this.model.getWatchExpressions().length
        });
        try {
            this.toDisposeOnSessionEnd[session.getId()] = lifecycle.dispose(this.toDisposeOnSessionEnd[session.getId()]);
        }
        catch (e) {
        }
        this.model.removeProcess(session.getId());
        this.focusStackFrameAndEvaluate(null).done(null, errors.onUnexpectedError);
        this.setStateAndEmit(session.getId(), debug.State.Inactive);
        if (this.model.getProcesses().length === 0) {
            this.partService.removeClass('debugging');
            // set breakpoints back to unverified since the session ended.
            var data_1 = {};
            this.model.getBreakpoints().forEach(function (bp) {
                data_1[bp.getId()] = { line: bp.lineNumber, verified: false };
            });
            this.model.updateBreakpoints(data_1);
            this.inDebugMode.reset();
            this.viewModel.setMultiProcessView(false);
            if (this.partService.isVisible(partService_1.Parts.SIDEBAR_PART) && this.configurationService.getConfiguration('debug').openExplorerOnEnd) {
                this.viewletService.openViewlet(files_2.VIEWLET_ID).done(null, errors.onUnexpectedError);
            }
        }
    };
    DebugService.prototype.getModel = function () {
        return this.model;
    };
    DebugService.prototype.getViewModel = function () {
        return this.viewModel;
    };
    DebugService.prototype.openOrRevealSource = function (sourceOrUri, lineNumber, preserveFocus, sideBySide) {
        var _this = this;
        var visibleEditors = this.editorService.getVisibleEditors();
        var uri = sourceOrUri instanceof debugSource_1.Source ? sourceOrUri.uri : sourceOrUri;
        var source = sourceOrUri instanceof debugSource_1.Source ? sourceOrUri : null;
        for (var i = 0; i < visibleEditors.length; i++) {
            var fileInput = editor_1.asFileEditorInput(visibleEditors[i].input);
            if ((fileInput && fileInput.getResource().toString() === uri.toString()) ||
                (visibleEditors[i].input instanceof debugEditorInputs_1.DebugStringEditorInput && visibleEditors[i].input.getResource().toString() === uri.toString())) {
                var control = visibleEditors[i].getControl();
                if (control) {
                    control.revealLineInCenterIfOutsideViewport(lineNumber);
                    control.setSelection({ startLineNumber: lineNumber, startColumn: 1, endLineNumber: lineNumber, endColumn: 1 });
                    this.editorGroupService.activateGroup(i);
                    if (!preserveFocus) {
                        this.editorGroupService.focusGroup(i);
                    }
                }
                return winjs_base_1.TPromise.as(null);
            }
        }
        var process = this.viewModel.focusedProcess;
        if (process && source && source.inMemory) {
            // internal module
            if (source.reference !== 0 && source.available) {
                return process.session.source({ sourceReference: source.reference }).then(function (response) {
                    var mime = response && response.body && response.body.mimeType ? response.body.mimeType : mime_1.guessMimeTypes(source.name)[0];
                    var inputValue = response && response.body ? response.body.content : '';
                    return _this.getDebugStringEditorInput(process, source, inputValue, mime);
                }, function (err) {
                    // Display the error from debug adapter using a temporary editor #8836
                    return _this.getDebugErrorEditorInput(process, source, err.message);
                }).then(function (editorInput) {
                    return _this.editorService.openEditor(editorInput, { preserveFocus: preserveFocus, selection: { startLineNumber: lineNumber, startColumn: 1, endLineNumber: lineNumber, endColumn: 1 } }, sideBySide);
                });
            }
            return this.sourceIsUnavailable(process, source, sideBySide);
        }
        if (debugSource_1.Source.isInMemory(uri)) {
            return winjs_base_1.TPromise.as(null);
        }
        return this.fileService.resolveFile(uri).then(function () {
            return _this.editorService.openEditor({
                resource: uri,
                options: {
                    selection: {
                        startLineNumber: lineNumber,
                        startColumn: 1,
                        endLineNumber: lineNumber,
                        endColumn: 1
                    },
                    preserveFocus: preserveFocus
                }
            }, sideBySide);
        }, function (err) { return _this.sourceIsUnavailable(process, source, sideBySide); });
    };
    DebugService.prototype.sourceIsUnavailable = function (process, source, sideBySide) {
        this.model.sourceIsUnavailable(source);
        var editorInput = this.getDebugErrorEditorInput(process, source, nls.localize('debugSourceNotAvailable', "Source {0} is not available.", source.name));
        return this.editorService.openEditor(editorInput, { preserveFocus: true }, sideBySide);
    };
    DebugService.prototype.getConfigurationManager = function () {
        return this.configurationManager;
    };
    DebugService.prototype.transitionToRunningState = function (session, threadId) {
        this.model.clearThreads(session.getId(), false, threadId);
        this.setStateAndEmit(session.getId(), session.requestType === debug.SessionRequestType.LAUNCH_NO_DEBUG ? debug.State.RunningNoDebug : debug.State.Running);
        this.focusStackFrameAndEvaluate(null).done(null, errors.onUnexpectedError);
    };
    DebugService.prototype.getDebugStringEditorInput = function (process, source, value, mtype) {
        var result = this.instantiationService.createInstance(debugEditorInputs_1.DebugStringEditorInput, source.name, source.uri, source.origin, value, mtype, void 0);
        this.toDisposeOnSessionEnd[process.getId()].push(result);
        return result;
    };
    DebugService.prototype.getDebugErrorEditorInput = function (process, source, value) {
        var result = this.instantiationService.createInstance(debugEditorInputs_1.DebugErrorEditorInput, source.name, value);
        this.toDisposeOnSessionEnd[process.getId()].push(result);
        return result;
    };
    DebugService.prototype.sendAllBreakpoints = function (process) {
        var _this = this;
        return winjs_base_1.TPromise.join(arrays_1.distinct(this.model.getBreakpoints(), function (bp) { return bp.uri.toString(); }).map(function (bp) { return _this.sendBreakpoints(bp.uri, false, process); }))
            .then(function () { return _this.sendFunctionBreakpoints(process); })
            .then(function () { return _this.sendExceptionBreakpoints(process); });
    };
    DebugService.prototype.sendBreakpoints = function (modelUri, sourceModified, targetProcess) {
        var _this = this;
        if (sourceModified === void 0) { sourceModified = false; }
        var sendBreakpointsToProcess = function (process) {
            var session = process.session;
            if (!session.readyForBreakpoints) {
                return winjs_base_1.TPromise.as(null);
            }
            if (_this.textFileService.isDirty(modelUri)) {
                // Only send breakpoints for a file once it is not dirty #8077
                _this.breakpointsToSendOnResourceSaved[modelUri.toString()] = true;
                return winjs_base_1.TPromise.as(null);
            }
            var breakpointsToSend = arrays_1.distinct(_this.model.getBreakpoints().filter(function (bp) { return _this.model.areBreakpointsActivated() && bp.enabled && bp.uri.toString() === modelUri.toString(); }), function (bp) { return bp.lineNumber.toString(); });
            var rawSource;
            for (var _i = 0, _a = process.getAllThreads(); _i < _a.length; _i++) {
                var t = _a[_i];
                var callStack = t.getCallStack();
                if (callStack) {
                    for (var _b = 0, callStack_1 = callStack; _b < callStack_1.length; _b++) {
                        var sf = callStack_1[_b];
                        if (sf.source.uri.toString() === modelUri.toString()) {
                            rawSource = sf.source.raw;
                            break;
                        }
                    }
                }
            }
            rawSource = rawSource || { path: paths.normalize(modelUri.fsPath, true), name: paths.basename(modelUri.fsPath) };
            return session.setBreakpoints({
                source: rawSource,
                lines: breakpointsToSend.map(function (bp) { return bp.lineNumber; }),
                breakpoints: breakpointsToSend.map(function (bp) { return ({ line: bp.lineNumber, condition: bp.condition, hitCondition: bp.hitCondition }); }),
                sourceModified: sourceModified
            }).then(function (response) {
                if (!response || !response.body) {
                    return;
                }
                var data = {};
                for (var i = 0; i < breakpointsToSend.length; i++) {
                    data[breakpointsToSend[i].getId()] = response.body.breakpoints[i];
                }
                _this.model.updateBreakpoints(data);
            });
        };
        return this.sendToOneOrAllProcesses(targetProcess, sendBreakpointsToProcess);
    };
    DebugService.prototype.sendFunctionBreakpoints = function (targetProcess) {
        var _this = this;
        var sendFunctionBreakpointsToProcess = function (process) {
            var session = process.session;
            if (!session.readyForBreakpoints || !session.configuration.capabilities.supportsFunctionBreakpoints) {
                return winjs_base_1.TPromise.as(null);
            }
            var breakpointsToSend = _this.model.getFunctionBreakpoints().filter(function (fbp) { return fbp.enabled && _this.model.areBreakpointsActivated(); });
            return session.setFunctionBreakpoints({ breakpoints: breakpointsToSend }).then(function (response) {
                if (!response || !response.body) {
                    return;
                }
                var data = {};
                for (var i = 0; i < breakpointsToSend.length; i++) {
                    data[breakpointsToSend[i].getId()] = response.body.breakpoints[i];
                }
                _this.model.updateFunctionBreakpoints(data);
            });
        };
        return this.sendToOneOrAllProcesses(targetProcess, sendFunctionBreakpointsToProcess);
    };
    DebugService.prototype.sendExceptionBreakpoints = function (targetProcess) {
        var _this = this;
        var sendExceptionBreakpointsToProcess = function (process) {
            var session = process.session;
            if (!session.readyForBreakpoints || _this.model.getExceptionBreakpoints().length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            var enabledExceptionBps = _this.model.getExceptionBreakpoints().filter(function (exb) { return exb.enabled; });
            return session.setExceptionBreakpoints({ filters: enabledExceptionBps.map(function (exb) { return exb.filter; }) });
        };
        return this.sendToOneOrAllProcesses(targetProcess, sendExceptionBreakpointsToProcess);
    };
    DebugService.prototype.sendToOneOrAllProcesses = function (process, send) {
        if (process) {
            return send(process);
        }
        return winjs_base_1.TPromise.join(this.model.getProcesses().map(function (p) { return send(p); })).then(function () { return void 0; });
    };
    DebugService.prototype.onFileChanges = function (fileChangesEvent) {
        var _this = this;
        this.model.removeBreakpoints(this.model.getBreakpoints().filter(function (bp) {
            return fileChangesEvent.contains(bp.uri, files_1.FileChangeType.DELETED);
        }));
        fileChangesEvent.getUpdated().forEach(function (event) {
            if (_this.breakpointsToSendOnResourceSaved[event.resource.toString()]) {
                _this.breakpointsToSendOnResourceSaved[event.resource.toString()] = false;
                _this.sendBreakpoints(event.resource, true).done(null, errors.onUnexpectedError);
            }
        });
    };
    DebugService.prototype.store = function () {
        this.storageService.store(DEBUG_BREAKPOINTS_KEY, JSON.stringify(this.model.getBreakpoints()), storage_1.StorageScope.WORKSPACE);
        this.storageService.store(DEBUG_BREAKPOINTS_ACTIVATED_KEY, this.model.areBreakpointsActivated() ? 'true' : 'false', storage_1.StorageScope.WORKSPACE);
        this.storageService.store(DEBUG_FUNCTION_BREAKPOINTS_KEY, JSON.stringify(this.model.getFunctionBreakpoints()), storage_1.StorageScope.WORKSPACE);
        this.storageService.store(DEBUG_EXCEPTION_BREAKPOINTS_KEY, JSON.stringify(this.model.getExceptionBreakpoints()), storage_1.StorageScope.WORKSPACE);
        this.storageService.store(DEBUG_SELECTED_CONFIG_NAME_KEY, this.viewModel.selectedConfigurationName, storage_1.StorageScope.WORKSPACE);
        this.storageService.store(DEBUG_WATCH_EXPRESSIONS_KEY, JSON.stringify(this.model.getWatchExpressions().map(function (we) { return ({ name: we.name, id: we.getId() }); })), storage_1.StorageScope.WORKSPACE);
    };
    DebugService.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.toDisposeOnSessionEnd).forEach(function (key) { return lifecycle.dispose(_this.toDisposeOnSessionEnd[key]); });
        this.toDispose = lifecycle.dispose(this.toDispose);
    };
    return DebugService;
}());
DebugService = __decorate([
    __param(0, storage_1.IStorageService),
    __param(1, editorService_1.IWorkbenchEditorService),
    __param(2, textfiles_1.ITextFileService),
    __param(3, viewlet_1.IViewletService),
    __param(4, panelService_1.IPanelService),
    __param(5, files_1.IFileService),
    __param(6, message_1.IMessageService),
    __param(7, partService_1.IPartService),
    __param(8, windows_1.IWindowsService),
    __param(9, windowService_1.IWindowIPCService),
    __param(10, telemetry_1.ITelemetryService),
    __param(11, workspace_1.IWorkspaceContextService),
    __param(12, contextkey_1.IContextKeyService),
    __param(13, groupService_1.IEditorGroupService),
    __param(14, event_2.IEventService),
    __param(15, lifecycle_1.ILifecycleService),
    __param(16, instantiation_1.IInstantiationService),
    __param(17, extensions_1.IExtensionService),
    __param(18, markers_1.IMarkerService),
    __param(19, taskService_1.ITaskService),
    __param(20, configuration_1.IConfigurationService)
], DebugService);
exports.DebugService = DebugService;
