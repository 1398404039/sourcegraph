/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var builder_1 = require("vs/base/browser/builder");
var uri_1 = require("vs/base/common/uri");
var async_1 = require("vs/base/common/async");
var errors = require("vs/base/common/errors");
var labels = require("vs/base/common/labels");
var paths = require("vs/base/common/paths");
var actionBarRegistry_1 = require("vs/workbench/browser/actionBarRegistry");
var treeImpl_1 = require("vs/base/parts/tree/browser/treeImpl");
var files_1 = require("vs/workbench/parts/files/common/files");
var files_2 = require("vs/platform/files/common/files");
var fileActions_1 = require("vs/workbench/parts/files/browser/fileActions");
var explorerViewer_1 = require("vs/workbench/parts/files/browser/views/explorerViewer");
var lifecycle = require("vs/base/common/lifecycle");
var editor_1 = require("vs/workbench/common/editor");
var diffEditorInput_1 = require("vs/workbench/common/editor/diffEditorInput");
var untitledEditorInput_1 = require("vs/workbench/common/editor/untitledEditorInput");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var DOM = require("vs/base/browser/dom");
var viewlet_1 = require("vs/workbench/browser/viewlet");
var explorerViewModel_1 = require("vs/workbench/parts/files/common/explorerViewModel");
var listService_1 = require("vs/platform/list/browser/listService");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var partService_1 = require("vs/workbench/services/part/common/partService");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var progress_1 = require("vs/platform/progress/common/progress");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var message_1 = require("vs/platform/message/common/message");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var resourceContextKey_1 = require("vs/workbench/common/resourceContextKey");
var themeService_1 = require("vs/workbench/services/themes/common/themeService");
var ExplorerView = (function (_super) {
    __extends(ExplorerView, _super);
    function ExplorerView(viewletState, actionRunner, settings, headerSize, messageService, contextMenuService, instantiationService, editorGroupService, contextService, progressService, listService, editorService, fileService, partService, keybindingService, contextKeyService, configurationService, themeService) {
        var _this = _super.call(this, actionRunner, false, nls.localize('explorerSection', "Files Explorer Section"), messageService, keybindingService, contextMenuService, headerSize) || this;
        _this.instantiationService = instantiationService;
        _this.editorGroupService = editorGroupService;
        _this.contextService = contextService;
        _this.progressService = progressService;
        _this.listService = listService;
        _this.editorService = editorService;
        _this.fileService = fileService;
        _this.partService = partService;
        _this.configurationService = configurationService;
        _this.themeService = themeService;
        _this.settings = settings;
        _this.viewletState = viewletState;
        _this.actionRunner = actionRunner;
        _this.autoReveal = true;
        _this.explorerRefreshDelayer = new async_1.ThrottledDelayer(ExplorerView.EXPLORER_FILE_CHANGES_REFRESH_DELAY);
        _this.explorerImportDelayer = new async_1.ThrottledDelayer(ExplorerView.EXPLORER_IMPORT_REFRESH_DELAY);
        _this.resourceContext = instantiationService.createInstance(resourceContextKey_1.ResourceContextKey);
        _this.folderContext = files_1.ExplorerFolderContext.bindTo(contextKeyService);
        _this.filesExplorerFocussedContext = files_1.FilesExplorerFocussedContext.bindTo(contextKeyService);
        _this.explorerFocussedContext = files_1.ExplorerFocussedContext.bindTo(contextKeyService);
        return _this;
    }
    ExplorerView.prototype.renderHeader = function (container) {
        var titleDiv = builder_1.$('div.title').appendTo(container);
        builder_1.$('span').text(this.contextService.getWorkspace().name).title(labels.getPathLabel(this.contextService.getWorkspace().resource.fsPath)).appendTo(titleDiv);
        _super.prototype.renderHeader.call(this, container);
    };
    ExplorerView.prototype.renderBody = function (container) {
        var _this = this;
        this.treeContainer = _super.prototype.renderViewTree.call(this, container);
        DOM.addClass(this.treeContainer, 'explorer-folders-view');
        DOM.addClass(this.treeContainer, 'show-file-icons');
        this.tree = this.createViewer(builder_1.$(this.treeContainer));
        if (this.toolBar) {
            this.toolBar.setActions(actionBarRegistry_1.prepareActions(this.getActions()), [])();
        }
        var onFileIconThemeChange = function (fileIconTheme) {
            DOM.toggleClass(_this.treeContainer, 'align-icons-and-twisties', fileIconTheme.hasFileIcons && !fileIconTheme.hasFolderIcons);
        };
        this.themeService.onDidFileIconThemeChange(onFileIconThemeChange);
        onFileIconThemeChange(this.themeService.getFileIconTheme());
    };
    ExplorerView.prototype.getActions = function () {
        var actions = [];
        actions.push(this.instantiationService.createInstance(fileActions_1.NewFileAction, this.getViewer(), null));
        actions.push(this.instantiationService.createInstance(fileActions_1.NewFolderAction, this.getViewer(), null));
        actions.push(this.instantiationService.createInstance(fileActions_1.RefreshViewExplorerAction, this, 'explorer-action refresh-explorer'));
        actions.push(this.instantiationService.createInstance(viewlet_1.CollapseAction, this.getViewer(), true, 'explorer-action collapse-explorer'));
        // Set Order
        for (var i = 0; i < actions.length; i++) {
            var action = actions[i];
            action.order = 10 * (i + 1);
        }
        return actions;
    };
    ExplorerView.prototype.create = function () {
        var _this = this;
        // Update configuration
        var configuration = this.configurationService.getConfiguration();
        this.onConfigurationUpdated(configuration);
        // Load and Fill Viewer
        return this.doRefresh().then(function () {
            // When the explorer viewer is loaded, listen to changes to the editor input
            _this.toDispose.push(_this.editorGroupService.onEditorsChanged(function () { return _this.onEditorsChanged(); }));
            // Also handle configuration updates
            _this.toDispose.push(_this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config, true); }));
        });
    };
    ExplorerView.prototype.onEditorsChanged = function () {
        if (!this.autoReveal) {
            return; // do not touch selection or focus if autoReveal === false
        }
        var clearSelection = true;
        var clearFocus = false;
        // Handle files
        var activeFile = this.getActiveFile();
        if (activeFile) {
            // Always remember last opened file
            this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = activeFile.toString();
            // Select file if input is inside workspace
            if (this.isVisible && this.contextService.isInsideWorkspace(activeFile)) {
                var selection = this.hasSelection(activeFile);
                if (!selection) {
                    this.select(activeFile).done(null, errors.onUnexpectedError);
                }
                clearSelection = false;
            }
        }
        // Handle closed or untitled file (convince explorer to not reopen any file when getting visible)
        var activeInput = this.editorService.getActiveEditorInput();
        if (activeInput instanceof untitledEditorInput_1.UntitledEditorInput || !activeInput) {
            this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = void 0;
            clearFocus = true;
        }
        // Otherwise clear
        if (clearSelection) {
            this.explorerViewer.clearSelection();
        }
        if (clearFocus) {
            this.explorerViewer.clearFocus();
        }
    };
    ExplorerView.prototype.onConfigurationUpdated = function (configuration, refresh) {
        if (this.isDisposed) {
            return; // guard against possible race condition when config change causes recreate of views
        }
        this.autoReveal = configuration && configuration.explorer && configuration.explorer.autoReveal;
        // Push down config updates to components of viewer
        var needsRefresh = false;
        if (this.filter) {
            needsRefresh = this.filter.updateConfiguration(configuration);
        }
        // Refresh viewer as needed
        if (refresh && needsRefresh) {
            this.doRefresh().done(null, errors.onUnexpectedError);
        }
    };
    ExplorerView.prototype.focusBody = function () {
        var keepFocus = false;
        // Make sure the current selected element is revealed
        if (this.explorerViewer) {
            if (this.autoReveal) {
                var selection = this.explorerViewer.getSelection();
                if (selection.length > 0) {
                    this.reveal(selection[0], 0.5).done(null, errors.onUnexpectedError);
                }
            }
            // Pass Focus to Viewer
            this.explorerViewer.DOMFocus();
            keepFocus = true;
        }
        // Open the focused element in the editor if there is currently no file opened
        var activeFile = this.getActiveFile();
        if (!activeFile) {
            this.openFocusedElement(keepFocus);
        }
    };
    ExplorerView.prototype.setVisible = function (visible) {
        var _this = this;
        return _super.prototype.setVisible.call(this, visible).then(function () {
            // Show
            if (visible) {
                // If a refresh was requested and we are now visible, run it
                var refreshPromise = winjs_base_1.TPromise.as(null);
                if (_this.shouldRefresh) {
                    refreshPromise = _this.doRefresh();
                    _this.shouldRefresh = false; // Reset flag
                }
                if (!_this.autoReveal) {
                    return refreshPromise; // do not react to setVisible call if autoReveal === false
                }
                // Always select the current navigated file in explorer if input is file editor input
                // unless autoReveal is set to false
                var activeFile_1 = _this.getActiveFile();
                if (activeFile_1) {
                    return refreshPromise.then(function () {
                        return _this.select(activeFile_1);
                    });
                }
                // Return now if the workbench has not yet been created - in this case the workbench takes care of restoring last used editors
                if (!_this.partService.isCreated()) {
                    return winjs_base_1.TPromise.as(null);
                }
                // Otherwise restore last used file: By lastActiveFileResource
                var lastActiveFileResource = void 0;
                if (_this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE]) {
                    lastActiveFileResource = uri_1.default.parse(_this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE]);
                }
                if (lastActiveFileResource && _this.root && _this.root.find(lastActiveFileResource)) {
                    _this.editorService.openEditor({ resource: lastActiveFileResource, options: { revealIfVisible: true } }).done(null, errors.onUnexpectedError);
                    return refreshPromise;
                }
                // Otherwise restore last used file: By Explorer selection
                return refreshPromise.then(function () {
                    _this.openFocusedElement();
                });
            }
            return undefined;
        });
    };
    ExplorerView.prototype.openFocusedElement = function (preserveFocus) {
        var stat = this.explorerViewer.getFocus();
        if (stat && !stat.isDirectory) {
            this.editorService.openEditor({ resource: stat.resource, options: { preserveFocus: preserveFocus, revealIfVisible: true } }).done(null, errors.onUnexpectedError);
        }
    };
    ExplorerView.prototype.getActiveFile = function () {
        var input = this.editorService.getActiveEditorInput();
        // ignore diff editor inputs (helps to get out of diffing when returning to explorer)
        if (input instanceof diffEditorInput_1.DiffEditorInput) {
            return null;
        }
        // check for files
        return editor_1.toResource(input, { supportSideBySide: true, filter: 'file' });
    };
    Object.defineProperty(ExplorerView.prototype, "root", {
        get: function () {
            return this.explorerViewer ? this.explorerViewer.getInput() : null;
        },
        enumerable: true,
        configurable: true
    });
    ExplorerView.prototype.createViewer = function (container) {
        var _this = this;
        var dataSource = this.instantiationService.createInstance(explorerViewer_1.FileDataSource);
        var renderer = this.instantiationService.createInstance(explorerViewer_1.FileRenderer, this.viewletState, this.actionRunner);
        var controller = this.instantiationService.createInstance(explorerViewer_1.FileController, this.viewletState);
        var sorter = new explorerViewer_1.FileSorter();
        this.filter = this.instantiationService.createInstance(explorerViewer_1.FileFilter);
        var dnd = this.instantiationService.createInstance(explorerViewer_1.FileDragAndDrop);
        var accessibilityProvider = this.instantiationService.createInstance(explorerViewer_1.FileAccessibilityProvider);
        this.explorerViewer = new treeImpl_1.Tree(container.getHTMLElement(), {
            dataSource: dataSource,
            renderer: renderer,
            controller: controller,
            sorter: sorter,
            filter: this.filter,
            dnd: dnd,
            accessibilityProvider: accessibilityProvider
        }, {
            autoExpandSingleChildren: true,
            ariaLabel: nls.localize('treeAriaLabel', "Files Explorer"),
            twistiePixels: 12,
            showTwistie: false,
            keyboardSupport: false
        });
        this.toDispose.push(lifecycle.toDisposable(function () { return renderer.dispose(); }));
        // Register to list service
        this.toDispose.push(this.listService.register(this.explorerViewer, [this.explorerFocussedContext, this.filesExplorerFocussedContext]));
        // Update Viewer based on File Change Events
        this.toDispose.push(this.fileService.onAfterOperation(function (e) { return _this.onFileOperation(e); }));
        this.toDispose.push(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));
        // Update resource context based on focused element
        this.toDispose.push(this.explorerViewer.addListener2('focus', function (e) {
            _this.resourceContext.set(e.focus && e.focus.resource);
            _this.folderContext.set(e.focus && e.focus.isDirectory);
        }));
        // Open when selecting via keyboard
        this.toDispose.push(this.explorerViewer.addListener2('selection', function (event) {
            if (event && event.payload && event.payload.origin === 'keyboard') {
                var element = _this.tree.getFocus();
                if (element instanceof explorerViewModel_1.FileStat) {
                    if (element.isDirectory) {
                        _this.explorerViewer.toggleExpansion(element);
                    }
                    controller.openEditor(element, { pinned: false, sideBySide: false, preserveFocus: false });
                }
            }
        }));
        return this.explorerViewer;
    };
    ExplorerView.prototype.getOptimalWidth = function () {
        var parentNode = this.explorerViewer.getHTMLElement();
        var childNodes = [].slice.call(parentNode.querySelectorAll('.explorer-item > a'));
        return DOM.getLargestChildWidth(parentNode, childNodes);
    };
    ExplorerView.prototype.onFileOperation = function (e) {
        var _this = this;
        var modelElement;
        var parent;
        var parentResource;
        var parentElement;
        // Add
        if (e.operation === files_2.FileOperation.CREATE || e.operation === files_2.FileOperation.IMPORT || e.operation === files_2.FileOperation.COPY) {
            var addedElement = e.target;
            parentResource = uri_1.default.file(paths.dirname(addedElement.resource.fsPath));
            parentElement = this.root.find(parentResource);
            if (parentElement) {
                // Add the new file to its parent (Model)
                var childElement_1 = explorerViewModel_1.FileStat.create(addedElement);
                parentElement.removeChild(childElement_1); // make sure to remove any previous version of the file if any
                parentElement.addChild(childElement_1);
                // Refresh the Parent (View)
                this.explorerViewer.refresh(parentElement).then(function () {
                    return _this.reveal(childElement_1, 0.5).then(function () {
                        // Focus new element
                        _this.explorerViewer.setFocus(childElement_1);
                    });
                }).done(null, errors.onUnexpectedError);
            }
        }
        else if (e.operation === files_2.FileOperation.MOVE) {
            var oldResource = e.resource;
            var newElement = e.target;
            var oldParentResource = uri_1.default.file(paths.dirname(oldResource.fsPath));
            var newParentResource = uri_1.default.file(paths.dirname(newElement.resource.fsPath));
            // Only update focus if renamed/moved element is selected
            var restoreFocus_1 = false;
            var focus_1 = this.explorerViewer.getFocus();
            if (focus_1 && focus_1.resource && focus_1.resource.toString() === oldResource.toString()) {
                restoreFocus_1 = true;
            }
            // Handle Rename
            if (oldParentResource && newParentResource && oldParentResource.toString() === newParentResource.toString()) {
                modelElement = this.root.find(oldResource);
                if (modelElement) {
                    // Rename File (Model)
                    modelElement.rename(newElement);
                    // Update Parent (View)
                    parent = modelElement.parent;
                    if (parent) {
                        this.explorerViewer.refresh(parent).done(function () {
                            // Select in Viewer if set
                            if (restoreFocus_1) {
                                _this.explorerViewer.setFocus(modelElement);
                            }
                        }, errors.onUnexpectedError);
                    }
                }
            }
            else if (oldParentResource && newParentResource) {
                var oldParent_1 = this.root.find(oldParentResource);
                var newParent_1 = this.root.find(newParentResource);
                modelElement = this.root.find(oldResource);
                if (oldParent_1 && newParent_1 && modelElement) {
                    // Move in Model
                    modelElement.move(newParent_1, function (callback) {
                        // Update old parent
                        _this.explorerViewer.refresh(oldParent_1, true).done(callback, errors.onUnexpectedError);
                    }, function () {
                        // Update new parent
                        _this.explorerViewer.refresh(newParent_1, true).done(function () { return _this.explorerViewer.expand(newParent_1); }, errors.onUnexpectedError);
                    });
                }
            }
        }
        else if (e.operation === files_2.FileOperation.DELETE) {
            modelElement = this.root.find(e.resource);
            if (modelElement && modelElement.parent) {
                parent = modelElement.parent;
                // Remove Element from Parent (Model)
                parent.removeChild(modelElement);
                // Refresh Parent (View)
                var restoreFocus_2 = this.explorerViewer.isDOMFocused();
                this.explorerViewer.refresh(parent).done(function () {
                    // Ensure viewer has keyboard focus if event originates from viewer
                    if (restoreFocus_2) {
                        _this.explorerViewer.DOMFocus();
                    }
                }, errors.onUnexpectedError);
            }
        }
    };
    ExplorerView.prototype.onFileChanges = function (e) {
        var _this = this;
        // Ensure memento state does not capture a deleted file (we run this from a timeout because
        // delete events can result in UI activity that will fill the memento again when multiple
        // editors are closing)
        setTimeout(function () {
            var lastActiveResource = _this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE];
            if (lastActiveResource && e.contains(uri_1.default.parse(lastActiveResource), files_2.FileChangeType.DELETED)) {
                _this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = null;
            }
        });
        // Check if an explorer refresh is necessary (delayed to give internal events a chance to react first)
        // Note: there is no guarantee when the internal events are fired vs real ones. Code has to deal with the fact that one might
        // be fired first over the other or not at all.
        setTimeout(function () {
            if (!_this.shouldRefresh && _this.shouldRefreshFromEvent(e)) {
                _this.refreshFromEvent();
            }
        }, ExplorerView.EXPLORER_FILE_CHANGES_REACT_DELAY);
    };
    ExplorerView.prototype.shouldRefreshFromEvent = function (e) {
        // Filter to the ones we care
        e = this.filterToAddRemovedOnWorkspacePath(e, function (event, segments) {
            if (segments[0] !== ExplorerView.COMMON_SCM_FOLDERS[0] &&
                segments[0] !== ExplorerView.COMMON_SCM_FOLDERS[1] &&
                segments[0] !== ExplorerView.COMMON_SCM_FOLDERS[2]) {
                return true; // we like all things outside common SCM folders
            }
            return segments.length === 1; // otherwise we only care about the SCM folder itself
        });
        // We only ever refresh from files/folders that got added or deleted
        if (e.gotAdded() || e.gotDeleted()) {
            var added = e.getAdded();
            var deleted = e.getDeleted();
            if (!this.root) {
                return false;
            }
            // Check added: Refresh if added file/folder is not part of resolved root and parent is part of it
            var ignoredPaths = {};
            for (var i = 0; i < added.length; i++) {
                var change = added[i];
                if (!this.contextService.isInsideWorkspace(change.resource)) {
                    continue; // out of workspace file
                }
                // Find parent
                var parent_1 = paths.dirname(change.resource.fsPath);
                // Continue if parent was already determined as to be ignored
                if (ignoredPaths[parent_1]) {
                    continue;
                }
                // Compute if parent is visible and added file not yet part of it
                var parentStat = this.root.find(uri_1.default.file(parent_1));
                if (parentStat && parentStat.isDirectoryResolved && !this.root.find(change.resource)) {
                    return true;
                }
                // Keep track of path that can be ignored for faster lookup
                if (!parentStat || !parentStat.isDirectoryResolved) {
                    ignoredPaths[parent_1] = true;
                }
            }
            // Check deleted: Refresh if deleted file/folder part of resolved root
            for (var j = 0; j < deleted.length; j++) {
                var del = deleted[j];
                if (!this.contextService.isInsideWorkspace(del.resource)) {
                    continue; // out of workspace file
                }
                if (this.root.find(del.resource)) {
                    return true;
                }
            }
        }
        return false;
    };
    ExplorerView.prototype.filterToAddRemovedOnWorkspacePath = function (e, fn) {
        var _this = this;
        return new files_2.FileChangesEvent(e.changes.filter(function (change) {
            if (change.type === files_2.FileChangeType.UPDATED) {
                return false; // we only want added / removed
            }
            var workspacePath = _this.contextService.toWorkspaceRelativePath(change.resource);
            if (!workspacePath) {
                return false; // not inside workspace
            }
            var segments = workspacePath.split(/\//);
            return fn(change, segments);
        }));
    };
    ExplorerView.prototype.refreshFromEvent = function () {
        var _this = this;
        if (this.isVisible) {
            this.explorerRefreshDelayer.trigger(function () {
                if (!_this.explorerViewer.getHighlight()) {
                    return _this.doRefresh();
                }
                return winjs_base_1.TPromise.as(null);
            }).done(null, errors.onUnexpectedError);
        }
        else {
            this.shouldRefresh = true;
        }
    };
    /**
     * Refresh the contents of the explorer to get up to date data from the disk about the file structure.
     */
    ExplorerView.prototype.refresh = function (workspaceUpdated) {
        var _this = this;
        if (!this.explorerViewer || this.explorerViewer.getHighlight()) {
            return winjs_base_1.TPromise.as(null);
        }
        // Focus
        this.explorerViewer.DOMFocus();
        // Find resource to focus from active editor input if set
        var resourceToFocus;
        if (this.autoReveal) {
            resourceToFocus = this.getActiveFile();
            if (!resourceToFocus) {
                var selection = this.explorerViewer.getSelection();
                if (selection && selection.length === 1) {
                    resourceToFocus = selection[0].resource;
                }
            }
        }
        return this.doRefresh(workspaceUpdated).then(function () {
            if (resourceToFocus) {
                return _this.select(resourceToFocus, true);
            }
            return winjs_base_1.TPromise.as(null);
        });
    };
    ExplorerView.prototype.doRefresh = function (workspaceUpdated) {
        var _this = this;
        var targetsToResolve = [];
        var targetsToExpand = [];
        if (this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES]) {
            targetsToExpand = this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES].map(function (e) { return uri_1.default.parse(e); });
        }
        // First time refresh: Receive target through active editor input or selection and also include settings from previous session
        if (!this.root) {
            var activeFile = this.getActiveFile();
            if (activeFile) {
                targetsToResolve.push(activeFile);
            }
            if (targetsToExpand.length) {
                targetsToResolve.push.apply(targetsToResolve, targetsToExpand);
            }
        }
        else {
            this.getResolvedDirectories(this.root, targetsToResolve);
        }
        // Load Root Stat with given target path configured
        var options = { resolveTo: targetsToResolve };
        var promise = this.fileService.resolveFile(this.contextService.getWorkspace().resource, options).then(function (stat) {
            var explorerPromise;
            // Convert to model
            var modelStat = explorerViewModel_1.FileStat.create(stat, options.resolveTo);
            // First time refresh: The stat becomes the input of the viewer
            if (!_this.root || workspaceUpdated) {
                explorerPromise = _this.explorerViewer.setInput(modelStat).then(function () {
                    // Make sure to expand all folders that where expanded in the previous session
                    if (targetsToExpand) {
                        return _this.explorerViewer.expandAll(targetsToExpand.map(function (expand) { return _this.root.find(expand); }));
                    }
                    return winjs_base_1.TPromise.as(null);
                });
            }
            else {
                explorerViewModel_1.FileStat.mergeLocalWithDisk(modelStat, _this.root);
                explorerPromise = _this.explorerViewer.refresh(_this.root);
            }
            return explorerPromise;
        }, function (e) { return winjs_base_1.TPromise.wrapError(e); });
        this.progressService.showWhile(promise, this.partService.isCreated() ? 800 : 3200 /* less ugly initial startup */);
        return promise;
    };
    /**
     * Given a stat, fills an array of path that make all folders below the stat that are resolved directories.
     */
    ExplorerView.prototype.getResolvedDirectories = function (stat, resolvedDirectories) {
        if (stat.isDirectoryResolved) {
            if (stat.resource.toString() !== this.contextService.getWorkspace().resource.toString()) {
                // Drop those path which are parents of the current one
                for (var i = resolvedDirectories.length - 1; i >= 0; i--) {
                    var resource = resolvedDirectories[i];
                    if (paths.isEqualOrParent(stat.resource.fsPath, resource.fsPath)) {
                        resolvedDirectories.splice(i);
                    }
                }
                // Add to the list of path to resolve
                resolvedDirectories.push(stat.resource);
            }
            // Recurse into children
            for (var i = 0; i < stat.children.length; i++) {
                var child = stat.children[i];
                this.getResolvedDirectories(child, resolvedDirectories);
            }
        }
    };
    /**
     * Selects and reveal the file element provided by the given resource if its found in the explorer. Will try to
     * resolve the path from the disk in case the explorer is not yet expanded to the file yet.
     */
    ExplorerView.prototype.select = function (resource, reveal) {
        var _this = this;
        if (reveal === void 0) { reveal = this.autoReveal; }
        // Require valid path
        if (!resource || resource.toString() === this.contextService.getWorkspace().resource.toString()) {
            return winjs_base_1.TPromise.as(null);
        }
        // If path already selected, just reveal and return
        var selection = this.hasSelection(resource);
        if (selection) {
            return reveal ? this.reveal(selection, 0.5) : winjs_base_1.TPromise.as(null);
        }
        // First try to get the stat object from the input to avoid a roundtrip
        if (!this.root) {
            return winjs_base_1.TPromise.as(null);
        }
        var fileStat = this.root.find(resource);
        if (fileStat) {
            return this.doSelect(fileStat, reveal);
        }
        // Stat needs to be resolved first and then revealed
        var options = { resolveTo: [resource] };
        return this.fileService.resolveFile(this.contextService.getWorkspace().resource, options).then(function (stat) {
            // Convert to model
            var modelStat = explorerViewModel_1.FileStat.create(stat, options.resolveTo);
            // Update Input with disk Stat
            explorerViewModel_1.FileStat.mergeLocalWithDisk(modelStat, _this.root);
            // Select and Reveal
            return _this.explorerViewer.refresh(_this.root).then(function () { return _this.doSelect(_this.root.find(resource), reveal); });
        }, function (e) { return _this.messageService.show(message_1.Severity.Error, e); });
    };
    ExplorerView.prototype.hasSelection = function (resource) {
        var currentSelection = this.explorerViewer.getSelection();
        for (var i = 0; i < currentSelection.length; i++) {
            if (currentSelection[i].resource.toString() === resource.toString()) {
                return currentSelection[i];
            }
        }
        return null;
    };
    ExplorerView.prototype.doSelect = function (fileStat, reveal) {
        var _this = this;
        if (!fileStat) {
            return winjs_base_1.TPromise.as(null);
        }
        // Special case: we are asked to reveal and select an element that is not visible
        // In this case we take the parent element so that we are at least close to it.
        if (!this.filter.isVisible(this.tree, fileStat)) {
            fileStat = fileStat.parent;
            if (!fileStat) {
                return winjs_base_1.TPromise.as(null);
            }
        }
        // Reveal depending on flag
        var revealPromise;
        if (reveal) {
            revealPromise = this.reveal(fileStat, 0.5);
        }
        else {
            revealPromise = winjs_base_1.TPromise.as(null);
        }
        return revealPromise.then(function () {
            if (!fileStat.isDirectory) {
                _this.explorerViewer.setSelection([fileStat]); // Since folders can not be opened, only select files
            }
            _this.explorerViewer.setFocus(fileStat);
        });
    };
    ExplorerView.prototype.shutdown = function () {
        var _this = this;
        // Keep list of expanded folders to restore on next load
        if (this.root) {
            var expanded = this.explorerViewer.getExpandedElements()
                .filter(function (e) { return e.resource.toString() !== _this.contextService.getWorkspace().resource.toString(); })
                .map(function (e) { return e.resource.toString(); });
            this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES] = expanded;
        }
        _super.prototype.shutdown.call(this);
    };
    ExplorerView.prototype.dispose = function () {
        if (this.toolBar) {
            this.toolBar.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    return ExplorerView;
}(viewlet_1.CollapsibleViewletView));
ExplorerView.EXPLORER_FILE_CHANGES_REACT_DELAY = 500; // delay in ms to react to file changes to give our internal events a chance to react first
ExplorerView.EXPLORER_FILE_CHANGES_REFRESH_DELAY = 100; // delay in ms to refresh the explorer from disk file changes
ExplorerView.EXPLORER_IMPORT_REFRESH_DELAY = 300; // delay in ms to refresh the explorer from imports
ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE = 'explorer.memento.lastActiveFileResource';
ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES = 'explorer.memento.expandedFolderResources';
ExplorerView.COMMON_SCM_FOLDERS = ['.git', '.svn', '.hg'];
ExplorerView = __decorate([
    __param(4, message_1.IMessageService),
    __param(5, contextView_1.IContextMenuService),
    __param(6, instantiation_1.IInstantiationService),
    __param(7, groupService_1.IEditorGroupService),
    __param(8, workspace_1.IWorkspaceContextService),
    __param(9, progress_1.IProgressService),
    __param(10, listService_1.IListService),
    __param(11, editorService_1.IWorkbenchEditorService),
    __param(12, files_2.IFileService),
    __param(13, partService_1.IPartService),
    __param(14, keybinding_1.IKeybindingService),
    __param(15, contextkey_1.IContextKeyService),
    __param(16, configuration_1.IConfigurationService),
    __param(17, themeService_1.IWorkbenchThemeService)
], ExplorerView);
exports.ExplorerView = ExplorerView;
