/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var path = require("path");
var DOM = require("vs/base/browser/dom");
var event_1 = require("vs/base/common/event");
var uri_1 = require("vs/base/common/uri");
var cp = require("child_process");
var lifecycle = require("vs/base/common/lifecycle");
var nls = require("vs/nls");
var os = require("os");
var platform = require("vs/base/common/platform");
var xterm = require("xterm");
var builder_1 = require("vs/base/browser/builder");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var message_1 = require("vs/platform/message/common/message");
var panelService_1 = require("vs/workbench/services/panel/common/panelService");
var terminal_1 = require("vs/workbench/parts/terminal/common/terminal");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var keyboardEvent_1 = require("vs/base/browser/keyboardEvent");
var commonEditorConfig_1 = require("vs/editor/common/config/commonEditorConfig");
/** The amount of time to consider terminal errors to be related to the launch */
var LAUNCHING_DURATION = 500;
var StandardTerminalProcessFactory = (function () {
    function StandardTerminalProcessFactory() {
    }
    StandardTerminalProcessFactory.prototype.create = function (env) {
        return cp.fork('./terminalProcess', [], {
            env: env,
            cwd: uri_1.default.parse(path.dirname(require.toUrl('./terminalProcess'))).fsPath
        });
    };
    return StandardTerminalProcessFactory;
}());
var TerminalInstance = (function () {
    function TerminalInstance(_terminalFocusContextKey, _configHelper, _linkHandler, _container, _shellLaunchConfig, _contextKeyService, _keybindingService, _messageService, _panelService, _contextService, _editorService) {
        this._terminalFocusContextKey = _terminalFocusContextKey;
        this._configHelper = _configHelper;
        this._linkHandler = _linkHandler;
        this._container = _container;
        this._shellLaunchConfig = _shellLaunchConfig;
        this._contextKeyService = _contextKeyService;
        this._keybindingService = _keybindingService;
        this._messageService = _messageService;
        this._panelService = _panelService;
        this._contextService = _contextService;
        this._editorService = _editorService;
        this._instanceDisposables = [];
        this._processDisposables = [];
        this._skipTerminalCommands = [];
        this._isExiting = false;
        this._hadFocusOnExit = false;
        this._isLaunching = true;
        this._isVisible = false;
        this._isDisposed = false;
        this._id = TerminalInstance._idCounter++;
        this._terminalHasTextContextKey = terminal_1.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.bindTo(this._contextKeyService);
        this._onDisposed = new event_1.Emitter();
        this._onProcessIdReady = new event_1.Emitter();
        this._onTitleChanged = new event_1.Emitter();
        this._initDimensions();
        this._createProcess(this._contextService.getWorkspace(), this._shellLaunchConfig);
        this._createXterm();
        // Only attach xterm.js to the DOM if the terminal panel has been opened before.
        if (_container) {
            this.attachToElement(_container);
        }
    }
    Object.defineProperty(TerminalInstance.prototype, "id", {
        get: function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "processId", {
        get: function () { return this._processId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onDisposed", {
        get: function () { return this._onDisposed.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onProcessIdReady", {
        get: function () { return this._onProcessIdReady.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "onTitleChanged", {
        get: function () { return this._onTitleChanged.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "title", {
        get: function () { return this._title; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerminalInstance.prototype, "hadFocusOnExit", {
        get: function () { return this._hadFocusOnExit; },
        enumerable: true,
        configurable: true
    });
    TerminalInstance.prototype.addDisposable = function (disposable) {
        this._instanceDisposables.push(disposable);
    };
    TerminalInstance.prototype._initDimensions = function () {
        // The terminal panel needs to have been created
        if (!this._container) {
            return;
        }
        var computedStyle = window.getComputedStyle(this._container);
        var width = parseInt(computedStyle.getPropertyValue('width').replace('px', ''), 10);
        var height = parseInt(computedStyle.getPropertyValue('height').replace('px', ''), 10);
        this._evaluateColsAndRows(width, height);
    };
    /**
     * Evaluates and sets the cols and rows of the terminal if possible.
     * @param width The width of the container.
     * @param height The height of the container.
     * @return The terminal's width if it requires a layout.
     */
    TerminalInstance.prototype._evaluateColsAndRows = function (width, height) {
        // The font needs to have been initialized
        var font = this._configHelper.getFont();
        if (!font || !font.charWidth || !font.charHeight) {
            return null;
        }
        // TODO: Fetch size from panel so initial size is correct
        // The panel is minimized
        if (!height) {
            return null;
        }
        else {
            // Trigger scroll event manually so that the viewport's scroll area is synced. This
            // needs to happen otherwise its scrollTop value is invalid when the panel is toggled as
            // it gets removed and then added back to the DOM (resetting scrollTop to 0).
            // Upstream issue: https://github.com/sourcelair/xterm.js/issues/291
            if (this._xterm) {
                this._xterm.emit('scroll', this._xterm.ydisp);
            }
        }
        var padding = parseInt(getComputedStyle(document.querySelector('.terminal-outer-container')).paddingLeft.split('px')[0], 10);
        // Use left padding as right padding, right padding is not defined in CSS just in case
        // xterm.js causes an unexpected overflow.
        var innerWidth = width - padding * 2;
        this._cols = Math.floor(innerWidth / font.charWidth);
        this._rows = Math.floor(height / font.charHeight);
        return innerWidth;
    };
    /**
     * Create xterm.js instance and attach data listeners.
     */
    TerminalInstance.prototype._createXterm = function () {
        var _this = this;
        this._xterm = xterm({
            scrollback: this._configHelper.config.scrollback
        });
        this._process.on('message', function (message) { return _this._sendPtyDataToXterm(message); });
        this._xterm.on('data', function (data) {
            if (_this._process) {
                _this._process.send({
                    event: 'input',
                    data: _this._sanitizeInput(data)
                });
            }
            return false;
        });
    };
    TerminalInstance.prototype.attachToElement = function (container) {
        var _this = this;
        if (this._wrapperElement) {
            throw new Error('The terminal instance has already been attached to a container');
        }
        this._container = container;
        this._wrapperElement = document.createElement('div');
        DOM.addClass(this._wrapperElement, 'terminal-wrapper');
        this._xtermElement = document.createElement('div');
        this._xterm.open(this._xtermElement);
        this._linkHandler.initialize(this._xterm);
        this._linkHandler.registerLocalLinkHandler(this._xterm);
        this._xterm.attachCustomKeydownHandler(function (event) {
            // Disable all input if the terminal is exiting
            if (_this._isExiting) {
                return false;
            }
            // Skip processing by xterm.js of keyboard events that resolve to commands described
            // within commandsToSkipShell
            var standardKeyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(event);
            var keybinding = standardKeyboardEvent.toKeybinding();
            var resolveResult = _this._keybindingService.resolve(keybinding, standardKeyboardEvent.target);
            if (resolveResult && _this._skipTerminalCommands.some(function (k) { return k === resolveResult.commandId; })) {
                event.preventDefault();
                return false;
            }
            // If tab focus mode is on, tab is not passed to the terminal
            if (commonEditorConfig_1.TabFocus.getTabFocusMode() && event.keyCode === 9) {
                return false;
            }
            return undefined;
        });
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.element, 'mouseup', function (event) {
            // Wait until mouseup has propogated through the DOM before evaluating the new selection
            // state.
            setTimeout(function () {
                _this._refreshSelectionContextKey();
            }, 0);
        }));
        // xterm.js currently drops selection on keyup as we need to handle this case.
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.element, 'keyup', function (event) {
            // Wait until keyup has propogated through the DOM before evaluating the new selection
            // state.
            setTimeout(function () {
                _this._refreshSelectionContextKey();
            }, 0);
        }));
        var xtermHelper = this._xterm.element.querySelector('.xterm-helpers');
        var focusTrap = document.createElement('div');
        focusTrap.setAttribute('tabindex', '0');
        DOM.addClass(focusTrap, 'focus-trap');
        this._instanceDisposables.push(DOM.addDisposableListener(focusTrap, 'focus', function (event) {
            var currentElement = focusTrap;
            while (!DOM.hasClass(currentElement, 'part')) {
                currentElement = currentElement.parentElement;
            }
            var hidePanelElement = currentElement.querySelector('.hide-panel-action');
            hidePanelElement.focus();
        }));
        xtermHelper.insertBefore(focusTrap, this._xterm.textarea);
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.textarea, 'focus', function (event) {
            _this._terminalFocusContextKey.set(true);
        }));
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.textarea, 'blur', function (event) {
            _this._terminalFocusContextKey.reset();
            _this._refreshSelectionContextKey();
        }));
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.element, 'focus', function (event) {
            _this._terminalFocusContextKey.set(true);
        }));
        this._instanceDisposables.push(DOM.addDisposableListener(this._xterm.element, 'blur', function (event) {
            _this._terminalFocusContextKey.reset();
            _this._refreshSelectionContextKey();
        }));
        this._wrapperElement.appendChild(this._xtermElement);
        this._container.appendChild(this._wrapperElement);
        var computedStyle = window.getComputedStyle(this._container);
        var width = parseInt(computedStyle.getPropertyValue('width').replace('px', ''), 10);
        var height = parseInt(computedStyle.getPropertyValue('height').replace('px', ''), 10);
        this.layout(new builder_1.Dimension(width, height));
        this.setVisible(this._isVisible);
        this.updateConfig();
    };
    TerminalInstance.prototype.registerLinkMatcher = function (regex, handler, matchIndex, validationCallback) {
        return this._linkHandler.registerCustomLinkHandler(this._xterm, regex, handler, matchIndex, validationCallback);
    };
    TerminalInstance.prototype.deregisterLinkMatcher = function (linkMatcherId) {
        this._xterm.deregisterLinkMatcher(linkMatcherId);
    };
    TerminalInstance.prototype.hasSelection = function () {
        return !document.getSelection().isCollapsed;
    };
    TerminalInstance.prototype.copySelection = function () {
        if (document.activeElement.classList.contains('xterm')) {
            document.execCommand('copy');
        }
        else {
            this._messageService.show(message_1.Severity.Warning, nls.localize('terminal.integrated.copySelection.noSelection', 'Cannot copy terminal selection when terminal does not have focus'));
        }
    };
    TerminalInstance.prototype.clearSelection = function () {
        document.getSelection().empty();
    };
    TerminalInstance.prototype.dispose = function () {
        if (this._xterm && this._xterm.element) {
            this._hadFocusOnExit = DOM.hasClass(this._xterm.element, 'focus');
        }
        if (this._wrapperElement) {
            this._container.removeChild(this._wrapperElement);
            this._wrapperElement = null;
        }
        if (this._xterm) {
            this._xterm.destroy();
            this._xterm = null;
        }
        if (this._process) {
            if (this._process.connected) {
                this._process.kill();
            }
            this._process = null;
        }
        if (!this._isDisposed) {
            this._isDisposed = true;
            this._onDisposed.fire(this);
        }
        this._processDisposables = lifecycle.dispose(this._processDisposables);
        this._instanceDisposables = lifecycle.dispose(this._instanceDisposables);
    };
    TerminalInstance.prototype.focus = function (force) {
        if (!this._xterm) {
            return;
        }
        var text = window.getSelection().toString();
        if (!text || force) {
            this._xterm.focus();
        }
    };
    TerminalInstance.prototype.paste = function () {
        this.focus();
        document.execCommand('paste');
    };
    TerminalInstance.prototype.sendText = function (text, addNewLine) {
        if (addNewLine && text.substr(text.length - os.EOL.length) !== os.EOL) {
            text += os.EOL;
        }
        this._process.send({
            event: 'input',
            data: text
        });
    };
    TerminalInstance.prototype.setVisible = function (visible) {
        this._isVisible = visible;
        if (this._wrapperElement) {
            DOM.toggleClass(this._wrapperElement, 'active', visible);
        }
        if (visible && this._xterm) {
            // Trigger a manual scroll event which will sync the viewport and scroll bar. This is
            // necessary if the number of rows in the terminal has decreased while it was in the
            // background since scrollTop changes take no effect but the terminal's position does
            // change since the number of visible rows decreases.
            this._xterm.emit('scroll', this._xterm.ydisp);
        }
    };
    TerminalInstance.prototype.scrollDownLine = function () {
        this._xterm.scrollDisp(1);
    };
    TerminalInstance.prototype.scrollDownPage = function () {
        this._xterm.scrollPages(1);
    };
    TerminalInstance.prototype.scrollToBottom = function () {
        this._xterm.scrollToBottom();
    };
    TerminalInstance.prototype.scrollUpLine = function () {
        this._xterm.scrollDisp(-1);
    };
    TerminalInstance.prototype.scrollUpPage = function () {
        this._xterm.scrollPages(-1);
    };
    TerminalInstance.prototype.scrollToTop = function () {
        this._xterm.scrollToTop();
    };
    TerminalInstance.prototype.clear = function () {
        this._xterm.clear();
    };
    TerminalInstance.prototype._refreshSelectionContextKey = function () {
        var activePanel = this._panelService.getActivePanel();
        var isFocused = activePanel && activePanel.getId() === terminal_1.TERMINAL_PANEL_ID;
        this._terminalHasTextContextKey.set(isFocused && !window.getSelection().isCollapsed);
    };
    TerminalInstance.prototype._sanitizeInput = function (data) {
        return typeof data === 'string' ? data.replace(TerminalInstance.EOL_REGEX, os.EOL) : data;
    };
    TerminalInstance.prototype._getCwd = function (shell, workspace) {
        if (shell.cwd) {
            return shell.cwd;
        }
        var cwd;
        // TODO: Handle non-existent customCwd
        if (!shell.ignoreConfigurationCwd) {
            // Evaluate custom cwd first
            var customCwd = this._configHelper.config.cwd;
            if (customCwd) {
                if (path.isAbsolute(customCwd)) {
                    cwd = customCwd;
                }
                else if (workspace) {
                    cwd = path.normalize(path.join(workspace.resource.fsPath, customCwd));
                }
            }
        }
        // If there was no custom cwd or it was relative with no workspace
        if (!cwd) {
            cwd = workspace ? workspace.resource.fsPath : os.homedir();
        }
        return TerminalInstance._sanitizeCwd(cwd);
    };
    TerminalInstance.prototype._createProcess = function (workspace, shell) {
        var _this = this;
        var locale = this._configHelper.config.setLocaleVariables ? platform.locale : undefined;
        if (!shell.executable) {
            this._configHelper.mergeDefaultShellPathAndArgs(shell);
        }
        var env = TerminalInstance.createTerminalEnv(process.env, shell, this._getCwd(shell, workspace), locale, this._cols, this._rows);
        this._title = shell.name || '';
        this._process = cp.fork('./terminalProcess', [], {
            env: env,
            cwd: uri_1.default.parse(path.dirname(require.toUrl('./terminalProcess'))).fsPath
        });
        if (!shell.name) {
            // Only listen for process title changes when a name is not provided
            this._process.on('message', function (message) {
                if (message.type === 'title') {
                    _this._title = message.content ? message.content : '';
                    _this._onTitleChanged.fire(_this._title);
                }
            });
        }
        this._process.on('message', function (message) {
            if (message.type === 'pid') {
                _this._processId = message.content;
                _this._onProcessIdReady.fire(_this);
            }
        });
        this._process.on('exit', function (exitCode) { return _this._onPtyProcessExit(exitCode); });
        setTimeout(function () {
            _this._isLaunching = false;
        }, LAUNCHING_DURATION);
    };
    TerminalInstance.prototype._sendPtyDataToXterm = function (message) {
        if (message.type === 'data') {
            this._xterm.write(message.content);
        }
    };
    TerminalInstance.prototype._onPtyProcessExit = function (exitCode) {
        var _this = this;
        // Prevent dispose functions being triggered multiple times
        if (this._isExiting) {
            return;
        }
        this._isExiting = true;
        var exitCodeMessage;
        if (exitCode) {
            exitCodeMessage = nls.localize('terminal.integrated.exitedWithCode', 'The terminal process terminated with exit code: {0}', exitCode);
        }
        // Only trigger wait on exit when the exit was triggered by the process, not through the
        // `workbench.action.terminal.kill` command
        var triggeredByProcess = exitCode !== null;
        if (triggeredByProcess && this._shellLaunchConfig.waitOnExit) {
            if (exitCode) {
                this._xterm.writeln(exitCodeMessage);
            }
            this._xterm.writeln(nls.localize('terminal.integrated.waitOnExit', 'Press any key to close the terminal'));
            // Disable all input if the terminal is exiting and listen for next keypress
            this._xterm.setOption('disableStdin', true);
            this._processDisposables.push(DOM.addDisposableListener(this._xterm.textarea, 'keypress', function (event) {
                _this.dispose();
                event.preventDefault();
            }));
        }
        else {
            this.dispose();
            if (exitCode) {
                if (this._isLaunching) {
                    var args = '';
                    if (this._shellLaunchConfig.args && this._shellLaunchConfig.args.length) {
                        args = ' ' + this._shellLaunchConfig.args.map(function (a) {
                            if (a.indexOf(' ') !== -1) {
                                return "'" + a + "'";
                            }
                            return a;
                        }).join(' ');
                    }
                    this._messageService.show(message_1.Severity.Error, nls.localize('terminal.integrated.launchFailed', 'The terminal process command `{0}{1}` failed to launch (exit code: {2})', this._shellLaunchConfig.executable, args, exitCode));
                }
                else {
                    this._messageService.show(message_1.Severity.Error, exitCodeMessage);
                }
            }
        }
    };
    TerminalInstance.prototype.reuseTerminal = function (shell) {
        var _this = this;
        // Kill and clean up old process
        if (this._process) {
            this._process.removeAllListeners('exit');
            if (this._process.connected) {
                this._process.kill();
            }
            this._process = null;
        }
        lifecycle.dispose(this._processDisposables);
        this._processDisposables = [];
        // Ensure new processes' output starts at start of new line
        this._xterm.write('\n\x1b[G');
        // Initialize new process
        var oldTitle = this._title;
        this._createProcess(this._contextService.getWorkspace(), shell);
        if (oldTitle !== this._title) {
            this._onTitleChanged.fire(this._title);
        }
        this._process.on('message', function (message) { return _this._sendPtyDataToXterm(message); });
        // Clean up waitOnExit state
        if (this._isExiting && this._shellLaunchConfig.waitOnExit) {
            this._xterm.setOption('disableStdin', false);
            this._isExiting = false;
        }
        // Set the new shell launch config
        this._shellLaunchConfig = shell;
    };
    // TODO: This should be private/protected
    // TODO: locale should not be optional
    TerminalInstance.createTerminalEnv = function (parentEnv, shell, cwd, locale, cols, rows) {
        var env = shell.env ? shell.env : TerminalInstance._cloneEnv(parentEnv);
        env['PTYPID'] = process.pid.toString();
        env['PTYSHELL'] = shell.executable;
        if (shell.args) {
            shell.args.forEach(function (arg, i) {
                env["PTYSHELLARG" + i] = arg;
            });
        }
        env['PTYCWD'] = cwd;
        env['LANG'] = TerminalInstance._getLangEnvVariable(locale);
        if (cols && rows) {
            env['PTYCOLS'] = cols.toString();
            env['PTYROWS'] = rows.toString();
        }
        return env;
    };
    TerminalInstance.prototype.onData = function (listener) {
        var _this = this;
        var callback = function (message) {
            if (message.type === 'data') {
                listener(message.content);
            }
        };
        this._process.on('message', callback);
        return {
            dispose: function () {
                if (_this._process) {
                    _this._process.removeListener('message', callback);
                }
            }
        };
    };
    TerminalInstance.prototype.onExit = function (listener) {
        var _this = this;
        this._process.on('exit', listener);
        return {
            dispose: function () {
                if (_this._process) {
                    _this._process.removeListener('exit', listener);
                }
            }
        };
    };
    TerminalInstance._sanitizeCwd = function (cwd) {
        // Make the drive letter uppercase on Windows (see #9448)
        if (platform.platform === platform.Platform.Windows && cwd && cwd[1] === ':') {
            return cwd[0].toUpperCase() + cwd.substr(1);
        }
        return cwd;
    };
    TerminalInstance._cloneEnv = function (env) {
        var newEnv = Object.create(null);
        Object.keys(env).forEach(function (key) {
            newEnv[key] = env[key];
        });
        return newEnv;
    };
    TerminalInstance._getLangEnvVariable = function (locale) {
        var parts = locale ? locale.split('-') : [];
        var n = parts.length;
        if (n === 0) {
            // Fallback to en_US to prevent possible encoding issues.
            return 'en_US.UTF-8';
        }
        if (n === 1) {
            // app.getLocale can return just a language without a variant, fill in the variant for
            // supported languages as many shells expect a 2-part locale.
            var languageVariants = {
                de: 'DE',
                en: 'US',
                es: 'ES',
                fr: 'FR',
                it: 'IT',
                ja: 'JP',
                ko: 'KR',
                ru: 'RU',
                zh: 'CN'
            };
            if (parts[0] in languageVariants) {
                parts.push(languageVariants[parts[0]]);
            }
        }
        else {
            // Ensure the variant is uppercase
            parts[1] = parts[1].toUpperCase();
        }
        return parts.join('_') + '.UTF-8';
    };
    TerminalInstance.prototype.updateConfig = function () {
        this._setCursorBlink(this._configHelper.config.cursorBlinking);
        this._setCursorStyle(this._configHelper.config.cursorStyle);
        this._setCommandsToSkipShell(this._configHelper.config.commandsToSkipShell);
        this._setScrollback(this._configHelper.config.scrollback);
    };
    TerminalInstance.prototype._setCursorBlink = function (blink) {
        if (this._xterm && this._xterm.getOption('cursorBlink') !== blink) {
            this._xterm.setOption('cursorBlink', blink);
            this._xterm.refresh(0, this._xterm.rows - 1);
        }
    };
    TerminalInstance.prototype._setCursorStyle = function (style) {
        if (this._xterm && this._xterm.getOption('cursorStyle') !== style) {
            // 'line' is used instead of bar in VS Code to be consistent with editor.cursorStyle
            var xtermOption = style === 'line' ? 'bar' : style;
            this._xterm.setOption('cursorStyle', xtermOption);
        }
    };
    TerminalInstance.prototype._setCommandsToSkipShell = function (commands) {
        this._skipTerminalCommands = commands;
    };
    TerminalInstance.prototype._setScrollback = function (lineCount) {
        if (this._xterm && this._xterm.getOption('scrollback') !== lineCount) {
            this._xterm.setOption('scrollback', lineCount);
        }
    };
    TerminalInstance.prototype.layout = function (dimension) {
        var terminalWidth = this._evaluateColsAndRows(dimension.width, dimension.height);
        if (!terminalWidth) {
            return;
        }
        if (this._xterm) {
            this._xterm.resize(this._cols, this._rows);
            this._xterm.element.style.width = terminalWidth + 'px';
        }
        if (this._process.connected) {
            this._process.send({
                event: 'resize',
                cols: this._cols,
                rows: this._rows
            });
        }
    };
    TerminalInstance.setTerminalProcessFactory = function (factory) {
        this._terminalProcessFactory = factory;
    };
    return TerminalInstance;
}());
TerminalInstance.EOL_REGEX = /\r?\n/g;
TerminalInstance._terminalProcessFactory = new StandardTerminalProcessFactory();
TerminalInstance._idCounter = 1;
TerminalInstance = __decorate([
    __param(5, contextkey_1.IContextKeyService),
    __param(6, keybinding_1.IKeybindingService),
    __param(7, message_1.IMessageService),
    __param(8, panelService_1.IPanelService),
    __param(9, workspace_1.IWorkspaceContextService),
    __param(10, editorService_1.IWorkbenchEditorService)
], TerminalInstance);
exports.TerminalInstance = TerminalInstance;
