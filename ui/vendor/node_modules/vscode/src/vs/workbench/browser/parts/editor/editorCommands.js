/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var nls = require("vs/nls");
var types = require("vs/base/common/types");
var keybindingsRegistry_1 = require("vs/platform/keybinding/common/keybindingsRegistry");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var editor_1 = require("vs/workbench/common/editor");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var editor_2 = require("vs/platform/editor/common/editor");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var textDiffEditor_1 = require("vs/workbench/browser/parts/editor/textDiffEditor");
var commands_1 = require("vs/platform/commands/common/commands");
var message_1 = require("vs/platform/message/common/message");
var actions_1 = require("vs/base/common/actions");
function setup() {
    registerActiveEditorMoveCommand();
    registerDiffEditorCommands();
    handleCommandDeprecations();
}
exports.setup = setup;
var isActiveEditorMoveArg = function (arg) {
    if (!types.isObject(arg)) {
        return false;
    }
    var activeEditorMoveArg = arg;
    if (!types.isString(activeEditorMoveArg.to)) {
        return false;
    }
    if (!types.isUndefined(activeEditorMoveArg.by) && !types.isString(activeEditorMoveArg.by)) {
        return false;
    }
    if (!types.isUndefined(activeEditorMoveArg.value) && !types.isNumber(activeEditorMoveArg.value)) {
        return false;
    }
    return true;
};
function registerActiveEditorMoveCommand() {
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: editor_1.EditorCommands.MoveActiveEditor,
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(),
        when: editorCommon_1.EditorContextKeys.TextFocus,
        primary: null,
        handler: function (accessor, args) { return moveActiveEditor(args, accessor); },
        description: {
            description: nls.localize('editorCommand.activeEditorMove.description', "Move the active editor by tabs or groups"),
            args: [
                {
                    name: nls.localize('editorCommand.activeEditorMove.arg.name', "Active editor move argument"),
                    description: nls.localize('editorCommand.activeEditorMove.arg.description', "Argument Properties:\n\t\t\t\t\t\t* 'to': String value providing where to move.\n\t\t\t\t\t\t* 'by': String value providing the unit for move. By tab or by group.\n\t\t\t\t\t\t* 'value': Number value providing how many positions or an absolute position to move.\n\t\t\t\t\t"),
                    constraint: isActiveEditorMoveArg
                }
            ]
        }
    });
}
function moveActiveEditor(args, accessor) {
    if (args === void 0) { args = {}; }
    var config = accessor.get(configuration_1.IConfigurationService).getConfiguration();
    var tabsShown = config.workbench && config.workbench.editor && config.workbench.editor.showTabs;
    args.to = args.to || editor_1.ActiveEditorMovePositioning.RIGHT;
    args.by = tabsShown ? args.by || editor_1.ActiveEditorMovePositioningBy.TAB : editor_1.ActiveEditorMovePositioningBy.GROUP;
    args.value = types.isUndefined(args.value) ? 1 : args.value;
    var activeEditor = accessor.get(editorService_1.IWorkbenchEditorService).getActiveEditor();
    if (activeEditor) {
        switch (args.by) {
            case editor_1.ActiveEditorMovePositioningBy.TAB:
                return moveActiveTab(args, activeEditor, accessor);
            case editor_1.ActiveEditorMovePositioningBy.GROUP:
                return moveActiveEditorToGroup(args, activeEditor, accessor);
        }
    }
}
function moveActiveTab(args, activeEditor, accessor) {
    var editorGroupsService = accessor.get(groupService_1.IEditorGroupService);
    var editorGroup = editorGroupsService.getStacksModel().groupAt(activeEditor.position);
    var index = editorGroup.indexOf(activeEditor.input);
    switch (args.to) {
        case editor_1.ActiveEditorMovePositioning.FIRST:
            index = 0;
            break;
        case editor_1.ActiveEditorMovePositioning.LAST:
            index = editorGroup.count - 1;
            break;
        case editor_1.ActiveEditorMovePositioning.LEFT:
            index = index - args.value;
            break;
        case editor_1.ActiveEditorMovePositioning.RIGHT:
            index = index + args.value;
            break;
        case editor_1.ActiveEditorMovePositioning.CENTER:
            index = Math.round(editorGroup.count / 2) - 1;
            break;
        case editor_1.ActiveEditorMovePositioning.POSITION:
            index = args.value - 1;
            break;
    }
    index = index < 0 ? 0 : index >= editorGroup.count ? editorGroup.count - 1 : index;
    editorGroupsService.moveEditor(activeEditor.input, editorGroup, editorGroup, index);
}
function moveActiveEditorToGroup(args, activeEditor, accessor) {
    var newPosition = activeEditor.position;
    switch (args.to) {
        case editor_1.ActiveEditorMovePositioning.LEFT:
            newPosition = newPosition - 1;
            break;
        case editor_1.ActiveEditorMovePositioning.RIGHT:
            newPosition = newPosition + 1;
            break;
        case editor_1.ActiveEditorMovePositioning.FIRST:
            newPosition = editor_2.Position.ONE;
            break;
        case editor_1.ActiveEditorMovePositioning.LAST:
            newPosition = editor_2.Position.THREE;
            break;
        case editor_1.ActiveEditorMovePositioning.CENTER:
            newPosition = editor_2.Position.TWO;
            break;
        case editor_1.ActiveEditorMovePositioning.POSITION:
            newPosition = args.value - 1;
            break;
    }
    newPosition = editor_2.POSITIONS.indexOf(newPosition) !== -1 ? newPosition : activeEditor.position;
    accessor.get(groupService_1.IEditorGroupService).moveEditor(activeEditor.input, activeEditor.position, newPosition);
}
function registerDiffEditorCommands() {
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.compareEditor.nextChange',
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(),
        when: textDiffEditor_1.TextCompareEditorVisible,
        primary: null,
        handler: function (accessor) { return navigateInDiffEditor(accessor, true); }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.compareEditor.previousChange',
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(),
        when: textDiffEditor_1.TextCompareEditorVisible,
        primary: null,
        handler: function (accessor) { return navigateInDiffEditor(accessor, false); }
    });
    function navigateInDiffEditor(accessor, next) {
        var editorService = accessor.get(editorService_1.IWorkbenchEditorService);
        var candidates = [editorService.getActiveEditor()].concat(editorService.getVisibleEditors()).filter(function (e) { return e instanceof textDiffEditor_1.TextDiffEditor; });
        if (candidates.length > 0) {
            next ? candidates[0].getDiffNavigator().next() : candidates[0].getDiffNavigator().previous();
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: '_workbench.printStacksModel',
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(0),
        handler: function (accessor) {
            console.log(accessor.get(groupService_1.IEditorGroupService).getStacksModel().toString() + "\n\n");
        },
        when: undefined,
        primary: undefined
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: '_workbench.validateStacksModel',
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(0),
        handler: function (accessor) {
            accessor.get(groupService_1.IEditorGroupService).getStacksModel().validate();
        },
        when: undefined,
        primary: undefined
    });
}
function handleCommandDeprecations() {
    var mapDeprecatedCommands = {
        'workbench.action.focusFirstEditor': 'workbench.action.focusFirstEditorGroup',
        'workbench.action.focusSecondEditor': 'workbench.action.focusSecondEditorGroup',
        'workbench.action.focusThirdEditor': 'workbench.action.focusThirdEditorGroup',
        'workbench.action.focusLeftEditor': 'workbench.action.focusPreviousGroup',
        'workbench.action.focusRightEditor': 'workbench.action.focusNextGroup',
        'workbench.action.moveActiveEditorLeft': 'workbench.action.moveActiveEditorGroupLeft',
        'workbench.action.moveActiveEditorRight': 'workbench.action.moveActiveEditorGroupRight',
        'workbench.action.openPreviousEditor': 'workbench.action.openPreviousEditorFromHistory',
        'workbench.files.action.addToWorkingFiles': 'workbench.action.keepEditor',
        'workbench.files.action.closeAllFiles': 'workbench.action.closeAllEditors',
        'workbench.files.action.closeFile': 'workbench.action.closeActiveEditor',
        'workbench.files.action.closeOtherFiles': 'workbench.action.closeOtherEditors',
        'workbench.files.action.focusWorkingFiles': 'workbench.files.action.focusOpenEditorsView',
        'workbench.files.action.openNextWorkingFile': 'workbench.action.nextEditor',
        'workbench.files.action.openPreviousWorkingFile': 'workbench.action.previousEditor',
        'workbench.files.action.reopenClosedFile': 'workbench.action.reopenClosedEditor',
        'workbench.files.action.workingFilesPicker': 'workbench.action.showAllEditors',
        'workbench.action.cycleEditor': 'workbench.action.navigateEditorGroups',
        'workbench.action.terminal.focus': 'workbench.action.focusPanel',
        'workbench.action.showEditorsInLeftGroup': 'workbench.action.showEditorsInFirstGroup',
        'workbench.action.showEditorsInCenterGroup': 'workbench.action.showEditorsInSecondGroup',
        'workbench.action.showEditorsInRightGroup': 'workbench.action.showEditorsInThirdGroup',
        'workbench.action.moveEditorToLeftGroup': 'workbench.action.moveEditorToPreviousGroup',
        'workbench.action.moveEditorToRightGroup': 'workbench.action.moveEditorToNextGroup'
    };
    Object.keys(mapDeprecatedCommands).forEach(function (deprecatedCommandId) {
        var newCommandId = mapDeprecatedCommands[deprecatedCommandId];
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: deprecatedCommandId,
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(0),
            handler: function (accessor) {
                var messageService = accessor.get(message_1.IMessageService);
                var commandService = accessor.get(commands_1.ICommandService);
                messageService.show(message_1.Severity.Warning, {
                    message: nls.localize('commandDeprecated', "Command **{0}** has been removed. You can use **{1}** instead", deprecatedCommandId, newCommandId),
                    actions: [
                        new actions_1.Action('openKeybindings', nls.localize('openKeybindings', "Configure Keyboard Shortcuts"), null, true, function () {
                            return commandService.executeCommand('workbench.action.openGlobalKeybindings');
                        }),
                        message_1.CloseAction
                    ]
                });
            },
            when: undefined,
            primary: undefined
        });
    });
}
