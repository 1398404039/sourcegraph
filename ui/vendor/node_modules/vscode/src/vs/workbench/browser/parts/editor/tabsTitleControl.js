/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require("./media/tabstitle.css");
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var errors = require("vs/base/common/errors");
var DOM = require("vs/base/browser/dom");
var platform_1 = require("vs/base/common/platform");
var mime_1 = require("vs/base/common/mime");
var labels_1 = require("vs/base/common/labels");
var actions_1 = require("vs/base/common/actions");
var editor_1 = require("vs/platform/editor/common/editor");
var editor_2 = require("vs/workbench/common/editor");
var keyboardEvent_1 = require("vs/base/browser/keyboardEvent");
var labels_2 = require("vs/workbench/browser/labels");
var actionbar_1 = require("vs/base/browser/ui/actionbar/actionbar");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var untitledEditorService_1 = require("vs/workbench/services/untitled/common/untitledEditorService");
var message_1 = require("vs/platform/message/common/message");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var actions_2 = require("vs/platform/actions/common/actions");
var windows_1 = require("vs/platform/windows/common/windows");
var titleControl_1 = require("vs/workbench/browser/parts/editor/titleControl");
var quickOpen_1 = require("vs/platform/quickOpen/common/quickOpen");
var lifecycle_1 = require("vs/base/common/lifecycle");
var scrollableElement_1 = require("vs/base/browser/ui/scrollbar/scrollableElement");
var scrollable_1 = require("vs/base/common/scrollable");
var dnd_1 = require("vs/base/browser/dnd");
var map_1 = require("vs/base/common/map");
var editorService_2 = require("vs/workbench/services/editor/browser/editorService");
var serviceCollection_1 = require("vs/platform/instantiation/common/serviceCollection");
var TabsTitleControl = (function (_super) {
    __extends(TabsTitleControl, _super);
    function TabsTitleControl(contextMenuService, instantiationService, editorService, editorGroupService, untitledEditorService, contextKeyService, keybindingService, telemetryService, messageService, menuService, quickOpenService, windowService) {
        var _this = _super.call(this, contextMenuService, instantiationService, editorService, editorGroupService, contextKeyService, keybindingService, telemetryService, messageService, menuService, quickOpenService) || this;
        _this.untitledEditorService = untitledEditorService;
        _this.windowService = windowService;
        _this.tabDisposeables = [];
        _this.editorLabels = [];
        return _this;
    }
    TabsTitleControl.prototype.initActions = function (services) {
        _super.prototype.initActions.call(this, this.createScopedInstantiationService());
    };
    TabsTitleControl.prototype.createScopedInstantiationService = function () {
        var _this = this;
        var stacks = this.editorGroupService.getStacksModel();
        var delegatingEditorService = this.instantiationService.createInstance(editorService_2.DelegatingWorkbenchEditorService);
        // We create a scoped instantiation service to override the behaviour when closing an inactive editor
        // Specifically we want to move focus back to the editor when an inactive editor is closed from anywhere
        // in the tabs title control (e.g. mouse middle click, context menu on tab). This is only needed for
        // the inactive editors because closing the active one will always cause a tab switch that sets focus.
        // We also want to block the tabs container to reveal the currently active tab because that makes it very
        // hard to close multiple inactive tabs next to each other.
        delegatingEditorService.setEditorCloseHandler(function (position, editor) {
            var group = stacks.groupAt(position);
            if (group && stacks.isActive(group) && !group.isActive(editor)) {
                _this.editorGroupService.focusGroup(group);
            }
            _this.blockRevealActiveTab = true;
            return winjs_base_1.TPromise.as(void 0);
        });
        return this.instantiationService.createChild(new serviceCollection_1.ServiceCollection([editorService_1.IWorkbenchEditorService, delegatingEditorService]));
    };
    TabsTitleControl.prototype.setContext = function (group) {
        _super.prototype.setContext.call(this, group);
        this.editorActionsToolbar.context = { group: group };
    };
    TabsTitleControl.prototype.create = function (parent) {
        var _this = this;
        _super.prototype.create.call(this, parent);
        this.titleContainer = parent;
        // Tabs Container
        this.tabsContainer = document.createElement('div');
        this.tabsContainer.setAttribute('role', 'tablist');
        DOM.addClass(this.tabsContainer, 'tabs-container');
        // Forward scrolling inside the container to our custom scrollbar
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.SCROLL, function (e) {
            if (DOM.hasClass(_this.tabsContainer, 'scroll')) {
                _this.scrollbar.updateState({
                    scrollLeft: _this.tabsContainer.scrollLeft // during DND the  container gets scrolled so we need to update the custom scrollbar
                });
            }
        }));
        // New file when double clicking on tabs container (but not tabs)
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DBLCLICK, function (e) {
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                DOM.EventHelper.stop(e);
                var group = _this.context;
                if (group) {
                    _this.editorService.openEditor(_this.untitledEditorService.createOrGet(), { pinned: true, index: group.count /* always at the end */ }).done(null, errors.onUnexpectedError); // untitled are always pinned
                }
            }
        }));
        // Custom Scrollbar
        this.scrollbar = new scrollableElement_1.ScrollableElement(this.tabsContainer, {
            horizontal: scrollable_1.ScrollbarVisibility.Auto,
            vertical: scrollable_1.ScrollbarVisibility.Hidden,
            scrollYToX: true,
            useShadows: false,
            canUseTranslate3d: true,
            horizontalScrollbarSize: 3
        });
        this.scrollbar.onScroll(function (e) {
            _this.tabsContainer.scrollLeft = e.scrollLeft;
        });
        this.titleContainer.appendChild(this.scrollbar.getDomNode());
        // Drag over
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_OVER, function (e) {
            DOM.addClass(_this.tabsContainer, 'scroll'); // enable support to scroll while dragging
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                DOM.addClass(_this.tabsContainer, 'dropfeedback');
            }
        }));
        // Drag leave
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_LEAVE, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
        }));
        // Drag end
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DRAG_END, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
        }));
        // Drop onto tabs container
        this.toDispose.push(DOM.addDisposableListener(this.tabsContainer, DOM.EventType.DROP, function (e) {
            DOM.removeClass(_this.tabsContainer, 'dropfeedback');
            DOM.removeClass(_this.tabsContainer, 'scroll');
            var target = e.target;
            if (target instanceof HTMLElement && target.className.indexOf('tabs-container') === 0) {
                var group = _this.context;
                if (group) {
                    var targetPosition = _this.stacks.positionOfGroup(group);
                    var targetIndex = group.count;
                    _this.onDrop(e, group, targetPosition, targetIndex);
                }
            }
        }));
        // Editor Actions Container
        var editorActionsContainer = document.createElement('div');
        DOM.addClass(editorActionsContainer, 'editor-actions');
        this.titleContainer.appendChild(editorActionsContainer);
        // Editor Actions Toolbar
        this.createEditorActionsToolBar(editorActionsContainer);
    };
    TabsTitleControl.prototype.allowDragging = function (element) {
        return (element.className === 'tabs-container');
    };
    TabsTitleControl.prototype.doUpdate = function () {
        var _this = this;
        if (!this.context) {
            return;
        }
        var group = this.context;
        // Tabs container activity state
        var isActive = this.stacks.isActive(group);
        if (isActive) {
            DOM.addClass(this.titleContainer, 'active');
        }
        else {
            DOM.removeClass(this.titleContainer, 'active');
        }
        // Compute labels and protect against duplicates
        var editorsOfGroup = this.context.getEditors();
        var labels = this.getUniqueTabLabels(editorsOfGroup);
        // Tab label and styles
        editorsOfGroup.forEach(function (editor, index) {
            var tabContainer = _this.tabsContainer.children[index];
            if (tabContainer instanceof HTMLElement) {
                var isPinned = group.isPinned(index);
                var isActive_1 = group.isActive(editor);
                var isDirty = editor.isDirty();
                var label = labels[index];
                var name_1 = label.name;
                var description = label.hasAmbiguousName && label.description ? label.description : '';
                var title = label.title || '';
                // Container
                tabContainer.setAttribute('aria-label', name_1 + ", tab");
                tabContainer.title = title;
                var tabOptions_1 = _this.editorGroupService.getTabOptions();
                ['off', 'left'].forEach(function (option) {
                    var domAction = tabOptions_1.tabCloseButton === option ? DOM.addClass : DOM.removeClass;
                    domAction(tabContainer, "close-button-" + option);
                });
                // Label
                var tabLabel = _this.editorLabels[index];
                tabLabel.setLabel({ name: name_1, description: description, resource: editor_2.toResource(editor, { supportSideBySide: true }) }, { extraClasses: ['tab-label'], italic: !isPinned });
                // Active state
                if (isActive_1) {
                    DOM.addClass(tabContainer, 'active');
                    tabContainer.setAttribute('aria-selected', 'true');
                    _this.activeTab = tabContainer;
                }
                else {
                    DOM.removeClass(tabContainer, 'active');
                    tabContainer.setAttribute('aria-selected', 'false');
                }
                // Dirty State
                if (isDirty) {
                    DOM.addClass(tabContainer, 'dirty');
                }
                else {
                    DOM.removeClass(tabContainer, 'dirty');
                }
            }
        });
        // Update Editor Actions Toolbar
        this.updateEditorActionsToolbar();
        // Ensure the active tab is always revealed
        this.layout();
    };
    TabsTitleControl.prototype.getUniqueTabLabels = function (editors) {
        var labels = [];
        var mapLabelToDuplicates = new map_1.LinkedMap();
        var mapLabelAndDescriptionToDuplicates = new map_1.LinkedMap();
        // Build labels and descriptions for each editor
        editors.forEach(function (editor) {
            var description = editor.getDescription();
            var item = {
                editor: editor,
                name: editor.getName(),
                description: description,
                title: editor.getTitle(editor_1.Verbosity.LONG)
            };
            labels.push(item);
            mapLabelToDuplicates.getOrSet(item.name, []).push(item);
            if (typeof description === 'string') {
                mapLabelAndDescriptionToDuplicates.getOrSet("" + item.name + item.description, []).push(item);
            }
        });
        // Mark duplicates and shorten their descriptions
        var labelDuplicates = mapLabelToDuplicates.values();
        labelDuplicates.forEach(function (duplicates) {
            if (duplicates.length > 1) {
                duplicates = duplicates.filter(function (d) {
                    // we could have items with equal label and description. in that case it does not make much
                    // sense to produce a shortened version of the label, so we ignore those kind of items
                    return typeof d.description === 'string' && mapLabelAndDescriptionToDuplicates.get("" + d.name + d.description).length === 1;
                });
                if (duplicates.length > 1) {
                    var shortenedDescriptions_1 = labels_1.shorten(duplicates.map(function (duplicate) { return duplicate.editor.getDescription(); }));
                    duplicates.forEach(function (duplicate, i) {
                        duplicate.description = shortenedDescriptions_1[i];
                        duplicate.hasAmbiguousName = true;
                    });
                }
            }
        });
        return labels;
    };
    TabsTitleControl.prototype.doRefresh = function () {
        var group = this.context;
        var editor = group && group.activeEditor;
        if (!editor) {
            this.clearTabs();
            this.clearEditorActionsToolbar();
            return; // return early if we are being closed
        }
        // Handle Tabs
        this.handleTabs(group.count);
        DOM.addClass(this.titleContainer, 'shows-tabs');
        // Update Tabs
        this.doUpdate();
    };
    TabsTitleControl.prototype.clearTabs = function () {
        DOM.clearNode(this.tabsContainer);
        this.tabDisposeables = lifecycle_1.dispose(this.tabDisposeables);
        this.editorLabels = [];
        DOM.removeClass(this.titleContainer, 'shows-tabs');
    };
    TabsTitleControl.prototype.handleTabs = function (tabsNeeded) {
        var tabs = this.tabsContainer.children;
        var tabsCount = tabs.length;
        // Nothing to do if count did not change
        if (tabsCount === tabsNeeded) {
            return;
        }
        // We need more tabs: create new ones
        if (tabsCount < tabsNeeded) {
            for (var i = tabsCount; i < tabsNeeded; i++) {
                this.tabsContainer.appendChild(this.createTab(i));
            }
        }
        else {
            for (var i = 0; i < tabsCount - tabsNeeded; i++) {
                this.tabsContainer.lastChild.remove();
                this.editorLabels.pop();
                this.tabDisposeables.pop().dispose();
            }
        }
    };
    TabsTitleControl.prototype.createTab = function (index) {
        var _this = this;
        // Tab Container
        var tabContainer = document.createElement('div');
        tabContainer.draggable = true;
        tabContainer.tabIndex = 0;
        tabContainer.setAttribute('role', 'presentation'); // cannot use role "tab" here due to https://github.com/Microsoft/vscode/issues/8659
        DOM.addClass(tabContainer, 'tab monaco-editor-background');
        // Tab Editor Label
        var editorLabel = this.instantiationService.createInstance(labels_2.EditorLabel, tabContainer, void 0);
        this.editorLabels.push(editorLabel);
        // Tab Close
        var tabCloseContainer = document.createElement('div');
        DOM.addClass(tabCloseContainer, 'tab-close');
        tabContainer.appendChild(tabCloseContainer);
        var bar = new actionbar_1.ActionBar(tabCloseContainer, { ariaLabel: nls.localize('araLabelTabActions', "Tab actions"), actionRunner: new TabActionRunner(function () { return _this.context; }, index) });
        bar.push(this.closeEditorAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.closeEditorAction) });
        // Eventing
        var disposable = this.hookTabListeners(tabContainer, index);
        this.tabDisposeables.push(lifecycle_1.combinedDisposable([disposable, bar, editorLabel]));
        return tabContainer;
    };
    TabsTitleControl.prototype.layout = function () {
        if (!this.activeTab) {
            return;
        }
        var visibleContainerWidth = this.tabsContainer.offsetWidth;
        var totalContainerWidth = this.tabsContainer.scrollWidth;
        // Update scrollbar
        this.scrollbar.updateState({
            width: visibleContainerWidth,
            scrollWidth: totalContainerWidth
        });
        // Return now if we are blocked to reveal the active tab and clear flag
        if (this.blockRevealActiveTab) {
            this.blockRevealActiveTab = false;
            return;
        }
        // Reveal the active one
        var containerScrollPosX = this.tabsContainer.scrollLeft;
        var activeTabPosX = this.activeTab.offsetLeft;
        var activeTabWidth = this.activeTab.offsetWidth;
        var activeTabFits = activeTabWidth <= visibleContainerWidth;
        // Tab is overflowing to the right: Scroll minimally until the element is fully visible to the right
        // Note: only try to do this if we actually have enough width to give to show the tab fully!
        if (activeTabFits && containerScrollPosX + visibleContainerWidth < activeTabPosX + activeTabWidth) {
            this.scrollbar.updateState({
                scrollLeft: containerScrollPosX + ((activeTabPosX + activeTabWidth) /* right corner of tab */ - (containerScrollPosX + visibleContainerWidth) /* right corner of view port */)
            });
        }
        else if (containerScrollPosX > activeTabPosX || !activeTabFits) {
            this.scrollbar.updateState({
                scrollLeft: this.activeTab.offsetLeft
            });
        }
    };
    TabsTitleControl.prototype.hookTabListeners = function (tab, index) {
        var _this = this;
        var disposables = [];
        // Open on Click
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.MOUSE_DOWN, function (e) {
            tab.blur();
            var _a = _this.toTabContext(index), editor = _a.editor, position = _a.position;
            if (e.button === 0 /* Left Button */ && !DOM.findParentWithClass((e.target || e.srcElement), 'monaco-action-bar', 'tab')) {
                setTimeout(function () { return _this.editorService.openEditor(editor, null, position).done(null, errors.onUnexpectedError); }); // timeout to keep focus in editor after mouse up
            }
        }));
        // Close on mouse middle click
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.MOUSE_UP, function (e) {
            DOM.EventHelper.stop(e);
            tab.blur();
            if (e.button === 1 /* Middle Button */) {
                _this.closeEditorAction.run(_this.toTabContext(index)).done(null, errors.onUnexpectedError);
            }
        }));
        // Context menu on Shift+F10
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.KEY_DOWN, function (e) {
            var event = new keyboardEvent_1.StandardKeyboardEvent(e);
            if (event.shiftKey && event.keyCode === 68 /* F10 */) {
                DOM.EventHelper.stop(e);
                var _a = _this.toTabContext(index), group = _a.group, editor = _a.editor;
                _this.onContextMenu({ group: group, editor: editor }, e, tab);
            }
        }));
        // Keyboard accessibility
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.KEY_UP, function (e) {
            var event = new keyboardEvent_1.StandardKeyboardEvent(e);
            var handled = false;
            var _a = _this.toTabContext(index), group = _a.group, position = _a.position, editor = _a.editor;
            // Run action on Enter/Space
            if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                handled = true;
                _this.editorService.openEditor(editor, null, position).done(null, errors.onUnexpectedError);
            }
            else if ([15 /* LeftArrow */, 17 /* RightArrow */, 16 /* UpArrow */, 18 /* DownArrow */, 14 /* Home */, 13 /* End */].some(function (kb) { return event.equals(kb); })) {
                var targetIndex = void 0;
                if (event.equals(15 /* LeftArrow */) || event.equals(16 /* UpArrow */)) {
                    targetIndex = index - 1;
                }
                else if (event.equals(17 /* RightArrow */) || event.equals(18 /* DownArrow */)) {
                    targetIndex = index + 1;
                }
                else if (event.equals(14 /* Home */)) {
                    targetIndex = 0;
                }
                else {
                    targetIndex = group.count - 1;
                }
                var target = group.getEditor(targetIndex);
                if (target) {
                    handled = true;
                    _this.editorService.openEditor(target, { preserveFocus: true }, position).done(null, errors.onUnexpectedError);
                    _this.tabsContainer.childNodes[targetIndex].focus();
                }
            }
            if (handled) {
                DOM.EventHelper.stop(e, true);
            }
            // moving in the tabs container can have an impact on scrolling position, so we need to update the custom scrollbar
            _this.scrollbar.updateState({
                scrollLeft: _this.tabsContainer.scrollLeft
            });
        }));
        // Pin on double click
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DBLCLICK, function (e) {
            DOM.EventHelper.stop(e);
            var _a = _this.toTabContext(index), group = _a.group, editor = _a.editor;
            _this.editorGroupService.pinEditor(group, editor);
        }));
        // Context menu
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.CONTEXT_MENU, function (e) {
            DOM.EventHelper.stop(e, true);
            var _a = _this.toTabContext(index), group = _a.group, editor = _a.editor;
            _this.onContextMenu({ group: group, editor: editor }, e, tab);
        }, true /* use capture to fix https://github.com/Microsoft/vscode/issues/19145 */));
        // Drag start
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_START, function (e) {
            var _a = _this.toTabContext(index), group = _a.group, editor = _a.editor;
            _this.onEditorDragStart({ editor: editor, group: group });
            e.dataTransfer.effectAllowed = 'copyMove';
            // Insert transfer accordingly
            var fileResource = editor_2.toResource(editor, { supportSideBySide: true, filter: 'file' });
            if (fileResource) {
                var resource = fileResource.toString();
                e.dataTransfer.setData('URL', resource); // enables cross window DND of tabs
                e.dataTransfer.setData('DownloadURL', [mime_1.MIME_BINARY, editor.getName(), resource].join(':')); // enables support to drag a tab as file to desktop
            }
        }));
        // We need to keep track of DRAG_ENTER and DRAG_LEAVE events because a tab is not just a div without children,
        // it contains a label and a close button. HTML gives us DRAG_ENTER and DRAG_LEAVE events when hovering over
        // these children and this can cause flicker of the drop feedback. The workaround is to count the events and only
        // remove the drop feedback when the counter is 0 (see https://github.com/Microsoft/vscode/issues/14470)
        var counter = 0;
        // Drag over
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_ENTER, function (e) {
            counter++;
            DOM.addClass(tab, 'dropfeedback');
        }));
        // Drag leave
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_LEAVE, function (e) {
            counter--;
            if (counter === 0) {
                DOM.removeClass(tab, 'dropfeedback');
            }
        }));
        // Drag end
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DRAG_END, function (e) {
            counter = 0;
            DOM.removeClass(tab, 'dropfeedback');
            _this.onEditorDragEnd();
        }));
        // Drop
        disposables.push(DOM.addDisposableListener(tab, DOM.EventType.DROP, function (e) {
            counter = 0;
            DOM.removeClass(tab, 'dropfeedback');
            var _a = _this.toTabContext(index), group = _a.group, position = _a.position;
            _this.onDrop(e, group, position, index);
        }));
        return lifecycle_1.combinedDisposable(disposables);
    };
    TabsTitleControl.prototype.toTabContext = function (index) {
        var group = this.context;
        var position = this.stacks.positionOfGroup(group);
        var editor = group.getEditor(index);
        return { group: group, position: position, editor: editor };
    };
    TabsTitleControl.prototype.onDrop = function (e, group, targetPosition, targetIndex) {
        DOM.removeClass(this.tabsContainer, 'dropfeedback');
        DOM.removeClass(this.tabsContainer, 'scroll');
        // Local DND
        var draggedEditor = TabsTitleControl.getDraggedEditor();
        if (draggedEditor) {
            DOM.EventHelper.stop(e, true);
            // Move editor to target position and index
            if (this.isMoveOperation(e, draggedEditor.group, group)) {
                this.editorGroupService.moveEditor(draggedEditor.editor, draggedEditor.group, group, targetIndex);
            }
            else {
                this.editorService.openEditor(draggedEditor.editor, { pinned: true, index: targetIndex }, targetPosition).done(null, errors.onUnexpectedError);
            }
            this.onEditorDragEnd();
        }
        else {
            this.handleExternalDrop(e, targetPosition, targetIndex);
        }
    };
    TabsTitleControl.prototype.handleExternalDrop = function (e, targetPosition, targetIndex) {
        var _this = this;
        var resources = dnd_1.extractResources(e).filter(function (d) { return d.resource.scheme === 'file' || d.resource.scheme === 'untitled'; });
        // Handle resources
        if (resources.length) {
            DOM.EventHelper.stop(e, true);
            // Add external ones to recently open list
            var externalResources = resources.filter(function (d) { return d.isExternal; }).map(function (d) { return d.resource; });
            if (externalResources.length) {
                this.windowService.addToRecentlyOpen(externalResources.map(function (resource) {
                    return {
                        path: resource.fsPath,
                        isFile: true
                    };
                }));
            }
            // Open in Editor
            this.editorService.openEditors(resources.map(function (d) {
                return {
                    input: { resource: d.resource, options: { pinned: true, index: targetIndex } },
                    position: targetPosition
                };
            })).then(function () {
                _this.editorGroupService.focusGroup(targetPosition);
                return _this.windowService.focusWindow();
            }).done(null, errors.onUnexpectedError);
        }
    };
    TabsTitleControl.prototype.isMoveOperation = function (e, source, target) {
        var isCopy = (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
        return !isCopy || source.id === target.id;
    };
    return TabsTitleControl;
}(titleControl_1.TitleControl));
TabsTitleControl = __decorate([
    __param(0, contextView_1.IContextMenuService),
    __param(1, instantiation_1.IInstantiationService),
    __param(2, editorService_1.IWorkbenchEditorService),
    __param(3, groupService_1.IEditorGroupService),
    __param(4, untitledEditorService_1.IUntitledEditorService),
    __param(5, contextkey_1.IContextKeyService),
    __param(6, keybinding_1.IKeybindingService),
    __param(7, telemetry_1.ITelemetryService),
    __param(8, message_1.IMessageService),
    __param(9, actions_2.IMenuService),
    __param(10, quickOpen_1.IQuickOpenService),
    __param(11, windows_1.IWindowService)
], TabsTitleControl);
exports.TabsTitleControl = TabsTitleControl;
var TabActionRunner = (function (_super) {
    __extends(TabActionRunner, _super);
    function TabActionRunner(group, index) {
        var _this = _super.call(this) || this;
        _this.group = group;
        _this.index = index;
        return _this;
    }
    TabActionRunner.prototype.run = function (action, context) {
        var group = this.group();
        if (!group) {
            return winjs_base_1.TPromise.as(void 0);
        }
        return _super.prototype.run.call(this, action, { group: group, editor: group.getEditor(this.index) });
    };
    return TabActionRunner;
}(actions_1.ActionRunner));
