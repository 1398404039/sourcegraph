/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require("./media/quickopen.css");
var winjs_base_1 = require("vs/base/common/winjs.base");
var nls = require("vs/nls");
var browser = require("vs/base/browser/browser");
var builder_1 = require("vs/base/browser/builder");
var strings = require("vs/base/common/strings");
var filters = require("vs/base/common/filters");
var DOM = require("vs/base/browser/dom");
var idGenerator_1 = require("vs/base/common/idGenerator");
var types = require("vs/base/common/types");
var actions_1 = require("vs/base/common/actions");
var cancellation_1 = require("vs/base/common/cancellation");
var quickOpen_1 = require("vs/base/parts/quickopen/common/quickOpen");
var quickOpenModel_1 = require("vs/base/parts/quickopen/browser/quickOpenModel");
var quickOpenWidget_1 = require("vs/base/parts/quickopen/browser/quickOpenWidget");
var actionBarRegistry_1 = require("vs/workbench/browser/actionBarRegistry");
var labels = require("vs/base/common/labels");
var paths = require("vs/base/common/paths");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var platform_1 = require("vs/platform/platform");
var modeService_1 = require("vs/editor/common/services/modeService");
var labels_1 = require("vs/workbench/browser/labels");
var modelService_1 = require("vs/editor/common/services/modelService");
var editor_1 = require("vs/workbench/common/editor");
var component_1 = require("vs/workbench/common/component");
var event_1 = require("vs/base/common/event");
var partService_1 = require("vs/workbench/services/part/common/partService");
var quickopen_1 = require("vs/workbench/browser/quickopen");
var errors = require("vs/base/common/errors");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var quickOpen_2 = require("vs/platform/quickOpen/common/quickOpen");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var contextkey_1 = require("vs/platform/contextkey/common/contextkey");
var history_1 = require("vs/workbench/services/history/common/history");
var listService_1 = require("vs/platform/list/browser/listService");
var HELP_PREFIX = '?';
var QuickOpenController = (function (_super) {
    __extends(QuickOpenController, _super);
    function QuickOpenController(editorService, messageService, telemetryService, contextService, contextKeyService, configurationService, historyService, instantiationService, partService, listService) {
        var _this = _super.call(this, QuickOpenController.ID) || this;
        _this.editorService = editorService;
        _this.messageService = messageService;
        _this.telemetryService = telemetryService;
        _this.contextService = contextService;
        _this.configurationService = configurationService;
        _this.historyService = historyService;
        _this.instantiationService = instantiationService;
        _this.partService = partService;
        _this.listService = listService;
        _this.actionProvider = new actionBarRegistry_1.ContributableActionProvider();
        _this.previousValue = '';
        _this.mapResolvedHandlersToPrefix = {};
        _this.handlerOnOpenCalled = {};
        _this.promisesToCompleteOnHide = [];
        _this.inQuickOpenMode = new contextkey_1.RawContextKey('inQuickOpen', false).bindTo(contextKeyService);
        _this._onShow = new event_1.Emitter();
        _this._onHide = new event_1.Emitter();
        _this.updateConfiguration(_this.configurationService.getConfiguration());
        _this.registerListeners();
        return _this;
    }
    QuickOpenController.prototype.registerListeners = function () {
        var _this = this;
        this.toUnbind.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.updateConfiguration(e.config); }));
        this.toUnbind.push(this.partService.onTitleBarVisibilityChange(function () { return _this.positionQuickOpenWidget(); }));
        this.toUnbind.push(browser.onDidChangeZoomLevel(function () { return _this.positionQuickOpenWidget(); }));
    };
    QuickOpenController.prototype.updateConfiguration = function (settings) {
        this.closeOnFocusLost = settings.workbench.quickOpen.closeOnFocusLost;
    };
    Object.defineProperty(QuickOpenController.prototype, "onShow", {
        get: function () {
            return this._onShow.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuickOpenController.prototype, "onHide", {
        get: function () {
            return this._onHide.event;
        },
        enumerable: true,
        configurable: true
    });
    QuickOpenController.prototype.navigate = function (next, quickNavigate) {
        if (this.quickOpenWidget) {
            this.quickOpenWidget.navigate(next, quickNavigate);
        }
        if (!quickNavigate && this.pickOpenWidget) {
            this.pickOpenWidget.navigate(next); // quick-navigate is only supported in quick open, not picker
        }
    };
    QuickOpenController.prototype.input = function (options, token) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (token === void 0) { token = cancellation_1.CancellationToken.None; }
        if (this.pickOpenWidget && this.pickOpenWidget.isVisible()) {
            this.pickOpenWidget.hide(quickOpenWidget_1.HideReason.CANCELED);
        }
        var defaultMessage = options.prompt
            ? nls.localize('inputModeEntryDescription', "{0} (Press 'Enter' to confirm or 'Escape' to cancel)", options.prompt)
            : nls.localize('inputModeEntry', "Press 'Enter' to confirm your input or 'Escape' to cancel");
        var currentPick = defaultMessage;
        var currentValidation = winjs_base_1.TPromise.as(true);
        var currentDecoration;
        var lastValue;
        var init = function (resolve, reject) {
            // open quick pick with just one choice. we will recurse whenever
            // the validation/success message changes
            _this.doPick(winjs_base_1.TPromise.as([{ label: currentPick }]), {
                ignoreFocusLost: options.ignoreFocusLost,
                autoFocus: { autoFocusFirstEntry: true },
                password: options.password,
                placeHolder: options.placeHolder,
                value: lastValue === void 0 ? options.value : lastValue,
                valueSelect: lastValue === void 0,
                inputDecoration: currentDecoration,
                onDidType: function (value) {
                    lastValue = value;
                    if (options.validateInput) {
                        if (currentValidation) {
                            currentValidation.cancel();
                        }
                        currentValidation = winjs_base_1.TPromise.timeout(100).then(function () {
                            return options.validateInput(value).then(function (message) {
                                currentDecoration = !!message ? message_1.Severity.Error : void 0;
                                var newPick = message || defaultMessage;
                                if (newPick !== currentPick) {
                                    currentPick = newPick;
                                    resolve(new winjs_base_1.TPromise(init));
                                }
                                return !message;
                            });
                        }, function (err) {
                            // ignore
                        });
                    }
                }
            }, token).then(resolve, reject);
        };
        return new winjs_base_1.TPromise(init).then(function (item) {
            return currentValidation.then(function (valid) {
                if (valid && item) {
                    return lastValue || options.value || '';
                }
                return undefined;
            });
        });
    };
    QuickOpenController.prototype.pick = function (arg1, options, token) {
        var _this = this;
        if (!options) {
            options = Object.create(null);
        }
        var arrayPromise;
        if (Array.isArray(arg1)) {
            arrayPromise = winjs_base_1.TPromise.as(arg1);
        }
        else if (winjs_base_1.TPromise.is(arg1)) {
            arrayPromise = arg1;
        }
        else {
            throw new Error('illegal input');
        }
        var isAboutStrings = false;
        var entryPromise = arrayPromise.then(function (elements) {
            return elements.map(function (element) {
                if (typeof element === 'string') {
                    isAboutStrings = true;
                    return { label: element };
                }
                else {
                    return element;
                }
            });
        });
        if (this.pickOpenWidget && this.pickOpenWidget.isVisible()) {
            this.pickOpenWidget.hide(quickOpenWidget_1.HideReason.CANCELED);
        }
        return new winjs_base_1.TPromise(function (resolve, reject, progress) {
            function onItem(item) {
                return item && isAboutStrings ? item.label : item;
            }
            _this.doPick(entryPromise, options, token).then(function (item) { return resolve(onItem(item)); }, function (err) { return reject(err); }, function (item) { return progress(onItem(item)); });
        });
    };
    QuickOpenController.prototype.doPick = function (picksPromise, options, token) {
        var _this = this;
        if (token === void 0) { token = cancellation_1.CancellationToken.None; }
        var autoFocus = options.autoFocus;
        // Use a generated token to avoid race conditions from long running promises
        var currentPickerToken = idGenerator_1.defaultGenerator.nextId();
        this.currentPickerToken = currentPickerToken;
        // Create upon first open
        if (!this.pickOpenWidget) {
            this.pickOpenWidget = new quickOpenWidget_1.QuickOpenWidget(builder_1.withElementById(this.partService.getWorkbenchElementId()).getHTMLElement(), {
                onOk: function () { },
                onCancel: function () { },
                onType: function (value) { },
                onShow: function () { return _this.handleOnShow(true); },
                onHide: function (reason) { return _this.handleOnHide(true, reason); }
            }, {
                inputPlaceHolder: options.placeHolder || '',
                keyboardSupport: false
            }, this.telemetryService);
            var pickOpenContainer = this.pickOpenWidget.create();
            this.toUnbind.push(this.listService.register(this.pickOpenWidget.getTree()));
            DOM.addClass(pickOpenContainer, 'show-file-icons');
            this.positionQuickOpenWidget();
        }
        else {
            this.pickOpenWidget.setPlaceHolder(options.placeHolder || '');
        }
        // Respect input value
        if (options.value) {
            this.pickOpenWidget.setValue(options.value, options.valueSelect);
        }
        // Respect password
        this.pickOpenWidget.setPassword(options.password);
        // Input decoration
        if (!types.isUndefinedOrNull(options.inputDecoration)) {
            this.pickOpenWidget.showInputDecoration(options.inputDecoration);
        }
        else {
            this.pickOpenWidget.clearInputDecoration();
        }
        // Layout
        if (this.layoutDimensions) {
            this.pickOpenWidget.layout(this.layoutDimensions);
        }
        // Detect cancellation while pick promise is loading
        var cancelTriggered = false;
        this.pickOpenWidget.setCallbacks({
            onOk: function () { },
            onCancel: function () { cancelTriggered = true; },
            onType: function (value) { },
        });
        return new winjs_base_1.TPromise(function (complete, error, progress) {
            // hide widget when being cancelled
            token.onCancellationRequested(function (e) {
                if (_this.currentPickerToken === currentPickerToken) {
                    _this.pickOpenWidget.hide(quickOpenWidget_1.HideReason.CANCELED);
                }
            });
            var picksPromiseDone = false;
            // Resolve picks
            picksPromise.then(function (picks) {
                if (_this.currentPickerToken !== currentPickerToken || cancelTriggered) {
                    return complete(void 0); // Return as canceled if another request came after or user canceled
                }
                picksPromiseDone = true;
                // Reset Progress
                _this.pickOpenWidget.getProgressBar().stop().getContainer().hide();
                // Model
                var model = new quickOpenModel_1.QuickOpenModel();
                var entries = picks.map(function (e, index) { return _this.instantiationService.createInstance(PickOpenEntry, e, index, function () { return progress(e); }); });
                if (picks.length === 0) {
                    entries.push(_this.instantiationService.createInstance(PickOpenEntry, { label: nls.localize('emptyPicks', "There are no entries to pick from") }, 0, null));
                }
                model.setEntries(entries);
                // Handlers
                var callbacks = {
                    onOk: function () {
                        if (picks.length === 0) {
                            return complete(null);
                        }
                        var index = -1;
                        var context;
                        entries.forEach(function (entry) {
                            if (entry.shouldRunWithContext) {
                                index = entry.index;
                                context = entry.shouldRunWithContext;
                            }
                        });
                        var selectedPick = picks[index];
                        if (selectedPick && typeof selectedPick.run === 'function') {
                            selectedPick.run(context);
                        }
                        complete(selectedPick || null);
                    },
                    onCancel: function () { return complete(void 0); },
                    onFocusLost: function () { return !_this.closeOnFocusLost || options.ignoreFocusLost; },
                    onType: function (value) {
                        // the caller takes care of all input
                        if (options.onDidType) {
                            options.onDidType(value);
                            return;
                        }
                        if (picks.length === 0) {
                            return;
                        }
                        value = value ? strings.trim(value) : value;
                        // Reset filtering
                        if (!value) {
                            entries.forEach(function (e) {
                                e.setHighlights(null);
                                e.setHidden(false);
                            });
                        }
                        else {
                            entries.forEach(function (entry) {
                                var labelHighlights = filters.matchesFuzzy(value, entry.getLabel());
                                var descriptionHighlights = options.matchOnDescription && filters.matchesFuzzy(value, entry.getDescription());
                                var detailHighlights = options.matchOnDetail && entry.getDetail() && filters.matchesFuzzy(value, entry.getDetail());
                                if (entry.shouldAlwaysShow() || labelHighlights || descriptionHighlights || detailHighlights) {
                                    entry.setHighlights(labelHighlights, descriptionHighlights, detailHighlights);
                                    entry.setHidden(false);
                                }
                                else {
                                    entry.setHighlights(null, null, null);
                                    entry.setHidden(true);
                                }
                            });
                        }
                        // Sort by value
                        var normalizedSearchValue = value ? strings.stripWildcards(value.toLowerCase()) : value;
                        model.entries.sort(function (pickA, pickB) {
                            if (!value) {
                                return pickA.index - pickB.index; // restore natural order
                            }
                            return quickOpenModel_1.QuickOpenEntry.compare(pickA, pickB, normalizedSearchValue);
                        });
                        _this.pickOpenWidget.refresh(model, value ? { autoFocusFirstEntry: true } : autoFocus);
                    },
                    onShow: function () { return _this.handleOnShow(true); },
                    onHide: function (reason) { return _this.handleOnHide(true, reason); }
                };
                _this.pickOpenWidget.setCallbacks(callbacks);
                // Set input
                if (!_this.pickOpenWidget.isVisible()) {
                    _this.pickOpenWidget.show(model, { autoFocus: autoFocus });
                }
                else {
                    _this.pickOpenWidget.setInput(model, autoFocus);
                }
                // The user might have typed something (or options.value was set) so we need to play back
                // the input box value through our callbacks to filter the result accordingly.
                var inputValue = _this.pickOpenWidget.getInputBox().value;
                if (inputValue) {
                    callbacks.onType(inputValue);
                }
            }, function (err) {
                _this.pickOpenWidget.hide();
                error(err);
            });
            // Progress if task takes a long time
            winjs_base_1.TPromise.timeout(800).then(function () {
                if (!picksPromiseDone && _this.currentPickerToken === currentPickerToken) {
                    _this.pickOpenWidget.getProgressBar().infinite().getContainer().show();
                }
            });
            // Show picker empty if resolving takes a while
            if (!picksPromiseDone) {
                _this.pickOpenWidget.show(new quickOpenModel_1.QuickOpenModel());
            }
        });
    };
    QuickOpenController.prototype.accept = function () {
        [this.quickOpenWidget, this.pickOpenWidget].forEach(function (w) {
            if (w && w.isVisible()) {
                w.accept();
            }
        });
    };
    QuickOpenController.prototype.focus = function () {
        [this.quickOpenWidget, this.pickOpenWidget].forEach(function (w) {
            if (w && w.isVisible()) {
                w.focus();
            }
        });
    };
    QuickOpenController.prototype.close = function () {
        [this.quickOpenWidget, this.pickOpenWidget].forEach(function (w) {
            if (w && w.isVisible()) {
                w.hide(quickOpenWidget_1.HideReason.CANCELED);
            }
        });
    };
    QuickOpenController.prototype.emitQuickOpenVisibilityChange = function (isVisible) {
        var _this = this;
        if (this.visibilityChangeTimeoutHandle) {
            window.clearTimeout(this.visibilityChangeTimeoutHandle);
        }
        this.visibilityChangeTimeoutHandle = setTimeout(function () {
            if (isVisible) {
                _this._onShow.fire();
            }
            else {
                _this._onHide.fire();
            }
            _this.visibilityChangeTimeoutHandle = void 0;
        }, 100 /* to prevent flashing, we accumulate visibility changes over a timeout of 100ms */);
    };
    QuickOpenController.prototype.show = function (prefix, options) {
        var _this = this;
        var quickNavigateConfiguration = options ? options.quickNavigateConfiguration : void 0;
        this.previousValue = prefix;
        var promiseCompletedOnHide = new winjs_base_1.TPromise(function (c) {
            _this.promisesToCompleteOnHide.push(c);
        });
        // Telemetry: log that quick open is shown and log the mode
        var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);
        var handlerDescriptor = registry.getQuickOpenHandler(prefix) || registry.getDefaultQuickOpenHandler();
        this.telemetryService.publicLog('quickOpenWidgetShown', { mode: handlerDescriptor.getId(), quickNavigate: quickNavigateConfiguration });
        // Trigger onOpen
        this.resolveHandler(handlerDescriptor)
            .done(null, errors.onUnexpectedError);
        // Create upon first open
        if (!this.quickOpenWidget) {
            this.quickOpenWidget = new quickOpenWidget_1.QuickOpenWidget(builder_1.withElementById(this.partService.getWorkbenchElementId()).getHTMLElement(), {
                onOk: function () { },
                onCancel: function () { },
                onType: function (value) { return _this.onType(value || ''); },
                onShow: function () { return _this.handleOnShow(false); },
                onHide: function (reason) { return _this.handleOnHide(false, reason); },
                onFocusLost: function () { return !_this.closeOnFocusLost; }
            }, {
                inputPlaceHolder: this.hasHandler(HELP_PREFIX) ? nls.localize('quickOpenInput', "Type '?' to get help on the actions you can take from here") : '',
                keyboardSupport: false
            }, this.telemetryService);
            var quickOpenContainer = this.quickOpenWidget.create();
            this.toUnbind.push(this.listService.register(this.quickOpenWidget.getTree()));
            DOM.addClass(quickOpenContainer, 'show-file-icons');
            this.positionQuickOpenWidget();
        }
        // Layout
        if (this.layoutDimensions) {
            this.quickOpenWidget.layout(this.layoutDimensions);
        }
        // Show quick open with prefix or editor history
        if (!this.quickOpenWidget.isVisible() || quickNavigateConfiguration) {
            if (prefix) {
                this.quickOpenWidget.show(prefix, { quickNavigateConfiguration: quickNavigateConfiguration });
            }
            else {
                var editorHistory = this.getEditorHistoryWithGroupLabel();
                if (editorHistory.getEntries().length < 2) {
                    quickNavigateConfiguration = null; // If no entries can be shown, default to normal quick open mode
                }
                var autoFocus = void 0;
                if (!quickNavigateConfiguration) {
                    autoFocus = { autoFocusFirstEntry: true };
                }
                else {
                    var visibleEditorCount = this.editorService.getVisibleEditors().length;
                    autoFocus = { autoFocusFirstEntry: visibleEditorCount === 0, autoFocusSecondEntry: visibleEditorCount !== 0 };
                }
                this.quickOpenWidget.show(editorHistory, { quickNavigateConfiguration: quickNavigateConfiguration, autoFocus: autoFocus });
            }
        }
        else {
            this.quickOpenWidget.show(prefix || '');
        }
        return promiseCompletedOnHide;
    };
    QuickOpenController.prototype.positionQuickOpenWidget = function () {
        var titlebarOffset = this.partService.getTitleBarOffset();
        if (this.quickOpenWidget) {
            this.quickOpenWidget.getElement().style('top', titlebarOffset + "px");
        }
        if (this.pickOpenWidget) {
            this.pickOpenWidget.getElement().style('top', titlebarOffset + "px");
        }
    };
    QuickOpenController.prototype.handleOnShow = function (isPicker) {
        if (isPicker && this.quickOpenWidget) {
            this.quickOpenWidget.hide(quickOpenWidget_1.HideReason.FOCUS_LOST);
        }
        else if (!isPicker && this.pickOpenWidget) {
            this.pickOpenWidget.hide(quickOpenWidget_1.HideReason.FOCUS_LOST);
        }
        this.inQuickOpenMode.set(true);
        this.emitQuickOpenVisibilityChange(true);
    };
    QuickOpenController.prototype.handleOnHide = function (isPicker, reason) {
        var _this = this;
        if (!isPicker) {
            // Clear state
            this.previousActiveHandlerDescriptor = null;
            var _loop_1 = function (prefix) {
                if (this_1.mapResolvedHandlersToPrefix.hasOwnProperty(prefix)) {
                    var promise = this_1.mapResolvedHandlersToPrefix[prefix];
                    promise.then(function (handler) {
                        _this.handlerOnOpenCalled[prefix] = false;
                        // Don't check if onOpen was called to preserve old behaviour for now
                        handler.onClose(reason === quickOpenWidget_1.HideReason.CANCELED);
                    });
                }
            };
            var this_1 = this;
            // Pass to handlers
            for (var prefix in this.mapResolvedHandlersToPrefix) {
                _loop_1(prefix);
            }
            // Complete promises that are waiting
            while (this.promisesToCompleteOnHide.length) {
                this.promisesToCompleteOnHide.pop()(true);
            }
        }
        if (reason !== quickOpenWidget_1.HideReason.FOCUS_LOST) {
            this.restoreFocus(); // focus back to editor unless user clicked somewhere else
        }
        this.inQuickOpenMode.reset();
        this.emitQuickOpenVisibilityChange(false);
    };
    QuickOpenController.prototype.hasHandler = function (prefix) {
        return !!platform_1.Registry.as(quickopen_1.Extensions.Quickopen).getQuickOpenHandler(prefix);
    };
    QuickOpenController.prototype.getEditorHistoryWithGroupLabel = function () {
        var entries = this.getEditorHistoryEntries();
        // Apply label to first entry
        if (entries.length > 0) {
            entries[0] = new EditorHistoryEntryGroup(entries[0], nls.localize('historyMatches', "recently opened"), false);
        }
        return new quickOpenModel_1.QuickOpenModel(entries, this.actionProvider);
    };
    QuickOpenController.prototype.restoreFocus = function () {
        // Try to focus active editor
        var editor = this.editorService.getActiveEditor();
        if (editor) {
            editor.focus();
        }
    };
    QuickOpenController.prototype.onType = function (value) {
        var _this = this;
        this.previousValue = value;
        // look for a handler
        var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);
        var handlerDescriptor = registry.getQuickOpenHandler(value);
        var defaultHandlerDescriptor = registry.getDefaultQuickOpenHandler();
        var instantProgress = handlerDescriptor && handlerDescriptor.instantProgress;
        // Use a generated token to avoid race conditions from long running promises
        var currentResultToken = idGenerator_1.defaultGenerator.nextId();
        this.currentResultToken = currentResultToken;
        // Reset Progress
        if (!instantProgress) {
            this.quickOpenWidget.getProgressBar().stop().getContainer().hide();
        }
        // Reset Extra Class
        this.quickOpenWidget.setExtraClass(null);
        // Remove leading and trailing whitespace
        var trimmedValue = strings.trim(value);
        // If no value provided, default to editor history
        if (!trimmedValue) {
            // Trigger onOpen
            this.resolveHandler(handlerDescriptor || defaultHandlerDescriptor)
                .done(null, errors.onUnexpectedError);
            this.quickOpenWidget.setInput(this.getEditorHistoryWithGroupLabel(), { autoFocusFirstEntry: true });
            return;
        }
        var resultPromise;
        var resultPromiseDone = false;
        if (handlerDescriptor) {
            resultPromise = this.handleSpecificHandler(handlerDescriptor, value, currentResultToken);
        }
        else {
            resultPromise = this.handleDefaultHandler(defaultHandlerDescriptor, value, currentResultToken);
        }
        // Remember as the active one
        this.previousActiveHandlerDescriptor = handlerDescriptor;
        // Progress if task takes a long time
        winjs_base_1.TPromise.timeout(instantProgress ? 0 : 800).then(function () {
            if (!resultPromiseDone && currentResultToken === _this.currentResultToken) {
                _this.quickOpenWidget.getProgressBar().infinite().getContainer().show();
            }
        });
        // Promise done handling
        resultPromise.done(function () {
            resultPromiseDone = true;
            if (currentResultToken === _this.currentResultToken) {
                _this.quickOpenWidget.getProgressBar().getContainer().hide();
            }
        }, function (error) {
            resultPromiseDone = true;
            errors.onUnexpectedError(error);
            _this.messageService.show(message_1.Severity.Error, types.isString(error) ? new Error(error) : error);
        });
    };
    QuickOpenController.prototype.handleDefaultHandler = function (handler, value, currentResultToken) {
        var _this = this;
        // Fill in history results if matching
        var matchingHistoryEntries = this.getEditorHistoryEntries(value);
        if (matchingHistoryEntries.length > 0) {
            matchingHistoryEntries[0] = new EditorHistoryEntryGroup(matchingHistoryEntries[0], nls.localize('historyMatches', "recently opened"), false);
        }
        // Resolve
        return this.resolveHandler(handler).then(function (resolvedHandler) {
            var quickOpenModel = new quickOpenModel_1.QuickOpenModel(matchingHistoryEntries, _this.actionProvider);
            var inputSet = false;
            // If we have matching entries from history we want to show them directly and not wait for the other results to come in
            // This also applies when we used to have entries from a previous run and now there are no more history results matching
            var previousInput = _this.quickOpenWidget.getInput();
            var wasShowingHistory = previousInput && previousInput.entries && previousInput.entries.some(function (e) { return e instanceof EditorHistoryEntry || e instanceof EditorHistoryEntryGroup; });
            if (wasShowingHistory || matchingHistoryEntries.length > 0) {
                (resolvedHandler.hasShortResponseTime() ? winjs_base_1.TPromise.timeout(QuickOpenController.MAX_SHORT_RESPONSE_TIME) : winjs_base_1.TPromise.as(undefined)).then(function () {
                    if (_this.currentResultToken === currentResultToken && !inputSet) {
                        _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });
                        inputSet = true;
                    }
                });
            }
            // Get results
            return resolvedHandler.getResults(value).then(function (result) {
                if (_this.currentResultToken === currentResultToken) {
                    // now is the time to show the input if we did not have set it before
                    if (!inputSet) {
                        _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });
                        inputSet = true;
                    }
                    // merge history and default handler results
                    var handlerResults = (result && result.entries) || [];
                    _this.mergeResults(quickOpenModel, handlerResults, resolvedHandler.getGroupLabel());
                }
            });
        });
    };
    QuickOpenController.prototype.getEditorHistoryEntries = function (searchValue) {
        var _this = this;
        if (searchValue) {
            searchValue = searchValue.replace(/ /g, ''); // get rid of all whitespace
        }
        // Just return all if we are not searching
        var history = this.historyService.getHistory();
        if (!searchValue) {
            return history.map(function (input) { return _this.instantiationService.createInstance(EditorHistoryEntry, input); });
        }
        var searchInPath = searchValue.indexOf(paths.nativeSep) >= 0;
        var results = [];
        history.forEach(function (input) {
            var resource;
            if (input instanceof editor_1.EditorInput) {
                resource = editor_1.toResource(input, { filter: ['file', 'untitled'] });
            }
            else {
                resource = input.resource;
            }
            if (!resource) {
                return; //For now, only support to match on inputs that provide resource information
            }
            var searchTargetToMatch;
            if (searchInPath) {
                searchTargetToMatch = labels.getPathLabel(resource, _this.contextService);
            }
            else if (input instanceof editor_1.EditorInput) {
                searchTargetToMatch = input.getName();
            }
            else {
                searchTargetToMatch = paths.basename(input.resource.fsPath);
            }
            // Check if this entry is a match for the search value
            if (!filters.matchesFuzzy(searchValue, searchTargetToMatch)) {
                return;
            }
            var entry = _this.instantiationService.createInstance(EditorHistoryEntry, input);
            var _a = quickOpenModel_1.QuickOpenEntry.highlight(entry, searchValue), labelHighlights = _a.labelHighlights, descriptionHighlights = _a.descriptionHighlights;
            entry.setHighlights(labelHighlights, descriptionHighlights);
            results.push(entry);
        });
        // Sort
        var normalizedSearchValue = strings.stripWildcards(searchValue.toLowerCase());
        return results.sort(function (elementA, elementB) { return quickOpenModel_1.QuickOpenEntry.compare(elementA, elementB, normalizedSearchValue); });
    };
    QuickOpenController.prototype.mergeResults = function (quickOpenModel, handlerResults, groupLabel) {
        // Remove results already showing by checking for a "resource" property
        var mapEntryToResource = this.mapEntriesToResource(quickOpenModel);
        var additionalHandlerResults = [];
        for (var i = 0; i < handlerResults.length; i++) {
            var result = handlerResults[i];
            var resource = result.getResource();
            if (!result.isFile() || !resource || !mapEntryToResource[resource.toString()]) {
                additionalHandlerResults.push(result);
            }
        }
        // Show additional handler results below any existing results
        if (additionalHandlerResults.length > 0) {
            var useTopBorder = quickOpenModel.getEntries().length > 0;
            additionalHandlerResults[0] = new quickOpenModel_1.QuickOpenEntryGroup(additionalHandlerResults[0], groupLabel, useTopBorder);
            quickOpenModel.addEntries(additionalHandlerResults);
            this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: true });
        }
        else if (quickOpenModel.getEntries().length === 0) {
            quickOpenModel.addEntries([new PlaceholderQuickOpenEntry(nls.localize('noResultsFound1', "No results found"))]);
            this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: true });
        }
    };
    QuickOpenController.prototype.handleSpecificHandler = function (handlerDescriptor, value, currentResultToken) {
        var _this = this;
        return this.resolveHandler(handlerDescriptor).then(function (resolvedHandler) {
            // Remove handler prefix from search value
            value = value.substr(handlerDescriptor.prefix.length);
            // Return early if the handler can not run in the current environment and inform the user
            var canRun = resolvedHandler.canRun();
            if (types.isUndefinedOrNull(canRun) || (typeof canRun === 'boolean' && !canRun) || typeof canRun === 'string') {
                var placeHolderLabel = (typeof canRun === 'string') ? canRun : nls.localize('canNotRunPlaceholder', "This quick open handler can not be used in the current context");
                var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(placeHolderLabel)], _this.actionProvider);
                _this.showModel(model, resolvedHandler.getAutoFocus(value, _this.quickOpenWidget.getQuickNavigateConfiguration()), resolvedHandler.getAriaLabel());
                return winjs_base_1.TPromise.as(null);
            }
            // Support extra class from handler
            var extraClass = resolvedHandler.getClass();
            if (extraClass) {
                _this.quickOpenWidget.setExtraClass(extraClass);
            }
            // When handlers change, clear the result list first before loading the new results
            if (_this.previousActiveHandlerDescriptor !== handlerDescriptor) {
                _this.clearModel();
            }
            // Receive Results from Handler and apply
            return resolvedHandler.getResults(value).then(function (result) {
                if (_this.currentResultToken === currentResultToken) {
                    if (!result || !result.entries.length) {
                        var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(resolvedHandler.getEmptyLabel(value))]);
                        _this.showModel(model, resolvedHandler.getAutoFocus(value, _this.quickOpenWidget.getQuickNavigateConfiguration()), resolvedHandler.getAriaLabel());
                    }
                    else {
                        _this.showModel(result, resolvedHandler.getAutoFocus(value, _this.quickOpenWidget.getQuickNavigateConfiguration()), resolvedHandler.getAriaLabel());
                    }
                }
            });
        });
    };
    QuickOpenController.prototype.showModel = function (model, autoFocus, ariaLabel) {
        // If the given model is already set in the widget, refresh and return early
        if (this.quickOpenWidget.getInput() === model) {
            this.quickOpenWidget.refresh(model, autoFocus);
            return;
        }
        // Otherwise just set it
        this.quickOpenWidget.setInput(model, autoFocus, ariaLabel);
    };
    QuickOpenController.prototype.clearModel = function () {
        this.showModel(new quickOpenModel_1.QuickOpenModel(), null);
    };
    QuickOpenController.prototype.mapEntriesToResource = function (model) {
        var entries = model.getEntries();
        var mapEntryToPath = {};
        entries.forEach(function (entry) {
            if (entry.getResource()) {
                mapEntryToPath[entry.getResource().toString()] = entry;
            }
        });
        return mapEntryToPath;
    };
    QuickOpenController.prototype.resolveHandler = function (handler) {
        var _this = this;
        var result = this._resolveHandler(handler);
        var id = handler.getId();
        if (!this.handlerOnOpenCalled[id]) {
            var original_1 = result;
            this.handlerOnOpenCalled[id] = true;
            result = this.mapResolvedHandlersToPrefix[id] = original_1.then(function (resolved) {
                _this.mapResolvedHandlersToPrefix[id] = original_1;
                resolved.onOpen();
                return resolved;
            });
        }
        return result.then(null, function (error) {
            delete _this.mapResolvedHandlersToPrefix[id];
            return winjs_base_1.TPromise.wrapError('Unable to instantiate quick open handler ' + handler.moduleName + ' - ' + handler.ctorName + ': ' + JSON.stringify(error));
        });
    };
    QuickOpenController.prototype._resolveHandler = function (handler) {
        var id = handler.getId();
        // Return Cached
        if (this.mapResolvedHandlersToPrefix[id]) {
            return this.mapResolvedHandlersToPrefix[id];
        }
        // Otherwise load and create
        return this.mapResolvedHandlersToPrefix[id] = this.instantiationService.createInstance(handler);
    };
    QuickOpenController.prototype.layout = function (dimension) {
        this.layoutDimensions = dimension;
        if (this.quickOpenWidget) {
            this.quickOpenWidget.layout(this.layoutDimensions);
        }
        if (this.pickOpenWidget) {
            this.pickOpenWidget.layout(this.layoutDimensions);
        }
    };
    QuickOpenController.prototype.dispose = function () {
        if (this.quickOpenWidget) {
            this.quickOpenWidget.dispose();
        }
        if (this.pickOpenWidget) {
            this.pickOpenWidget.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    return QuickOpenController;
}(component_1.WorkbenchComponent));
QuickOpenController.MAX_SHORT_RESPONSE_TIME = 500;
QuickOpenController.ID = 'workbench.component.quickopen';
QuickOpenController = __decorate([
    __param(0, editorService_1.IWorkbenchEditorService),
    __param(1, message_1.IMessageService),
    __param(2, telemetry_1.ITelemetryService),
    __param(3, workspace_1.IWorkspaceContextService),
    __param(4, contextkey_1.IContextKeyService),
    __param(5, configuration_1.IConfigurationService),
    __param(6, history_1.IHistoryService),
    __param(7, instantiation_1.IInstantiationService),
    __param(8, partService_1.IPartService),
    __param(9, listService_1.IListService)
], QuickOpenController);
exports.QuickOpenController = QuickOpenController;
var PlaceholderQuickOpenEntry = (function (_super) {
    __extends(PlaceholderQuickOpenEntry, _super);
    function PlaceholderQuickOpenEntry(placeHolderLabel) {
        var _this = _super.call(this) || this;
        _this.placeHolderLabel = placeHolderLabel;
        return _this;
    }
    PlaceholderQuickOpenEntry.prototype.getLabel = function () {
        return this.placeHolderLabel;
    };
    return PlaceholderQuickOpenEntry;
}(quickOpenModel_1.QuickOpenEntryGroup));
var PickOpenEntry = (function (_super) {
    __extends(PickOpenEntry, _super);
    function PickOpenEntry(item, _index, onPreview, modeService, modelService) {
        var _this = _super.call(this, item.label) || this;
        _this._index = _index;
        _this.onPreview = onPreview;
        _this.modeService = modeService;
        _this.modelService = modelService;
        _this.description = item.description;
        _this.detail = item.detail;
        _this.hasSeparator = item.separator && item.separator.border;
        _this.separatorLabel = item.separator && item.separator.label;
        _this.alwaysShow = item.alwaysShow;
        var fileItem = item;
        _this.resource = fileItem.resource;
        _this.isFolder = fileItem.isFolder;
        return _this;
    }
    Object.defineProperty(PickOpenEntry.prototype, "index", {
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    PickOpenEntry.prototype.getLabelOptions = function () {
        return {
            extraClasses: this.resource ? labels_1.getIconClasses(this.modelService, this.modeService, this.resource, this.isFolder) : []
        };
    };
    Object.defineProperty(PickOpenEntry.prototype, "shouldRunWithContext", {
        get: function () {
            return this._shouldRunWithContext;
        },
        enumerable: true,
        configurable: true
    });
    PickOpenEntry.prototype.getDescription = function () {
        return this.description;
    };
    PickOpenEntry.prototype.getDetail = function () {
        return this.detail;
    };
    PickOpenEntry.prototype.showBorder = function () {
        return this.hasSeparator;
    };
    PickOpenEntry.prototype.getGroupLabel = function () {
        return this.separatorLabel;
    };
    PickOpenEntry.prototype.shouldAlwaysShow = function () {
        return this.alwaysShow;
    };
    PickOpenEntry.prototype.run = function (mode, context) {
        if (mode === quickOpen_1.Mode.OPEN) {
            this._shouldRunWithContext = context;
            return true;
        }
        if (mode === quickOpen_1.Mode.PREVIEW && this.onPreview) {
            this.onPreview();
        }
        return false;
    };
    return PickOpenEntry;
}(PlaceholderQuickOpenEntry));
PickOpenEntry = __decorate([
    __param(3, modeService_1.IModeService),
    __param(4, modelService_1.IModelService)
], PickOpenEntry);
var EditorHistoryEntryGroup = (function (_super) {
    __extends(EditorHistoryEntryGroup, _super);
    function EditorHistoryEntryGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EditorHistoryEntryGroup;
}(quickOpenModel_1.QuickOpenEntryGroup));
exports.EditorHistoryEntryGroup = EditorHistoryEntryGroup;
var EditorHistoryEntry = (function (_super) {
    __extends(EditorHistoryEntry, _super);
    function EditorHistoryEntry(input, editorService, modeService, modelService, textFileService, contextService, configurationService) {
        var _this = _super.call(this, editorService) || this;
        _this.modeService = modeService;
        _this.modelService = modelService;
        _this.textFileService = textFileService;
        _this.configurationService = configurationService;
        _this.contextService = contextService;
        _this.input = input;
        if (input instanceof editor_1.EditorInput) {
            _this.resource = editor_1.toResource(input, { filter: ['file', 'untitled'] });
            _this.label = input.getName();
            _this.description = input.getDescription();
            _this.dirty = input.isDirty();
        }
        else {
            var resourceInput = input;
            _this.resource = resourceInput.resource;
            _this.label = paths.basename(resourceInput.resource.fsPath);
            _this.description = labels.getPathLabel(paths.dirname(_this.resource.fsPath), contextService);
            _this.dirty = _this.resource && _this.textFileService.isDirty(_this.resource);
            if (_this.dirty && _this.textFileService.getAutoSaveMode() === textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) {
                _this.dirty = false; // no dirty decoration if auto save is on with a short timeout
            }
        }
        return _this;
    }
    EditorHistoryEntry.prototype.getIcon = function () {
        return this.dirty ? 'dirty' : '';
    };
    EditorHistoryEntry.prototype.getLabel = function () {
        return this.label;
    };
    EditorHistoryEntry.prototype.getLabelOptions = function () {
        return {
            extraClasses: labels_1.getIconClasses(this.modelService, this.modeService, this.resource)
        };
    };
    EditorHistoryEntry.prototype.getAriaLabel = function () {
        return nls.localize('entryAriaLabel', "{0}, recently opened", this.getLabel());
    };
    EditorHistoryEntry.prototype.getDescription = function () {
        return this.description;
    };
    EditorHistoryEntry.prototype.getResource = function () {
        return this.resource;
    };
    EditorHistoryEntry.prototype.getInput = function () {
        return this.input;
    };
    EditorHistoryEntry.prototype.run = function (mode, context) {
        var _this = this;
        if (mode === quickOpen_1.Mode.OPEN) {
            var sideBySide = !context.quickNavigateConfiguration && context.keymods.indexOf(2048 /* CtrlCmd */) >= 0;
            var pinned = !this.configurationService.getConfiguration().workbench.editor.enablePreviewFromQuickOpen;
            if (this.input instanceof editor_1.EditorInput) {
                this.editorService.openEditor(this.input, { pinned: pinned }, sideBySide).done(null, errors.onUnexpectedError);
            }
            else {
                this.editorService.openEditor({ resource: this.input.resource, options: { pinned: pinned } }, sideBySide).then(function () {
                    var workspace = _this.contextService.tryGetWorkspaceFromRegistry(_this.resource);
                    if (workspace) {
                        _this.contextService.setWorkspace(workspace);
                    }
                });
            }
            return true;
        }
        return _super.prototype.run.call(this, mode, context);
    };
    return EditorHistoryEntry;
}(quickopen_1.EditorQuickOpenEntry));
EditorHistoryEntry = __decorate([
    __param(1, editorService_1.IWorkbenchEditorService),
    __param(2, modeService_1.IModeService),
    __param(3, modelService_1.IModelService),
    __param(4, textfiles_1.ITextFileService),
    __param(5, workspace_1.IWorkspaceContextService),
    __param(6, configuration_1.IConfigurationService)
], EditorHistoryEntry);
exports.EditorHistoryEntry = EditorHistoryEntry;
var RemoveFromEditorHistoryAction = (function (_super) {
    __extends(RemoveFromEditorHistoryAction, _super);
    function RemoveFromEditorHistoryAction(id, label, quickOpenService, instantiationService, historyService) {
        var _this = _super.call(this, id, label) || this;
        _this.quickOpenService = quickOpenService;
        _this.instantiationService = instantiationService;
        _this.historyService = historyService;
        return _this;
    }
    RemoveFromEditorHistoryAction.prototype.run = function () {
        var _this = this;
        var history = this.historyService.getHistory();
        var picks = history.map(function (h) {
            var entry = _this.instantiationService.createInstance(EditorHistoryEntry, h);
            return {
                input: h,
                resource: entry.getResource(),
                label: entry.getLabel(),
                description: entry.getDescription()
            };
        });
        return this.quickOpenService.pick(picks, { placeHolder: nls.localize('pickHistory', "Select an editor entry to remove from history"), autoFocus: { autoFocusFirstEntry: true }, matchOnDescription: true }).then(function (pick) {
            if (pick) {
                _this.historyService.remove(pick.input);
            }
        });
    };
    return RemoveFromEditorHistoryAction;
}(actions_1.Action));
RemoveFromEditorHistoryAction.ID = 'workbench.action.removeFromEditorHistory';
RemoveFromEditorHistoryAction.LABEL = nls.localize('removeFromEditorHistory', "Remove From History");
RemoveFromEditorHistoryAction = __decorate([
    __param(2, quickOpen_2.IQuickOpenService),
    __param(3, instantiation_1.IInstantiationService),
    __param(4, history_1.IHistoryService)
], RemoveFromEditorHistoryAction);
exports.RemoveFromEditorHistoryAction = RemoveFromEditorHistoryAction;
