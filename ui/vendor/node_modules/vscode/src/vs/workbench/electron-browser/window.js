/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var platform = require("vs/base/common/platform");
var uri_1 = require("vs/base/common/uri");
var errors = require("vs/base/common/errors");
var types = require("vs/base/common/types");
var winjs_base_1 = require("vs/base/common/winjs.base");
var pfs_1 = require("vs/base/node/pfs");
var arrays = require("vs/base/common/arrays");
var DOM = require("vs/base/browser/dom");
var severity_1 = require("vs/base/common/severity");
var actionbar_1 = require("vs/base/browser/ui/actionbar/actionbar");
var actions_1 = require("vs/base/common/actions");
var dnd_1 = require("vs/base/browser/dnd");
var builder_1 = require("vs/base/browser/builder");
var partService_1 = require("vs/workbench/services/part/common/partService");
var files_1 = require("vs/platform/files/common/files");
var editor_1 = require("vs/workbench/common/editor");
var editorService_1 = require("vs/workbench/services/editor/common/editorService");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var message_1 = require("vs/platform/message/common/message");
var configuration_1 = require("vs/workbench/services/configuration/common/configuration");
var windows_1 = require("vs/platform/windows/common/windows");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var windowService_1 = require("vs/workbench/services/window/electron-browser/windowService");
var untitledEditorService_1 = require("vs/workbench/services/untitled/common/untitledEditorService");
var environment_1 = require("vs/platform/environment/common/environment");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var configurationEditing_1 = require("vs/workbench/services/configuration/common/configurationEditing");
var titleService_1 = require("vs/workbench/services/title/common/titleService");
var platform_1 = require("vs/platform/platform");
var actionRegistry_1 = require("vs/workbench/common/actionRegistry");
var actions_2 = require("vs/platform/actions/common/actions");
var themeService_1 = require("vs/workbench/services/themes/common/themeService");
var browser = require("vs/base/browser/browser");
var actions_3 = require("vs/workbench/electron-browser/actions");
var commands_1 = require("vs/platform/commands/common/commands");
var viewlet_1 = require("vs/workbench/services/viewlet/browser/viewlet");
var editor_2 = require("vs/platform/editor/common/editor");
var extensions_1 = require("vs/platform/extensions/common/extensions");
var electron_1 = require("electron");
var dialog = electron_1.remote.dialog;
var TextInputActions = [
    new actions_1.Action('undo', nls.localize('undo', "Undo"), null, true, function () { return document.execCommand('undo') && winjs_base_1.TPromise.as(true); }),
    new actions_1.Action('redo', nls.localize('redo', "Redo"), null, true, function () { return document.execCommand('redo') && winjs_base_1.TPromise.as(true); }),
    new actionbar_1.Separator(),
    new actions_1.Action('editor.action.clipboardCutAction', nls.localize('cut', "Cut"), null, true, function () { return document.execCommand('cut') && winjs_base_1.TPromise.as(true); }),
    new actions_1.Action('editor.action.clipboardCopyAction', nls.localize('copy', "Copy"), null, true, function () { return document.execCommand('copy') && winjs_base_1.TPromise.as(true); }),
    new actions_1.Action('editor.action.clipboardPasteAction', nls.localize('paste', "Paste"), null, true, function () { return document.execCommand('paste') && winjs_base_1.TPromise.as(true); }),
    new actionbar_1.Separator(),
    new actions_1.Action('editor.action.selectAll', nls.localize('selectAll', "Select All"), null, true, function () { return document.execCommand('selectAll') && winjs_base_1.TPromise.as(true); })
];
var ElectronWindow = (function () {
    function ElectronWindow(win, shellContainer, windowIPCService, editorService, editorGroupService, partService, windowsService, windowService, configurationService, titleService, themeService, messageService, configurationEditingService, commandService, extensionService, viewletService, contextMenuService, keybindingService, environmentService, untitledEditorService) {
        this.windowIPCService = windowIPCService;
        this.editorService = editorService;
        this.editorGroupService = editorGroupService;
        this.partService = partService;
        this.windowsService = windowsService;
        this.windowService = windowService;
        this.configurationService = configurationService;
        this.titleService = titleService;
        this.themeService = themeService;
        this.messageService = messageService;
        this.configurationEditingService = configurationEditingService;
        this.commandService = commandService;
        this.extensionService = extensionService;
        this.viewletService = viewletService;
        this.contextMenuService = contextMenuService;
        this.keybindingService = keybindingService;
        this.environmentService = environmentService;
        this.untitledEditorService = untitledEditorService;
        this.win = win;
        this.windowId = win.id;
        this.registerListeners();
        this.setup();
    }
    ElectronWindow.prototype.registerListeners = function () {
        var _this = this;
        // React to editor input changes (Mac only)
        if (platform.platform === platform.Platform.Mac) {
            this.editorGroupService.onEditorsChanged(function () {
                var file = editor_1.toResource(_this.editorService.getActiveEditorInput(), { supportSideBySide: true, filter: 'file' });
                _this.titleService.setRepresentedFilename(file ? file.fsPath : '');
            });
        }
        var draggedExternalResources;
        var dropOverlay;
        function cleanUp() {
            draggedExternalResources = void 0;
            if (dropOverlay) {
                dropOverlay.destroy();
                dropOverlay = void 0;
            }
        }
        // Detect resources dropped into Code from outside
        window.document.body.addEventListener(DOM.EventType.DRAG_OVER, function (e) {
            DOM.EventHelper.stop(e);
            if (!draggedExternalResources) {
                draggedExternalResources = dnd_1.extractResources(e, true /* external only */).map(function (d) { return d.resource; });
                // Find out if folders are dragged and show the appropiate feedback then
                _this.includesFolder(draggedExternalResources).done(function (includesFolder) {
                    if (includesFolder) {
                        dropOverlay = builder_1.$(window.document.getElementById(_this.partService.getWorkbenchElementId()))
                            .div({ id: 'monaco-workbench-drop-overlay' })
                            .on(DOM.EventType.DROP, function (e) {
                            DOM.EventHelper.stop(e, true);
                            _this.focus(); // make sure this window has focus so that the open call reaches the right window!
                            // Ask the user when opening a potential large number of folders
                            var doOpen = true;
                            if (draggedExternalResources.length > 20) {
                                doOpen = _this.messageService.confirm({
                                    message: nls.localize('confirmOpen', "Are you sure you want to open {0} folders?", draggedExternalResources.length),
                                    primaryButton: nls.localize({ key: 'confirmOpenButton', comment: ['&& denotes a mnemonic'] }, "&&Open")
                                });
                            }
                            if (doOpen) {
                                _this.windowsService.openWindow(draggedExternalResources.map(function (r) { return r.fsPath; }), { forceReuseWindow: true });
                            }
                            cleanUp();
                        })
                            .on([DOM.EventType.DRAG_LEAVE, DOM.EventType.DRAG_END], function () {
                            cleanUp();
                        }).once(DOM.EventType.MOUSE_OVER, function () {
                            // Under some circumstances we have seen reports where the drop overlay is not being
                            // cleaned up and as such the editor area remains under the overlay so that you cannot
                            // type into the editor anymore. This seems related to using VMs and DND via host and
                            // guest OS, though some users also saw it without VMs.
                            // To protect against this issue we always destroy the overlay as soon as we detect a
                            // mouse event over it. The delay is used to guarantee we are not interfering with the
                            // actual DROP event that can also trigger a mouse over event.
                            // See also: https://github.com/Microsoft/vscode/issues/10970
                            setTimeout(function () {
                                cleanUp();
                            }, 300);
                        });
                    }
                });
            }
        });
        // Clear our map and overlay on any finish of DND outside the overlay
        [DOM.EventType.DROP, DOM.EventType.DRAG_END].forEach(function (event) {
            window.document.body.addEventListener(event, function (e) {
                if (!dropOverlay || e.target !== dropOverlay.getHTMLElement()) {
                    cleanUp(); // only run cleanUp() if we are not over the overlay (because we are being called in capture phase)
                }
            }, true /* use capture because components within may preventDefault() when they accept the drop */);
        });
        // prevent opening a real URL inside the shell
        window.document.body.addEventListener(DOM.EventType.DROP, function (e) {
            DOM.EventHelper.stop(e);
        });
        // Handle window.open() calls
        var $this = this;
        window.open = function (url, target, features, replace) {
            $this.windowsService.openExternal(url);
            return null;
        };
    };
    ElectronWindow.prototype.setup = function () {
        var _this = this;
        // Support runAction event
        electron_1.ipcRenderer.on('vscode:runAction', function (event, actionId) {
            _this.commandService.executeCommand(actionId, { from: 'menu' }).done(undefined, function (err) { return _this.messageService.show(severity_1.default.Error, err); });
        });
        // Support resolve keybindings event
        electron_1.ipcRenderer.on('vscode:resolveKeybindings', function (event, rawActionIds) {
            var actionIds = [];
            try {
                actionIds = JSON.parse(rawActionIds);
            }
            catch (error) {
            }
            // Resolve keys using the keybinding service and send back to browser process
            _this.resolveKeybindings(actionIds).done(function (keybindings) {
                if (keybindings.length) {
                    electron_1.ipcRenderer.send('vscode:keybindingsResolved', JSON.stringify(keybindings));
                }
            }, function () { return errors.onUnexpectedError; });
        });
        // Send over all extension viewlets when extensions are ready
        this.extensionService.onReady().then(function () {
            electron_1.ipcRenderer.send('vscode:extensionViewlets', JSON.stringify(_this.viewletService.getViewlets().filter(function (v) { return !!v.extensionId; }).map(function (v) { return { id: v.id, label: v.name }; })));
        });
        electron_1.ipcRenderer.on('vscode:reportError', function (event, error) {
            if (error) {
                var errorParsed = JSON.parse(error);
                errorParsed.mainProcess = true;
                errors.onUnexpectedError(errorParsed);
            }
        });
        // Support openFiles event for existing and new files
        electron_1.ipcRenderer.on('vscode:openFiles', function (event, request) { return _this.onOpenFiles(request); });
        // Emit event when vscode has loaded
        this.partService.joinCreation().then(function () {
            electron_1.ipcRenderer.send('vscode:workbenchLoaded', _this.windowIPCService.getWindowId());
        });
        // Message support
        electron_1.ipcRenderer.on('vscode:showInfoMessage', function (event, message) {
            _this.messageService.show(severity_1.default.Info, message);
        });
        // Support toggling auto save
        electron_1.ipcRenderer.on('vscode.toggleAutoSave', function (event) {
            _this.toggleAutoSave();
        });
        // Fullscreen Events
        electron_1.ipcRenderer.on('vscode:enterFullScreen', function (event) {
            _this.partService.joinCreation().then(function () {
                browser.setFullscreen(true);
            });
        });
        electron_1.ipcRenderer.on('vscode:leaveFullScreen', function (event) {
            _this.partService.joinCreation().then(function () {
                browser.setFullscreen(false);
            });
        });
        // High Contrast Events
        electron_1.ipcRenderer.on('vscode:enterHighContrast', function (event) {
            var windowConfig = _this.configurationService.getConfiguration('window');
            if (windowConfig && windowConfig.autoDetectHighContrast) {
                _this.partService.joinCreation().then(function () {
                    _this.themeService.setColorTheme(themeService_1.VS_HC_THEME, null);
                });
            }
        });
        electron_1.ipcRenderer.on('vscode:leaveHighContrast', function (event) {
            var windowConfig = _this.configurationService.getConfiguration('window');
            if (windowConfig && windowConfig.autoDetectHighContrast) {
                _this.partService.joinCreation().then(function () {
                    _this.themeService.setColorTheme(themeService_1.VS_DARK_THEME, null);
                });
            }
        });
        // Configuration changes
        var previousConfiguredZoomLevel;
        this.configurationService.onDidUpdateConfiguration(function (e) {
            var windowConfig = e.config;
            var newZoomLevel = 0;
            if (windowConfig.window && typeof windowConfig.window.zoomLevel === 'number') {
                newZoomLevel = windowConfig.window.zoomLevel;
                // Leave early if the configured zoom level did not change (https://github.com/Microsoft/vscode/issues/1536)
                if (previousConfiguredZoomLevel === newZoomLevel) {
                    return;
                }
                previousConfiguredZoomLevel = newZoomLevel;
            }
            if (electron_1.webFrame.getZoomLevel() !== newZoomLevel) {
                electron_1.webFrame.setZoomLevel(newZoomLevel);
                browser.setZoomFactor(electron_1.webFrame.getZoomFactor());
                browser.setZoomLevel(electron_1.webFrame.getZoomLevel()); // Ensure others can listen to zoom level changes
            }
        });
        // Context menu support in input/textarea
        window.document.addEventListener('contextmenu', function (e) {
            if (e.target instanceof HTMLElement) {
                var target_1 = e.target;
                if (target_1.nodeName && (target_1.nodeName.toLowerCase() === 'input' || target_1.nodeName.toLowerCase() === 'textarea')) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.contextMenuService.showContextMenu({
                        getAnchor: function () { return target_1; },
                        getActions: function () { return winjs_base_1.TPromise.as(TextInputActions); },
                        getKeyBinding: function (action) {
                            return _this.keybindingService.lookupKeybinding(action.id);
                        }
                    });
                }
            }
        });
        // Developer related actions
        var developerCategory = nls.localize('developer', "Developer");
        var workbenchActionsRegistry = platform_1.Registry.as(actionRegistry_1.Extensions.WorkbenchActions);
        var isDeveloping = !this.environmentService.isBuilt || this.environmentService.isExtensionDevelopment;
        workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(actions_3.ReloadWindowAction, actions_3.ReloadWindowAction.ID, actions_3.ReloadWindowAction.LABEL, isDeveloping ? { primary: 2048 /* CtrlCmd */ | 48 /* KEY_R */ } : void 0), 'Reload Window');
        workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(actions_3.ToggleDevToolsAction, actions_3.ToggleDevToolsAction.ID, actions_3.ToggleDevToolsAction.LABEL, isDeveloping ? { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 39 /* KEY_I */, mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 39 /* KEY_I */ } } : void 0), 'Developer: Toggle Developer Tools', developerCategory);
        workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(actions_3.ShowStartupPerformance, actions_3.ShowStartupPerformance.ID, actions_3.ShowStartupPerformance.LABEL), 'Developer: Startup Performance', developerCategory);
        workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(actions_3.ToggleSharedProcessAction, actions_3.ToggleSharedProcessAction.ID, actions_3.ToggleSharedProcessAction.LABEL), 'Developer: Toggle Shared Process', developerCategory);
        // Action registered here to prevent a keybinding conflict with reload window
        var fileCategory = nls.localize('file', "File");
        workbenchActionsRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(actions_3.OpenRecentAction, actions_3.OpenRecentAction.ID, actions_3.OpenRecentAction.LABEL, { primary: isDeveloping ? null : 2048 /* CtrlCmd */ | 48 /* KEY_R */, mac: { primary: 256 /* WinCtrl */ | 48 /* KEY_R */ } }), 'File: Open Recent', fileCategory);
    };
    ElectronWindow.prototype.resolveKeybindings = function (actionIds) {
        var _this = this;
        return this.partService.joinCreation().then(function () {
            return arrays.coalesce(actionIds.map(function (id) {
                var binding = _this.keybindingService.lookupKeybinding(id);
                // first try to resolve a native accelerator
                var electronAccelerator = binding.getElectronAccelerator();
                if (electronAccelerator) {
                    return { id: id, label: electronAccelerator, isNative: true };
                }
                // we need this fallback to support keybindings that cannot show in electron menus (e.g. chords)
                var acceleratorLabel = binding.getLabel();
                if (acceleratorLabel) {
                    return { id: id, label: acceleratorLabel, isNative: false };
                }
                return null;
            }));
        });
    };
    ElectronWindow.prototype.onOpenFiles = function (request) {
        var inputs = [];
        var diffMode = (request.filesToDiff.length === 2);
        if (!diffMode && request.filesToOpen) {
            inputs.push.apply(inputs, this.toInputs(request.filesToOpen, false));
        }
        if (!diffMode && request.filesToCreate) {
            inputs.push.apply(inputs, this.toInputs(request.filesToCreate, true));
        }
        if (diffMode) {
            inputs.push.apply(inputs, this.toInputs(request.filesToDiff, false));
        }
        if (inputs.length) {
            this.openResources(inputs, diffMode).done(null, errors.onUnexpectedError);
        }
    };
    ElectronWindow.prototype.openResources = function (resources, diffMode) {
        var _this = this;
        return this.partService.joinCreation().then(function () {
            // In diffMode we open 2 resources as diff
            if (diffMode && resources.length === 2) {
                return _this.editorService.openEditor({ leftResource: resources[0].resource, rightResource: resources[1].resource, options: { pinned: true } });
            }
            // For one file, just put it into the current active editor
            if (resources.length === 1) {
                return _this.editorService.openEditor(resources[0]);
            }
            // Otherwise open all
            var activeEditor = _this.editorService.getActiveEditor();
            return _this.editorService.openEditors(resources.map(function (r, index) {
                return {
                    input: r,
                    position: activeEditor ? activeEditor.position : editor_2.Position.ONE
                };
            }));
        });
    };
    ElectronWindow.prototype.toInputs = function (paths, isNew) {
        var _this = this;
        return paths.map(function (p) {
            var input = {
                resource: isNew ? _this.untitledEditorService.createOrGet(uri_1.default.file(p.filePath)).getResource() : uri_1.default.file(p.filePath),
                options: {
                    pinned: true
                }
            };
            if (!isNew && p.lineNumber) {
                input.options.selection = {
                    startLineNumber: p.lineNumber,
                    startColumn: p.columnNumber
                };
            }
            return input;
        });
    };
    ElectronWindow.prototype.toggleAutoSave = function () {
        var _this = this;
        var setting = this.configurationService.lookup(ElectronWindow.AUTO_SAVE_SETTING);
        var userAutoSaveConfig = setting.user;
        if (types.isUndefinedOrNull(userAutoSaveConfig)) {
            userAutoSaveConfig = setting.default; // use default if setting not defined
        }
        var newAutoSaveValue;
        if ([files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE].some(function (s) { return s === userAutoSaveConfig; })) {
            newAutoSaveValue = files_1.AutoSaveConfiguration.OFF;
        }
        else {
            newAutoSaveValue = files_1.AutoSaveConfiguration.AFTER_DELAY;
        }
        this.configurationEditingService.writeConfiguration(configurationEditing_1.ConfigurationTarget.USER, { key: ElectronWindow.AUTO_SAVE_SETTING, value: newAutoSaveValue }).done(null, function (error) { return _this.messageService.show(severity_1.default.Error, error); });
    };
    ElectronWindow.prototype.includesFolder = function (resources) {
        return winjs_base_1.TPromise.join(resources.map(function (resource) {
            return pfs_1.stat(resource.fsPath).then(function (stats) { return stats.isDirectory() ? true : false; }, function (error) { return false; });
        })).then(function (res) { return res.some(function (res) { return !!res; }); });
    };
    ElectronWindow.prototype.close = function () {
        this.win.close();
    };
    ElectronWindow.prototype.showMessageBox = function (options) {
        return dialog.showMessageBox(this.win, options);
    };
    ElectronWindow.prototype.showSaveDialog = function (options, callback) {
        if (callback) {
            return dialog.showSaveDialog(this.win, options, callback);
        }
        return dialog.showSaveDialog(this.win, options); // https://github.com/electron/electron/issues/4936
    };
    ElectronWindow.prototype.focus = function () {
        return this.windowService.focusWindow();
    };
    return ElectronWindow;
}());
ElectronWindow.AUTO_SAVE_SETTING = 'files.autoSave';
ElectronWindow = __decorate([
    __param(2, windowService_1.IWindowIPCService),
    __param(3, editorService_1.IWorkbenchEditorService),
    __param(4, groupService_1.IEditorGroupService),
    __param(5, partService_1.IPartService),
    __param(6, windows_1.IWindowsService),
    __param(7, windows_1.IWindowService),
    __param(8, configuration_1.IWorkspaceConfigurationService),
    __param(9, titleService_1.ITitleService),
    __param(10, themeService_1.IWorkbenchThemeService),
    __param(11, message_1.IMessageService),
    __param(12, configurationEditing_1.IConfigurationEditingService),
    __param(13, commands_1.ICommandService),
    __param(14, extensions_1.IExtensionService),
    __param(15, viewlet_1.IViewletService),
    __param(16, contextView_1.IContextMenuService),
    __param(17, keybinding_1.IKeybindingService),
    __param(18, environment_1.IEnvironmentService),
    __param(19, untitledEditorService_1.IUntitledEditorService)
], ElectronWindow);
exports.ElectronWindow = ElectronWindow;
