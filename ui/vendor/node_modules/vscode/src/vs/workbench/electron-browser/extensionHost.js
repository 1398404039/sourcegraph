/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var errorMessage_1 = require("vs/base/common/errorMessage");
var marshalling_1 = require("vs/base/common/marshalling");
var objects = require("vs/base/common/objects");
var uri_1 = require("vs/base/common/uri");
var winjs_base_1 = require("vs/base/common/winjs.base");
var platform_1 = require("vs/base/common/platform");
var ports_1 = require("vs/base/node/ports");
var message_1 = require("vs/platform/message/common/message");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
var windows_1 = require("vs/platform/windows/common/windows");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var windowService_1 = require("vs/workbench/services/window/electron-browser/windowService");
var child_process_1 = require("child_process");
var electron_1 = require("electron");
var product_1 = require("vs/platform/product");
var environment_1 = require("vs/platform/environment/common/environment");
var actions_1 = require("vs/workbench/electron-browser/actions");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var event_1 = require("vs/base/common/event");
var watchDog_1 = require("vs/base/common/watchDog");
var processes_1 = require("vs/base/node/processes");
var configuration_1 = require("vs/workbench/services/configuration/common/configuration");
exports.EXTENSION_LOG_BROADCAST_CHANNEL = 'vscode:extensionLog';
exports.EXTENSION_ATTACH_BROADCAST_CHANNEL = 'vscode:extensionAttach';
exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL = 'vscode:extensionTerminate';
var ExtensionHostProcessWorker = (function () {
    function ExtensionHostProcessWorker(contextService, messageService, windowsService, windowService, lifecycleService, instantiationService, environmentService, configurationService, telemetryService) {
        var _this = this;
        this.contextService = contextService;
        this.messageService = messageService;
        this.windowsService = windowsService;
        this.windowService = windowService;
        this.instantiationService = instantiationService;
        this.environmentService = environmentService;
        this.configurationService = configurationService;
        this.telemetryService = telemetryService;
        this.extHostWatchDog = new watchDog_1.WatchDog(250, 4);
        this._onMessage = new event_1.Emitter();
        // handle extension host lifecycle a bit special when we know we are developing an extension that runs inside
        this.isExtensionDevelopmentHost = environmentService.isExtensionDevelopment;
        this.isExtensionDevelopmentDebugging = !!environmentService.debugExtensionHost.break;
        this.isExtensionDevelopmentTestFromCli = this.isExtensionDevelopmentHost && !!environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break;
        this.unsentMessages = [];
        this.extensionHostProcessReady = false;
        lifecycleService.onWillShutdown(this._onWillShutdown, this);
        lifecycleService.onShutdown(function (reason) { return _this.terminate(); });
    }
    Object.defineProperty(ExtensionHostProcessWorker.prototype, "onMessage", {
        get: function () {
            return this._onMessage.event;
        },
        enumerable: true,
        configurable: true
    });
    ExtensionHostProcessWorker.prototype.start = function (extensionService) {
        var _this = this;
        this.extensionService = extensionService;
        var opts = {
            env: objects.mixin(objects.clone(process.env), {
                AMD_ENTRYPOINT: 'vs/workbench/node/extensionHostProcess',
                PIPE_LOGGING: 'true',
                VERBOSE_LOGGING: true,
                VSCODE_WINDOW_ID: String(this.windowService.getWindowId()),
                ELECTRON_NO_ASAR: '1'
            }),
            // We only detach the extension host on windows. Linux and Mac orphan by default
            // and detach under Linux and Mac create another process group.
            // We detach because we have noticed that when the renderer exits, its child processes
            // (i.e. extension host) is taken down in a brutal fashion by the OS
            detached: !!platform_1.isWindows,
        };
        // Help in case we fail to start it
        if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.initializeTimer = setTimeout(function () {
                var msg = _this.isExtensionDevelopmentDebugging ? nls.localize('extensionHostProcess.startupFailDebug', "Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.") : nls.localize('extensionHostProcess.startupFail', "Extension host did not start in 10 seconds, that might be a problem.");
                _this.messageService.show(message_1.Severity.Warning, msg);
            }, 10000);
        }
        // Initialize extension host process with hand shakes
        this.initializeExtensionHostProcess = this.doInitializeExtensionHostProcess(opts);
        // Check how well the extension host is doing
        if (this.environmentService.isBuilt) {
            this.initializeExtensionHostProcess.done(function () {
                _this.extHostWatchDog.start();
                _this.extHostWatchDog.onAlert(function () {
                    _this.extHostWatchDog.reset();
                    // log the identifiers of those extensions that
                    // have code and are loaded in the extension host
                    _this.extensionService.getExtensions().then(function (extensions) {
                        var ids = [];
                        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
                            var ext = extensions_1[_i];
                            if (ext.main && _this.extensionService.isActivated(ext.id)) {
                                ids.push(ext.id);
                            }
                        }
                        _this.telemetryService.publicLog('extHostUnresponsive2', { extensionIds: ids });
                    });
                });
            });
        }
    };
    Object.defineProperty(ExtensionHostProcessWorker.prototype, "messagingProtocol", {
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    ExtensionHostProcessWorker.prototype.doInitializeExtensionHostProcess = function (opts) {
        var _this = this;
        return new winjs_base_1.TPromise(function (c, e) {
            // Resolve additional execution args (e.g. debug)
            _this.resolveDebugPort(_this.environmentService.debugExtensionHost.port).then(function (port) {
                if (port) {
                    opts.execArgv = ['--nolazy', (_this.isExtensionDevelopmentDebugging ? '--debug-brk=' : '--debug=') + port];
                }
                // Run Extension Host as fork of current process
                _this.extensionHostProcessHandle = child_process_1.fork(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, ['--type=extensionHost'], opts);
                _this.extensionHostProcessQueuedSender = processes_1.createQueuedSender(_this.extensionHostProcessHandle);
                // Notify debugger that we are ready to attach to the process if we run a development extension
                if (_this.isExtensionDevelopmentHost && port) {
                    _this.windowService.broadcast({
                        channel: exports.EXTENSION_ATTACH_BROADCAST_CHANNEL,
                        payload: { port: port }
                    }, _this.environmentService.extensionDevelopmentPath /* target */);
                }
                // Messages from Extension host
                _this.extensionHostProcessHandle.on('message', function (msg) {
                    if (_this.onMessaage(msg)) {
                        c(_this.extensionHostProcessHandle);
                    }
                });
                // Lifecycle
                var onExit = function () { return _this.terminate(); };
                process.once('exit', onExit);
                _this.extensionHostProcessHandle.on('error', function (err) { return _this.onError(err); });
                _this.extensionHostProcessHandle.on('exit', function (code, signal) { return _this.onExit(code, signal, onExit); });
            });
        }, function () { return _this.terminate(); });
    };
    ExtensionHostProcessWorker.prototype.resolveDebugPort = function (extensionHostPort) {
        var _this = this;
        if (typeof extensionHostPort !== 'number') {
            return winjs_base_1.TPromise.wrap(void 0);
        }
        return new winjs_base_1.TPromise(function (c, e) {
            ports_1.findFreePort(extensionHostPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */, function (port) {
                if (!port) {
                    console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');
                    return c(void 0);
                }
                if (port !== extensionHostPort) {
                    console.warn("%c[Extension Host] %cProvided debugging port " + extensionHostPort + " is not free, using " + port + " instead.", 'color: blue', 'color: black');
                }
                if (_this.isExtensionDevelopmentDebugging) {
                    console.warn("%c[Extension Host] %cSTOPPED on first line for debugging on port " + port, 'color: blue', 'color: black');
                }
                else {
                    console.info("%c[Extension Host] %cdebugger listening on port " + port, 'color: blue', 'color: black');
                }
                return c(port);
            });
        });
    };
    // @return `true` if ready
    ExtensionHostProcessWorker.prototype.onMessaage = function (msg) {
        var _this = this;
        // 1) Host is ready to receive messages, initialize it
        if (msg === 'ready') {
            this.initializeExtensionHost();
            return false;
        }
        // 2) Host is initialized
        if (msg === 'initialized') {
            this.unsentMessages.forEach(function (m) { return _this.send(m); });
            this.unsentMessages = [];
            this.extensionHostProcessReady = true;
            return true;
        }
        // Heartbeat message
        if (msg === '__$heartbeat') {
            this.extHostWatchDog.reset();
            return false;
        }
        // Support logging from extension host
        if (msg && msg.type === '__$console') {
            this.logExtensionHostMessage(msg);
            return false;
        }
        // Any other message emits event
        this._onMessage.fire(msg);
        return false;
    };
    ExtensionHostProcessWorker.prototype.initializeExtensionHost = function () {
        var _this = this;
        if (this.initializeTimer) {
            window.clearTimeout(this.initializeTimer);
        }
        winjs_base_1.TPromise.join([
            this.telemetryService.getTelemetryInfo(),
            this.extensionService.getExtensions()
        ]).then(function (_a) {
            var telemetryInfo = _a[0], extensionDescriptions = _a[1];
            var initData = {
                seqId: 0,
                parentPid: process.pid,
                environment: {
                    appSettingsHome: _this.environmentService.appSettingsHome,
                    disableExtensions: _this.environmentService.disableExtensions,
                    userExtensionsHome: _this.environmentService.extensionsPath,
                    extensionDevelopmentPath: _this.environmentService.extensionDevelopmentPath,
                    extensionTestsPath: _this.environmentService.extensionTestsPath,
                    // globally disable proposed api when built and not insiders developing extensions
                    enableProposedApi: !_this.environmentService.isBuilt || (!!_this.environmentService.extensionDevelopmentPath && product_1.default.nameLong.indexOf('Insiders') >= 0)
                },
                contextService: {
                    workspace: _this.contextService.getWorkspace()
                },
                extensions: extensionDescriptions,
                configuration: _this.configurationService.values(),
                telemetryInfo: telemetryInfo
            };
            _this.extensionHostProcessQueuedSender.send(marshalling_1.stringify(initData));
        });
    };
    ExtensionHostProcessWorker.prototype.logExtensionHostMessage = function (logEntry) {
        var args = [];
        try {
            var parsed_1 = JSON.parse(logEntry.arguments);
            args.push.apply(args, Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
        }
        catch (error) {
            args.push(logEntry.arguments);
        }
        // If the first argument is a string, check for % which indicates that the message
        // uses substitution for variables. In this case, we cannot just inject our colored
        // [Extension Host] to the front because it breaks substitution.
        var consoleArgs = [];
        if (typeof args[0] === 'string' && args[0].indexOf('%') >= 0) {
            consoleArgs = ["%c[Extension Host]%c " + args[0], 'color: blue', 'color: black'].concat(args.slice(1));
        }
        else {
            consoleArgs = ['%c[Extension Host]', 'color: blue'].concat(args);
        }
        // Send to local console unless we run tests from cli
        if (!this.isExtensionDevelopmentTestFromCli) {
            console[logEntry.severity].apply(console, consoleArgs);
        }
        // Log on main side if running tests from cli
        if (this.isExtensionDevelopmentTestFromCli) {
            (_a = this.windowsService).log.apply(_a, [logEntry.severity].concat(args));
        }
        else if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_LOG_BROADCAST_CHANNEL,
                payload: logEntry
            }, this.environmentService.extensionDevelopmentPath /* target */);
        }
        var _a;
    };
    ExtensionHostProcessWorker.prototype.onError = function (err) {
        var errorMessage = errorMessage_1.toErrorMessage(err);
        if (errorMessage === this.lastExtensionHostError) {
            return; // prevent error spam
        }
        this.lastExtensionHostError = errorMessage;
        this.messageService.show(message_1.Severity.Error, nls.localize('extensionHostProcess.error', "Error from the extension host: {0}", errorMessage));
    };
    ExtensionHostProcessWorker.prototype.onExit = function (code, signal, onProcessExit) {
        process.removeListener('exit', onProcessExit);
        if (!this.terminating) {
            // Unexpected termination
            if (!this.isExtensionDevelopmentHost) {
                this.messageService.show(message_1.Severity.Error, {
                    message: nls.localize('extensionHostProcess.crash', "Extension host terminated unexpectedly. Please reload the window to recover."),
                    actions: [this.instantiationService.createInstance(actions_1.ReloadWindowAction, actions_1.ReloadWindowAction.ID, actions_1.ReloadWindowAction.LABEL)]
                });
                console.error('Extension host terminated unexpectedly. Code: ', code, ' Signal: ', signal);
            }
            else if (!this.isExtensionDevelopmentTestFromCli) {
                this.windowService.getWindow().close();
            }
            else {
                electron_1.ipcRenderer.send('vscode:exit', code);
            }
        }
    };
    ExtensionHostProcessWorker.prototype.send = function (msg) {
        var _this = this;
        if (this.extensionHostProcessReady) {
            this.extensionHostProcessQueuedSender.send(msg);
        }
        else if (this.initializeExtensionHostProcess) {
            this.initializeExtensionHostProcess.done(function () { return _this.extensionHostProcessQueuedSender.send(msg); });
        }
        else {
            this.unsentMessages.push(msg);
        }
    };
    ExtensionHostProcessWorker.prototype.terminate = function () {
        this.terminating = true;
        if (this.extensionHostProcessHandle) {
            this.extensionHostProcessQueuedSender.send({
                type: '__$terminate'
            });
        }
    };
    ExtensionHostProcessWorker.prototype._onWillShutdown = function (event) {
        // If the extension development host was started without debugger attached we need
        // to communicate this back to the main side to terminate the debug session
        if (this.isExtensionDevelopmentHost && !this.isExtensionDevelopmentTestFromCli && !this.isExtensionDevelopmentDebugging) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL,
                payload: true
            }, this.environmentService.extensionDevelopmentPath /* target */);
            event.veto(winjs_base_1.TPromise.timeout(100 /* wait a bit for IPC to get delivered */).then(function () { return false; }));
        }
    };
    return ExtensionHostProcessWorker;
}());
ExtensionHostProcessWorker = __decorate([
    __param(0, workspace_1.IWorkspaceContextService),
    __param(1, message_1.IMessageService),
    __param(2, windows_1.IWindowsService),
    __param(3, windowService_1.IWindowIPCService),
    __param(4, lifecycle_1.ILifecycleService),
    __param(5, instantiation_1.IInstantiationService),
    __param(6, environment_1.IEnvironmentService),
    __param(7, configuration_1.IWorkspaceConfigurationService),
    __param(8, telemetry_1.ITelemetryService)
], ExtensionHostProcessWorker);
exports.ExtensionHostProcessWorker = ExtensionHostProcessWorker;
