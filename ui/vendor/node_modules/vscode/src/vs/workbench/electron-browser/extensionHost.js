/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var errorMessage_1 = require("vs/base/common/errorMessage");
var marshalling_1 = require("vs/base/common/marshalling");
var objects = require("vs/base/common/objects");
var uri_1 = require("vs/base/common/uri");
var winjs_base_1 = require("vs/base/common/winjs.base");
var platform_1 = require("vs/base/common/platform");
var ports_1 = require("vs/base/node/ports");
var message_1 = require("vs/platform/message/common/message");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
var windows_1 = require("vs/platform/windows/common/windows");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var windowService_1 = require("vs/workbench/services/window/electron-browser/windowService");
var child_process_1 = require("child_process");
var electron_1 = require("electron");
var product_1 = require("vs/platform/node/product");
var environment_1 = require("vs/platform/environment/common/environment");
var actions_1 = require("vs/workbench/electron-browser/actions");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var ipc_net_1 = require("vs/base/parts/ipc/node/ipc.net");
var net_1 = require("net");
var event_1 = require("vs/base/common/event");
var configuration_1 = require("vs/workbench/services/configuration/common/configuration");
exports.EXTENSION_LOG_BROADCAST_CHANNEL = 'vscode:extensionLog';
exports.EXTENSION_ATTACH_BROADCAST_CHANNEL = 'vscode:extensionAttach';
exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL = 'vscode:extensionTerminate';
var LazyMessagePassingProtol = (function () {
    function LazyMessagePassingProtol() {
        this._onMessage = new event_1.Emitter();
        this._buffer = [];
        this.onMessage = this._onMessage.event;
    }
    LazyMessagePassingProtol.prototype.send = function (msg) {
        if (this._delegate) {
            this._delegate.send(msg);
        }
        else {
            this._buffer.push(msg);
        }
    };
    LazyMessagePassingProtol.prototype.resolve = function (delegate) {
        var _this = this;
        this._delegate = delegate;
        this._delegate.onMessage(function (data) { return _this._onMessage.fire(data); });
        this._buffer.forEach(this._delegate.send, this._delegate);
        this._buffer = null;
    };
    return LazyMessagePassingProtol;
}());
exports.LazyMessagePassingProtol = LazyMessagePassingProtol;
var ExtensionHostProcessWorker = (function () {
    function ExtensionHostProcessWorker(contextService, messageService, windowsService, windowService, lifecycleService, instantiationService, environmentService, configurationService, telemetryService) {
        var _this = this;
        this.contextService = contextService;
        this.messageService = messageService;
        this.windowsService = windowsService;
        this.windowService = windowService;
        this.instantiationService = instantiationService;
        this.environmentService = environmentService;
        this.configurationService = configurationService;
        this.telemetryService = telemetryService;
        this.messagingProtocol = new LazyMessagePassingProtol();
        // handle extension host lifecycle a bit special when we know we are developing an extension that runs inside
        this.isExtensionDevelopmentHost = environmentService.isExtensionDevelopment;
        this.isExtensionDevelopmentDebugging = !!environmentService.debugExtensionHost.break;
        this.isExtensionDevelopmentTestFromCli = this.isExtensionDevelopmentHost && !!environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break;
        lifecycleService.onWillShutdown(this._onWillShutdown, this);
        lifecycleService.onShutdown(function (reason) { return _this.terminate(); });
    }
    ExtensionHostProcessWorker.prototype.start = function (extensionService) {
        var _this = this;
        this.extensionService = extensionService;
        winjs_base_1.TPromise.join([this.tryListenOnPipe(), this.tryFindDebugPort()]).then(function (data) {
            var _a = data[0], server = _a[0], hook = _a[1];
            var port = data[1];
            var opts = {
                env: objects.mixin(objects.clone(process.env), {
                    AMD_ENTRYPOINT: 'vs/workbench/node/extensionHostProcess',
                    PIPE_LOGGING: 'true',
                    VERBOSE_LOGGING: true,
                    VSCODE_WINDOW_ID: String(_this.windowService.getWindowId()),
                    VSCODE_IPC_HOOK_EXTHOST: hook,
                    ELECTRON_NO_ASAR: '1'
                }),
                // We only detach the extension host on windows. Linux and Mac orphan by default
                // and detach under Linux and Mac create another process group.
                // We detach because we have noticed that when the renderer exits, its child processes
                // (i.e. extension host) is taken down in a brutal fashion by the OS
                detached: !!platform_1.isWindows,
                execArgv: port
                    ? ['--nolazy', (_this.isExtensionDevelopmentDebugging ? '--debug-brk=' : '--debug=') + port]
                    : undefined
            };
            // Run Extension Host as fork of current process
            _this.extensionHostProcess = child_process_1.fork(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, ['--type=extensionHost'], opts);
            // Support logging from extension host
            _this.extensionHostProcess.on('message', function (msg) {
                if (msg && msg.type === '__$console') {
                    _this.logExtensionHostMessage(msg);
                }
            });
            // Lifecycle
            var onExit = function () { return _this.terminate(); };
            process.once('exit', onExit);
            _this.extensionHostProcess.on('error', function (err) { return _this.onError(err); });
            _this.extensionHostProcess.on('exit', function (code, signal) { return _this.onExit(code, signal, onExit); });
            // Notify debugger that we are ready to attach to the process if we run a development extension
            if (_this.isExtensionDevelopmentHost && port) {
                _this.windowService.broadcast({
                    channel: exports.EXTENSION_ATTACH_BROADCAST_CHANNEL,
                    payload: { port: port }
                }, _this.environmentService.extensionDevelopmentPath /* target */);
            }
            // Help in case we fail to start it
            var startupTimeoutHandle;
            if (!_this.environmentService.isBuilt || _this.isExtensionDevelopmentHost) {
                startupTimeoutHandle = setTimeout(function () {
                    var msg = _this.isExtensionDevelopmentDebugging
                        ? nls.localize('extensionHostProcess.startupFailDebug', "Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.")
                        : nls.localize('extensionHostProcess.startupFail', "Extension host did not start in 10 seconds, that might be a problem.");
                    _this.messageService.show(message_1.Severity.Warning, msg);
                }, 10000);
            }
            // Initialize extension host process with hand shakes
            return _this.tryExtHostHandshake(server).then(function () { return clearTimeout(startupTimeoutHandle); });
        }).done(undefined, function (err) {
            console.error('ERROR starting extension host');
            console.error(err);
        });
    };
    ExtensionHostProcessWorker.prototype.tryListenOnPipe = function () {
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var server = net_1.createServer();
            server.on('error', reject);
            var hook = ipc_net_1.generateRandomPipeName();
            server.listen(hook, function () {
                server.removeListener('error', reject);
                resolve([server, hook]);
            });
        });
    };
    ExtensionHostProcessWorker.prototype.tryFindDebugPort = function () {
        var _this = this;
        var extensionHostPort = this.environmentService.debugExtensionHost.port;
        if (typeof extensionHostPort !== 'number') {
            return winjs_base_1.TPromise.wrap(void 0);
        }
        return new winjs_base_1.TPromise(function (c, e) {
            ports_1.findFreePort(extensionHostPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */, function (port) {
                if (!port) {
                    console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');
                    return c(void 0);
                }
                if (port !== extensionHostPort) {
                    console.warn("%c[Extension Host] %cProvided debugging port " + extensionHostPort + " is not free, using " + port + " instead.", 'color: blue', 'color: black');
                }
                if (_this.isExtensionDevelopmentDebugging) {
                    console.warn("%c[Extension Host] %cSTOPPED on first line for debugging on port " + port, 'color: blue', 'color: black');
                }
                else {
                    console.info("%c[Extension Host] %cdebugger listening on port " + port, 'color: blue', 'color: black');
                }
                return c(port);
            });
        });
    };
    ExtensionHostProcessWorker.prototype.tryExtHostHandshake = function (server) {
        var _this = this;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var handle = setTimeout(function () { return reject('timeout'); }, 60 * 1000);
            server.on('connection', function (socket) {
                clearTimeout(handle);
                var protocol = new ipc_net_1.Protocol(socket);
                resolve(protocol);
            });
            // }).then(protocol => {
            // 	return protocol;
        }).then(function (protocol) {
            protocol.onMessage(function (msg) {
                if (msg === 'ready') {
                    // 1) Host is ready to receive messages, initialize it
                    return _this.createExtHostInitData().then(function (data) { return protocol.send(marshalling_1.stringify(data)); });
                }
                else if (msg === 'initialized') {
                    // 2) Host is initialized
                    _this.messagingProtocol.resolve(protocol);
                }
                return undefined;
            });
        });
    };
    ExtensionHostProcessWorker.prototype.createExtHostInitData = function () {
        var _this = this;
        return winjs_base_1.TPromise.join([this.telemetryService.getTelemetryInfo(), this.extensionService.getExtensions()]).then(function (_a) {
            var telemetryInfo = _a[0], extensionDescriptions = _a[1];
            return {
                seqId: 0,
                parentPid: process.pid,
                environment: {
                    appSettingsHome: _this.environmentService.appSettingsHome,
                    disableExtensions: _this.environmentService.disableExtensions,
                    userExtensionsHome: _this.environmentService.extensionsPath,
                    extensionDevelopmentPath: _this.environmentService.extensionDevelopmentPath,
                    extensionTestsPath: _this.environmentService.extensionTestsPath,
                    // globally disable proposed api when built and not insiders developing extensions
                    enableProposedApi: !_this.environmentService.isBuilt || (!!_this.environmentService.extensionDevelopmentPath && product_1.default.nameLong.indexOf('Insiders') >= 0)
                },
                contextService: {
                    workspace: _this.contextService.getWorkspace()
                },
                extensions: extensionDescriptions,
                configuration: _this.configurationService.values(),
                telemetryInfo: telemetryInfo
            };
        });
    };
    ExtensionHostProcessWorker.prototype.logExtensionHostMessage = function (logEntry) {
        var args = [];
        try {
            var parsed_1 = JSON.parse(logEntry.arguments);
            args.push.apply(args, Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
        }
        catch (error) {
            args.push(logEntry.arguments);
        }
        // If the first argument is a string, check for % which indicates that the message
        // uses substitution for variables. In this case, we cannot just inject our colored
        // [Extension Host] to the front because it breaks substitution.
        var consoleArgs = [];
        if (typeof args[0] === 'string' && args[0].indexOf('%') >= 0) {
            consoleArgs = ["%c[Extension Host]%c " + args[0], 'color: blue', 'color: black'].concat(args.slice(1));
        }
        else {
            consoleArgs = ['%c[Extension Host]', 'color: blue'].concat(args);
        }
        // Send to local console unless we run tests from cli
        if (!this.isExtensionDevelopmentTestFromCli) {
            console[logEntry.severity].apply(console, consoleArgs);
        }
        // Log on main side if running tests from cli
        if (this.isExtensionDevelopmentTestFromCli) {
            (_a = this.windowsService).log.apply(_a, [logEntry.severity].concat(args));
        }
        else if (!this.environmentService.isBuilt || this.isExtensionDevelopmentHost) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_LOG_BROADCAST_CHANNEL,
                payload: logEntry
            }, this.environmentService.extensionDevelopmentPath /* target */);
        }
        var _a;
    };
    ExtensionHostProcessWorker.prototype.onError = function (err) {
        var errorMessage = errorMessage_1.toErrorMessage(err);
        if (errorMessage === this.lastExtensionHostError) {
            return; // prevent error spam
        }
        this.lastExtensionHostError = errorMessage;
        this.messageService.show(message_1.Severity.Error, nls.localize('extensionHostProcess.error', "Error from the extension host: {0}", errorMessage));
    };
    ExtensionHostProcessWorker.prototype.onExit = function (code, signal, onProcessExit) {
        process.removeListener('exit', onProcessExit);
        if (!this.terminating) {
            // Unexpected termination
            if (!this.isExtensionDevelopmentHost) {
                this.messageService.show(message_1.Severity.Error, {
                    message: nls.localize('extensionHostProcess.crash', "Extension host terminated unexpectedly. Please reload the window to recover."),
                    actions: [this.instantiationService.createInstance(actions_1.ReloadWindowAction, actions_1.ReloadWindowAction.ID, actions_1.ReloadWindowAction.LABEL)]
                });
                console.error('Extension host terminated unexpectedly. Code: ', code, ' Signal: ', signal);
            }
            else if (!this.isExtensionDevelopmentTestFromCli) {
                this.windowService.getWindow().close();
            }
            else {
                electron_1.ipcRenderer.send('vscode:exit', code);
            }
        }
    };
    ExtensionHostProcessWorker.prototype.terminate = function () {
        this.terminating = true;
        if (this.extensionHostProcess) {
            this.messagingProtocol.send({
                type: '__$terminate'
            });
        }
    };
    ExtensionHostProcessWorker.prototype._onWillShutdown = function (event) {
        // If the extension development host was started without debugger attached we need
        // to communicate this back to the main side to terminate the debug session
        if (this.isExtensionDevelopmentHost && !this.isExtensionDevelopmentTestFromCli && !this.isExtensionDevelopmentDebugging) {
            this.windowService.broadcast({
                channel: exports.EXTENSION_TERMINATE_BROADCAST_CHANNEL,
                payload: true
            }, this.environmentService.extensionDevelopmentPath /* target */);
            event.veto(winjs_base_1.TPromise.timeout(100 /* wait a bit for IPC to get delivered */).then(function () { return false; }));
        }
    };
    return ExtensionHostProcessWorker;
}());
ExtensionHostProcessWorker = __decorate([
    __param(0, workspace_1.IWorkspaceContextService),
    __param(1, message_1.IMessageService),
    __param(2, windows_1.IWindowsService),
    __param(3, windowService_1.IWindowIPCService),
    __param(4, lifecycle_1.ILifecycleService),
    __param(5, instantiation_1.IInstantiationService),
    __param(6, environment_1.IEnvironmentService),
    __param(7, configuration_1.IWorkspaceConfigurationService),
    __param(8, telemetry_1.ITelemetryService)
], ExtensionHostProcessWorker);
exports.ExtensionHostProcessWorker = ExtensionHostProcessWorker;
