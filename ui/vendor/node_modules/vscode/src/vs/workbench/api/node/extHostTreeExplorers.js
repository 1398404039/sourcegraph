/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var nls_1 = require("vs/nls");
var idGenerator_1 = require("vs/base/common/idGenerator");
var winjs_base_1 = require("vs/base/common/winjs.base");
var extHostTypes_1 = require("vs/workbench/api/node/extHostTypes");
var extHost_protocol_1 = require("./extHost.protocol");
var async_1 = require("vs/base/common/async");
var InternalTreeExplorerNodeImpl = (function () {
    function InternalTreeExplorerNodeImpl(node, provider) {
        this.id = idGenerator_1.defaultGenerator.nextId();
        this.label = provider.getLabel ? provider.getLabel(node) : node.toString();
        this.hasChildren = provider.getHasChildren ? provider.getHasChildren(node) : true;
        this.clickCommand = provider.getClickCommand ? provider.getClickCommand(node) : null;
    }
    return InternalTreeExplorerNodeImpl;
}());
var ExtHostTreeExplorers = (function (_super) {
    __extends(ExtHostTreeExplorers, _super);
    function ExtHostTreeExplorers(threadService, commands) {
        var _this = _super.call(this) || this;
        _this.commands = commands;
        _this._proxy = threadService.get(extHost_protocol_1.MainContext.MainThreadExplorers);
        _this._extNodeProviders = Object.create(null);
        _this._extNodeMaps = Object.create(null);
        return _this;
    }
    ExtHostTreeExplorers.prototype.registerTreeExplorerNodeProvider = function (providerId, provider) {
        var _this = this;
        this._proxy.$registerTreeExplorerNodeProvider(providerId);
        this._extNodeProviders[providerId] = provider;
        return new extHostTypes_1.Disposable(function () {
            delete _this._extNodeProviders[providerId];
            delete _this._extNodeProviders[providerId];
        });
    };
    ExtHostTreeExplorers.prototype.$provideRootNode = function (providerId) {
        var _this = this;
        var provider = this._extNodeProviders[providerId];
        if (!provider) {
            var errMessage = nls_1.localize('treeExplorer.notRegistered', 'No TreeExplorerNodeProvider with id \'{0}\' registered.', providerId);
            return winjs_base_1.TPromise.wrapError(errMessage);
        }
        return async_1.asWinJsPromise(function () { return provider.provideRootNode(); }).then(function (extRootNode) {
            var extNodeMap = Object.create(null);
            var internalRootNode = new InternalTreeExplorerNodeImpl(extRootNode, provider);
            extNodeMap[internalRootNode.id] = extRootNode;
            _this._extNodeMaps[providerId] = extNodeMap;
            return internalRootNode;
        }, function (err) {
            var errMessage = nls_1.localize('treeExplorer.failedToProvideRootNode', 'TreeExplorerNodeProvider \'{0}\' failed to provide root node.', providerId);
            return winjs_base_1.TPromise.wrapError(errMessage);
        });
    };
    ExtHostTreeExplorers.prototype.$resolveChildren = function (providerId, mainThreadNode) {
        var provider = this._extNodeProviders[providerId];
        if (!provider) {
            var errMessage = nls_1.localize('treeExplorer.notRegistered', 'No TreeExplorerNodeProvider with id \'{0}\' registered.', providerId);
            return winjs_base_1.TPromise.wrapError(errMessage);
        }
        var extNodeMap = this._extNodeMaps[providerId];
        var extNode = extNodeMap[mainThreadNode.id];
        return async_1.asWinJsPromise(function () { return provider.resolveChildren(extNode); }).then(function (children) {
            return children.map(function (extChild) {
                var internalChild = new InternalTreeExplorerNodeImpl(extChild, provider);
                extNodeMap[internalChild.id] = extChild;
                return internalChild;
            });
        }, function (err) {
            var errMessage = nls_1.localize('treeExplorer.failedToResolveChildren', 'TreeExplorerNodeProvider \'{0}\' failed to resolveChildren.', providerId);
            return winjs_base_1.TPromise.wrapError(errMessage);
        });
    };
    // Convert the command on the ExtHost side so we can pass the original externalNode to the registered handler
    ExtHostTreeExplorers.prototype.$getInternalCommand = function (providerId, mainThreadNode) {
        var commandConverter = this.commands.converter;
        if (mainThreadNode.clickCommand) {
            var extNode = this._extNodeMaps[providerId][mainThreadNode.id];
            var internalCommand = commandConverter.toInternal({
                title: '',
                command: mainThreadNode.clickCommand,
                arguments: [extNode]
            });
            return winjs_base_1.TPromise.wrap(internalCommand);
        }
        return winjs_base_1.TPromise.as(null);
    };
    return ExtHostTreeExplorers;
}(extHost_protocol_1.ExtHostTreeExplorersShape));
exports.ExtHostTreeExplorers = ExtHostTreeExplorers;
