/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var event_1 = require("vs/base/common/event");
var lifecycle_1 = require("vs/base/common/lifecycle");
var extHost_protocol_1 = require("./extHost.protocol");
var extHostDocumentData_1 = require("./extHostDocumentData");
var extHostTextEditor_1 = require("./extHostTextEditor");
var threadService_1 = require("vs/workbench/services/thread/common/threadService");
var assert = require("assert");
var typeConverters = require("./extHostTypeConverters");
var ExtHostDocumentsAndEditors = (function (_super) {
    __extends(ExtHostDocumentsAndEditors, _super);
    function ExtHostDocumentsAndEditors(_threadService) {
        var _this = _super.call(this) || this;
        _this._threadService = _threadService;
        _this._editors = new Map();
        _this._documents = new Map();
        _this._onDidAddDocuments = new event_1.Emitter();
        _this._onDidRemoveDocuments = new event_1.Emitter();
        _this._onDidChangeVisibleTextEditors = new event_1.Emitter();
        _this._onDidChangeActiveTextEditor = new event_1.Emitter();
        _this.onDidAddDocuments = _this._onDidAddDocuments.event;
        _this.onDidRemoveDocuments = _this._onDidRemoveDocuments.event;
        _this.onDidChangeVisibleTextEditors = _this._onDidChangeVisibleTextEditors.event;
        _this.onDidChangeActiveTextEditor = _this._onDidChangeActiveTextEditor.event;
        return _this;
    }
    ExtHostDocumentsAndEditors.prototype.$acceptDocumentsAndEditorsDelta = function (delta) {
        var removedDocuments = [];
        var addedDocuments = [];
        var removedEditors = [];
        if (delta.removedDocuments) {
            for (var _i = 0, _a = delta.removedDocuments; _i < _a.length; _i++) {
                var id = _a[_i];
                var data = this._documents.get(id);
                if (data) {
                    this._documents.delete(id);
                    removedDocuments.push(data);
                }
            }
        }
        if (delta.addedDocuments) {
            for (var _b = 0, _c = delta.addedDocuments; _b < _c.length; _b++) {
                var data = _c[_b];
                assert.ok(!this._documents.has(data.url.toString()), "document '" + data.url + " already exists!'");
                var documentData = new extHostDocumentData_1.ExtHostDocumentData(this._threadService.get(extHost_protocol_1.MainContext.MainThreadDocuments), data.url, data.lines, data.EOL, data.modeId, data.versionId, data.isDirty);
                this._documents.set(data.url.toString(), documentData);
                addedDocuments.push(documentData);
            }
        }
        if (delta.removedEditors) {
            for (var _d = 0, _e = delta.removedEditors; _d < _e.length; _d++) {
                var id = _e[_d];
                var editor = this._editors.get(id);
                this._editors.delete(id);
                removedEditors.push(editor);
            }
        }
        if (delta.addedEditors) {
            for (var _f = 0, _g = delta.addedEditors; _f < _g.length; _f++) {
                var data = _g[_f];
                assert.ok(this._documents.has(data.document.toString()), "document '" + data.document + "' does not exist");
                assert.ok(!this._editors.has(data.id), "editor '" + data.id + "' already exists!");
                var documentData = this._documents.get(data.document.toString());
                var editor = new extHostTextEditor_1.ExtHostTextEditor(this._threadService.get(extHost_protocol_1.MainContext.MainThreadEditors), data.id, documentData, data.selections.map(typeConverters.toSelection), data.options, typeConverters.toViewColumn(data.editorPosition));
                this._editors.set(data.id, editor);
            }
        }
        if (delta.newActiveEditor !== undefined) {
            assert.ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), "active editor '" + delta.newActiveEditor + "' does not exist");
            this._activeEditorId = delta.newActiveEditor;
        }
        // now that the internal state is complete, fire events
        if (delta.removedDocuments) {
            this._onDidRemoveDocuments.fire(removedDocuments);
        }
        if (delta.addedDocuments) {
            this._onDidAddDocuments.fire(addedDocuments);
        }
        if (delta.removedEditors || delta.addedEditors) {
            this._onDidChangeVisibleTextEditors.fire(this.allEditors());
        }
        if (delta.newActiveEditor) {
            this._onDidChangeActiveTextEditor.fire(this.activeEditor());
        }
        // now that the events are out, dispose removed documents and editors
        lifecycle_1.dispose(removedDocuments);
        lifecycle_1.dispose(removedEditors);
    };
    ExtHostDocumentsAndEditors.prototype.getDocument = function (strUrl) {
        return this._documents.get(strUrl);
    };
    ExtHostDocumentsAndEditors.prototype.allDocuments = function () {
        var result = [];
        this._documents.forEach(function (data) { return result.push(data); });
        return result;
    };
    ExtHostDocumentsAndEditors.prototype.getEditor = function (id) {
        return this._editors.get(id);
    };
    ExtHostDocumentsAndEditors.prototype.activeEditor = function () {
        if (!this._activeEditorId) {
            return undefined;
        }
        else {
            return this._editors.get(this._activeEditorId);
        }
    };
    ExtHostDocumentsAndEditors.prototype.allEditors = function () {
        var result = [];
        this._editors.forEach(function (data) { return result.push(data); });
        return result;
    };
    return ExtHostDocumentsAndEditors;
}(extHost_protocol_1.ExtHostDocumentsAndEditorsShape));
ExtHostDocumentsAndEditors = __decorate([
    __param(0, threadService_1.IThreadService)
], ExtHostDocumentsAndEditors);
exports.ExtHostDocumentsAndEditors = ExtHostDocumentsAndEditors;
