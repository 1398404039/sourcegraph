/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var nls = require("vs/nls");
var pfs = require("vs/base/node/pfs");
var winjs_base_1 = require("vs/base/common/winjs.base");
var paths = require("vs/base/common/paths");
var extHostExtensionService_1 = require("vs/workbench/api/node/extHostExtensionService");
var extHostThreadService_1 = require("vs/workbench/services/thread/common/extHostThreadService");
var extHostTelemetry_1 = require("vs/workbench/api/node/extHostTelemetry");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var extHost_protocol_1 = require("vs/workbench/api/node/extHost.protocol");
var errors = require("vs/base/common/errors");
var nativeExit = process.exit.bind(process);
process.exit = function () {
    var err = new Error('An extension called process.exit() and this was prevented.');
    console.warn(err.stack);
};
function exit(code) {
    nativeExit(code);
}
exports.exit = exit;
var ExtensionHostMain = (function () {
    function ExtensionHostMain(remoteCom, initData) {
        this._isTerminating = false;
        // services
        this._environment = initData.environment;
        this._contextService = new workspace_1.WorkspaceContextService(initData.contextService.workspace);
        var threadService = new extHostThreadService_1.ExtHostThreadService(remoteCom);
        var telemetryService = new extHostTelemetry_1.RemoteTelemetryService('pluginHostTelemetry', threadService);
        this._extensionService = new extHostExtensionService_1.ExtHostExtensionService(initData, threadService, telemetryService, this._contextService);
        // Error forwarding
        var mainThreadErrors = threadService.get(extHost_protocol_1.MainContext.MainThreadErrors);
        errors.setUnexpectedErrorHandler(function (err) { return mainThreadErrors.onUnexpectedExtHostError(errors.transformErrorForSerialization(err)); });
    }
    ExtensionHostMain.prototype.start = function () {
        var _this = this;
        return this._extensionService.onReady()
            .then(function () { return _this.handleEagerExtensions(); })
            .then(function () { return _this.handleExtensionTests(); });
    };
    ExtensionHostMain.prototype.terminate = function () {
        var _this = this;
        if (this._isTerminating) {
            // we are already shutting down...
            return;
        }
        this._isTerminating = true;
        errors.setUnexpectedErrorHandler(function (err) {
            // TODO: write to log once we have one
        });
        var allPromises = [];
        try {
            var allExtensions = this._extensionService.getAllExtensionDescriptions();
            var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
            var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
            allPromises = activatedExtensions.map(function (extensionId) {
                return _this._extensionService.deactivate(extensionId);
            });
        }
        catch (err) {
        }
        var extensionsDeactivated = winjs_base_1.TPromise.join(allPromises).then(function () { return void 0; });
        // Give extensions 1 second to wrap up any async dispose, then exit
        setTimeout(function () {
            winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(4000), extensionsDeactivated]).then(function () { return exit(); }, function () { return exit(); });
        }, 1000);
    };
    // Handle "eager" activation extensions
    ExtensionHostMain.prototype.handleEagerExtensions = function () {
        this._extensionService.activateByEvent('*').then(null, function (err) {
            console.error(err);
        });
        return this.handleWorkspaceContainsEagerExtensions();
    };
    ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
        var _this = this;
        var workspace = this._contextService.getWorkspace();
        if (!workspace || !workspace.resource) {
            return winjs_base_1.TPromise.as(null);
        }
        var folderPath = workspace.resource.fsPath;
        var desiredFilesMap = {};
        this._extensionService.getAllExtensionDescriptions().forEach(function (desc) {
            var activationEvents = desc.activationEvents;
            if (!activationEvents) {
                return;
            }
            for (var i = 0; i < activationEvents.length; i++) {
                if (/^workspaceContains:/.test(activationEvents[i])) {
                    var fileName = activationEvents[i].substr('workspaceContains:'.length);
                    desiredFilesMap[fileName] = true;
                }
            }
        });
        var fileNames = Object.keys(desiredFilesMap);
        return winjs_base_1.TPromise.join(fileNames.map(function (f) { return pfs.exists(paths.join(folderPath, f)); })).then(function (exists) {
            fileNames
                .filter(function (f, i) { return exists[i]; })
                .forEach(function (fileName) {
                var activationEvent = "workspaceContains:" + fileName;
                _this._extensionService.activateByEvent(activationEvent)
                    .done(null, function (err) { return console.error(err); });
            });
        });
    };
    ExtensionHostMain.prototype.handleExtensionTests = function () {
        var _this = this;
        if (!this._environment.extensionTestsPath || !this._environment.extensionDevelopmentPath) {
            return winjs_base_1.TPromise.as(null);
        }
        // Require the test runner via node require from the provided path
        var testRunner;
        var requireError;
        try {
            testRunner = require.__$__nodeRequire(this._environment.extensionTestsPath);
        }
        catch (error) {
            requireError = error;
        }
        // Execute the runner if it follows our spec
        if (testRunner && typeof testRunner.run === 'function') {
            return new winjs_base_1.TPromise(function (c, e) {
                testRunner.run(_this._environment.extensionTestsPath, function (error, failures) {
                    if (error) {
                        e(error.toString());
                    }
                    else {
                        c(null);
                    }
                    // after tests have run, we shutdown the host
                    _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                });
            });
        }
        else {
            this.gracefulExit(1 /* ERROR */);
        }
        return winjs_base_1.TPromise.wrapError(requireError ? requireError.toString() : nls.localize('extensionTestError', "Path {0} does not point to a valid extension test runner.", this._environment.extensionTestsPath));
    };
    ExtensionHostMain.prototype.gracefulExit = function (code) {
        // to give the PH process a chance to flush any outstanding console
        // messages to the main process, we delay the exit() by some time
        setTimeout(function () { return exit(code); }, 500);
    };
    return ExtensionHostMain;
}());
exports.ExtensionHostMain = ExtensionHostMain;
