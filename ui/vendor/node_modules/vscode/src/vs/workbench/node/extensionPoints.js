/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var nls = require("vs/nls");
var Platform = require("vs/base/common/platform");
var pfs = require("vs/base/node/pfs");
var severity_1 = require("vs/base/common/severity");
var winjs_base_1 = require("vs/base/common/winjs.base");
var collections_1 = require("vs/base/common/collections");
var paths = require("vs/base/common/paths");
var json = require("vs/base/common/json");
var Types = require("vs/base/common/types");
var extensionValidator_1 = require("vs/platform/extensions/node/extensionValidator");
var semver = require("semver");
var extensionManagementUtil_1 = require("vs/platform/extensionManagement/common/extensionManagementUtil");
var MANIFEST_FILE = 'package.json';
var devMode = !!process.env['VSCODE_DEV'];
var nlsConfig = {
    locale: Platform.locale,
    pseudo: Platform.locale === 'pseudo'
};
var MessagesCollector = (function () {
    function MessagesCollector() {
        this._messages = [];
    }
    MessagesCollector.prototype.getMessages = function () {
        return this._messages;
    };
    MessagesCollector.prototype._msg = function (source, type, message) {
        this._messages.push({
            type: type,
            message: message,
            source: source
        });
    };
    MessagesCollector.prototype.error = function (source, message) {
        this._msg(source, severity_1.default.Error, message);
    };
    MessagesCollector.prototype.warn = function (source, message) {
        this._msg(source, severity_1.default.Warning, message);
    };
    MessagesCollector.prototype.info = function (source, message) {
        this._msg(source, severity_1.default.Info, message);
    };
    return MessagesCollector;
}());
exports.MessagesCollector = MessagesCollector;
var ExtensionManifestHandler = (function () {
    function ExtensionManifestHandler(ourVersion, collector, absoluteFolderPath, isBuiltin) {
        this._ourVersion = ourVersion;
        this._collector = collector;
        this._absoluteFolderPath = absoluteFolderPath;
        this._isBuiltin = isBuiltin;
        this._absoluteManifestPath = paths.join(absoluteFolderPath, MANIFEST_FILE);
    }
    return ExtensionManifestHandler;
}());
var ExtensionManifestParser = (function (_super) {
    __extends(ExtensionManifestParser, _super);
    function ExtensionManifestParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExtensionManifestParser.prototype.parse = function () {
        var _this = this;
        return pfs.readFile(this._absoluteManifestPath).then(function (manifestContents) {
            try {
                return JSON.parse(manifestContents.toString());
            }
            catch (e) {
                _this._collector.error(_this._absoluteFolderPath, nls.localize('jsonParseFail', "Failed to parse {0}: {1}.", _this._absoluteManifestPath, json.getParseErrorMessage(e.message)));
            }
            return null;
        }, function (err) {
            if (err.code === 'ENOENT') {
                return null;
            }
            _this._collector.error(_this._absoluteFolderPath, nls.localize('fileReadFail', "Cannot read file {0}: {1}.", _this._absoluteManifestPath, err.message));
            return null;
        });
    };
    return ExtensionManifestParser;
}(ExtensionManifestHandler));
var ExtensionManifestNLSReplacer = (function (_super) {
    __extends(ExtensionManifestNLSReplacer, _super);
    function ExtensionManifestNLSReplacer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExtensionManifestNLSReplacer.prototype.replaceNLS = function (extensionDescription) {
        var _this = this;
        var extension = paths.extname(this._absoluteManifestPath);
        var basename = this._absoluteManifestPath.substr(0, this._absoluteManifestPath.length - extension.length);
        return pfs.fileExists(basename + '.nls' + extension).then(function (exists) {
            if (!exists) {
                return extensionDescription;
            }
            return ExtensionManifestNLSReplacer.findMessageBundle(basename).then(function (messageBundle) {
                if (!messageBundle) {
                    return extensionDescription;
                }
                return pfs.readFile(messageBundle).then(function (messageBundleContent) {
                    var errors = [];
                    var messages = json.parse(messageBundleContent.toString(), errors);
                    if (errors.length > 0) {
                        errors.forEach(function (error) {
                            _this._collector.error(_this._absoluteFolderPath, nls.localize('jsonParseFail', "Failed to parse {0}: {1}.", messageBundle, json.getParseErrorMessage(error.error)));
                        });
                        return extensionDescription;
                    }
                    ExtensionManifestNLSReplacer._replaceNLStrings(extensionDescription, messages, _this._collector, _this._absoluteFolderPath);
                    return extensionDescription;
                }, function (err) {
                    _this._collector.error(_this._absoluteFolderPath, nls.localize('fileReadFail', "Cannot read file {0}: {1}.", messageBundle, err.message));
                    return null;
                });
            });
        });
    };
    ExtensionManifestNLSReplacer.findMessageBundle = function (basename) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            function loop(basename, locale) {
                var toCheck = basename + ".nls." + locale + ".json";
                pfs.fileExists(toCheck).then(function (exists) {
                    if (exists) {
                        c(toCheck);
                    }
                    var index = locale.lastIndexOf('-');
                    if (index === -1) {
                        c(basename + ".nls.json");
                    }
                    else {
                        locale = locale.substring(0, index);
                        loop(basename, locale);
                    }
                });
            }
            if (devMode || nlsConfig.pseudo || !nlsConfig.locale) {
                return c(basename + '.nls.json');
            }
            loop(basename, nlsConfig.locale);
        });
    };
    /**
     * This routine make the following assumptions:
     * The root element is a object literal
     */
    ExtensionManifestNLSReplacer._replaceNLStrings = function (literal, messages, collector, messageScope) {
        function processEntry(obj, key) {
            var value = obj[key];
            if (Types.isString(value)) {
                var str = value;
                var length_1 = str.length;
                if (length_1 > 1 && str[0] === '%' && str[length_1 - 1] === '%') {
                    var messageKey = str.substr(1, length_1 - 2);
                    var message = messages[messageKey];
                    if (message) {
                        if (nlsConfig.pseudo) {
                            // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
                            message = '\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\uFF3D';
                        }
                        obj[key] = message;
                    }
                    else {
                        collector.warn(messageScope, nls.localize('missingNLSKey', "Couldn't find message for key {0}.", messageKey));
                    }
                }
            }
            else if (Types.isObject(value)) {
                for (var k in value) {
                    if (value.hasOwnProperty(k)) {
                        processEntry(value, k);
                    }
                }
            }
            else if (Types.isArray(value)) {
                for (var i = 0; i < value.length; i++) {
                    processEntry(value, i);
                }
            }
        }
        for (var key in literal) {
            if (literal.hasOwnProperty(key)) {
                processEntry(literal, key);
            }
        }
        ;
    };
    return ExtensionManifestNLSReplacer;
}(ExtensionManifestHandler));
var ExtensionManifestValidator = (function (_super) {
    __extends(ExtensionManifestValidator, _super);
    function ExtensionManifestValidator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExtensionManifestValidator.prototype.validate = function (_extensionDescription) {
        var _this = this;
        var extensionDescription = _extensionDescription;
        extensionDescription.isBuiltin = this._isBuiltin;
        var notices = [];
        if (!extensionValidator_1.isValidExtensionDescription(this._ourVersion, this._absoluteFolderPath, extensionDescription, notices)) {
            notices.forEach(function (error) {
                _this._collector.error(_this._absoluteFolderPath, error);
            });
            return null;
        }
        // in this case the notices are warnings
        notices.forEach(function (error) {
            _this._collector.warn(_this._absoluteFolderPath, error);
        });
        // id := `publisher.name`
        extensionDescription.id = extensionDescription.publisher + "." + extensionDescription.name;
        // main := absolutePath(`main`)
        if (extensionDescription.main) {
            extensionDescription.main = paths.normalize(paths.join(this._absoluteFolderPath, extensionDescription.main));
        }
        extensionDescription.extensionFolderPath = this._absoluteFolderPath;
        return extensionDescription;
    };
    return ExtensionManifestValidator;
}(ExtensionManifestHandler));
var ExtensionScanner = (function () {
    function ExtensionScanner() {
    }
    /**
     * Read the extension defined in `absoluteFolderPath`
     */
    ExtensionScanner.scanExtension = function (version, collector, absoluteFolderPath, isBuiltin) {
        absoluteFolderPath = paths.normalize(absoluteFolderPath);
        var parser = new ExtensionManifestParser(version, collector, absoluteFolderPath, isBuiltin);
        return parser.parse().then(function (extensionDescription) {
            if (extensionDescription === null) {
                return null;
            }
            var nlsReplacer = new ExtensionManifestNLSReplacer(version, collector, absoluteFolderPath, isBuiltin);
            return nlsReplacer.replaceNLS(extensionDescription);
        }).then(function (extensionDescription) {
            if (extensionDescription === null) {
                return null;
            }
            var validator = new ExtensionManifestValidator(version, collector, absoluteFolderPath, isBuiltin);
            return validator.validate(extensionDescription);
        });
    };
    /**
     * Scan a list of extensions defined in `absoluteFolderPath`
     */
    ExtensionScanner.scanExtensions = function (version, collector, absoluteFolderPath, isBuiltin) {
        var _this = this;
        var obsolete = winjs_base_1.TPromise.as({});
        if (!isBuiltin) {
            obsolete = pfs.readFile(paths.join(absoluteFolderPath, '.obsolete'), 'utf8')
                .then(function (raw) { return JSON.parse(raw); })
                .then(null, function (err) { return ({}); });
        }
        return obsolete.then(function (obsolete) {
            return pfs.readDirsInDir(absoluteFolderPath)
                .then(function (folders) {
                if (isBuiltin) {
                    return folders;
                }
                // TODO: align with extensionsService
                var nonGallery = [];
                var gallery = [];
                folders.forEach(function (folder) {
                    if (obsolete[folder]) {
                        return;
                    }
                    var _a = extensionManagementUtil_1.getIdAndVersionFromLocalExtensionId(folder), id = _a.id, version = _a.version;
                    if (!id || !version) {
                        nonGallery.push(folder);
                        return;
                    }
                    gallery.push({ folder: folder, id: id, version: version });
                });
                var byId = collections_1.values(collections_1.groupBy(gallery, function (p) { return p.id; }));
                var latest = byId.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.version, b.version); })[0]; })
                    .map(function (a) { return a.folder; });
                return nonGallery.concat(latest);
            })
                .then(function (folders) { return winjs_base_1.TPromise.join(folders.map(function (f) { return _this.scanExtension(version, collector, paths.join(absoluteFolderPath, f), isBuiltin); })); })
                .then(function (extensionDescriptions) { return extensionDescriptions.filter(function (item) { return item !== null; }); })
                .then(null, function (err) {
                collector.error(absoluteFolderPath, err);
                return [];
            });
        });
    };
    /**
     * Combination of scanExtension and scanExtensions: If an extension manifest is found at root, we load just this extension,
     * otherwise we assume the folder contains multiple extensions.
     */
    ExtensionScanner.scanOneOrMultipleExtensions = function (version, collector, absoluteFolderPath, isBuiltin) {
        var _this = this;
        return pfs.fileExists(paths.join(absoluteFolderPath, MANIFEST_FILE)).then(function (exists) {
            if (exists) {
                return _this.scanExtension(version, collector, absoluteFolderPath, isBuiltin).then(function (extensionDescription) {
                    if (extensionDescription === null) {
                        return [];
                    }
                    return [extensionDescription];
                });
            }
            return _this.scanExtensions(version, collector, absoluteFolderPath, isBuiltin);
        }, function (err) {
            collector.error(absoluteFolderPath, err);
            return [];
        });
    };
    return ExtensionScanner;
}());
exports.ExtensionScanner = ExtensionScanner;
