/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var fs = require("fs");
var path_1 = require("path");
var gracefulFs = require("graceful-fs");
gracefulFs.gracefulify(fs);
var arrays = require("vs/base/common/arrays");
var comparers_1 = require("vs/base/common/comparers");
var objects = require("vs/base/common/objects");
var scorer = require("vs/base/common/scorer");
var strings = require("vs/base/common/strings");
var winjs_base_1 = require("vs/base/common/winjs.base");
var files_1 = require("vs/platform/files/common/files");
var fileSearch_1 = require("vs/workbench/services/search/node/fileSearch");
var textSearch_1 = require("vs/workbench/services/search/node/textSearch");
var textSearchWorkerProvider_1 = require("vs/workbench/services/search/node/textSearchWorkerProvider");
var SearchService = (function () {
    function SearchService() {
        this.caches = Object.create(null);
    }
    SearchService.prototype.fileSearch = function (config) {
        return this.doFileSearch(fileSearch_1.Engine, config, SearchService.BATCH_SIZE);
    };
    SearchService.prototype.textSearch = function (config) {
        if (!this.textSearchWorkerProvider) {
            this.textSearchWorkerProvider = new textSearchWorkerProvider_1.TextSearchWorkerProvider();
        }
        var engine = new textSearch_1.Engine(config, new fileSearch_1.FileWalker({
            rootFolders: config.rootFolders,
            extraFiles: config.extraFiles,
            includePattern: config.includePattern,
            excludePattern: config.excludePattern,
            filePattern: config.filePattern,
            maxFilesize: files_1.MAX_FILE_SIZE
        }), this.textSearchWorkerProvider);
        return this.doTextSearch(engine, SearchService.BATCH_SIZE);
    };
    SearchService.prototype.doFileSearch = function (EngineClass, config, batchSize) {
        var _this = this;
        if (config.sortByScore) {
            var sortedSearch_1 = this.trySortedSearchFromCache(config);
            if (!sortedSearch_1) {
                var walkerConfig = config.maxResults ? objects.assign({}, config, { maxResults: null }) : config;
                var engine = new EngineClass(walkerConfig);
                sortedSearch_1 = this.doSortedSearch(engine, config);
            }
            return new winjs_base_1.PPromise(function (c, e, p) {
                process.nextTick(function () {
                    sortedSearch_1.then(function (_a) {
                        var result = _a[0], rawMatches = _a[1];
                        var serializedMatches = rawMatches.map(function (rawMatch) { return _this.rawMatchToSearchItem(rawMatch); });
                        _this.sendProgress(serializedMatches, p, batchSize);
                        c(result);
                    }, e, p);
                });
            }, function () {
                sortedSearch_1.cancel();
            });
        }
        var searchPromise;
        return new winjs_base_1.PPromise(function (c, e, p) {
            var engine = new EngineClass(config);
            searchPromise = _this.doSearch(engine, batchSize)
                .then(c, e, function (progress) {
                if (Array.isArray(progress)) {
                    p(progress.map(function (m) { return _this.rawMatchToSearchItem(m); }));
                }
                else if (progress.relativePath) {
                    p(_this.rawMatchToSearchItem(progress));
                }
                else {
                    p(progress);
                }
            });
        }, function () {
            searchPromise.cancel();
        });
    };
    SearchService.prototype.rawMatchToSearchItem = function (match) {
        return { path: match.base ? [match.base, match.relativePath].join(path_1.sep) : match.relativePath };
    };
    SearchService.prototype.doSortedSearch = function (engine, config) {
        var _this = this;
        var searchPromise;
        var allResultsPromise = new winjs_base_1.PPromise(function (c, e, p) {
            var results = [];
            searchPromise = _this.doSearch(engine, -1)
                .then(function (result) {
                c([result, results]);
            }, e, function (progress) {
                if (Array.isArray(progress)) {
                    results = progress;
                }
                else {
                    p(progress);
                }
            });
        }, function () {
            searchPromise.cancel();
        });
        var cache;
        if (config.cacheKey) {
            cache = this.getOrCreateCache(config.cacheKey);
            cache.resultsToSearchCache[config.filePattern] = allResultsPromise;
            allResultsPromise.then(null, function (err) {
                delete cache.resultsToSearchCache[config.filePattern];
            });
            allResultsPromise = this.preventCancellation(allResultsPromise);
        }
        return new winjs_base_1.PPromise(function (c, e, p) {
            allResultsPromise.then(function (_a) {
                var result = _a[0], results = _a[1];
                var scorerCache = cache ? cache.scorerCache : Object.create(null);
                var unsortedResultTime = Date.now();
                var sortedResults = _this.sortResults(config, results, scorerCache);
                var sortedResultTime = Date.now();
                c([{
                        stats: objects.assign({}, result.stats, {
                            unsortedResultTime: unsortedResultTime,
                            sortedResultTime: sortedResultTime
                        }),
                        limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults
                    }, sortedResults]);
            }, e, p);
        }, function () {
            allResultsPromise.cancel();
        });
    };
    SearchService.prototype.getOrCreateCache = function (cacheKey) {
        var existing = this.caches[cacheKey];
        if (existing) {
            return existing;
        }
        return this.caches[cacheKey] = new Cache();
    };
    SearchService.prototype.trySortedSearchFromCache = function (config) {
        var _this = this;
        var cache = config.cacheKey && this.caches[config.cacheKey];
        if (!cache) {
            return undefined;
        }
        var cacheLookupStartTime = Date.now();
        var cached = this.getResultsFromCache(cache, config.filePattern);
        if (cached) {
            return new winjs_base_1.PPromise(function (c, e, p) {
                cached.then(function (_a) {
                    var result = _a[0], results = _a[1], cacheStats = _a[2];
                    var cacheLookupResultTime = Date.now();
                    var sortedResults = _this.sortResults(config, results, cache.scorerCache);
                    var sortedResultTime = Date.now();
                    var stats = {
                        fromCache: true,
                        cacheLookupStartTime: cacheLookupStartTime,
                        cacheFilterStartTime: cacheStats.cacheFilterStartTime,
                        cacheLookupResultTime: cacheLookupResultTime,
                        cacheEntryCount: cacheStats.cacheFilterResultCount,
                        resultCount: results.length
                    };
                    if (config.sortByScore) {
                        stats.unsortedResultTime = cacheLookupResultTime;
                        stats.sortedResultTime = sortedResultTime;
                    }
                    if (!cacheStats.cacheWasResolved) {
                        stats.joined = result.stats;
                    }
                    c([
                        {
                            limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,
                            stats: stats
                        },
                        sortedResults
                    ]);
                }, e, p);
            }, function () {
                cached.cancel();
            });
        }
        return undefined;
    };
    SearchService.prototype.sortResults = function (config, results, scorerCache) {
        var filePattern = config.filePattern;
        var normalizedSearchValue = strings.stripWildcards(filePattern).toLowerCase();
        var compare = function (elementA, elementB) { return comparers_1.compareByScore(elementA, elementB, FileMatchAccessor, filePattern, normalizedSearchValue, scorerCache); };
        return arrays.top(results, compare, config.maxResults);
    };
    SearchService.prototype.sendProgress = function (results, progressCb, batchSize) {
        if (batchSize && batchSize > 0) {
            for (var i = 0; i < results.length; i += batchSize) {
                progressCb(results.slice(i, i + batchSize));
            }
        }
        else {
            progressCb(results);
        }
    };
    SearchService.prototype.getResultsFromCache = function (cache, searchValue) {
        if (path_1.isAbsolute(searchValue)) {
            return null; // bypass cache if user looks up an absolute path where matching goes directly on disk
        }
        // Find cache entries by prefix of search value
        var hasPathSep = searchValue.indexOf(path_1.sep) >= 0;
        var cached;
        var wasResolved;
        for (var previousSearch in cache.resultsToSearchCache) {
            // If we narrow down, we might be able to reuse the cached results
            if (strings.startsWith(searchValue, previousSearch)) {
                if (hasPathSep && previousSearch.indexOf(path_1.sep) < 0) {
                    continue; // since a path character widens the search for potential more matches, require it in previous search too
                }
                var c = cache.resultsToSearchCache[previousSearch];
                c.then(function () { wasResolved = false; });
                wasResolved = true;
                cached = this.preventCancellation(c);
                break;
            }
        }
        if (!cached) {
            return null;
        }
        return new winjs_base_1.PPromise(function (c, e, p) {
            cached.then(function (_a) {
                var complete = _a[0], cachedEntries = _a[1];
                var cacheFilterStartTime = Date.now();
                // Pattern match on results
                var results = [];
                var normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();
                for (var i = 0; i < cachedEntries.length; i++) {
                    var entry = cachedEntries[i];
                    // Check if this entry is a match for the search value
                    if (!scorer.matches(entry.relativePath, normalizedSearchValueLowercase)) {
                        continue;
                    }
                    results.push(entry);
                }
                c([complete, results, {
                        cacheWasResolved: wasResolved,
                        cacheFilterStartTime: cacheFilterStartTime,
                        cacheFilterResultCount: cachedEntries.length
                    }]);
            }, e, p);
        }, function () {
            cached.cancel();
        });
    };
    SearchService.prototype.doTextSearch = function (engine, batchSize) {
        return new winjs_base_1.PPromise(function (c, e, p) {
            // Use BatchedCollector to get new results to the frontend every 2s at least, until 50 results have been returned
            var collector = new BatchedCollector(batchSize, p);
            engine.search(function (matches) {
                var totalMatches = matches.reduce(function (acc, m) { return acc + m.numMatches; }, 0);
                collector.addItems(matches, totalMatches);
            }, function (progress) {
                p(progress);
            }, function (error, stats) {
                collector.flush();
                if (error) {
                    e(error);
                }
                else {
                    c(stats);
                }
            });
        }, function () {
            engine.cancel();
        });
    };
    SearchService.prototype.doSearch = function (engine, batchSize) {
        return new winjs_base_1.PPromise(function (c, e, p) {
            var batch = [];
            engine.search(function (match) {
                if (match) {
                    if (batchSize) {
                        batch.push(match);
                        if (batchSize > 0 && batch.length >= batchSize) {
                            p(batch);
                            batch = [];
                        }
                    }
                    else {
                        p(match);
                    }
                }
            }, function (progress) {
                p(progress);
            }, function (error, stats) {
                if (batch.length) {
                    p(batch);
                }
                if (error) {
                    e(error);
                }
                else {
                    c(stats);
                }
            });
        }, function () {
            engine.cancel();
        });
    };
    SearchService.prototype.clearCache = function (cacheKey) {
        delete this.caches[cacheKey];
        return winjs_base_1.TPromise.as(undefined);
    };
    SearchService.prototype.preventCancellation = function (promise) {
        return new winjs_base_1.PPromise(function (c, e, p) {
            // Allow for piled up cancellations to come through first.
            process.nextTick(function () {
                promise.then(c, e, p);
            });
        }, function () {
            // Do not propagate.
        });
    };
    return SearchService;
}());
SearchService.BATCH_SIZE = 512;
exports.SearchService = SearchService;
var Cache = (function () {
    function Cache() {
        this.resultsToSearchCache = Object.create(null);
        this.scorerCache = Object.create(null);
    }
    return Cache;
}());
var FileMatchAccessor = (function () {
    function FileMatchAccessor() {
    }
    FileMatchAccessor.getLabel = function (match) {
        return match.basename;
    };
    FileMatchAccessor.getResourcePath = function (match) {
        return match.relativePath;
    };
    return FileMatchAccessor;
}());
/**
 * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every
 * set of items collected.
 * But after that point, the callback is called with batches of maxBatchSize.
 * If the batch isn't filled within some time, the callback is also called.
 */
var BatchedCollector = (function () {
    function BatchedCollector(maxBatchSize, cb) {
        this.maxBatchSize = maxBatchSize;
        this.cb = cb;
        this.totalNumberCompleted = 0;
        this.batch = [];
        this.batchSize = 0;
    }
    BatchedCollector.prototype.addItems = function (items, size) {
        if (!items) {
            return;
        }
        if (this.maxBatchSize > 0) {
            this.addItemsToBatch(items, size);
        }
        else {
            this.cb(items);
        }
    };
    BatchedCollector.prototype.addItemsToBatch = function (items, size) {
        var _this = this;
        this.batch = this.batch.concat(items);
        this.batchSize += size;
        if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {
            // Flush because we aren't batching yet
            this.flush();
        }
        else if (this.batchSize >= this.maxBatchSize) {
            // Flush because the batch is full
            this.flush();
        }
        else if (!this.timeoutHandle) {
            // No timeout running, start a timeout to flush
            this.timeoutHandle = setTimeout(function () {
                _this.flush();
            }, BatchedCollector.TIMEOUT);
        }
    };
    BatchedCollector.prototype.flush = function () {
        if (this.batchSize) {
            this.totalNumberCompleted += this.batchSize;
            this.cb(this.batch);
            this.batch = [];
            this.batchSize = 0;
            if (this.timeoutHandle) {
                clearTimeout(this.timeoutHandle);
                this.timeoutHandle = 0;
            }
        }
    };
    return BatchedCollector;
}());
BatchedCollector.TIMEOUT = 4000;
// After RUN_TIMEOUT_UNTIL_COUNT items have been collected, stop flushing on timeout
BatchedCollector.START_BATCH_AFTER_COUNT = 50;
