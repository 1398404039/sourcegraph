/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var event_1 = require("vs/base/common/event");
var winjs_base_1 = require("vs/base/common/winjs.base");
var textFileEditorModel_1 = require("vs/workbench/services/textfile/common/textFileEditorModel");
var lifecycle_1 = require("vs/base/common/lifecycle");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var lifecycle_2 = require("vs/platform/lifecycle/common/lifecycle");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var TextFileEditorModelManager = (function () {
    function TextFileEditorModelManager(lifecycleService, instantiationService, editorGroupService) {
        this.lifecycleService = lifecycleService;
        this.instantiationService = instantiationService;
        this.editorGroupService = editorGroupService;
        this.toUnbind = [];
        this._onModelDisposed = new event_1.Emitter();
        this._onModelContentChanged = new event_1.Emitter();
        this._onModelDirty = new event_1.Emitter();
        this._onModelSaveError = new event_1.Emitter();
        this._onModelSaved = new event_1.Emitter();
        this._onModelReverted = new event_1.Emitter();
        this._onModelEncodingChanged = new event_1.Emitter();
        this.toUnbind.push(this._onModelDisposed);
        this.toUnbind.push(this._onModelContentChanged);
        this.toUnbind.push(this._onModelDirty);
        this.toUnbind.push(this._onModelSaveError);
        this.toUnbind.push(this._onModelSaved);
        this.toUnbind.push(this._onModelReverted);
        this.toUnbind.push(this._onModelEncodingChanged);
        this.mapResourceToModel = Object.create(null);
        this.mapResourceToDisposeListener = Object.create(null);
        this.mapResourceToStateChangeListener = Object.create(null);
        this.mapResourceToModelContentChangeListener = Object.create(null);
        this.mapResourceToPendingModelLoaders = Object.create(null);
        this.registerListeners();
    }
    TextFileEditorModelManager.prototype.registerListeners = function () {
        var _this = this;
        // Editors changing/closing
        this.toUnbind.push(this.editorGroupService.onEditorsChanged(function () { return _this.onEditorsChanged(); }));
        this.toUnbind.push(this.editorGroupService.getStacksModel().onEditorClosed(function () { return _this.onEditorClosed(); }));
        // Lifecycle
        this.lifecycleService.onShutdown(this.dispose, this);
    };
    TextFileEditorModelManager.prototype.onEditorsChanged = function () {
        this.disposeUnusedModels();
    };
    TextFileEditorModelManager.prototype.onEditorClosed = function () {
        this.disposeUnusedModels();
    };
    TextFileEditorModelManager.prototype.disposeUnusedModels = function () {
        // To not grow our text file model cache infinitly, we dispose models that
        // are not showing up in any opened editor.
        // TODO@Ben this is a workaround until we have adopted model references from
        // the resolver service (https://github.com/Microsoft/vscode/issues/17888)
        var _this = this;
        this.getAll(void 0, function (model) { return _this.canDispose(model); }).forEach(function (model) {
            model.dispose();
        });
    };
    TextFileEditorModelManager.prototype.canDispose = function (model) {
        if (!model) {
            return false; // we need data!
        }
        if (model.isDisposed()) {
            return false; // already disposed
        }
        if (this.mapResourceToPendingModelLoaders[model.getResource().toString()]) {
            return false; // not yet loaded
        }
        if (model.getState() !== textfiles_1.ModelState.SAVED) {
            return false; // not saved
        }
        if (model.textEditorModel && model.textEditorModel.isAttachedToEditor()) {
            return false; // never dispose when attached to editor (e.g. viewzones)
        }
        if (this.editorGroupService.getStacksModel().isOpen(model.getResource())) {
            return false; // never dispose when opened inside an editor (e.g. tabs)
        }
        return true;
    };
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelDisposed", {
        get: function () {
            return this._onModelDisposed.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelContentChanged", {
        get: function () {
            return this._onModelContentChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelDirty", {
        get: function () {
            return this._onModelDirty.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaveError", {
        get: function () {
            return this._onModelSaveError.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaved", {
        get: function () {
            return this._onModelSaved.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelReverted", {
        get: function () {
            return this._onModelReverted.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelEncodingChanged", {
        get: function () {
            return this._onModelEncodingChanged.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsDirty", {
        get: function () {
            if (!this._onModelsDirtyEvent) {
                this._onModelsDirtyEvent = this.debounce(this.onModelDirty);
            }
            return this._onModelsDirtyEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsSaveError", {
        get: function () {
            if (!this._onModelsSaveError) {
                this._onModelsSaveError = this.debounce(this.onModelSaveError);
            }
            return this._onModelsSaveError;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsSaved", {
        get: function () {
            if (!this._onModelsSaved) {
                this._onModelsSaved = this.debounce(this.onModelSaved);
            }
            return this._onModelsSaved;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsReverted", {
        get: function () {
            if (!this._onModelsReverted) {
                this._onModelsReverted = this.debounce(this.onModelReverted);
            }
            return this._onModelsReverted;
        },
        enumerable: true,
        configurable: true
    });
    TextFileEditorModelManager.prototype.debounce = function (event) {
        return event_1.debounceEvent(event, function (prev, cur) {
            if (!prev) {
                prev = [cur];
            }
            else {
                prev.push(cur);
            }
            return prev;
        }, this.debounceDelay());
    };
    TextFileEditorModelManager.prototype.debounceDelay = function () {
        return 250;
    };
    TextFileEditorModelManager.prototype.get = function (resource) {
        return this.mapResourceToModel[resource.toString()];
    };
    TextFileEditorModelManager.prototype.loadOrCreate = function (resource, encoding, refresh) {
        var _this = this;
        // Return early if model is currently being loaded
        var pendingLoad = this.mapResourceToPendingModelLoaders[resource.toString()];
        if (pendingLoad) {
            return pendingLoad;
        }
        var modelPromise;
        // Model exists
        var model = this.get(resource);
        if (model) {
            if (!refresh) {
                modelPromise = winjs_base_1.TPromise.as(model);
            }
            else {
                modelPromise = model.load();
            }
        }
        else {
            model = this.instantiationService.createInstance(textFileEditorModel_1.TextFileEditorModel, resource, encoding);
            modelPromise = model.load();
            // Install state change listener
            this.mapResourceToStateChangeListener[resource.toString()] = model.onDidStateChange(function (state) {
                var event = new textfiles_1.TextFileModelChangeEvent(model, state);
                switch (state) {
                    case textfiles_1.StateChange.DIRTY:
                        _this._onModelDirty.fire(event);
                        break;
                    case textfiles_1.StateChange.SAVE_ERROR:
                        _this._onModelSaveError.fire(event);
                        break;
                    case textfiles_1.StateChange.SAVED:
                        _this._onModelSaved.fire(event);
                        break;
                    case textfiles_1.StateChange.REVERTED:
                        _this._onModelReverted.fire(event);
                        break;
                    case textfiles_1.StateChange.ENCODING:
                        _this._onModelEncodingChanged.fire(event);
                        break;
                }
            });
            // Install model content change listener
            this.mapResourceToModelContentChangeListener[resource.toString()] = model.onDidContentChange(function (e) {
                _this._onModelContentChanged.fire(new textfiles_1.TextFileModelChangeEvent(model, e));
            });
        }
        // Store pending loads to avoid race conditions
        this.mapResourceToPendingModelLoaders[resource.toString()] = modelPromise;
        return modelPromise.then(function (model) {
            // Make known to manager (if not already known)
            _this.add(resource, model);
            // Model can be dirty if a backup was restored, so we make sure to have this event delivered
            if (model.isDirty()) {
                _this._onModelDirty.fire(new textfiles_1.TextFileModelChangeEvent(model, textfiles_1.StateChange.DIRTY));
            }
            // Remove from pending loads
            _this.mapResourceToPendingModelLoaders[resource.toString()] = null;
            return model;
        }, function (error) {
            // Free resources of this invalid model
            model.dispose();
            // Remove from pending loads
            _this.mapResourceToPendingModelLoaders[resource.toString()] = null;
            return winjs_base_1.TPromise.wrapError(error);
        });
    };
    TextFileEditorModelManager.prototype.getAll = function (resource, filter) {
        if (resource) {
            var res_1 = this.mapResourceToModel[resource.toString()];
            return res_1 ? [res_1] : [];
        }
        var keys = Object.keys(this.mapResourceToModel);
        var res = [];
        for (var i = 0; i < keys.length; i++) {
            var model = this.mapResourceToModel[keys[i]];
            if (!filter || filter(model)) {
                res.push(model);
            }
        }
        return res;
    };
    TextFileEditorModelManager.prototype.add = function (resource, model) {
        var _this = this;
        var knownModel = this.mapResourceToModel[resource.toString()];
        if (knownModel === model) {
            return; // already cached
        }
        // dispose any previously stored dispose listener for this resource
        var disposeListener = this.mapResourceToDisposeListener[resource.toString()];
        if (disposeListener) {
            disposeListener.dispose();
        }
        // store in cache but remove when model gets disposed
        this.mapResourceToModel[resource.toString()] = model;
        this.mapResourceToDisposeListener[resource.toString()] = model.onDispose(function () {
            _this.remove(resource);
            _this._onModelDisposed.fire(resource);
        });
    };
    TextFileEditorModelManager.prototype.remove = function (resource) {
        delete this.mapResourceToModel[resource.toString()];
        var disposeListener = this.mapResourceToDisposeListener[resource.toString()];
        if (disposeListener) {
            lifecycle_1.dispose(disposeListener);
            delete this.mapResourceToDisposeListener[resource.toString()];
        }
        var stateChangeListener = this.mapResourceToStateChangeListener[resource.toString()];
        if (stateChangeListener) {
            lifecycle_1.dispose(stateChangeListener);
            delete this.mapResourceToStateChangeListener[resource.toString()];
        }
        var modelContentChangeListener = this.mapResourceToModelContentChangeListener[resource.toString()];
        if (modelContentChangeListener) {
            lifecycle_1.dispose(modelContentChangeListener);
            delete this.mapResourceToModelContentChangeListener[resource.toString()];
        }
    };
    TextFileEditorModelManager.prototype.clear = function () {
        var _this = this;
        // model cache
        this.mapResourceToModel = Object.create(null);
        // dispose dispose listeners
        var keys = Object.keys(this.mapResourceToDisposeListener);
        lifecycle_1.dispose(keys.map(function (k) { return _this.mapResourceToDisposeListener[k]; }));
        this.mapResourceToDisposeListener = Object.create(null);
        // dispose state change listeners
        keys = Object.keys(this.mapResourceToStateChangeListener);
        lifecycle_1.dispose(keys.map(function (k) { return _this.mapResourceToStateChangeListener[k]; }));
        this.mapResourceToStateChangeListener = Object.create(null);
        // dispose model content change listeners
        keys = Object.keys(this.mapResourceToModelContentChangeListener);
        lifecycle_1.dispose(keys.map(function (k) { return _this.mapResourceToModelContentChangeListener[k]; }));
        this.mapResourceToModelContentChangeListener = Object.create(null);
    };
    TextFileEditorModelManager.prototype.dispose = function () {
        this.toUnbind = lifecycle_1.dispose(this.toUnbind);
    };
    return TextFileEditorModelManager;
}());
TextFileEditorModelManager = __decorate([
    __param(0, lifecycle_2.ILifecycleService),
    __param(1, instantiation_1.IInstantiationService),
    __param(2, groupService_1.IEditorGroupService)
], TextFileEditorModelManager);
exports.TextFileEditorModelManager = TextFileEditorModelManager;
