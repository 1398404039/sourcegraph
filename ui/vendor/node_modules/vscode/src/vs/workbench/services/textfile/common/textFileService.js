/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var uri_1 = require("vs/base/common/uri");
var paths = require("vs/base/common/paths");
var errors = require("vs/base/common/errors");
var objects = require("vs/base/common/objects");
var event_1 = require("vs/base/common/event");
var platform = require("vs/base/common/platform");
var windows_1 = require("vs/platform/windows/common/windows");
var backup_1 = require("vs/workbench/services/backup/common/backup");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var editor_1 = require("vs/workbench/common/editor");
var groupService_1 = require("vs/workbench/services/group/common/groupService");
var lifecycle_1 = require("vs/platform/lifecycle/common/lifecycle");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var files_1 = require("vs/platform/files/common/files");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var lifecycle_2 = require("vs/base/common/lifecycle");
var environment_1 = require("vs/platform/environment/common/environment");
var untitledEditorService_1 = require("vs/workbench/services/untitled/common/untitledEditorService");
var textFileEditorModelManager_1 = require("vs/workbench/services/textfile/common/textFileEditorModelManager");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var message_1 = require("vs/platform/message/common/message");
/**
 * The workbench file service implementation implements the raw file service spec and adds additional methods on top.
 *
 * It also adds diagnostics and logging around file system operations.
 */
var TextFileService = (function () {
    function TextFileService(lifecycleService, contextService, configurationService, telemetryService, fileService, untitledEditorService, instantiationService, messageService, environmentService, backupFileService, editorGroupService, windowsService) {
        this.lifecycleService = lifecycleService;
        this.contextService = contextService;
        this.configurationService = configurationService;
        this.telemetryService = telemetryService;
        this.fileService = fileService;
        this.untitledEditorService = untitledEditorService;
        this.instantiationService = instantiationService;
        this.messageService = messageService;
        this.environmentService = environmentService;
        this.backupFileService = backupFileService;
        this.editorGroupService = editorGroupService;
        this.windowsService = windowsService;
        this.toUnbind = [];
        this._onAutoSaveConfigurationChange = new event_1.Emitter();
        this.toUnbind.push(this._onAutoSaveConfigurationChange);
        this._onFilesAssociationChange = new event_1.Emitter();
        this.toUnbind.push(this._onFilesAssociationChange);
        this._models = this.instantiationService.createInstance(textFileEditorModelManager_1.TextFileEditorModelManager);
        var configuration = this.configurationService.getConfiguration();
        this.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;
        this.onConfigurationChange(configuration);
        this.telemetryService.publicLog('autoSave', this.getAutoSaveConfiguration());
        this.registerListeners();
    }
    Object.defineProperty(TextFileService.prototype, "models", {
        get: function () {
            return this._models;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileService.prototype, "onAutoSaveConfigurationChange", {
        get: function () {
            return this._onAutoSaveConfigurationChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFileService.prototype, "onFilesAssociationChange", {
        get: function () {
            return this._onFilesAssociationChange.event;
        },
        enumerable: true,
        configurable: true
    });
    TextFileService.prototype.registerListeners = function () {
        var _this = this;
        // Lifecycle
        this.lifecycleService.onWillShutdown(function (event) { return event.veto(_this.beforeShutdown(event.reason)); });
        this.lifecycleService.onShutdown(this.dispose, this);
        // Configuration changes
        this.toUnbind.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationChange(e.config); }));
    };
    TextFileService.prototype.beforeShutdown = function (reason) {
        var _this = this;
        // Dirty files need treatment on shutdown
        var dirty = this.getDirty();
        if (dirty.length) {
            // If auto save is enabled, save all files and then check again for dirty files
            var handleAutoSave = void 0;
            if (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {
                handleAutoSave = this.saveAll(false /* files only */).then(function () { return _this.getDirty(); });
            }
            else {
                handleAutoSave = winjs_base_1.TPromise.as(dirty);
            }
            return handleAutoSave.then(function (dirty) {
                // If we still have dirty files, we either have untitled ones or files that cannot be saved
                // or auto save was not enabled and as such we did not save any dirty files to disk automatically
                if (dirty.length) {
                    // If hot exit is enabled, backup dirty files and allow to exit without confirmation
                    if (_this.isHotExitEnabled) {
                        _this.showHotExitMessage();
                        return _this.backupBeforeShutdown(dirty, _this.models, reason).then(function (result) {
                            if (result.didBackup) {
                                return _this.noVeto({ cleanUpBackups: false }); // no veto and no backup cleanup (since backup was successful)
                            }
                            // since a backup did not happen, we have to confirm for the dirty files now
                            return _this.confirmBeforeShutdown();
                        }, function (errors) {
                            var firstError = errors[0];
                            _this.messageService.show(message_1.Severity.Error, nls.localize('files.backup.failSave', "Files could not be backed up (Error: {0}), try saving your files to exit.", firstError.message));
                            return true; // veto, the backups failed
                        });
                    }
                    // Otherwise just confirm from the user what to do with the dirty files
                    return _this.confirmBeforeShutdown();
                }
                return undefined;
            });
        }
        // No dirty files: no veto
        return this.noVeto({ cleanUpBackups: true });
    };
    TextFileService.prototype.backupBeforeShutdown = function (dirtyToBackup, textFileEditorModelManager, reason) {
        var _this = this;
        return this.windowsService.getWindowCount().then(function (windowCount) {
            // When quit is requested skip the confirm callback and attempt to backup all workspaces.
            // When quit is not requested the confirm callback should be shown when the window being
            // closed is the only VS Code window open, except for on Mac where hot exit is only
            // ever activated when quit is requested.
            var doBackup;
            switch (reason) {
                case lifecycle_1.ShutdownReason.CLOSE:
                    if (_this.contextService.hasWorkspace() && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
                        doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured
                    }
                    else if (windowCount > 1 || platform.isMacintosh) {
                        doBackup = false; // do not backup if a window is closed that does not cause quitting of the application
                    }
                    else {
                        doBackup = true; // backup if last window is closed on win/linux where the application quits right after
                    }
                    break;
                case lifecycle_1.ShutdownReason.QUIT:
                    doBackup = true; // backup because next start we restore all backups
                    break;
                case lifecycle_1.ShutdownReason.RELOAD:
                    doBackup = true; // backup because after window reload, backups restore
                    break;
                case lifecycle_1.ShutdownReason.LOAD:
                    if (_this.contextService.hasWorkspace() && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
                        doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured
                    }
                    else {
                        doBackup = false; // do not backup because we are switching contexts
                    }
                    break;
            }
            if (!doBackup) {
                return winjs_base_1.TPromise.as({ didBackup: false });
            }
            // Telemetry
            _this.telemetryService.publicLog('hotExit:triggered', { reason: reason, windowCount: windowCount, fileCount: dirtyToBackup.length });
            // Backup
            return _this.backupAll(dirtyToBackup, textFileEditorModelManager).then(function () { return { didBackup: true }; });
        });
    };
    TextFileService.prototype.backupAll = function (dirtyToBackup, textFileEditorModelManager) {
        // split up between files and untitled
        var filesToBackup = [];
        var untitledToBackup = [];
        dirtyToBackup.forEach(function (s) {
            if (s.scheme === 'file') {
                filesToBackup.push(textFileEditorModelManager.get(s));
            }
            else if (s.scheme === 'untitled') {
                untitledToBackup.push(s);
            }
        });
        return this.doBackupAll(filesToBackup, untitledToBackup);
    };
    TextFileService.prototype.doBackupAll = function (dirtyFileModels, untitledResources) {
        var _this = this;
        // Handle file resources first
        return winjs_base_1.TPromise.join(dirtyFileModels.map(function (model) { return _this.backupFileService.backupResource(model.getResource(), model.getValue(), model.getVersionId()); })).then(function (results) {
            // Handle untitled resources
            var untitledModelPromises = untitledResources.map(function (untitledResource) { return _this.untitledEditorService.get(untitledResource); })
                .filter(function (untitled) { return !!untitled; })
                .map(function (untitled) { return untitled.resolve(); });
            return winjs_base_1.TPromise.join(untitledModelPromises).then(function (untitledModels) {
                var untitledBackupPromises = untitledModels.map(function (model) {
                    return _this.backupFileService.backupResource(model.getResource(), model.getValue(), model.getVersionId());
                });
                return winjs_base_1.TPromise.join(untitledBackupPromises).then(function () { return void 0; });
            });
        });
    };
    TextFileService.prototype.confirmBeforeShutdown = function () {
        var _this = this;
        var confirm = this.confirmSave();
        // Save
        if (confirm === editor_1.ConfirmResult.SAVE) {
            return this.saveAll(true /* includeUntitled */).then(function (result) {
                if (result.results.some(function (r) { return !r.success; })) {
                    return true; // veto if some saves failed
                }
                return _this.noVeto({ cleanUpBackups: true });
            });
        }
        else if (confirm === editor_1.ConfirmResult.DONT_SAVE) {
            return this.noVeto({ cleanUpBackups: true });
        }
        else if (confirm === editor_1.ConfirmResult.CANCEL) {
            return true; // veto
        }
        return undefined;
    };
    TextFileService.prototype.noVeto = function (options) {
        if (!options.cleanUpBackups) {
            return false;
        }
        return this.cleanupBackupsBeforeShutdown().then(function () { return false; }, function () { return false; });
    };
    TextFileService.prototype.cleanupBackupsBeforeShutdown = function () {
        if (this.environmentService.isExtensionDevelopment) {
            return winjs_base_1.TPromise.as(void 0);
        }
        return this.backupFileService.discardAllWorkspaceBackups();
    };
    TextFileService.prototype.onConfigurationChange = function (configuration) {
        var wasAutoSaveEnabled = (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF);
        var autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || files_1.AutoSaveConfiguration.OFF;
        switch (autoSaveMode) {
            case files_1.AutoSaveConfiguration.AFTER_DELAY:
                this.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = true;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = true;
                break;
            default:
                this.configuredAutoSaveDelay = void 0;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
        }
        // Emit as event
        this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
        // save all dirty when enabling auto save
        if (!wasAutoSaveEnabled && this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {
            this.saveAll().done(null, errors.onUnexpectedError);
        }
        // Check for change in files associations
        var filesAssociation = configuration && configuration.files && configuration.files.associations;
        if (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {
            this.currentFilesAssociationConfig = filesAssociation;
            this._onFilesAssociationChange.fire();
        }
        // Hot exit
        var hotExitMode = configuration && configuration.files ? configuration.files.hotExit : files_1.HotExitConfiguration.OFF;
        // Handle the legacy case where hot exit was a boolean
        if (hotExitMode === false) {
            this.configuredHotExit = files_1.HotExitConfiguration.OFF;
        }
        else if (hotExitMode === true) {
            this.configuredHotExit = files_1.HotExitConfiguration.ON_EXIT;
        }
        else {
            this.configuredHotExit = hotExitMode;
        }
    };
    TextFileService.prototype.getDirty = function (resources) {
        var _this = this;
        // Collect files
        var dirty = this.getDirtyFileModels(resources).map(function (m) { return m.getResource(); });
        // Add untitled ones
        if (!resources) {
            dirty.push.apply(dirty, this.untitledEditorService.getDirty());
        }
        else {
            var dirtyUntitled = resources.map(function (r) { return _this.untitledEditorService.get(r); }).filter(function (u) { return u && u.isDirty(); }).map(function (u) { return u.getResource(); });
            dirty.push.apply(dirty, dirtyUntitled);
        }
        return dirty;
    };
    TextFileService.prototype.isDirty = function (resource) {
        // Check for dirty file
        if (this._models.getAll(resource).some(function (model) { return model.isDirty(); })) {
            return true;
        }
        // Check for dirty untitled
        return this.untitledEditorService.getDirty().some(function (dirty) { return !resource || dirty.toString() === resource.toString(); });
    };
    TextFileService.prototype.save = function (resource, options) {
        // Run a forced save if we detect the file is not dirty so that save participants can still run
        if (options && options.force && resource.scheme === 'file' && !this.isDirty(resource)) {
            var model_1 = this._models.get(resource);
            if (model_1) {
                model_1.save({ force: true, reason: textfiles_1.SaveReason.EXPLICIT }).then(function () { return !model_1.isDirty(); });
            }
        }
        return this.saveAll([resource]).then(function (result) { return result.results.length === 1 && result.results[0].success; });
    };
    TextFileService.prototype.saveAll = function (arg1, reason) {
        // get all dirty
        var toSave = [];
        if (Array.isArray(arg1)) {
            toSave = this.getDirty(arg1);
        }
        else {
            toSave = this.getDirty();
        }
        // split up between files and untitled
        var filesToSave = [];
        var untitledToSave = [];
        toSave.forEach(function (s) {
            if (s.scheme === 'file') {
                filesToSave.push(s);
            }
            else if ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === 'untitled') {
                untitledToSave.push(s);
            }
        });
        return this.doSaveAll(filesToSave, untitledToSave, reason);
    };
    TextFileService.prototype.doSaveAll = function (fileResources, untitledResources, reason) {
        var _this = this;
        // Handle files first that can just be saved
        return this.doSaveAllFiles(fileResources, reason).then(function (result) {
            // Preflight for untitled to handle cancellation from the dialog
            var targetsForUntitled = [];
            for (var i = 0; i < untitledResources.length; i++) {
                var untitled = _this.untitledEditorService.get(untitledResources[i]);
                if (untitled) {
                    var targetPath = void 0;
                    // Untitled with associated file path don't need to prompt
                    if (_this.untitledEditorService.hasAssociatedFilePath(untitled.getResource())) {
                        targetPath = untitled.getResource().fsPath;
                    }
                    else {
                        targetPath = _this.promptForPath(_this.suggestFileName(untitledResources[i]));
                        if (!targetPath) {
                            return winjs_base_1.TPromise.as({
                                results: fileResources.concat(untitledResources).map(function (r) {
                                    return {
                                        source: r
                                    };
                                })
                            });
                        }
                    }
                    targetsForUntitled.push(uri_1.default.file(targetPath));
                }
            }
            // Handle untitled
            var untitledSaveAsPromises = [];
            targetsForUntitled.forEach(function (target, index) {
                var untitledSaveAsPromise = _this.saveAs(untitledResources[index], target).then(function (uri) {
                    result.results.push({
                        source: untitledResources[index],
                        target: uri,
                        success: !!uri
                    });
                });
                untitledSaveAsPromises.push(untitledSaveAsPromise);
            });
            return winjs_base_1.TPromise.join(untitledSaveAsPromises).then(function () {
                return result;
            });
        });
    };
    TextFileService.prototype.doSaveAllFiles = function (arg1 /* URI[] */, reason) {
        var dirtyFileModels = this.getDirtyFileModels(Array.isArray(arg1) ? arg1 : void 0 /* Save All */)
            .filter(function (model) {
            if ((model.getState() === textfiles_1.ModelState.CONFLICT || model.getState() === textfiles_1.ModelState.ORPHAN) && (reason === textfiles_1.SaveReason.AUTO || reason === textfiles_1.SaveReason.FOCUS_CHANGE || reason === textfiles_1.SaveReason.WINDOW_CHANGE)) {
                return false; // if model is in an orphan or in save conflict, do not save unless save reason is explicit or not provided at all
            }
            return true;
        });
        var mapResourceToResult = Object.create(null);
        dirtyFileModels.forEach(function (m) {
            mapResourceToResult[m.getResource().toString()] = {
                source: m.getResource()
            };
        });
        return winjs_base_1.TPromise.join(dirtyFileModels.map(function (model) {
            return model.save({ reason: reason }).then(function () {
                if (!model.isDirty()) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
            });
        })).then(function (r) {
            return {
                results: Object.keys(mapResourceToResult).map(function (k) { return mapResourceToResult[k]; })
            };
        });
    };
    TextFileService.prototype.getFileModels = function (arg1) {
        var _this = this;
        if (Array.isArray(arg1)) {
            var models_1 = [];
            arg1.forEach(function (resource) {
                models_1.push.apply(models_1, _this.getFileModels(resource));
            });
            return models_1;
        }
        return this._models.getAll(arg1);
    };
    TextFileService.prototype.getDirtyFileModels = function (arg1) {
        return this.getFileModels(arg1).filter(function (model) { return model.isDirty(); });
    };
    TextFileService.prototype.saveAs = function (resource, target) {
        // Get to target resource
        if (!target) {
            var dialogPath = resource.fsPath;
            if (resource.scheme === 'untitled') {
                dialogPath = this.suggestFileName(resource);
            }
            var pathRaw = this.promptForPath(dialogPath);
            if (pathRaw) {
                target = uri_1.default.file(pathRaw);
            }
        }
        if (!target) {
            return winjs_base_1.TPromise.as(null); // user canceled
        }
        // Just save if target is same as models own resource
        if (resource.toString() === target.toString()) {
            return this.save(resource).then(function () { return resource; });
        }
        // Do it
        return this.doSaveAs(resource, target);
    };
    TextFileService.prototype.doSaveAs = function (resource, target) {
        var _this = this;
        // Retrieve text model from provided resource if any
        var modelPromise = winjs_base_1.TPromise.as(null);
        if (resource.scheme === 'file') {
            modelPromise = winjs_base_1.TPromise.as(this._models.get(resource));
        }
        else if (resource.scheme === 'untitled') {
            var untitled = this.untitledEditorService.get(resource);
            if (untitled) {
                modelPromise = untitled.resolve();
            }
        }
        return modelPromise.then(function (model) {
            // We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)
            if (model) {
                return _this.doSaveTextFileAs(model, resource, target);
            }
            // Otherwise we can only copy
            return _this.fileService.copyFile(resource, target);
        }).then(function () {
            // Revert the source
            return _this.revert(resource).then(function () {
                // Done: return target
                return target;
            });
        });
    };
    TextFileService.prototype.doSaveTextFileAs = function (sourceModel, resource, target) {
        var _this = this;
        // create the target file empty if it does not exist already
        return this.fileService.resolveFile(target).then(function (stat) { return stat; }, function () { return null; }).then(function (stat) { return stat || _this.fileService.updateContent(target, ''); }).then(function (stat) {
            // resolve a model for the file (which can be binary if the file is not a text file)
            return _this.models.loadOrCreate(target).then(function (targetModel) {
                // take over encoding and model value from source model
                targetModel.updatePreferredEncoding(sourceModel.getEncoding());
                targetModel.textEditorModel.setValue(sourceModel.getValue());
                // save model
                return targetModel.save();
            }, function (error) {
                // binary model: delete the file and run the operation again
                if (error.fileOperationResult === files_1.FileOperationResult.FILE_IS_BINARY || error.fileOperationResult === files_1.FileOperationResult.FILE_TOO_LARGE) {
                    return _this.fileService.del(target).then(function () { return _this.doSaveTextFileAs(sourceModel, resource, target); });
                }
                return winjs_base_1.TPromise.wrapError(error);
            });
        });
    };
    TextFileService.prototype.suggestFileName = function (untitledResource) {
        var workspace = this.contextService.getWorkspace();
        if (workspace) {
            return uri_1.default.file(paths.join(workspace.resource.fsPath, this.untitledEditorService.get(untitledResource).suggestFileName())).fsPath;
        }
        return this.untitledEditorService.get(untitledResource).suggestFileName();
    };
    TextFileService.prototype.revert = function (resource, options) {
        return this.revertAll([resource], options).then(function (result) { return result.results.length === 1 && result.results[0].success; });
    };
    TextFileService.prototype.revertAll = function (resources, options) {
        var _this = this;
        // Revert files first
        return this.doRevertAllFiles(resources, options).then(function (operation) {
            // Revert untitled
            var reverted = _this.untitledEditorService.revertAll(resources);
            reverted.forEach(function (res) { return operation.results.push({ source: res, success: true }); });
            return operation;
        });
    };
    TextFileService.prototype.doRevertAllFiles = function (resources, options) {
        var fileModels = options && options.force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);
        var mapResourceToResult = Object.create(null);
        fileModels.forEach(function (m) {
            mapResourceToResult[m.getResource().toString()] = {
                source: m.getResource()
            };
        });
        return winjs_base_1.TPromise.join(fileModels.map(function (model) {
            return model.revert(options && options.soft).then(function () {
                if (!model.isDirty()) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
            }, function (error) {
                // FileNotFound means the file got deleted meanwhile, so still record as successful revert
                if (error.fileOperationResult === files_1.FileOperationResult.FILE_NOT_FOUND) {
                    mapResourceToResult[model.getResource().toString()].success = true;
                }
                else {
                    return winjs_base_1.TPromise.wrapError(error);
                }
                return undefined;
            });
        })).then(function (r) {
            return {
                results: Object.keys(mapResourceToResult).map(function (k) { return mapResourceToResult[k]; })
            };
        });
    };
    TextFileService.prototype.delete = function (resource) {
        return this.fileService.del(resource, false);
    };
    TextFileService.prototype.getAutoSaveMode = function () {
        if (this.configuredAutoSaveOnFocusChange) {
            return textfiles_1.AutoSaveMode.ON_FOCUS_CHANGE;
        }
        if (this.configuredAutoSaveOnWindowChange) {
            return textfiles_1.AutoSaveMode.ON_WINDOW_CHANGE;
        }
        if (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {
            return this.configuredAutoSaveDelay <= 1000 ? textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY : textfiles_1.AutoSaveMode.AFTER_LONG_DELAY;
        }
        return textfiles_1.AutoSaveMode.OFF;
    };
    TextFileService.prototype.getAutoSaveConfiguration = function () {
        return {
            autoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : void 0,
            autoSaveFocusChange: this.configuredAutoSaveOnFocusChange,
            autoSaveApplicationChange: this.configuredAutoSaveOnWindowChange
        };
    };
    Object.defineProperty(TextFileService.prototype, "isHotExitEnabled", {
        get: function () {
            return !this.environmentService.isExtensionDevelopment && this.configuredHotExit !== files_1.HotExitConfiguration.OFF;
        },
        enumerable: true,
        configurable: true
    });
    TextFileService.prototype.dispose = function () {
        this.toUnbind = lifecycle_2.dispose(this.toUnbind);
        // Clear all caches
        this._models.clear();
    };
    return TextFileService;
}());
TextFileService = __decorate([
    __param(0, lifecycle_1.ILifecycleService),
    __param(1, workspace_1.IWorkspaceContextService),
    __param(2, configuration_1.IConfigurationService),
    __param(3, telemetry_1.ITelemetryService),
    __param(4, files_1.IFileService),
    __param(5, untitledEditorService_1.IUntitledEditorService),
    __param(6, instantiation_1.IInstantiationService),
    __param(7, message_1.IMessageService),
    __param(8, environment_1.IEnvironmentService),
    __param(9, backup_1.IBackupFileService),
    __param(10, groupService_1.IEditorGroupService),
    __param(11, windows_1.IWindowsService)
], TextFileService);
exports.TextFileService = TextFileService;
