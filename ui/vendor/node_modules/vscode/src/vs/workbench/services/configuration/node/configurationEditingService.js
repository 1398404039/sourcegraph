/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var uri_1 = require("vs/base/common/uri");
var json = require("vs/base/common/json");
var encoding = require("vs/base/node/encoding");
var strings = require("vs/base/common/strings");
var jsonEdit_1 = require("vs/base/common/jsonEdit");
var async_1 = require("vs/base/common/async");
var editOperation_1 = require("vs/editor/common/core/editOperation");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var environment_1 = require("vs/platform/environment/common/environment");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var model_1 = require("vs/platform/configuration/common/model");
var configuration_2 = require("vs/workbench/services/configuration/common/configuration");
var files_1 = require("vs/platform/files/common/files");
var configurationEditing_1 = require("vs/workbench/services/configuration/common/configurationEditing");
var resolverService_1 = require("vs/editor/common/services/resolverService");
var configurationRegistry_1 = require("vs/platform/configuration/common/configurationRegistry");
var ConfigurationEditingService = (function () {
    function ConfigurationEditingService(configurationService, contextService, environmentService, fileService, textModelResolverService, textFileService) {
        this.configurationService = configurationService;
        this.contextService = contextService;
        this.environmentService = environmentService;
        this.fileService = fileService;
        this.textModelResolverService = textModelResolverService;
        this.textFileService = textFileService;
        this.queue = new async_1.Queue();
    }
    ConfigurationEditingService.prototype.writeConfiguration = function (target, value, save) {
        var _this = this;
        if (save === void 0) { save = true; }
        return this.queue.queue(function () { return _this.doWriteConfiguration(target, value, save); }); // queue up writes to prevent race conditions
    };
    ConfigurationEditingService.prototype.doWriteConfiguration = function (target, value, save) {
        var _this = this;
        var operation = this.getConfigurationEditOperation(target, value);
        return this.resolveAndValidate(target, operation, save)
            .then(function (reference) { return _this.writeToBuffer(reference.object.textEditorModel, operation, save)
            .then(function () { return reference.dispose(); }); });
    };
    ConfigurationEditingService.prototype.writeToBuffer = function (model, operation, save) {
        var edit = this.getEdits(model, operation)[0];
        if (this.applyEditsToBuffer(edit, model) && save) {
            return this.textFileService.save(operation.resource);
        }
        return winjs_base_1.TPromise.as(null);
    };
    ConfigurationEditingService.prototype.applyEditsToBuffer = function (edit, model) {
        var startPosition = model.getPositionAt(edit.offset);
        var endPosition = model.getPositionAt(edit.offset + edit.length);
        var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        var currentText = model.getValueInRange(range);
        if (edit.content !== currentText) {
            var editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
            model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], function () { return []; });
            return true;
        }
        return false;
    };
    ConfigurationEditingService.prototype.wrapError = function (code, target) {
        var message = this.toErrorMessage(code, target);
        return winjs_base_1.TPromise.wrapError({
            code: code,
            message: message,
            toString: function () { return message; }
        });
    };
    ConfigurationEditingService.prototype.toErrorMessage = function (error, target) {
        switch (error) {
            // API constraints
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY: return nls.localize('errorUnknownKey', "Unable to write to the configuration file (Unknown Key)");
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_TARGET: return nls.localize('errorInvalidTarget', "Unable to write to the configuration file (Invalid Target)");
            // User issues
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED: return nls.localize('errorNoWorkspaceOpened', "Unable to write settings because no folder is opened. Please open a folder first and try again.");
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION:
                {
                    if (target === configurationEditing_1.ConfigurationTarget.USER) {
                        return nls.localize('errorInvalidConfiguration', "Unable to write settings. Please open **User Settings** to correct errors/warnings in the file and try again.");
                    }
                    return nls.localize('errorInvalidConfigurationWorkspace', "Unable to write settings. Please open **Workspace Settings** to correct errors/warnings in the file and try again.");
                }
                ;
            case configurationEditing_1.ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY:
                {
                    if (target === configurationEditing_1.ConfigurationTarget.USER) {
                        return nls.localize('errorConfigurationFileDirty', "Unable to write settings because the file is dirty. Please save the **User Settings** file and try again.");
                    }
                    return nls.localize('errorConfigurationFileDirtyWorkspace', "Unable to write settings because the file is dirty. Please save the **Workspace Settings** file and try again.");
                }
                ;
        }
    };
    ConfigurationEditingService.prototype.getEdits = function (model, edit) {
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        var eol = model.getEOL();
        var key = edit.key, value = edit.value, overrideIdentifier = edit.overrideIdentifier;
        // Without key, the entire settings file is being replaced, so we just use JSON.stringify
        if (!key) {
            var content = JSON.stringify(value, null, insertSpaces ? strings.repeat(' ', tabSize) : '\t');
            return [{
                    content: content,
                    length: content.length,
                    offset: 0
                }];
        }
        return jsonEdit_1.setProperty(model.getValue(), overrideIdentifier ? [model_1.keyFromOverrideIdentifier(overrideIdentifier), key] : [key], value, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol });
    };
    ConfigurationEditingService.prototype.resolveModelReference = function (resource) {
        var _this = this;
        return this.fileService.existsFile(resource)
            .then(function (exists) {
            var result = exists ? winjs_base_1.TPromise.as(null) : _this.fileService.updateContent(resource, '{}', { encoding: encoding.UTF8 });
            return result.then(function () { return _this.textModelResolverService.createModelReference(resource); });
        });
    };
    ConfigurationEditingService.prototype.hasParseErrors = function (model, operation) {
        // If we write to a workspace standalone file and replace the entire contents (no key provided)
        // we can return here because any parse errors can safely be ignored since all contents are replaced
        if (operation.isWorkspaceStandalone && !operation.key) {
            return false;
        }
        var parseErrors = [];
        json.parse(model.getValue(), parseErrors, { allowTrailingComma: true });
        return parseErrors.length > 0;
    };
    ConfigurationEditingService.prototype.resolveAndValidate = function (target, operation, save) {
        var _this = this;
        // Any key must be a known setting from the registry (unless this is a standalone config)
        if (!operation.isWorkspaceStandalone) {
            var validKeys = this.configurationService.keys().default;
            if (validKeys.indexOf(operation.key) < 0 && !configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(operation.key)) {
                return this.wrapError(configurationEditing_1.ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY, target);
            }
        }
        // Target cannot be user if is standalone
        if (operation.isWorkspaceStandalone && target === configurationEditing_1.ConfigurationTarget.USER) {
            return this.wrapError(configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_TARGET, target);
        }
        // Target cannot be workspace if no workspace opened
        if (target === configurationEditing_1.ConfigurationTarget.WORKSPACE && !this.contextService.hasWorkspace()) {
            return this.wrapError(configurationEditing_1.ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED, target);
        }
        // Target cannot be dirty if not writing into buffer
        var resource = operation.resource;
        if (save && this.textFileService.isDirty(resource)) {
            return this.wrapError(configurationEditing_1.ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY, target);
        }
        return this.resolveModelReference(operation.resource)
            .then(function (reference) {
            var model = reference.object.textEditorModel;
            if (_this.hasParseErrors(model, operation)) {
                return _this.wrapError(configurationEditing_1.ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION, target);
            }
            return reference;
        });
    };
    ConfigurationEditingService.prototype.getConfigurationEditOperation = function (target, config) {
        // Check for standalone workspace configurations
        if (config.key) {
            var standaloneConfigurationKeys = Object.keys(configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS);
            for (var i = 0; i < standaloneConfigurationKeys.length; i++) {
                var key = standaloneConfigurationKeys[i];
                var resource = this.contextService.toResource(configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS[key]);
                // Check for prefix
                if (config.key === key) {
                    return { key: '', value: config.value, resource: resource, isWorkspaceStandalone: true };
                }
                // Check for prefix.<setting>
                var keyPrefix = key + ".";
                if (config.key.indexOf(keyPrefix) === 0) {
                    return { key: config.key.substr(keyPrefix.length), value: config.value, resource: resource, isWorkspaceStandalone: true };
                }
            }
        }
        if (target === configurationEditing_1.ConfigurationTarget.USER) {
            return { key: config.key, value: config.value, overrideIdentifier: config.overrideIdentifier, resource: uri_1.default.file(this.environmentService.appSettingsPath) };
        }
        return { key: config.key, value: config.value, overrideIdentifier: config.overrideIdentifier, resource: this.contextService.toResource(configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH) };
    };
    return ConfigurationEditingService;
}());
ConfigurationEditingService = __decorate([
    __param(0, configuration_1.IConfigurationService),
    __param(1, workspace_1.IWorkspaceContextService),
    __param(2, environment_1.IEnvironmentService),
    __param(3, files_1.IFileService),
    __param(4, resolverService_1.ITextModelResolverService),
    __param(5, textfiles_1.ITextFileService)
], ConfigurationEditingService);
exports.ConfigurationEditingService = ConfigurationEditingService;
