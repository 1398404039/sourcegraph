/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var nls = require("vs/nls");
var Paths = require("vs/base/common/paths");
var Json = require("vs/base/common/json");
var types = require("vs/base/common/types");
var extensions_1 = require("vs/platform/extensions/common/extensions");
var extensionsRegistry_1 = require("vs/platform/extensions/common/extensionsRegistry");
var themeService_1 = require("vs/workbench/services/themes/common/themeService");
var windowService_1 = require("vs/workbench/services/window/electron-browser/windowService");
var storage_1 = require("vs/platform/storage/common/storage");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var platform_1 = require("vs/platform/platform");
var errors = require("vs/base/common/errors");
var configurationEditing_1 = require("vs/workbench/services/configuration/common/configurationEditing");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var configurationRegistry_1 = require("vs/platform/configuration/common/configurationRegistry");
var files_1 = require("vs/platform/files/common/files");
var environment_1 = require("vs/platform/environment/common/environment");
var message_1 = require("vs/platform/message/common/message");
var severity_1 = require("vs/base/common/severity");
var uri_1 = require("vs/base/common/uri");
var colorThemeData_1 = require("./colorThemeData");
var stylesContributions_1 = require("vs/workbench/services/themes/electron-browser/stylesContributions");
var builder_1 = require("vs/base/browser/builder");
var event_1 = require("vs/base/common/event");
var pfs = require("vs/base/node/pfs");
var colorThemeSchema = require("vs/workbench/services/themes/common/colorThemeSchema");
var fileIconThemeSchema = require("vs/workbench/services/themes/common/fileIconThemeSchema");
// implementation
var DEFAULT_THEME_ID = 'vs-dark vscode-theme-defaults-themes-dark_plus-json';
var DEFAULT_THEME_SETTING_VALUE = 'Default Dark+';
var defaultBaseTheme = 'vs-dark';
var defaultThemeExtensionId = 'vscode-theme-defaults';
var oldDefaultThemeExtensionId = 'vscode-theme-colorful-defaults';
var fileIconsEnabledClass = 'file-icons-enabled';
function validateThemeId(theme) {
    // migrations
    switch (theme) {
        case themeService_1.VS_LIGHT_THEME: return "vs " + defaultThemeExtensionId + "-themes-light_vs-json";
        case themeService_1.VS_DARK_THEME: return "vs-dark " + defaultThemeExtensionId + "-themes-dark_vs-json";
        case themeService_1.VS_HC_THEME: return "hc-black " + defaultThemeExtensionId + "-themes-hc_black-json";
        case "vs " + oldDefaultThemeExtensionId + "-themes-light_plus-tmTheme": return "vs " + defaultThemeExtensionId + "-themes-light_plus-json";
        case "vs-dark " + oldDefaultThemeExtensionId + "-themes-dark_plus-tmTheme": return "vs-dark " + defaultThemeExtensionId + "-themes-dark_plus-json";
    }
    return theme;
}
var themesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('themes', [], {
    description: nls.localize('vscode.extension.contributes.themes', 'Contributes textmate color themes.'),
    type: 'array',
    items: {
        type: 'object',
        defaultSnippets: [{ body: { label: '${1:label}', id: '${2:id}', uiTheme: themeService_1.VS_DARK_THEME, path: './themes/${3:id}.tmTheme.' } }],
        properties: {
            id: {
                description: nls.localize('vscode.extension.contributes.themes.id', 'Id of the icon theme as used in the user settings.'),
                type: 'string'
            },
            label: {
                description: nls.localize('vscode.extension.contributes.themes.label', 'Label of the color theme as shown in the UI.'),
                type: 'string'
            },
            uiTheme: {
                description: nls.localize('vscode.extension.contributes.themes.uiTheme', 'Base theme defining the colors around the editor: \'vs\' is the light color theme, \'vs-dark\' is the dark color theme. \'hc-black\' is the dark high contrast theme.'),
                enum: [themeService_1.VS_LIGHT_THEME, themeService_1.VS_DARK_THEME, themeService_1.VS_HC_THEME]
            },
            path: {
                description: nls.localize('vscode.extension.contributes.themes.path', 'Path of the tmTheme file. The path is relative to the extension folder and is typically \'./themes/themeFile.tmTheme\'.'),
                type: 'string'
            }
        },
        required: ['path', 'uiTheme']
    }
});
var iconThemeExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('iconThemes', [], {
    description: nls.localize('vscode.extension.contributes.iconThemes', 'Contributes file icon themes.'),
    type: 'array',
    items: {
        type: 'object',
        defaultSnippets: [{ body: { id: '${1:id}', label: '${2:label}', path: './fileicons/${3:id}-icon-theme.json' } }],
        properties: {
            id: {
                description: nls.localize('vscode.extension.contributes.iconThemes.id', 'Id of the icon theme as used in the user settings.'),
                type: 'string'
            },
            label: {
                description: nls.localize('vscode.extension.contributes.iconThemes.label', 'Label of the icon theme as shown in the UI.'),
                type: 'string'
            },
            path: {
                description: nls.localize('vscode.extension.contributes.iconThemes.path', 'Path of the icon theme definition file. The path is relative to the extension folder and is typically \'./icons/awesome-icon-theme.json\'.'),
                type: 'string'
            }
        },
        required: ['path', 'id']
    }
});
var noFileIconTheme = {
    id: '',
    label: '',
    settingsId: null,
    hasFileIcons: false,
    hasFolderIcons: false,
    isLoaded: true,
    extensionData: null
};
var WorkbenchThemeService = (function () {
    function WorkbenchThemeService(container, extensionService, storageService, windowService, configurationService, configurationEditingService, environmentService, fileService, messageService, telemetryService) {
        var _this = this;
        this.extensionService = extensionService;
        this.storageService = storageService;
        this.windowService = windowService;
        this.configurationService = configurationService;
        this.configurationEditingService = configurationEditingService;
        this.environmentService = environmentService;
        this.fileService = fileService;
        this.messageService = messageService;
        this.telemetryService = telemetryService;
        this.themeExtensionsActivated = {};
        this.container = container;
        this.knownColorThemes = [];
        this.themingParticipants = [];
        // In order to avoid paint flashing for tokens, because
        // themes are loaded asynchronously, we need to initialize
        // a color theme document with good defaults until the theme is loaded
        var isLightTheme = (Array.prototype.indexOf.call(document.body.classList, 'vs') >= 0);
        var foreground = isLightTheme ? '#000000' : '#D4D4D4';
        var background = isLightTheme ? '#ffffff' : '#1E1E1E';
        var initialTheme = new colorThemeData_1.ColorThemeData();
        initialTheme.id = isLightTheme ? themeService_1.VS_LIGHT_THEME : themeService_1.VS_DARK_THEME;
        initialTheme.label = '';
        initialTheme.selector = isLightTheme ? themeService_1.VS_LIGHT_THEME : themeService_1.VS_DARK_THEME;
        initialTheme.settingsId = null;
        initialTheme.isLoaded = false;
        initialTheme.tokenColors = [{
                settings: {
                    foreground: foreground,
                    background: background
                }
            }];
        this.currentColorTheme = initialTheme;
        this.onColorThemeChange = new event_1.Emitter();
        this.knownIconThemes = [];
        this.currentIconTheme = {
            id: '',
            label: '',
            settingsId: null,
            isLoaded: false,
            hasFileIcons: false,
            hasFolderIcons: false,
            extensionData: null
        };
        this.onFileIconThemeChange = new event_1.Emitter();
        themesExtPoint.setHandler(function (extensions) {
            for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
                var ext = extensions_2[_i];
                var extensionData = {
                    extensionId: ext.description.id,
                    extensionPublisher: ext.description.publisher,
                    extensionName: ext.description.name,
                    extensionIsBuiltin: ext.description.isBuiltin
                };
                _this.onThemes(ext.description.extensionFolderPath, extensionData, ext.value, ext.collector);
            }
        });
        iconThemeExtPoint.setHandler(function (extensions) {
            for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
                var ext = extensions_3[_i];
                var extensionData = {
                    extensionId: ext.description.id,
                    extensionPublisher: ext.description.publisher,
                    extensionName: ext.description.name,
                    extensionIsBuiltin: ext.description.isBuiltin
                };
                _this.onIconThemes(ext.description.extensionFolderPath, extensionData, ext.value, ext.collector);
            }
        });
        this.migrate().then(function (_) {
            _this.initialize().then(null, errors.onUnexpectedError).then(function (_) {
                _this.installConfigurationListener();
            });
        });
    }
    Object.defineProperty(WorkbenchThemeService.prototype, "onDidColorThemeChange", {
        get: function () {
            return this.onColorThemeChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkbenchThemeService.prototype, "onDidThemeChange", {
        get: function () {
            return this.onColorThemeChange.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkbenchThemeService.prototype, "onDidFileIconThemeChange", {
        get: function () {
            return this.onFileIconThemeChange.event;
        },
        enumerable: true,
        configurable: true
    });
    WorkbenchThemeService.prototype.registerThemingParticipant = function (participant) {
        var _this = this;
        this.themingParticipants.push(participant);
        return {
            dispose: function () {
                var idx = _this.themingParticipants.indexOf(participant);
                _this.themingParticipants.splice(idx, 1);
            }
        };
    };
    WorkbenchThemeService.prototype.getThemingParticipants = function () {
        return this.themingParticipants;
    };
    WorkbenchThemeService.prototype.backupSettings = function () {
        var resource = uri_1.default.file(this.environmentService.appSettingsPath);
        var backupFileLocation = uri_1.default.file(resource.fsPath + '-' + new Date().getTime() + '.backup');
        return this.fileService.copyFile(resource, backupFileLocation, true).then(function (_) { return backupFileLocation.fsPath; }, function (err) {
            if (err && err.code === 'ENOENT') {
                return winjs_base_1.TPromise.as(null); // ignore, user config file doesn't exist yet
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    };
    WorkbenchThemeService.prototype.migrate = function () {
        var _this = this;
        var legacyColorThemeId = this.storageService.get('workbench.theme', storage_1.StorageScope.GLOBAL, void 0);
        var legacyIconThemeId = this.storageService.get('workbench.iconTheme', storage_1.StorageScope.GLOBAL, void 0);
        if (types.isUndefined(legacyColorThemeId) && types.isUndefined(legacyIconThemeId)) {
            return winjs_base_1.TPromise.as(null);
        }
        return this.backupSettings().then(function (backupLocation) {
            var promise = winjs_base_1.TPromise.as(null);
            if (!types.isUndefined(legacyColorThemeId)) {
                _this.storageService.remove('workbench.theme', storage_1.StorageScope.GLOBAL);
                promise = _this.findThemeData(legacyColorThemeId, DEFAULT_THEME_ID).then(function (theme) {
                    var value = theme ? theme.settingsId : DEFAULT_THEME_SETTING_VALUE;
                    return _this.writeConfiguration(themeService_1.COLOR_THEME_SETTING, value, configurationEditing_1.ConfigurationTarget.USER).then(null, function (error) { return null; });
                });
            }
            if (!types.isUndefined(legacyIconThemeId)) {
                _this.storageService.remove('workbench.iconTheme', storage_1.StorageScope.GLOBAL);
                promise = promise.then(function (_) {
                    return _this._findIconThemeData(legacyIconThemeId).then(function (theme) {
                        var value = theme ? theme.settingsId : null;
                        return _this.writeConfiguration(themeService_1.ICON_THEME_SETTING, value, configurationEditing_1.ConfigurationTarget.USER).then(null, function (error) { return null; });
                    });
                });
            }
            return promise.then(function (_) {
                if (backupLocation) {
                    var message = nls.localize('migration.completed', 'New theme settings have been added to the user settings. Backup available at {0}.', backupLocation);
                    _this.messageService.show(severity_1.default.Info, message);
                    console.log(message);
                }
            });
        });
    };
    WorkbenchThemeService.prototype.initialize = function () {
        var _this = this;
        stylesContributions_1.registerParticipants(this);
        var colorThemeSetting = this.configurationService.lookup(themeService_1.COLOR_THEME_SETTING).value;
        var iconThemeSetting = this.configurationService.lookup(themeService_1.ICON_THEME_SETTING).value || '';
        return winjs_base_1.Promise.join([
            this.findThemeDataBySettingsId(colorThemeSetting, DEFAULT_THEME_ID).then(function (theme) {
                return _this.setColorTheme(theme && theme.id, null);
            }),
            this.findIconThemeBySettingsId(iconThemeSetting).then(function (theme) {
                return _this.setFileIconTheme(theme && theme.id, null);
            }),
        ]);
    };
    WorkbenchThemeService.prototype.installConfigurationListener = function () {
        var _this = this;
        this.configurationService.onDidUpdateConfiguration(function (e) {
            var colorThemeSetting = _this.configurationService.lookup(themeService_1.COLOR_THEME_SETTING).value;
            if (colorThemeSetting !== _this.currentColorTheme.settingsId) {
                _this.findThemeDataBySettingsId(colorThemeSetting, null).then(function (theme) {
                    if (theme) {
                        _this.setColorTheme(theme.id, null);
                    }
                });
            }
            var iconThemeSetting = _this.configurationService.lookup(themeService_1.ICON_THEME_SETTING).value || '';
            if (iconThemeSetting !== _this.currentIconTheme.settingsId) {
                _this.findIconThemeBySettingsId(iconThemeSetting).then(function (theme) {
                    _this.setFileIconTheme(theme && theme.id, null);
                });
            }
        });
    };
    WorkbenchThemeService.prototype.getTheme = function () {
        return this.getColorTheme();
    };
    WorkbenchThemeService.prototype.setColorTheme = function (themeId, settingsTarget) {
        var _this = this;
        if (!themeId) {
            return winjs_base_1.TPromise.as(null);
        }
        if (themeId === this.currentColorTheme.id && this.currentColorTheme.isLoaded) {
            return this.writeColorThemeConfiguration(settingsTarget);
        }
        themeId = validateThemeId(themeId); // migrate theme ids
        var onApply = function (newTheme) {
            var newThemeId = newTheme.id;
            if (_this.container) {
                if (_this.currentColorTheme) {
                    builder_1.$(_this.container).removeClass(_this.currentColorTheme.id);
                }
                builder_1.$(_this.container).addClass(newThemeId);
            }
            _this.currentColorTheme = newTheme;
            _this.sendTelemetry(newTheme.id, newTheme.extensionData, 'color');
            _this.onColorThemeChange.fire(_this.currentColorTheme);
            if (settingsTarget !== configurationEditing_1.ConfigurationTarget.WORKSPACE) {
                _this.windowService.broadcast({ channel: 'vscode:changeColorTheme', payload: newTheme.id });
            }
            return _this.writeColorThemeConfiguration(settingsTarget);
        };
        return this.findThemeData(themeId, DEFAULT_THEME_ID).then(function (themeData) {
            if (themeData) {
                return themeData.ensureLoaded(_this).then(function (_) {
                    _applyRules(themeData.styleSheetContent, colorThemeRulesClassName);
                    return onApply(themeData);
                }, function (error) {
                    return winjs_base_1.TPromise.wrapError(nls.localize('error.cannotloadtheme', "Unable to load {0}: {1}", themeData.path, error.message));
                });
            }
            return null;
        });
    };
    WorkbenchThemeService.prototype.writeColorThemeConfiguration = function (settingsTarget) {
        var _this = this;
        if (!types.isUndefinedOrNull(settingsTarget)) {
            return this.writeConfiguration(themeService_1.COLOR_THEME_SETTING, this.currentColorTheme.settingsId, settingsTarget).then(function (_) { return _this.currentColorTheme; });
        }
        return winjs_base_1.TPromise.as(this.currentColorTheme);
    };
    WorkbenchThemeService.prototype.getColorTheme = function () {
        return this.currentColorTheme;
    };
    WorkbenchThemeService.prototype.findThemeData = function (themeId, defaultId) {
        return this.getColorThemes().then(function (allThemes) {
            var defaultTheme = void 0;
            for (var _i = 0, allThemes_1 = allThemes; _i < allThemes_1.length; _i++) {
                var t = allThemes_1[_i];
                if (t.id === themeId) {
                    return t;
                }
                if (t.id === defaultId) {
                    defaultTheme = t;
                }
            }
            return defaultTheme;
        });
    };
    WorkbenchThemeService.prototype.findThemeDataBySettingsId = function (settingsId, defaultId) {
        return this.getColorThemes().then(function (allThemes) {
            var defaultTheme = void 0;
            for (var _i = 0, allThemes_2 = allThemes; _i < allThemes_2.length; _i++) {
                var t = allThemes_2[_i];
                if (t.settingsId === settingsId) {
                    return t;
                }
                if (t.id === defaultId) {
                    defaultTheme = t;
                }
            }
            return defaultTheme;
        });
    };
    WorkbenchThemeService.prototype.getColorThemes = function () {
        var _this = this;
        return this.extensionService.onReady().then(function (isReady) {
            return _this.knownColorThemes;
        });
    };
    WorkbenchThemeService.prototype.onThemes = function (extensionFolderPath, extensionData, themes, collector) {
        var _this = this;
        if (!Array.isArray(themes)) {
            collector.error(nls.localize('reqarray', "Extension point `{0}` must be an array.", themesExtPoint.name));
            return;
        }
        themes.forEach(function (theme) {
            if (!theme.path || !types.isString(theme.path)) {
                collector.error(nls.localize('reqpath', "Expected string in `contributes.{0}.path`. Provided value: {1}", themesExtPoint.name, String(theme.path)));
                return;
            }
            var normalizedAbsolutePath = Paths.normalize(Paths.join(extensionFolderPath, theme.path));
            if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
                collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", themesExtPoint.name, normalizedAbsolutePath, extensionFolderPath));
            }
            var baseTheme = theme.uiTheme || defaultBaseTheme;
            var themeSelector = toCSSSelector(extensionData.extensionId + '-' + Paths.normalize(theme.path));
            var themeData = new colorThemeData_1.ColorThemeData();
            themeData.id = baseTheme + " " + themeSelector;
            themeData.label = theme.label || Paths.basename(theme.path);
            themeData.settingsId = theme.id || themeData.label;
            themeData.selector = baseTheme + "." + themeSelector;
            themeData.description = theme.description;
            themeData.path = normalizedAbsolutePath;
            themeData.extensionData = extensionData;
            themeData.isLoaded = false;
            _this.knownColorThemes.push(themeData);
            colorThemeSetting.enum.push(themeData.settingsId);
            colorThemeSetting.enumDescriptions.push(themeData.description || '');
        });
    };
    WorkbenchThemeService.prototype.onIconThemes = function (extensionFolderPath, extensionData, iconThemes, collector) {
        var _this = this;
        if (!Array.isArray(iconThemes)) {
            collector.error(nls.localize('reqarray', "Extension point `{0}` must be an array.", themesExtPoint.name));
            return;
        }
        iconThemes.forEach(function (iconTheme) {
            if (!iconTheme.path || !types.isString(iconTheme.path)) {
                collector.error(nls.localize('reqpath', "Expected string in `contributes.{0}.path`. Provided value: {1}", themesExtPoint.name, String(iconTheme.path)));
                return;
            }
            if (!iconTheme.id || !types.isString(iconTheme.id)) {
                collector.error(nls.localize('reqid', "Expected string in `contributes.{0}.id`. Provided value: {1}", themesExtPoint.name, String(iconTheme.path)));
                return;
            }
            var normalizedAbsolutePath = Paths.normalize(Paths.join(extensionFolderPath, iconTheme.path));
            if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
                collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", themesExtPoint.name, normalizedAbsolutePath, extensionFolderPath));
            }
            var themeData = {
                id: extensionData.extensionId + '-' + iconTheme.id,
                label: iconTheme.label || Paths.basename(iconTheme.path),
                settingsId: iconTheme.id,
                description: iconTheme.description,
                path: normalizedAbsolutePath,
                extensionData: extensionData,
                isLoaded: false
            };
            _this.knownIconThemes.push(themeData);
            iconThemeSetting.enum.push(themeData.settingsId);
            iconThemeSetting.enumDescriptions.push(themeData.description || '');
        });
    };
    WorkbenchThemeService.prototype.sendTelemetry = function (themeId, themeData, themeType) {
        var key = themeType + themeData.extensionId;
        if (!this.themeExtensionsActivated[key]) {
            this.telemetryService.publicLog('activatePlugin', {
                id: themeData.extensionId,
                name: themeData.extensionName,
                isBuiltin: themeData.extensionIsBuiltin,
                publisherDisplayName: themeData.extensionPublisher,
                themeId: themeId
            });
            this.themeExtensionsActivated[key] = true;
        }
    };
    WorkbenchThemeService.prototype.getFileIconThemes = function () {
        var _this = this;
        return this.extensionService.onReady().then(function (isReady) {
            return _this.knownIconThemes;
        });
    };
    WorkbenchThemeService.prototype.getFileIconTheme = function () {
        return this.currentIconTheme;
    };
    WorkbenchThemeService.prototype.setFileIconTheme = function (iconTheme, settingsTarget) {
        var _this = this;
        iconTheme = iconTheme || '';
        if (iconTheme === this.currentIconTheme.id && this.currentIconTheme.isLoaded) {
            return this.writeFileIconConfiguration(settingsTarget);
        }
        var onApply = function (newIconTheme) {
            if (newIconTheme) {
                _this.currentIconTheme = newIconTheme;
            }
            else {
                _this.currentIconTheme = noFileIconTheme;
            }
            if (_this.container) {
                if (newIconTheme) {
                    builder_1.$(_this.container).addClass(fileIconsEnabledClass);
                }
                else {
                    builder_1.$(_this.container).removeClass(fileIconsEnabledClass);
                }
            }
            if (newIconTheme) {
                _this.sendTelemetry(newIconTheme.id, newIconTheme.extensionData, 'fileIcon');
            }
            _this.onFileIconThemeChange.fire(_this.currentIconTheme);
            return _this.writeFileIconConfiguration(settingsTarget);
        };
        return this._findIconThemeData(iconTheme).then(function (iconThemeData) {
            return _applyIconTheme(iconThemeData, onApply);
        });
    };
    WorkbenchThemeService.prototype.writeFileIconConfiguration = function (settingsTarget) {
        var _this = this;
        if (!types.isUndefinedOrNull(settingsTarget)) {
            return this.writeConfiguration(themeService_1.ICON_THEME_SETTING, this.currentIconTheme.settingsId, settingsTarget).then(function (_) { return _this.currentIconTheme; });
        }
        return winjs_base_1.TPromise.as(this.currentIconTheme);
    };
    WorkbenchThemeService.prototype.writeConfiguration = function (key, value, settingsTarget) {
        var settings = this.configurationService.lookup(key);
        if (settingsTarget === configurationEditing_1.ConfigurationTarget.USER) {
            if (value === settings.user) {
                return winjs_base_1.TPromise.as(null); // nothing to do
            }
            else if (value === settings.default) {
                if (types.isUndefined(settings.user)) {
                    return winjs_base_1.TPromise.as(null); // nothing to do
                }
                value = void 0; // remove configuration from user settings
            }
        }
        else if (settingsTarget === configurationEditing_1.ConfigurationTarget.WORKSPACE) {
            if (value === settings.value) {
                return winjs_base_1.TPromise.as(null); // nothing to do
            }
        }
        return this.configurationEditingService.writeConfiguration(settingsTarget, { key: key, value: value });
    };
    WorkbenchThemeService.prototype._findIconThemeData = function (iconTheme) {
        return this.getFileIconThemes().then(function (allIconSets) {
            for (var _i = 0, allIconSets_1 = allIconSets; _i < allIconSets_1.length; _i++) {
                var iconSet = allIconSets_1[_i];
                if (iconSet.id === iconTheme) {
                    return iconSet;
                }
            }
            return null;
        });
    };
    WorkbenchThemeService.prototype.findIconThemeBySettingsId = function (settingsId) {
        return this.getFileIconThemes().then(function (allIconSets) {
            for (var _i = 0, allIconSets_2 = allIconSets; _i < allIconSets_2.length; _i++) {
                var iconSet = allIconSets_2[_i];
                if (iconSet.settingsId === settingsId) {
                    return iconSet;
                }
            }
            return null;
        });
    };
    return WorkbenchThemeService;
}());
WorkbenchThemeService = __decorate([
    __param(1, extensions_1.IExtensionService),
    __param(2, storage_1.IStorageService),
    __param(3, windowService_1.IWindowIPCService),
    __param(4, configuration_1.IConfigurationService),
    __param(5, configurationEditing_1.IConfigurationEditingService),
    __param(6, environment_1.IEnvironmentService),
    __param(7, files_1.IFileService),
    __param(8, message_1.IMessageService),
    __param(9, telemetry_1.ITelemetryService)
], WorkbenchThemeService);
exports.WorkbenchThemeService = WorkbenchThemeService;
function _applyIconTheme(data, onApply) {
    if (!data) {
        _applyRules('', iconThemeRulesClassName);
        return winjs_base_1.TPromise.as(onApply(data));
    }
    if (data.styleSheetContent) {
        _applyRules(data.styleSheetContent, iconThemeRulesClassName);
        return winjs_base_1.TPromise.as(onApply(data));
    }
    return _loadIconThemeDocument(data.path).then(function (iconThemeDocument) {
        var result = _processIconThemeDocument(data.id, data.path, iconThemeDocument);
        data.styleSheetContent = result.content;
        data.hasFileIcons = result.hasFileIcons;
        data.hasFolderIcons = result.hasFolderIcons;
        data.isLoaded = true;
        _applyRules(data.styleSheetContent, iconThemeRulesClassName);
        return onApply(data);
    }, function (error) {
        return winjs_base_1.TPromise.wrapError(nls.localize('error.cannotloadicontheme', "Unable to load {0}", data.path));
    });
}
function _loadIconThemeDocument(fileSetPath) {
    return pfs.readFile(fileSetPath).then(function (content) {
        var errors = [];
        var contentValue = Json.parse(content.toString(), errors);
        if (errors.length > 0) {
            return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparseicontheme', "Problems parsing file icons file: {0}", errors.map(function (e) { return Json.getParseErrorMessage(e.error); }).join(', '))));
        }
        return winjs_base_1.TPromise.as(contentValue);
    });
}
function _processIconThemeDocument(id, iconThemeDocumentPath, iconThemeDocument) {
    var result = { content: '', hasFileIcons: false, hasFolderIcons: false };
    if (!iconThemeDocument.iconDefinitions) {
        return result;
    }
    var selectorByDefinitionId = {};
    function resolvePath(path) {
        return Paths.join(Paths.dirname(iconThemeDocumentPath), path);
    }
    function collectSelectors(associations, baseThemeClassName) {
        function addSelector(selector, defId) {
            if (defId) {
                var list = selectorByDefinitionId[defId];
                if (!list) {
                    list = selectorByDefinitionId[defId] = [];
                }
                list.push(selector);
            }
        }
        if (associations) {
            var qualifier = '.show-file-icons';
            if (baseThemeClassName) {
                qualifier = baseThemeClassName + ' ' + qualifier;
            }
            var expanded = '.monaco-tree-row.expanded'; // workaround for #11453
            if (associations.folder) {
                addSelector(qualifier + " .folder-icon::before", associations.folder);
                result.hasFolderIcons = true;
            }
            if (associations.folderExpanded) {
                addSelector(qualifier + " " + expanded + " .folder-icon::before", associations.folderExpanded);
                result.hasFolderIcons = true;
            }
            if (associations.file) {
                addSelector(qualifier + " .file-icon::before", associations.file);
                result.hasFileIcons = true;
            }
            var folderNames = associations.folderNames;
            if (folderNames) {
                for (var folderName in folderNames) {
                    addSelector(qualifier + " ." + escapeCSS(folderName.toLowerCase()) + "-name-folder-icon.folder-icon::before", folderNames[folderName]);
                    result.hasFolderIcons = true;
                }
            }
            var folderNamesExpanded = associations.folderNamesExpanded;
            if (folderNamesExpanded) {
                for (var folderName in folderNamesExpanded) {
                    addSelector(qualifier + " " + expanded + " ." + escapeCSS(folderName.toLowerCase()) + "-name-folder-icon.folder-icon::before", folderNamesExpanded[folderName]);
                    result.hasFolderIcons = true;
                }
            }
            var languageIds = associations.languageIds;
            if (languageIds) {
                for (var languageId in languageIds) {
                    addSelector(qualifier + " ." + escapeCSS(languageId) + "-lang-file-icon.file-icon::before", languageIds[languageId]);
                    result.hasFileIcons = true;
                }
            }
            var fileExtensions = associations.fileExtensions;
            if (fileExtensions) {
                for (var fileExtension in fileExtensions) {
                    var selectors = [];
                    var segments = fileExtension.toLowerCase().split('.');
                    for (var i = 0; i < segments.length; i++) {
                        selectors.push("." + escapeCSS(segments.slice(i).join('.')) + "-ext-file-icon");
                    }
                    addSelector(qualifier + " " + selectors.join('') + ".file-icon::before", fileExtensions[fileExtension]);
                    result.hasFileIcons = true;
                }
            }
            var fileNames = associations.fileNames;
            if (fileNames) {
                for (var fileName in fileNames) {
                    var selectors = [];
                    fileName = fileName.toLowerCase();
                    selectors.push("." + escapeCSS(fileName) + "-name-file-icon");
                    var segments = fileName.split('.');
                    for (var i = 1; i < segments.length; i++) {
                        selectors.push("." + escapeCSS(segments.slice(i).join('.')) + "-ext-file-icon");
                    }
                    addSelector(qualifier + " " + selectors.join('') + ".file-icon::before", fileNames[fileName]);
                    result.hasFileIcons = true;
                }
            }
        }
    }
    collectSelectors(iconThemeDocument);
    collectSelectors(iconThemeDocument.light, '.vs');
    collectSelectors(iconThemeDocument.highContrast, '.hc-black');
    if (!result.hasFileIcons && !result.hasFolderIcons) {
        return result;
    }
    var cssRules = [];
    var fonts = iconThemeDocument.fonts;
    if (Array.isArray(fonts)) {
        fonts.forEach(function (font) {
            var src = font.src.map(function (l) { return "url('" + resolvePath(l.path) + "') format('" + l.format + "')"; }).join(', ');
            cssRules.push("@font-face { src: " + src + "; font-family: '" + font.id + "'; font-weigth: " + font.weight + "; font-style: " + font.style + "; }");
        });
        cssRules.push(".show-file-icons .file-icon::before, .show-file-icons .folder-icon::before { font-family: '" + fonts[0].id + "'; font-size: " + (fonts[0].size || '150%') + "}");
    }
    for (var defId in selectorByDefinitionId) {
        var selectors = selectorByDefinitionId[defId];
        var definition = iconThemeDocument.iconDefinitions[defId];
        if (definition) {
            if (definition.iconPath) {
                cssRules.push(selectors.join(', ') + " { content: ' '; background-image: url(\"" + resolvePath(definition.iconPath) + "\"); }");
            }
            if (definition.fontCharacter || definition.fontColor) {
                var body = '';
                if (definition.fontColor) {
                    body += " color: " + definition.fontColor + ";";
                }
                if (definition.fontCharacter) {
                    body += " content: '" + definition.fontCharacter + "';";
                }
                if (definition.fontSize) {
                    body += " font-size: " + definition.fontSize + ";";
                }
                if (definition.fontId) {
                    body += " font-family: " + definition.fontId + ";";
                }
                cssRules.push(selectors.join(', ') + " { " + body + " }");
            }
        }
    }
    result.content = cssRules.join('\n');
    return result;
}
function escapeCSS(str) {
    return window['CSS'].escape(str);
}
function toCSSSelector(str) {
    str = str.replace(/[^_\-a-zA-Z0-9]/g, '-');
    if (str.charAt(0).match(/[0-9\-]/)) {
        str = '_' + str;
    }
    return str;
}
var colorThemeRulesClassName = 'contributedColorTheme';
var iconThemeRulesClassName = 'contributedIconTheme';
function _applyRules(styleSheetContent, rulesClassName) {
    var themeStyles = document.head.getElementsByClassName(rulesClassName);
    if (themeStyles.length === 0) {
        var elStyle = document.createElement('style');
        elStyle.type = 'text/css';
        elStyle.className = rulesClassName;
        elStyle.innerHTML = styleSheetContent;
        document.head.appendChild(elStyle);
    }
    else {
        themeStyles[0].innerHTML = styleSheetContent;
    }
}
colorThemeSchema.register();
fileIconThemeSchema.register();
// Configuration: Themes
var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
var colorThemeSetting = {
    type: 'string',
    description: nls.localize('colorTheme', "Specifies the color theme used in the workbench."),
    default: DEFAULT_THEME_SETTING_VALUE,
    enum: [],
    enumDescriptions: [],
    errorMessage: nls.localize('colorThemeError', "Theme is unknown or not installed."),
};
var iconThemeSetting = {
    type: ['string', 'null'],
    default: null,
    description: nls.localize('iconTheme', "Specifies the icon theme used in the workbench."),
    enum: [null],
    enumDescriptions: [nls.localize('noIconThemeDesc', 'No file icons')],
    errorMessage: nls.localize('iconThemeError', "File icon theme is unknown or not installed.")
};
configurationRegistry.registerConfiguration({
    id: 'workbench',
    order: 7.1,
    type: 'object',
    properties: (_a = {},
        _a[themeService_1.COLOR_THEME_SETTING] = colorThemeSetting,
        _a[themeService_1.ICON_THEME_SETTING] = iconThemeSetting,
        _a)
});
var _a;
