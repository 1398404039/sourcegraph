/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
// declare var Proxy:any; // TODO@TypeScript
var AbstractThreadService = (function () {
    function AbstractThreadService(isMain) {
        this._proxies = Object.create(null);
        this._isMain = isMain;
        this._locals = Object.create(null);
        this._proxies = Object.create(null);
    }
    AbstractThreadService.prototype.handle = function (rpcId, methodName, args) {
        if (!this._locals[rpcId]) {
            throw new Error('Unknown actor ' + rpcId);
        }
        var actor = this._locals[rpcId];
        var method = actor[methodName];
        if (typeof method !== 'function') {
            throw new Error('Unknown method ' + methodName + ' on actor ' + rpcId);
        }
        return method.apply(actor, args);
    };
    AbstractThreadService.prototype.get = function (identifier) {
        if (!this._proxies[identifier.id]) {
            this._proxies[identifier.id] = this._createProxy(identifier.id, identifier.methodNames);
        }
        return this._proxies[identifier.id];
    };
    AbstractThreadService.prototype._createProxy = function (id, methodNames) {
        // Check below how to switch to native proxies
        var result = {};
        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i];
            result[methodName] = this.createMethodProxy(id, methodName);
        }
        return result;
        // let handler = {
        // 	get: (target, name) => {
        // 		return (...myArgs: any[]) => {
        // 			return this._callOnRemote(id, name, myArgs);
        // 		};
        // 	}
        // };
        // return new Proxy({}, handler);
    };
    AbstractThreadService.prototype.createMethodProxy = function (id, methodName) {
        var _this = this;
        return function () {
            var myArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                myArgs[_i] = arguments[_i];
            }
            return _this._callOnRemote(id, methodName, myArgs);
        };
    };
    AbstractThreadService.prototype.set = function (identifier, value) {
        if (identifier.isMain !== this._isMain) {
            throw new Error('Mismatch in object registration!');
        }
        this._locals[identifier.id] = value;
    };
    return AbstractThreadService;
}());
exports.AbstractThreadService = AbstractThreadService;
