/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var Paths = require("vs/base/common/paths");
var Json = require("vs/base/common/json");
var color_1 = require("vs/base/common/color");
var stylesContributions_1 = require("vs/workbench/services/themes/electron-browser/stylesContributions");
var winjs_base_1 = require("vs/base/common/winjs.base");
var themes_1 = require("vs/platform/theme/common/themes");
var nls = require("vs/nls");
var plist = require("fast-plist");
var pfs = require("vs/base/node/pfs");
var ColorThemeData = (function () {
    function ColorThemeData() {
    }
    ColorThemeData.prototype.getColor = function (colorId) {
        if (this.colorMap) {
            return this.colorMap[colorId];
        }
        return null;
    };
    ColorThemeData.prototype.ensureLoaded = function (themeService) {
        var _this = this;
        if (!this.isLoaded) {
            var tokenColors_1 = [];
            var colorMap_1 = {};
            return _loadThemeDocument(this.getBaseThemeId(), this.path, tokenColors_1, colorMap_1).then(function (_) {
                var cssRules = [];
                themeService.getThemingParticipants().forEach(function (p) {
                    p(_this, cssRules);
                });
                _this.styleSheetContent = cssRules.join('\n');
                _this.tokenColors = tokenColors_1;
                _this.colorMap = colorMap_1;
                _this.isLoaded = true;
            });
        }
        return winjs_base_1.TPromise.as(null);
    };
    ColorThemeData.prototype.toThemeFile = function () {
        if (!this.isLoaded) {
            return '';
        }
        var content = { name: this.label, colors: {}, tokenColors: this.tokenColors };
        for (var key in this.colorMap) {
            content.colors[key] = this.colorMap[key].toRGBAHex(true);
        }
        return JSON.stringify(content, null, '\t');
    };
    ColorThemeData.prototype.isLightTheme = function () {
        return themes_1.isLightTheme(this.id);
    };
    ColorThemeData.prototype.isDarkTheme = function () {
        return themes_1.isDarkTheme(this.id);
    };
    ColorThemeData.prototype.getSyntaxThemeId = function () {
        return themes_1.getSyntaxThemeId(this.id);
    };
    ColorThemeData.prototype.getBaseThemeId = function () {
        return themes_1.getBaseThemeId(this.id);
    };
    return ColorThemeData;
}());
exports.ColorThemeData = ColorThemeData;
var defaultThemeColors = {
    'vs': [
        { scope: 'token.info-token', settings: { foreground: '#316bcd' } },
        { scope: 'token.warn-token', settings: { foreground: '#cd9731' } },
        { scope: 'token.error-token', settings: { foreground: '#cd3131' } },
        { scope: 'token.debug-token', settings: { foreground: 'purple' } }
    ],
    'vs-dark': [
        { scope: 'token.info-token', settings: { foreground: '#6796e6' } },
        { scope: 'token.warn-token', settings: { foreground: '#cd9731' } },
        { scope: 'token.error-token', settings: { foreground: '#f44747' } },
        { scope: 'token.debug-token', settings: { foreground: '#b267e6' } }
    ],
    'hc-black': [
        { scope: 'token.info-token', settings: { foreground: '#6796e6' } },
        { scope: 'token.warn-token', settings: { foreground: '#008000' } },
        { scope: 'token.error-token', settings: { foreground: '#FF0000' } },
        { scope: 'token.debug-token', settings: { foreground: '#b267e6' } }
    ],
};
function _loadThemeDocument(baseTheme, themePath, resultRules, resultColors) {
    return pfs.readFile(themePath).then(function (content) {
        if (resultRules.length === 0) {
            var defaultRules = defaultThemeColors[baseTheme] || [];
            resultRules.push.apply(resultRules, defaultRules);
        }
        if (Paths.extname(themePath) === '.json') {
            var errors = [];
            var contentValue_1 = Json.parse(content.toString(), errors);
            if (errors.length > 0) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparsejson', "Problems parsing JSON theme file: {0}", errors.map(function (e) { return Json.getParseErrorMessage(e.error); }).join(', '))));
            }
            var includeCompletes = winjs_base_1.TPromise.as(null);
            if (contentValue_1.include) {
                includeCompletes = _loadThemeDocument(baseTheme, Paths.join(Paths.dirname(themePath), contentValue_1.include), resultRules, resultColors);
            }
            return includeCompletes.then(function (_) {
                if (Array.isArray(contentValue_1.settings)) {
                    // legacy information
                    stylesContributions_1.convertSettings(contentValue_1.settings, resultRules, resultColors);
                }
                else {
                    if (!Array.isArray(contentValue_1.tokenColors) && typeof contentValue_1.colors !== 'object') {
                        return winjs_base_1.TPromise.wrapError(new Error(nls.localize({ key: 'error.invalidformat', comment: ['{0} will be replaced by a path. Values in quotes should not be translated.'] }, "Problem parsing JSON theme file: {0}. Expecting 'tokenColors' and 'colors'.", themePath)));
                    }
                    if (contentValue_1.tokenColors) {
                        resultRules.push.apply(resultRules, contentValue_1.tokenColors);
                    }
                    if (contentValue_1.colors) {
                        for (var colorId in contentValue_1.colors) {
                            var colorHex = contentValue_1.colors[colorId];
                            resultColors[colorId] = color_1.Color.fromHex(colorHex);
                        }
                    }
                }
                return null;
            });
        }
        try {
            var contentValue = plist.parse(content.toString());
            var settings = contentValue.settings;
            if (!Array.isArray(settings)) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.plist.invalidformat', "Problem parsing theme file: {0}. 'settings' is not array.")));
            }
            stylesContributions_1.convertSettings(settings, resultRules, resultColors);
            return winjs_base_1.TPromise.as(null);
        }
        catch (e) {
            return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotparse', "Problems parsing theme file: {0}", e.message)));
        }
    }, function (error) {
        return winjs_base_1.TPromise.wrapError(new Error(nls.localize('error.cannotload', "Problems loading theme file {0}: {1}", themePath, error.message)));
    });
}
