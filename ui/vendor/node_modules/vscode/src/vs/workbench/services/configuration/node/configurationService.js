/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var uri_1 = require("vs/base/common/uri");
var paths = require("vs/base/common/paths");
var extfs = require("vs/base/node/extfs");
var objects = require("vs/base/common/objects");
var async_1 = require("vs/base/common/async");
var collections = require("vs/base/common/collections");
var workspace_1 = require("vs/platform/workspace/common/workspace");
var environment_1 = require("vs/platform/environment/common/environment");
var lifecycle_1 = require("vs/base/common/lifecycle");
var pfs_1 = require("vs/base/node/pfs");
var errors = require("vs/base/common/errors");
var configurationModels_1 = require("vs/workbench/services/configuration/common/configurationModels");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var model_1 = require("vs/platform/configuration/common/model");
var configurationService_1 = require("vs/platform/configuration/node/configurationService");
var configuration_2 = require("vs/workbench/services/configuration/common/configuration");
var files_1 = require("vs/platform/files/common/files");
var event_1 = require("vs/base/common/event");
/**
 * Wraps around the basic configuration service and adds knowledge about workspace settings.
 */
var WorkspaceConfigurationService = (function (_super) {
    __extends(WorkspaceConfigurationService, _super);
    function WorkspaceConfigurationService(contextService, environmentService, workspaceSettingsRootFolder) {
        if (workspaceSettingsRootFolder === void 0) { workspaceSettingsRootFolder = configuration_2.WORKSPACE_CONFIG_FOLDER_DEFAULT_NAME; }
        var _this = _super.call(this) || this;
        _this.contextService = contextService;
        _this.workspaceSettingsRootFolder = workspaceSettingsRootFolder;
        _this.workspaceFilePathToConfiguration = Object.create(null);
        _this.cachedConfig = new model_1.ConfigModel(null);
        _this.cachedWorkspaceConfig = new configurationModels_1.WorkspaceConfigModel(new configurationModels_1.WorkspaceSettingsConfigModel(null), []);
        _this._onDidUpdateConfiguration = _this._register(new event_1.Emitter());
        _this.baseConfigurationService = _this._register(new configurationService_1.ConfigurationService(environmentService));
        _this.reloadConfigurationScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this.doLoadConfiguration()
            .then(function (config) { return _this._onDidUpdateConfiguration.fire({
            config: config.consolidated,
            source: configuration_1.ConfigurationSource.Workspace,
            sourceConfig: config.workspace
        }); })
            .done(null, errors.onUnexpectedError); }, WorkspaceConfigurationService.RELOAD_CONFIGURATION_DELAY));
        _this._register(_this.baseConfigurationService.onDidUpdateConfiguration(function (e) { return _this.onBaseConfigurationChanged(e); }));
        return _this;
    }
    Object.defineProperty(WorkspaceConfigurationService.prototype, "onDidUpdateConfiguration", {
        get: function () {
            return this._onDidUpdateConfiguration.event;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceConfigurationService.prototype.onBaseConfigurationChanged = function (event) {
        if (event.source === configuration_1.ConfigurationSource.Default) {
            this.cachedWorkspaceConfig.update();
        }
        // update cached config when base config changes
        var configModel = this.baseConfigurationService.getCache().consolidated // global/default values (do NOT modify)
            .merge(this.cachedWorkspaceConfig); // workspace configured values
        // emit this as update to listeners if changed
        if (!objects.equals(this.cachedConfig.contents, configModel.contents)) {
            this.cachedConfig = configModel;
            this._onDidUpdateConfiguration.fire({
                config: this.cachedConfig.contents,
                source: event.source,
                sourceConfig: event.sourceConfig
            });
        }
    };
    WorkspaceConfigurationService.prototype.initialize = function () {
        return this.doLoadConfiguration().then(function () { return null; });
    };
    WorkspaceConfigurationService.prototype.getConfiguration = function (arg) {
        var options = this.toOptions(arg);
        var configModel = options.overrideIdentifier ? this.cachedConfig.configWithOverrides(options.overrideIdentifier) : this.cachedConfig;
        return options.section ? configModel.getContentsFor(options.section) : configModel.contents;
    };
    WorkspaceConfigurationService.prototype.lookup = function (key, overrideIdentifier) {
        var configurationValue = this.baseConfigurationService.lookup(key, overrideIdentifier);
        return {
            default: configurationValue.default,
            user: configurationValue.user,
            workspace: objects.clone(configuration_1.getConfigurationValue(overrideIdentifier ? this.cachedWorkspaceConfig.configWithOverrides(overrideIdentifier).contents : this.cachedWorkspaceConfig.contents, key)),
            value: objects.clone(configuration_1.getConfigurationValue(overrideIdentifier ? this.cachedConfig.configWithOverrides(overrideIdentifier).contents : this.cachedConfig.contents, key))
        };
    };
    WorkspaceConfigurationService.prototype.keys = function () {
        var keys = this.baseConfigurationService.keys();
        return {
            default: keys.default,
            user: keys.user,
            workspace: this.cachedWorkspaceConfig.keys
        };
    };
    WorkspaceConfigurationService.prototype.values = function () {
        var result = Object.create(null);
        var keyset = this.keys();
        var keys = keyset.workspace.concat(keyset.user, keyset.default).sort();
        var lastKey;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (key !== lastKey) {
                lastKey = key;
                result[key] = this.lookup(key);
            }
        }
        return result;
    };
    WorkspaceConfigurationService.prototype.reloadConfiguration = function (section) {
        var _this = this;
        // Reset caches to ensure we are hitting the disk
        this.bulkFetchFromWorkspacePromise = null;
        this.workspaceFilePathToConfiguration = Object.create(null);
        // Load configuration
        return this.baseConfigurationService.reloadConfiguration().then(function () {
            return _this.doLoadConfiguration().then(function (configuration) {
                return section ? configuration.consolidated[section] : configuration.consolidated;
            });
        });
    };
    WorkspaceConfigurationService.prototype.toOptions = function (arg) {
        if (typeof arg === 'string') {
            return { section: arg };
        }
        if (typeof arg === 'object') {
            return arg;
        }
        return {};
    };
    WorkspaceConfigurationService.prototype.doLoadConfiguration = function () {
        var _this = this;
        // Load workspace locals
        return this.loadWorkspaceConfigFiles().then(function (workspaceConfigFiles) {
            // Consolidate (support *.json files in the workspace settings folder)
            var workspaceSettingsConfig = workspaceConfigFiles[configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH] || new configurationModels_1.WorkspaceSettingsConfigModel(null);
            var otherConfigModels = Object.keys(workspaceConfigFiles).filter(function (key) { return key !== configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH; }).map(function (key) { return workspaceConfigFiles[key]; });
            _this.cachedWorkspaceConfig = new configurationModels_1.WorkspaceConfigModel(workspaceSettingsConfig, otherConfigModels);
            // Override base (global < user) with workspace locals (global < user < workspace)
            _this.cachedConfig = _this.baseConfigurationService.getCache().consolidated // global/default values (do NOT modify)
                .merge(_this.cachedWorkspaceConfig); // workspace configured values
            return {
                consolidated: _this.cachedConfig.contents,
                workspace: _this.cachedWorkspaceConfig.contents
            };
        });
    };
    WorkspaceConfigurationService.prototype.loadWorkspaceConfigFiles = function () {
        var _this = this;
        // Return early if we don't have a workspace
        if (!this.contextService.hasWorkspace()) {
            return winjs_base_1.TPromise.as(Object.create(null));
        }
        // once: when invoked for the first time we fetch json files that contribute settings
        if (!this.bulkFetchFromWorkspacePromise) {
            this.bulkFetchFromWorkspacePromise = resolveStat(this.contextService.toResource(this.workspaceSettingsRootFolder)).then(function (stat) {
                if (!stat.isDirectory) {
                    return winjs_base_1.TPromise.as([]);
                }
                return resolveContents(stat.children.filter(function (stat) {
                    var isJson = paths.extname(stat.resource.fsPath) === '.json';
                    if (!isJson) {
                        return false; // only JSON files
                    }
                    return _this.isWorkspaceConfigurationFile(_this.contextService.toWorkspaceRelativePath(stat.resource)); // only workspace config files
                }).map(function (stat) { return stat.resource; }));
            }, function (err) { return []; } /* never fail this call */)
                .then(function (contents) {
                contents.forEach(function (content) { return _this.workspaceFilePathToConfiguration[_this.contextService.toWorkspaceRelativePath(content.resource)] = winjs_base_1.TPromise.as(_this.createConfigModel(content)); });
            }, errors.onUnexpectedError);
        }
        // on change: join on *all* configuration file promises so that we can merge them into a single configuration object. this
        // happens whenever a config file changes, is deleted, or added
        return this.bulkFetchFromWorkspacePromise.then(function () { return winjs_base_1.TPromise.join(_this.workspaceFilePathToConfiguration); });
    };
    WorkspaceConfigurationService.prototype.handleWorkspaceFileEvents = function (event) {
        var _this = this;
        var events = event.changes;
        var affectedByChanges = false;
        // Find changes that affect workspace configuration files
        for (var i = 0, len = events.length; i < len; i++) {
            var resource = events[i].resource;
            var isJson = paths.extname(resource.fsPath) === '.json';
            var isDeletedSettingsFolder = (events[i].type === files_1.FileChangeType.DELETED && paths.basename(resource.fsPath) === this.workspaceSettingsRootFolder);
            if (!isJson && !isDeletedSettingsFolder) {
                continue; // only JSON files or the actual settings folder
            }
            var workspacePath = this.contextService.toWorkspaceRelativePath(resource);
            if (!workspacePath) {
                continue; // event is not inside workspace
            }
            // Handle case where ".vscode" got deleted
            if (workspacePath === this.workspaceSettingsRootFolder && events[i].type === files_1.FileChangeType.DELETED) {
                this.workspaceFilePathToConfiguration = Object.create(null);
                affectedByChanges = true;
            }
            // only valid workspace config files
            if (!this.isWorkspaceConfigurationFile(workspacePath)) {
                continue;
            }
            // insert 'fetch-promises' for add and update events and
            // remove promises for delete events
            switch (events[i].type) {
                case files_1.FileChangeType.DELETED:
                    affectedByChanges = collections.remove(this.workspaceFilePathToConfiguration, workspacePath);
                    break;
                case files_1.FileChangeType.UPDATED:
                case files_1.FileChangeType.ADDED:
                    this.workspaceFilePathToConfiguration[workspacePath] = resolveContent(resource).then(function (content) { return _this.createConfigModel(content); }, errors.onUnexpectedError);
                    affectedByChanges = true;
            }
        }
        // trigger reload of the configuration if we are affected by changes
        if (affectedByChanges && !this.reloadConfigurationScheduler.isScheduled()) {
            this.reloadConfigurationScheduler.schedule();
        }
    };
    WorkspaceConfigurationService.prototype.createConfigModel = function (content) {
        var path = this.contextService.toWorkspaceRelativePath(content.resource);
        if (path === configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH) {
            return new configurationModels_1.WorkspaceSettingsConfigModel(content.value, content.resource.toString());
        }
        else {
            var matches = /\/([^\.]*)*\.json/.exec(path);
            if (matches && matches[1]) {
                return new configurationModels_1.ScopedConfigModel(content.value, content.resource.toString(), matches[1]);
            }
        }
        return new model_1.ConfigModel(null);
    };
    WorkspaceConfigurationService.prototype.isWorkspaceConfigurationFile = function (workspaceRelativePath) {
        return [configuration_2.WORKSPACE_CONFIG_DEFAULT_PATH, configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS.launch, configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS.tasks].some(function (p) { return p === workspaceRelativePath; });
    };
    WorkspaceConfigurationService.prototype.getUnsupportedWorkspaceKeys = function () {
        return this.cachedWorkspaceConfig.workspaceSettingsConfig.unsupportedKeys;
    };
    return WorkspaceConfigurationService;
}(lifecycle_1.Disposable));
WorkspaceConfigurationService.RELOAD_CONFIGURATION_DELAY = 50;
WorkspaceConfigurationService = __decorate([
    __param(0, workspace_1.IWorkspaceContextService),
    __param(1, environment_1.IEnvironmentService)
], WorkspaceConfigurationService);
exports.WorkspaceConfigurationService = WorkspaceConfigurationService;
// node.hs helper functions
function resolveContents(resources) {
    var contents = [];
    return winjs_base_1.TPromise.join(resources.map(function (resource) {
        return resolveContent(resource).then(function (content) {
            contents.push(content);
        });
    })).then(function () { return contents; });
}
function resolveContent(resource) {
    return pfs_1.readFile(resource.fsPath).then(function (contents) { return ({ resource: resource, value: contents.toString() }); });
}
function resolveStat(resource) {
    return new winjs_base_1.TPromise(function (c, e) {
        extfs.readdir(resource.fsPath, function (error, children) {
            if (error) {
                if (error.code === 'ENOTDIR') {
                    c({ resource: resource });
                }
                else {
                    e(error);
                }
            }
            else {
                c({
                    resource: resource,
                    isDirectory: true,
                    children: children.map(function (child) { return { resource: uri_1.default.file(paths.join(resource.fsPath, child)) }; })
                });
            }
        });
    });
}
