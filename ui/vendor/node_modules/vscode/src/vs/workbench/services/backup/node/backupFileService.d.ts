import Uri from 'vs/base/common/uri';
import { IBackupFileService } from 'vs/workbench/services/backup/common/backup';
import { IBackupService } from 'vs/platform/backup/common/backup';
import { IEnvironmentService } from 'vs/platform/environment/common/environment';
import { IFileService } from 'vs/platform/files/common/files';
import { TPromise } from 'vs/base/common/winjs.base';
import { IWindowService } from 'vs/platform/windows/common/windows';
import { IRawTextSource } from 'vs/editor/common/model/textSource';
export interface IBackupFilesModel {
    resolve(backupRoot: string): TPromise<IBackupFilesModel>;
    add(resource: Uri, versionId?: number): void;
    has(resource: Uri, versionId?: number): boolean;
    get(): Uri[];
    remove(resource: Uri): void;
    count(): number;
    clear(): void;
}
export declare class BackupFilesModel implements IBackupFilesModel {
    private cache;
    resolve(backupRoot: string): TPromise<IBackupFilesModel>;
    add(resource: Uri, versionId?: number): void;
    count(): number;
    has(resource: Uri, versionId?: number): boolean;
    get(): Uri[];
    remove(resource: Uri): void;
    clear(): void;
}
export declare class BackupFileService implements IBackupFileService {
    private environmentService;
    private fileService;
    private backupService;
    _serviceBrand: any;
    private static readonly META_MARKER;
    private isShuttingDown;
    private backupWorkspacePath;
    private ready;
    /**
     * Ensure IO operations on individual files are performed in order, this could otherwise lead
     * to unexpected behavior when backups are persisted and discarded in the wrong order.
     */
    private ioOperationQueues;
    constructor(environmentService: IEnvironmentService, fileService: IFileService, windowService: IWindowService, backupService: IBackupService);
    private readonly backupEnabled;
    private init(windowId);
    hasBackups(): TPromise<boolean>;
    hasBackup(resource: Uri): TPromise<boolean>;
    loadBackupResource(resource: Uri): TPromise<Uri>;
    backupResource(resource: Uri, content: string, versionId?: number): TPromise<void>;
    discardResourceBackup(resource: Uri): TPromise<void>;
    private getResourceIOQueue(resource);
    discardAllWorkspaceBackups(): TPromise<void>;
    getWorkspaceFileBackups(): TPromise<Uri[]>;
    parseBackupContent(rawTextSource: IRawTextSource): string;
    protected getBackupResource(resource: Uri): Uri;
    private hashPath(resource);
}
