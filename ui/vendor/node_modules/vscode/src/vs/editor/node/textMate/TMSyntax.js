/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var errors_1 = require("vs/base/common/errors");
var paths = require("vs/base/common/paths");
var strings = require("vs/base/common/strings");
var types = require("vs/base/common/types");
var event_1 = require("vs/base/common/event");
var extensionsRegistry_1 = require("vs/platform/extensions/common/extensionsRegistry");
var modes_1 = require("vs/editor/common/modes");
var TMState_1 = require("vs/editor/node/textMate/TMState");
var supports_1 = require("vs/editor/common/modes/supports");
var modeService_1 = require("vs/editor/common/services/modeService");
var vscode_textmate_1 = require("vscode-textmate");
var modeTransition_1 = require("vs/editor/common/core/modeTransition");
var token_1 = require("vs/editor/common/core/token");
var modeServiceImpl_1 = require("vs/editor/common/services/modeServiceImpl");
// TODO@Martin TS(2.0.2) - Type IJsonSchema has no defined property require. Keeping semantic using any cast
exports.grammarsExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('grammars', [modeServiceImpl_1.languagesExtPoint], {
    description: nls.localize('vscode.extension.contributes.grammars', 'Contributes textmate tokenizers.'),
    type: 'array',
    defaultSnippets: [{ body: [{ language: '${1:id}', scopeName: 'source.${2:id}', path: './syntaxes/${3:id}.tmLanguage.' }] }],
    items: {
        type: 'object',
        defaultSnippets: [{ body: { language: '${1:id}', scopeName: 'source.${2:id}', path: './syntaxes/${3:id}.tmLanguage.' } }],
        properties: {
            language: {
                description: nls.localize('vscode.extension.contributes.grammars.language', 'Language identifier for which this syntax is contributed to.'),
                type: 'string'
            },
            scopeName: {
                description: nls.localize('vscode.extension.contributes.grammars.scopeName', 'Textmate scope name used by the tmLanguage file.'),
                type: 'string'
            },
            path: {
                description: nls.localize('vscode.extension.contributes.grammars.path', 'Path of the tmLanguage file. The path is relative to the extension folder and typically starts with \'./syntaxes/\'.'),
                type: 'string'
            },
            embeddedLanguages: {
                description: nls.localize('vscode.extension.contributes.grammars.embeddedLanguages', 'A map of scope name to language id if this grammar contains embedded languages.'),
                type: 'object'
            },
            injectTo: {
                description: nls.localize('vscode.extension.contributes.grammars.injectTo', 'List of language scope names to which this grammar is injected to.'),
                type: 'array',
                items: {
                    type: 'string'
                }
            }
        },
        require: ['scopeName', 'path']
    }
});
var TMScopeRegistry = (function () {
    function TMScopeRegistry() {
        this._onDidEncounterLanguage = new event_1.Emitter();
        this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;
        this._scopeNameToLanguageRegistration = Object.create(null);
        this._encounteredLanguages = Object.create(null);
    }
    TMScopeRegistry.prototype.register = function (scopeName, filePath, embeddedLanguages) {
        this._scopeNameToLanguageRegistration[scopeName] = new TMLanguageRegistration(this, scopeName, filePath, embeddedLanguages);
    };
    TMScopeRegistry.prototype.getLanguageRegistration = function (scopeName) {
        return this._scopeNameToLanguageRegistration[scopeName] || null;
    };
    TMScopeRegistry.prototype.getFilePath = function (scopeName) {
        var data = this.getLanguageRegistration(scopeName);
        return data ? data.grammarFilePath : null;
    };
    /**
     * To be called when tokenization found/hit an embedded language.
     */
    TMScopeRegistry.prototype.onEncounteredLanguage = function (language) {
        if (!this._encounteredLanguages[language]) {
            this._encounteredLanguages[language] = true;
            this._onDidEncounterLanguage.fire(language);
        }
    };
    return TMScopeRegistry;
}());
exports.TMScopeRegistry = TMScopeRegistry;
var TMLanguageRegistration = (function () {
    function TMLanguageRegistration(registry, scopeName, grammarFilePath, embeddedLanguages) {
        this._registry = registry;
        this.scopeName = scopeName;
        this.grammarFilePath = grammarFilePath;
        // embeddedLanguages handling
        this._embeddedLanguages = Object.create(null);
        if (embeddedLanguages) {
            // If embeddedLanguages are configured, fill in `this._embeddedLanguages`
            var scopes = Object.keys(embeddedLanguages);
            for (var i = 0, len = scopes.length; i < len; i++) {
                var scope = scopes[i];
                var language = embeddedLanguages[scope];
                if (typeof language !== 'string') {
                    // never hurts to be too careful
                    continue;
                }
                this._embeddedLanguages[scope] = language;
            }
        }
        // create the regex
        var escapedScopes = Object.keys(this._embeddedLanguages).map(function (scopeName) { return strings.escapeRegExpCharacters(scopeName); });
        if (escapedScopes.length === 0) {
            // no scopes registered
            this._embeddedLanguagesRegex = null;
        }
        else {
            escapedScopes.sort();
            escapedScopes.reverse();
            this._embeddedLanguagesRegex = new RegExp("^((" + escapedScopes.join(')|(') + "))($|\\.)", '');
        }
    }
    /**
     * Given a produced TM scope, return the language that token describes or null if unknown.
     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
     */
    TMLanguageRegistration.prototype.scopeToLanguage = function (scope) {
        if (!scope) {
            return null;
        }
        if (!this._embeddedLanguagesRegex) {
            // no scopes registered
            return null;
        }
        var m = scope.match(this._embeddedLanguagesRegex);
        if (!m) {
            // no scopes matched
            return null;
        }
        var language = this._embeddedLanguages[m[1]] || null;
        if (!language) {
            return null;
        }
        this._registry.onEncounteredLanguage(language);
        return language;
    };
    return TMLanguageRegistration;
}());
exports.TMLanguageRegistration = TMLanguageRegistration;
var MainProcessTextMateSyntax = (function () {
    function MainProcessTextMateSyntax(modeService) {
        var _this = this;
        this._modeService = modeService;
        this._scopeRegistry = new TMScopeRegistry();
        this.onDidEncounterLanguage = this._scopeRegistry.onDidEncounterLanguage;
        this._injections = {};
        this._grammarRegistry = new vscode_textmate_1.Registry({
            getFilePath: function (scopeName) {
                return _this._scopeRegistry.getFilePath(scopeName);
            },
            getInjections: function (scopeName) {
                return _this._injections[scopeName];
            }
        });
        exports.grammarsExtPoint.setHandler(function (extensions) {
            for (var i = 0; i < extensions.length; i++) {
                var grammars = extensions[i].value;
                for (var j = 0; j < grammars.length; j++) {
                    _this._handleGrammarExtensionPointUser(extensions[i].description.extensionFolderPath, grammars[j], extensions[i].collector);
                }
            }
        });
    }
    MainProcessTextMateSyntax.prototype._handleGrammarExtensionPointUser = function (extensionFolderPath, syntax, collector) {
        var _this = this;
        if (syntax.language && ((typeof syntax.language !== 'string') || !this._modeService.isRegisteredMode(syntax.language))) {
            collector.error(nls.localize('invalid.language', "Unknown language in `contributes.{0}.language`. Provided value: {1}", exports.grammarsExtPoint.name, String(syntax.language)));
            return;
        }
        if (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {
            collector.error(nls.localize('invalid.scopeName', "Expected string in `contributes.{0}.scopeName`. Provided value: {1}", exports.grammarsExtPoint.name, String(syntax.scopeName)));
            return;
        }
        if (!syntax.path || (typeof syntax.path !== 'string')) {
            collector.error(nls.localize('invalid.path.0', "Expected string in `contributes.{0}.path`. Provided value: {1}", exports.grammarsExtPoint.name, String(syntax.path)));
            return;
        }
        if (syntax.injectTo && (!Array.isArray(syntax.injectTo) || syntax.injectTo.some(function (scope) { return typeof scope !== 'string'; }))) {
            collector.error(nls.localize('invalid.injectTo', "Invalid value in `contributes.{0}.injectTo`. Must be an array of language scope names. Provided value: {1}", exports.grammarsExtPoint.name, JSON.stringify(syntax.injectTo)));
            return;
        }
        if (syntax.embeddedLanguages && !types.isObject(syntax.embeddedLanguages)) {
            collector.error(nls.localize('invalid.embeddedLanguages', "Invalid value in `contributes.{0}.embeddedLanguages`. Must be an object map from scope name to language. Provided value: {1}", exports.grammarsExtPoint.name, JSON.stringify(syntax.embeddedLanguages)));
            return;
        }
        var normalizedAbsolutePath = paths.normalize(paths.join(extensionFolderPath, syntax.path));
        if (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {
            collector.warn(nls.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", exports.grammarsExtPoint.name, normalizedAbsolutePath, extensionFolderPath));
        }
        this._scopeRegistry.register(syntax.scopeName, normalizedAbsolutePath, syntax.embeddedLanguages);
        if (syntax.injectTo) {
            for (var _i = 0, _a = syntax.injectTo; _i < _a.length; _i++) {
                var injectScope = _a[_i];
                var injections = this._injections[injectScope];
                if (!injections) {
                    this._injections[injectScope] = injections = [];
                }
                injections.push(syntax.scopeName);
            }
        }
        var modeId = syntax.language;
        if (modeId) {
            var disposable_1 = this._modeService.onDidCreateMode(function (mode) {
                if (mode.getId() !== modeId) {
                    return;
                }
                _this.registerDefinition(modeId, syntax.scopeName);
                disposable_1.dispose();
            });
        }
    };
    MainProcessTextMateSyntax.prototype.registerDefinition = function (modeId, scopeName) {
        var _this = this;
        this._grammarRegistry.loadGrammar(scopeName, function (err, grammar) {
            if (err) {
                errors_1.onUnexpectedError(err);
                return;
            }
            var languageRegistration = _this._scopeRegistry.getLanguageRegistration(scopeName);
            modes_1.TokenizationRegistry.register(modeId, createTokenizationSupport(languageRegistration, modeId, grammar));
        });
    };
    return MainProcessTextMateSyntax;
}());
MainProcessTextMateSyntax = __decorate([
    __param(0, modeService_1.IModeService)
], MainProcessTextMateSyntax);
exports.MainProcessTextMateSyntax = MainProcessTextMateSyntax;
function createTokenizationSupport(languageRegistration, modeId, grammar) {
    var tokenizer = new Tokenizer(languageRegistration, modeId, grammar);
    return {
        getInitialState: function () { return new TMState_1.TMState(modeId, null, null); },
        tokenize: function (line, state, offsetDelta, stopAtOffset) { return tokenizer.tokenize(line, state, offsetDelta, stopAtOffset); }
    };
}
/**
 * Data associated with a text mate scope as part of decoding.
 *
 * e.g.
 * For a scope "punctuation.definition.string.end.html", the tokens are: punctuation, definition, string, end, html.
 * Each of those tokens receive a unique numeric id, so instead of storing the token strings, we store the token ids.
 * Ultimately this means we store something like [23, 21, 12, 13, 1], considering those numbers to be the ids of the tokens.
 */
var TMScopeDecodeData = (function () {
    function TMScopeDecodeData(scope, language, tokenIds) {
        this.scope = scope;
        this.language = language;
        this.tokenIds = tokenIds;
    }
    return TMScopeDecodeData;
}());
exports.TMScopeDecodeData = TMScopeDecodeData;
/**
 * Data associated with a stack of text mate scopes as part of decoding.
 */
var TMScopesDecodeData = (function () {
    function TMScopesDecodeData(parent, scope) {
        // 1) Inherit data from `parent`.
        var tokensMask;
        var language;
        if (parent) {
            tokensMask = parent.tokensMask.slice(0);
            language = parent.language;
        }
        else {
            tokensMask = [];
            language = null;
        }
        // 2) Overwrite with data from `scope`.
        var scopeTokenIds = scope.tokenIds;
        for (var i = 0, len = scopeTokenIds.length; i < len; i++) {
            tokensMask[scopeTokenIds[i]] = true;
        }
        if (scope.language) {
            language = scope.language;
        }
        this.scope = scope.scope;
        this.tokensMask = tokensMask;
        this.language = language;
    }
    return TMScopesDecodeData;
}());
exports.TMScopesDecodeData = TMScopesDecodeData;
var DecodeMap = (function () {
    function DecodeMap(languageRegistration) {
        this.lastAssignedTokenId = 0;
        this.languageRegistration = languageRegistration;
        this.scopeToTokenIds = Object.create(null);
        this.tokenToTokenId = Object.create(null);
        this.tokenIdToToken = [null];
        this.prevTokenScopes = [];
        this.topLevelScope = new TMScopesDecodeData(null, new TMScopeDecodeData(languageRegistration.scopeName, this.languageRegistration.scopeToLanguage(languageRegistration.scopeName), []));
    }
    DecodeMap.prototype._getTokenId = function (token) {
        var tokenId = this.tokenToTokenId[token];
        if (!tokenId) {
            tokenId = (++this.lastAssignedTokenId);
            this.tokenToTokenId[token] = tokenId;
            this.tokenIdToToken[tokenId] = token;
        }
        return tokenId;
    };
    DecodeMap.prototype.decodeTMScope = function (scope) {
        var result = this.scopeToTokenIds[scope];
        if (result) {
            return result;
        }
        var scopePieces = scope.split('.');
        var tokenIds = [];
        for (var i = 0; i < scopePieces.length; i++) {
            tokenIds[i] = this._getTokenId(scopePieces[i]);
        }
        result = new TMScopeDecodeData(scope, this.languageRegistration.scopeToLanguage(scope), tokenIds);
        this.scopeToTokenIds[scope] = result;
        return result;
    };
    DecodeMap.prototype.getToken = function (tokenMap) {
        var result = '';
        var isFirst = true;
        for (var i = 1, len = tokenMap.length; i < len; i++) {
            if (tokenMap[i]) {
                if (isFirst) {
                    isFirst = false;
                    result += this.tokenIdToToken[i];
                }
                else {
                    result += '.';
                    result += this.tokenIdToToken[i];
                }
            }
        }
        return result;
    };
    return DecodeMap;
}());
exports.DecodeMap = DecodeMap;
function depth(stackElement) {
    var result = 0;
    while (stackElement) {
        result++;
        stackElement = stackElement._parent;
    }
    return result;
}
var Tokenizer = (function () {
    function Tokenizer(languageRegistration, modeId, grammar) {
        this._modeId = modeId;
        this._grammar = grammar;
        this._decodeMap = new DecodeMap(languageRegistration);
    }
    Tokenizer.prototype.tokenize = function (line, state, offsetDelta, stopAtOffset) {
        if (offsetDelta === void 0) { offsetDelta = 0; }
        // Do not attempt to tokenize if a line has over 20k
        // or if the rule stack contains more than 100 rules (indicator of broken grammar that forgets to pop rules)
        if (line.length >= 20000 || depth(state.getRuleStack()) > 100) {
            return new supports_1.RawLineTokens([new token_1.Token(offsetDelta, '')], [new modeTransition_1.ModeTransition(offsetDelta, state.getModeId())], offsetDelta, state);
        }
        var freshState = state.clone();
        var textMateResult = this._grammar.tokenizeLine(line, freshState.getRuleStack());
        freshState.setRuleStack(textMateResult.ruleStack);
        return decodeTextMateTokens(line, offsetDelta, this._decodeMap, textMateResult.tokens, freshState);
    };
    return Tokenizer;
}());
function decodeTextMateTokens(line, offsetDelta, decodeMap, resultTokens, resultState) {
    var topLevelModeId = resultState.getModeId();
    // Create the result early and fill in the tokens later
    var tokens = [];
    var modeTransitions = [];
    var lastTokenType = null;
    var lastModeId = null;
    for (var tokenIndex = 0, len = resultTokens.length; tokenIndex < len; tokenIndex++) {
        var token = resultTokens[tokenIndex];
        var tokenStartIndex = token.startIndex;
        var tokenType = '';
        var tokenModeId = topLevelModeId;
        var decodedToken = decodeTextMateToken(decodeMap, token.scopes);
        if (decodedToken) {
            tokenType = decodeMap.getToken(decodedToken.tokensMask);
            if (decodedToken.language) {
                tokenModeId = decodedToken.language;
            }
        }
        // do not push a new token if the type is exactly the same (also helps with ligatures)
        if (tokenType !== lastTokenType) {
            tokens.push(new token_1.Token(tokenStartIndex + offsetDelta, tokenType));
            lastTokenType = tokenType;
        }
        if (tokenModeId !== lastModeId) {
            modeTransitions.push(new modeTransition_1.ModeTransition(tokenStartIndex + offsetDelta, tokenModeId));
            lastModeId = tokenModeId;
        }
    }
    return new supports_1.RawLineTokens(tokens, modeTransitions, offsetDelta + line.length, resultState);
}
exports.decodeTextMateTokens = decodeTextMateTokens;
function decodeTextMateToken(decodeMap, scopes) {
    var prevTokenScopes = decodeMap.prevTokenScopes;
    var prevTokenScopesLength = prevTokenScopes.length;
    var resultScopes = [decodeMap.topLevelScope];
    var lastResultScope = decodeMap.topLevelScope;
    var sameAsPrev = true;
    for (var level = 1 /* deliberately skip scope 0*/, scopesLength = scopes.length; level < scopesLength; level++) {
        var scope = scopes[level];
        if (sameAsPrev && level < prevTokenScopesLength) {
            var prevTokenScope = prevTokenScopes[level];
            if (prevTokenScope.scope === scope) {
                // continue reusing the results of the previous token's computation
                lastResultScope = prevTokenScope;
                resultScopes[level] = lastResultScope;
                continue;
            }
        }
        sameAsPrev = false;
        lastResultScope = new TMScopesDecodeData(lastResultScope, decodeMap.decodeTMScope(scope));
        resultScopes[level] = lastResultScope;
    }
    decodeMap.prevTokenScopes = resultScopes;
    return lastResultScope;
}
exports.decodeTextMateToken = decodeTextMateToken;
