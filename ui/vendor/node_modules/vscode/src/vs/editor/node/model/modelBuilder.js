/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var crypto = require("crypto");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var strings = require("vs/base/common/strings");
var indentationGuesser_1 = require("vs/editor/common/model/indentationGuesser");
var winjs_base_1 = require("vs/base/common/winjs.base");
var ModelBuilderResult = (function () {
    function ModelBuilderResult() {
    }
    return ModelBuilderResult;
}());
exports.ModelBuilderResult = ModelBuilderResult;
var ModelLineBasedBuilder = (function () {
    function ModelLineBasedBuilder() {
        this.hash = crypto.createHash('sha1');
        this.BOM = '';
        this.lines = [];
        this.currLineIndex = 0;
    }
    ModelLineBasedBuilder.prototype.acceptLines = function (lines) {
        if (this.currLineIndex === 0) {
            // Remove the BOM (if present)
            if (strings.startsWithUTF8BOM(lines[0])) {
                this.BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
        }
        for (var i = 0, len = lines.length; i < len; i++) {
            this.lines[this.currLineIndex++] = lines[i];
        }
        this.hash.update(lines.join('\n') + '\n');
    };
    ModelLineBasedBuilder.prototype.finish = function (totalLength, carriageReturnCnt, containsRTL, opts) {
        var lineFeedCnt = this.lines.length - 1;
        var EOL = '';
        if (lineFeedCnt === 0) {
            // This is an empty file or a file with precisely one line
            EOL = (opts.defaultEOL === editorCommon_1.DefaultEndOfLine.LF ? '\n' : '\r\n');
        }
        else if (carriageReturnCnt > lineFeedCnt / 2) {
            // More than half of the file contains \r\n ending lines
            EOL = '\r\n';
        }
        else {
            // At least one line more ends in \n
            EOL = '\n';
        }
        var resolvedOpts;
        if (opts.detectIndentation) {
            var guessedIndentation = indentationGuesser_1.guessIndentation(this.lines, opts.tabSize, opts.insertSpaces);
            resolvedOpts = new editorCommon_1.TextModelResolvedOptions({
                tabSize: guessedIndentation.tabSize,
                insertSpaces: guessedIndentation.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                defaultEOL: opts.defaultEOL
            });
        }
        else {
            resolvedOpts = new editorCommon_1.TextModelResolvedOptions({
                tabSize: opts.tabSize,
                insertSpaces: opts.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                defaultEOL: opts.defaultEOL
            });
        }
        return {
            rawText: {
                BOM: this.BOM,
                EOL: EOL,
                lines: this.lines,
                length: totalLength,
                containsRTL: containsRTL,
                options: resolvedOpts
            },
            hash: this.hash.digest('hex')
        };
    };
    return ModelLineBasedBuilder;
}());
function computeHash(rawText) {
    var hash = crypto.createHash('sha1');
    for (var i = 0, len = rawText.lines.length; i < len; i++) {
        hash.update(rawText.lines[i] + '\n');
    }
    return hash.digest('hex');
}
exports.computeHash = computeHash;
var ModelBuilder = (function () {
    function ModelBuilder() {
        this.leftoverPrevChunk = '';
        this.leftoverEndsInCR = false;
        this.totalCRCount = 0;
        this.lineBasedBuilder = new ModelLineBasedBuilder();
        this.totalLength = 0;
        this.containsRTL = false;
    }
    ModelBuilder.fromStringStream = function (stream, options) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            var done = false;
            var builder = new ModelBuilder();
            stream.on('data', function (chunk) {
                builder.acceptChunk(chunk);
            });
            stream.on('error', function (error) {
                if (!done) {
                    done = true;
                    e(error);
                }
            });
            stream.on('end', function () {
                if (!done) {
                    done = true;
                    c(builder.finish(options));
                }
            });
        });
    };
    ModelBuilder.prototype._updateCRCount = function (chunk) {
        // Count how many \r are present in chunk to determine the majority EOL sequence
        var chunkCarriageReturnCnt = 0;
        var lastCarriageReturnIndex = -1;
        while ((lastCarriageReturnIndex = chunk.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
            chunkCarriageReturnCnt++;
        }
        this.totalCRCount += chunkCarriageReturnCnt;
    };
    ModelBuilder.prototype.acceptChunk = function (chunk) {
        if (chunk.length === 0) {
            return;
        }
        this.totalLength += chunk.length;
        this._updateCRCount(chunk);
        if (!this.containsRTL) {
            this.containsRTL = strings.containsRTL(chunk);
        }
        // Avoid dealing with a chunk that ends in \r (push the \r to the next chunk)
        if (this.leftoverEndsInCR) {
            chunk = '\r' + chunk;
        }
        if (chunk.charCodeAt(chunk.length - 1) === 13 /* CarriageReturn */) {
            this.leftoverEndsInCR = true;
            chunk = chunk.substr(0, chunk.length - 1);
        }
        else {
            this.leftoverEndsInCR = false;
        }
        var lines = chunk.split(/\r\n|\r|\n/);
        if (lines.length === 1) {
            // no \r or \n encountered
            this.leftoverPrevChunk += lines[0];
            return;
        }
        lines[0] = this.leftoverPrevChunk + lines[0];
        this.lineBasedBuilder.acceptLines(lines.slice(0, lines.length - 1));
        this.leftoverPrevChunk = lines[lines.length - 1];
    };
    ModelBuilder.prototype.finish = function (opts) {
        var finalLines = [this.leftoverPrevChunk];
        if (this.leftoverEndsInCR) {
            finalLines.push('');
        }
        this.lineBasedBuilder.acceptLines(finalLines);
        return this.lineBasedBuilder.finish(this.totalLength, this.totalCRCount, this.containsRTL, opts);
    };
    return ModelBuilder;
}());
exports.ModelBuilder = ModelBuilder;
