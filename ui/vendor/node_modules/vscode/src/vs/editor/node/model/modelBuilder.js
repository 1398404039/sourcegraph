/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var crypto = require("crypto");
var strings = require("vs/base/common/strings");
var winjs_base_1 = require("vs/base/common/winjs.base");
var ModelLineBasedBuilder = (function () {
    function ModelLineBasedBuilder() {
        this.hash = crypto.createHash('sha1');
        this.BOM = '';
        this.lines = [];
        this.currLineIndex = 0;
    }
    ModelLineBasedBuilder.prototype.acceptLines = function (lines) {
        if (this.currLineIndex === 0) {
            // Remove the BOM (if present)
            if (strings.startsWithUTF8BOM(lines[0])) {
                this.BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
        }
        for (var i = 0, len = lines.length; i < len; i++) {
            this.lines[this.currLineIndex++] = lines[i];
        }
        this.hash.update(lines.join('\n') + '\n');
    };
    ModelLineBasedBuilder.prototype.finish = function (length, carriageReturnCnt, containsRTL, isBasicASCII) {
        return {
            hash: this.hash.digest('hex'),
            value: {
                BOM: this.BOM,
                lines: this.lines,
                length: length,
                containsRTL: containsRTL,
                totalCRCount: carriageReturnCnt,
                isBasicASCII: isBasicASCII,
            }
        };
    };
    return ModelLineBasedBuilder;
}());
function computeHash(rawText) {
    var hash = crypto.createHash('sha1');
    for (var i = 0, len = rawText.lines.length; i < len; i++) {
        hash.update(rawText.lines[i] + '\n');
    }
    return hash.digest('hex');
}
exports.computeHash = computeHash;
var ModelBuilder = (function () {
    function ModelBuilder() {
        this.leftoverPrevChunk = '';
        this.leftoverEndsInCR = false;
        this.totalCRCount = 0;
        this.lineBasedBuilder = new ModelLineBasedBuilder();
        this.totalLength = 0;
        this.containsRTL = false;
        this.isBasicASCII = true;
    }
    ModelBuilder.fromStringStream = function (stream) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            var done = false;
            var builder = new ModelBuilder();
            stream.on('data', function (chunk) {
                builder.acceptChunk(chunk);
            });
            stream.on('error', function (error) {
                if (!done) {
                    done = true;
                    e(error);
                }
            });
            stream.on('end', function () {
                if (!done) {
                    done = true;
                    c(builder.finish());
                }
            });
        });
    };
    ModelBuilder.prototype._updateCRCount = function (chunk) {
        // Count how many \r are present in chunk to determine the majority EOL sequence
        var chunkCarriageReturnCnt = 0;
        var lastCarriageReturnIndex = -1;
        while ((lastCarriageReturnIndex = chunk.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
            chunkCarriageReturnCnt++;
        }
        this.totalCRCount += chunkCarriageReturnCnt;
    };
    ModelBuilder.prototype.acceptChunk = function (chunk) {
        if (chunk.length === 0) {
            return;
        }
        this.totalLength += chunk.length;
        this._updateCRCount(chunk);
        if (!this.containsRTL) {
            this.containsRTL = strings.containsRTL(chunk);
        }
        if (this.isBasicASCII) {
            this.isBasicASCII = strings.isBasicASCII(chunk);
        }
        // Avoid dealing with a chunk that ends in \r (push the \r to the next chunk)
        if (this.leftoverEndsInCR) {
            chunk = '\r' + chunk;
        }
        if (chunk.charCodeAt(chunk.length - 1) === 13 /* CarriageReturn */) {
            this.leftoverEndsInCR = true;
            chunk = chunk.substr(0, chunk.length - 1);
        }
        else {
            this.leftoverEndsInCR = false;
        }
        var lines = chunk.split(/\r\n|\r|\n/);
        if (lines.length === 1) {
            // no \r or \n encountered
            this.leftoverPrevChunk += lines[0];
            return;
        }
        lines[0] = this.leftoverPrevChunk + lines[0];
        this.lineBasedBuilder.acceptLines(lines.slice(0, lines.length - 1));
        this.leftoverPrevChunk = lines[lines.length - 1];
    };
    ModelBuilder.prototype.finish = function () {
        var finalLines = [this.leftoverPrevChunk];
        if (this.leftoverEndsInCR) {
            finalLines.push('');
        }
        this.lineBasedBuilder.acceptLines(finalLines);
        return this.lineBasedBuilder.finish(this.totalLength, this.totalCRCount, this.containsRTL, this.isBasicASCII);
    };
    return ModelBuilder;
}());
exports.ModelBuilder = ModelBuilder;
