import Event from 'vs/base/common/event';
import { IExtensionPoint } from 'vs/platform/extensions/common/extensionsRegistry';
import { TMState } from 'vs/editor/node/textMate/TMState';
import { RawLineTokens } from 'vs/editor/common/modes/supports';
import { IModeService } from 'vs/editor/common/services/modeService';
import { IToken } from 'vscode-textmate';
export interface IEmbeddedLanguagesMap {
    [scopeName: string]: string;
}
export interface ITMSyntaxExtensionPoint {
    language: string;
    scopeName: string;
    path: string;
    embeddedLanguages: IEmbeddedLanguagesMap;
    injectTo: string[];
}
export declare const grammarsExtPoint: IExtensionPoint<ITMSyntaxExtensionPoint[]>;
export declare class TMScopeRegistry {
    private _scopeNameToLanguageRegistration;
    private _encounteredLanguages;
    private _onDidEncounterLanguage;
    onDidEncounterLanguage: Event<string>;
    constructor();
    register(scopeName: string, filePath: string, embeddedLanguages?: IEmbeddedLanguagesMap): void;
    getLanguageRegistration(scopeName: string): TMLanguageRegistration;
    getFilePath(scopeName: string): string;
    /**
     * To be called when tokenization found/hit an embedded language.
     */
    onEncounteredLanguage(language: string): void;
}
export declare class TMLanguageRegistration {
    _topLevelScopeNameDataBrand: void;
    readonly scopeName: string;
    readonly grammarFilePath: string;
    private readonly _registry;
    private readonly _embeddedLanguages;
    private readonly _embeddedLanguagesRegex;
    constructor(registry: TMScopeRegistry, scopeName: string, grammarFilePath: string, embeddedLanguages: IEmbeddedLanguagesMap);
    /**
     * Given a produced TM scope, return the language that token describes or null if unknown.
     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
     */
    scopeToLanguage(scope: string): string;
}
export declare class MainProcessTextMateSyntax {
    private _grammarRegistry;
    private _modeService;
    private _scopeRegistry;
    private _injections;
    onDidEncounterLanguage: Event<string>;
    constructor(modeService: IModeService);
    private _handleGrammarExtensionPointUser(extensionFolderPath, syntax, collector);
    private registerDefinition(modeId, scopeName);
}
/**
 * Data associated with a text mate scope as part of decoding.
 *
 * e.g.
 * For a scope "punctuation.definition.string.end.html", the tokens are: punctuation, definition, string, end, html.
 * Each of those tokens receive a unique numeric id, so instead of storing the token strings, we store the token ids.
 * Ultimately this means we store something like [23, 21, 12, 13, 1], considering those numbers to be the ids of the tokens.
 */
export declare class TMScopeDecodeData {
    _tmScopeDecodeDataBrand: void;
    /**
     * The original text mate scope.
     */
    readonly scope: string;
    /**
     * The language this scope belongs to.
     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
     */
    readonly language: string;
    /**
     * The token ids this scope consists of.
     */
    readonly tokenIds: number[];
    constructor(scope: string, language: string, tokenIds: number[]);
}
/**
 * Data associated with a stack of text mate scopes as part of decoding.
 */
export declare class TMScopesDecodeData {
    _tmScopesDecodeDataBrand: void;
    /**
     * The last scope in the stack.
     */
    readonly scope: string;
    /**
     * The resolved tokens mask.
     * tokens[i] === true ===> token with id i is present.
     */
    readonly tokensMask: boolean[];
    /**
     * The resolved language.
     */
    readonly language: string;
    constructor(parent: TMScopesDecodeData, scope: TMScopeDecodeData);
}
export declare class DecodeMap {
    _decodeMapBrand: void;
    private lastAssignedTokenId;
    private readonly languageRegistration;
    private readonly scopeToTokenIds;
    private readonly tokenToTokenId;
    private readonly tokenIdToToken;
    prevTokenScopes: TMScopesDecodeData[];
    readonly topLevelScope: TMScopesDecodeData;
    constructor(languageRegistration: TMLanguageRegistration);
    private _getTokenId(token);
    decodeTMScope(scope: string): TMScopeDecodeData;
    getToken(tokenMap: boolean[]): string;
}
export declare function decodeTextMateTokens(line: string, offsetDelta: number, decodeMap: DecodeMap, resultTokens: IToken[], resultState: TMState): RawLineTokens;
export declare function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): TMScopesDecodeData;
