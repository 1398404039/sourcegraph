/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
require("./minimap.css");
var viewPart_1 = require("vs/editor/browser/view/viewPart");
var runtimeMinimapCharRenderer_1 = require("vs/editor/common/view/runtimeMinimapCharRenderer");
var browser = require("vs/base/browser/browser");
var dom = require("vs/base/browser/dom");
var minimapCharRenderer_1 = require("vs/editor/common/view/minimapCharRenderer");
var editorCommon = require("vs/editor/common/editorCommon");
var fastDomNode_1 = require("vs/base/browser/fastDomNode");
var viewLayer_1 = require("vs/editor/browser/view/viewLayer");
var range_1 = require("vs/editor/common/core/range");
var viewEvents = require("vs/editor/common/view/viewEvents");
var globalMouseMoveMonitor_1 = require("vs/base/browser/globalMouseMoveMonitor");
var platform = require("vs/base/common/platform");
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Small"] = 1] = "Small";
    RenderMinimap[RenderMinimap["Large"] = 2] = "Large";
    RenderMinimap[RenderMinimap["SmallBlocks"] = 3] = "SmallBlocks";
    RenderMinimap[RenderMinimap["LargeBlocks"] = 4] = "LargeBlocks";
})(RenderMinimap || (RenderMinimap = {}));
function getMinimapLineHeight(renderMinimap) {
    if (renderMinimap === 2 /* Large */) {
        return 4 /* x2_CHAR_HEIGHT */;
    }
    if (renderMinimap === 4 /* LargeBlocks */) {
        return 4 /* x2_CHAR_HEIGHT */ + 2;
    }
    if (renderMinimap === 1 /* Small */) {
        return 2 /* x1_CHAR_HEIGHT */;
    }
    // RenderMinimap.SmallBlocks
    return 2 /* x1_CHAR_HEIGHT */ + 1;
}
function getMinimapCharWidth(renderMinimap) {
    if (renderMinimap === 2 /* Large */) {
        return 2 /* x2_CHAR_WIDTH */;
    }
    if (renderMinimap === 4 /* LargeBlocks */) {
        return 2 /* x2_CHAR_WIDTH */;
    }
    if (renderMinimap === 1 /* Small */) {
        return 1 /* x1_CHAR_WIDTH */;
    }
    // RenderMinimap.SmallBlocks
    return 1 /* x1_CHAR_WIDTH */;
}
/**
 * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
 */
var MOUSE_DRAG_RESET_DISTANCE = 140;
var MinimapOptions = (function () {
    function MinimapOptions(configuration) {
        var pixelRatio = browser.getPixelRatio();
        var layoutInfo = configuration.editor.layoutInfo;
        this.renderMinimap = layoutInfo.renderMinimap | 0;
        this.pixelRatio = pixelRatio;
        this.lineHeight = configuration.editor.lineHeight;
        this.minimapWidth = layoutInfo.minimapWidth;
        this.minimapHeight = layoutInfo.height;
        this.canvasInnerWidth = Math.floor(pixelRatio * this.minimapWidth);
        this.canvasInnerHeight = Math.floor(pixelRatio * this.minimapHeight);
        this.canvasOuterWidth = this.canvasInnerWidth / pixelRatio;
        this.canvasOuterHeight = this.canvasInnerHeight / pixelRatio;
    }
    MinimapOptions.prototype.equals = function (other) {
        return (this.renderMinimap === other.renderMinimap
            && this.pixelRatio === other.pixelRatio
            && this.lineHeight === other.lineHeight
            && this.minimapWidth === other.minimapWidth
            && this.minimapHeight === other.minimapHeight
            && this.canvasInnerWidth === other.canvasInnerWidth
            && this.canvasInnerHeight === other.canvasInnerHeight
            && this.canvasOuterWidth === other.canvasOuterWidth
            && this.canvasOuterHeight === other.canvasOuterHeight);
    };
    return MinimapOptions;
}());
var MinimapLayout = (function () {
    function MinimapLayout(lastRenderData, options, viewportStartLineNumber, viewportEndLineNumber, viewportHeight, lineCount, scrollbarSliderCenter) {
        var pixelRatio = options.pixelRatio;
        var minimapLineHeight = getMinimapLineHeight(options.renderMinimap);
        var minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);
        var lineHeight = options.lineHeight;
        // Sometimes, the number of rendered lines varies for a constant viewport height.
        // The reason is that only parts of the viewportStartLineNumber or viewportEndLineNumber are visible.
        // This leads to an apparent tremor in the minimap's slider height.
        // We try here to compensate, making the slider slightly incorrect in these cases, but more pleasing to the eye.
        var viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;
        var expectedViewportLineCount = Math.round(viewportHeight / lineHeight);
        if (viewportLineCount > expectedViewportLineCount) {
            viewportLineCount = expectedViewportLineCount;
        }
        if (minimapLinesFitting >= lineCount) {
            // All lines fit in the minimap => no minimap scrolling
            this.startLineNumber = 1;
            this.endLineNumber = lineCount;
        }
        else {
            // The desire is to align (centers) the minimap's slider with the scrollbar's slider
            // For a resolved this.startLineNumber, we can compute the minimap's slider's center with the following formula:
            // scrollbarSliderCenter = (viewportStartLineNumber - this.startLineNumber + viewportLineCount/2) * minimapLineHeight / pixelRatio;
            // =>
            // scrollbarSliderCenter = (viewportStartLineNumber - this.startLineNumber + viewportLineCount/2) * minimapLineHeight / pixelRatio;
            // scrollbarSliderCenter * pixelRatio / minimapLineHeight = viewportStartLineNumber - this.startLineNumber + viewportLineCount/2
            // this.startLineNumber = viewportStartLineNumber + viewportLineCount/2 - scrollbarSliderCenter * pixelRatio / minimapLineHeight
            var desiredStartLineNumber = Math.floor(viewportStartLineNumber + viewportLineCount / 2 - scrollbarSliderCenter * pixelRatio / minimapLineHeight);
            var desiredEndLineNumber = desiredStartLineNumber + minimapLinesFitting - 1;
            // Aligning the slider's centers can result (correctly) in tremor.
            // i.e. scrolling down might result in the startLineNumber going up.
            // Avoid this tremor by being consistent w.r.t. the previous computed result
            if (lastRenderData) {
                var lastLayoutDecision = lastRenderData.renderedLayout;
                if (lastLayoutDecision.viewportStartLineNumber <= viewportStartLineNumber) {
                    // going down => make sure we don't go above our previous decision
                    if (desiredStartLineNumber < lastLayoutDecision.startLineNumber) {
                        desiredStartLineNumber = lastLayoutDecision.startLineNumber;
                        desiredEndLineNumber = desiredStartLineNumber + minimapLinesFitting - 1;
                    }
                }
                if (lastLayoutDecision.viewportStartLineNumber >= viewportStartLineNumber) {
                    // going up => make sure we don't go below our previous decision
                    if (desiredEndLineNumber > lastLayoutDecision.endLineNumber) {
                        desiredEndLineNumber = lastLayoutDecision.endLineNumber;
                        desiredStartLineNumber = desiredEndLineNumber - minimapLinesFitting + 1;
                    }
                }
            }
            // Aligning the slider's centers is a very good thing, but this would make
            // the minimap never scroll all the way to the top or to the bottom of the file.
            // We therefore check that the viewport lines are in the minimap viewport.
            // (a) validate on start line number
            if (desiredStartLineNumber < 1) {
                // must start after 1
                desiredStartLineNumber = 1;
                desiredEndLineNumber = desiredStartLineNumber + minimapLinesFitting - 1;
            }
            if (desiredStartLineNumber > viewportStartLineNumber) {
                // must contain the viewport's start line number
                desiredStartLineNumber = viewportStartLineNumber;
                desiredEndLineNumber = desiredStartLineNumber + minimapLinesFitting - 1;
            }
            // (b) validate on end line number
            if (desiredEndLineNumber > lineCount) {
                // must end before line count
                desiredEndLineNumber = lineCount;
                desiredStartLineNumber = desiredEndLineNumber - minimapLinesFitting + 1;
            }
            if (desiredEndLineNumber < viewportEndLineNumber) {
                // must contain the viewport's end line number
                desiredEndLineNumber = viewportEndLineNumber;
                desiredStartLineNumber = desiredEndLineNumber - minimapLinesFitting + 1;
            }
            this.startLineNumber = desiredStartLineNumber;
            this.endLineNumber = desiredEndLineNumber;
        }
        this.sliderTop = Math.floor((viewportStartLineNumber - this.startLineNumber) * minimapLineHeight / pixelRatio);
        if (viewportEndLineNumber === lineCount) {
            // The last line is in the viewport => try to extend slider height below the painted lines
            var desiredSliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);
            if (this.sliderTop + desiredSliderHeight > options.minimapHeight) {
                this.sliderHeight = options.minimapHeight - this.sliderTop;
            }
            else {
                this.sliderHeight = desiredSliderHeight;
            }
        }
        else {
            this.sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);
        }
    }
    return MinimapLayout;
}());
var RenderedLayout = (function () {
    function RenderedLayout(viewportStartLineNumber, viewportEndLineNumber, startLineNumber, endLineNumber) {
        this.viewportStartLineNumber = viewportStartLineNumber;
        this.viewportEndLineNumber = viewportEndLineNumber;
        this.startLineNumber = startLineNumber;
        this.endLineNumber = endLineNumber;
    }
    return RenderedLayout;
}());
var MinimapLine = (function () {
    function MinimapLine(dy) {
        this.dy = dy;
    }
    MinimapLine.prototype.onContentChanged = function () {
        this.dy = -1;
    };
    MinimapLine.prototype.onTokensChanged = function () {
        this.dy = -1;
    };
    return MinimapLine;
}());
MinimapLine.INVALID = new MinimapLine(-1);
var RenderData = (function () {
    function RenderData(renderedLayout, imageData, lines) {
        this.renderedLayout = renderedLayout;
        this._imageData = imageData;
        this._renderedLines = new viewLayer_1.RenderedLinesCollection(function () { return MinimapLine.INVALID; });
        this._renderedLines._set(renderedLayout.startLineNumber, lines);
    }
    RenderData.prototype._get = function () {
        var tmp = this._renderedLines._get();
        return {
            imageData: this._imageData,
            rendLineNumberStart: tmp.rendLineNumberStart,
            lines: tmp.lines
        };
    };
    RenderData.prototype.onLinesChanged = function (e) {
        return this._renderedLines.onLinesChanged(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onLinesDeleted = function (e) {
        this._renderedLines.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onLinesInserted = function (e) {
        this._renderedLines.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    };
    RenderData.prototype.onTokensChanged = function (e) {
        return this._renderedLines.onTokensChanged(e.ranges);
    };
    return RenderData;
}());
/**
 * Some sort of double buffering.
 *
 * Keeps two buffers around that will be rotated for painting.
 * Always gives a buffer that is filled with the background color.
 */
var MinimapBuffers = (function () {
    function MinimapBuffers(ctx, WIDTH, HEIGHT, background) {
        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);
        this._buffers = [
            ctx.createImageData(WIDTH, HEIGHT),
            ctx.createImageData(WIDTH, HEIGHT)
        ];
        this._lastUsedBuffer = 0;
    }
    MinimapBuffers.prototype.getBuffer = function () {
        // rotate buffers
        this._lastUsedBuffer = 1 - this._lastUsedBuffer;
        var result = this._buffers[this._lastUsedBuffer];
        // fill with background color
        result.data.set(this._backgroundFillData);
        return result;
    };
    MinimapBuffers._createBackgroundFillData = function (WIDTH, HEIGHT, background) {
        var backgroundR = background.r;
        var backgroundG = background.g;
        var backgroundB = background.b;
        var result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);
        var offset = 0;
        for (var i = 0; i < HEIGHT; i++) {
            for (var j = 0; j < WIDTH; j++) {
                result[offset] = backgroundR;
                result[offset + 1] = backgroundG;
                result[offset + 2] = backgroundB;
                result[offset + 3] = 255;
                offset += 4;
            }
        }
        return result;
    };
    return MinimapBuffers;
}());
var Minimap = (function (_super) {
    __extends(Minimap, _super);
    function Minimap(context, viewLayout, editorScrollbar) {
        var _this = _super.call(this, context) || this;
        _this._viewLayout = viewLayout;
        _this._editorScrollbar = editorScrollbar;
        _this._options = new MinimapOptions(_this._context.configuration);
        _this._lastRenderData = null;
        _this._buffers = null;
        _this._domNode = fastDomNode_1.createFastDomNode(document.createElement('div'));
        _this._domNode.setClassName('minimap');
        _this._domNode.setPosition('absolute');
        _this._domNode.setRight(_this._context.configuration.editor.layoutInfo.verticalScrollbarWidth);
        _this._shadow = fastDomNode_1.createFastDomNode(document.createElement('div'));
        _this._shadow.setClassName('minimap-shadow-hidden');
        _this._domNode.domNode.appendChild(_this._shadow.domNode);
        _this._canvas = fastDomNode_1.createFastDomNode(document.createElement('canvas'));
        _this._canvas.setPosition('absolute');
        _this._canvas.setLeft(0);
        _this._domNode.domNode.appendChild(_this._canvas.domNode);
        _this._slider = fastDomNode_1.createFastDomNode(document.createElement('div'));
        _this._slider.setPosition('absolute');
        _this._slider.setClassName('minimap-slider');
        _this._domNode.domNode.appendChild(_this._slider.domNode);
        _this._tokensColorTracker = minimapCharRenderer_1.MinimapTokensColorTracker.getInstance();
        _this._minimapCharRenderer = runtimeMinimapCharRenderer_1.getOrCreateMinimapCharRenderer();
        _this._applyLayout();
        _this._mouseDownListener = dom.addStandardDisposableListener(_this._canvas.domNode, 'mousedown', function (e) {
            e.preventDefault();
            var renderMinimap = _this._options.renderMinimap;
            if (renderMinimap === 0 /* None */) {
                return;
            }
            if (!_this._lastRenderData) {
                return;
            }
            var minimapLineHeight = getMinimapLineHeight(renderMinimap);
            var internalOffsetY = _this._options.pixelRatio * e.browserEvent.offsetY;
            var lineIndex = Math.floor(internalOffsetY / minimapLineHeight);
            var lineNumber = lineIndex + _this._lastRenderData.renderedLayout.startLineNumber;
            lineNumber = Math.min(lineNumber, _this._context.model.getLineCount());
            _this._context.privateViewEventBus.emit(new viewEvents.ViewRevealRangeRequestEvent(new range_1.Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, false, false));
        });
        _this._sliderMouseMoveMonitor = new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor();
        _this._sliderMouseDownListener = dom.addStandardDisposableListener(_this._slider.domNode, 'mousedown', function (e) {
            e.preventDefault();
            if (e.leftButton) {
                var initialMouseOrthogonalPosition_1 = e.posx;
                var initialScrollTop_1 = _this._viewLayout.getScrollTop();
                var initialSliderCenter = (_this._slider.getTop() + _this._slider.getHeight() / 2);
                var draggingDeltaCenter_1 = e.posy - initialSliderCenter;
                _this._slider.toggleClassName('active', true);
                _this._sliderMouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                    var mouseOrthogonalPosition = mouseMoveData.posx;
                    var mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition_1);
                    if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
                        // The mouse has wondered away from the slider => reset dragging
                        _this._viewLayout.setScrollPosition({
                            scrollTop: initialScrollTop_1
                        });
                    }
                    else {
                        var pixelRatio = _this._options.pixelRatio;
                        var minimapLineHeight = getMinimapLineHeight(_this._options.renderMinimap);
                        var entireCanvasOuterHeight = _this._context.model.getLineCount() * minimapLineHeight / pixelRatio;
                        var representableHeight = Math.min(entireCanvasOuterHeight, _this._options.canvasOuterHeight);
                        // Account for the fact that the minimap does not render the extra space below the viewport
                        var discountScrollHeight = 0;
                        if (_this._context.configuration.editor.viewInfo.scrollBeyondLastLine) {
                            discountScrollHeight = _this._canvas.getHeight() - _this._context.configuration.editor.lineHeight;
                        }
                        var scrollHeight = _this._viewLayout.getScrollHeight() - discountScrollHeight;
                        var desiredSliderCenter = mouseMoveData.posy - draggingDeltaCenter_1;
                        var desiredScrollCenter = desiredSliderCenter * (scrollHeight / representableHeight);
                        var desiredScrollTop = desiredScrollCenter - _this._canvas.getHeight() / 2;
                        _this._viewLayout.setScrollPosition({
                            scrollTop: desiredScrollTop
                        });
                    }
                }, function () {
                    _this._slider.toggleClassName('active', false);
                });
            }
        });
        return _this;
    }
    Minimap.prototype.dispose = function () {
        this._mouseDownListener.dispose();
        this._sliderMouseMoveMonitor.dispose();
        this._sliderMouseDownListener.dispose();
        _super.prototype.dispose.call(this);
    };
    Minimap.prototype.getDomNode = function () {
        return this._domNode.domNode;
    };
    Minimap.prototype._applyLayout = function () {
        this._domNode.setWidth(this._options.minimapWidth);
        this._domNode.setHeight(this._options.minimapHeight);
        this._shadow.setHeight(this._options.minimapHeight);
        this._canvas.setWidth(this._options.canvasOuterWidth);
        this._canvas.setHeight(this._options.canvasOuterHeight);
        this._canvas.domNode.width = this._options.canvasInnerWidth;
        this._canvas.domNode.height = this._options.canvasInnerHeight;
        this._slider.setWidth(this._options.minimapWidth);
    };
    Minimap.prototype._getBuffer = function () {
        if (!this._buffers) {
            this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._options.canvasInnerWidth, this._options.canvasInnerHeight, this._tokensColorTracker.getColor(2 /* DefaultBackground */));
        }
        return this._buffers.getBuffer();
    };
    Minimap.prototype._onOptionsMaybeChanged = function () {
        var opts = new MinimapOptions(this._context.configuration);
        if (this._options.equals(opts)) {
            return false;
        }
        this._options = opts;
        this._lastRenderData = null;
        this._buffers = null;
        this._applyLayout();
        return true;
    };
    // ---- begin view event handlers
    Minimap.prototype.onConfigurationChanged = function (e) {
        return this._onOptionsMaybeChanged();
    };
    Minimap.prototype.onFlushed = function (e) {
        this._lastRenderData = null;
        return true;
    };
    Minimap.prototype.onLinesChanged = function (e) {
        if (this._lastRenderData) {
            return this._lastRenderData.onLinesChanged(e);
        }
        return false;
    };
    Minimap.prototype.onLinesDeleted = function (e) {
        if (this._lastRenderData) {
            this._lastRenderData.onLinesDeleted(e);
        }
        return true;
    };
    Minimap.prototype.onLinesInserted = function (e) {
        if (this._lastRenderData) {
            this._lastRenderData.onLinesInserted(e);
        }
        return true;
    };
    Minimap.prototype.onScrollChanged = function (e) {
        return true;
    };
    Minimap.prototype.onTokensChanged = function (e) {
        if (this._lastRenderData) {
            return this._lastRenderData.onTokensChanged(e);
        }
        return false;
    };
    Minimap.prototype.onTokensColorsChanged = function (e) {
        this._lastRenderData = null;
        this._buffers = null;
        return true;
    };
    Minimap.prototype.onZonesChanged = function (e) {
        this._lastRenderData = null;
        return true;
    };
    // --- end event handlers
    Minimap.prototype.prepareRender = function (ctx) {
        // Nothing to read
    };
    Minimap.prototype.render = function (renderingCtx) {
        var renderMinimap = this._options.renderMinimap;
        if (renderMinimap === 0 /* None */) {
            this._shadow.setClassName('minimap-shadow-hidden');
            return;
        }
        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {
            this._shadow.setClassName('minimap-shadow-hidden');
        }
        else {
            this._shadow.setClassName('minimap-shadow-visible');
        }
        var layout = new MinimapLayout(this._lastRenderData, this._options, renderingCtx.visibleRange.startLineNumber, renderingCtx.visibleRange.endLineNumber, renderingCtx.viewportHeight, this._context.model.getLineCount(), this._editorScrollbar.getVerticalSliderVerticalCenter());
        this._slider.setTop(layout.sliderTop);
        this._slider.setHeight(layout.sliderHeight);
        var startLineNumber = layout.startLineNumber;
        var endLineNumber = layout.endLineNumber;
        var minimapLineHeight = getMinimapLineHeight(renderMinimap);
        var imageData = this._getBuffer();
        // Render untouched lines by using last rendered data.
        var needed = Minimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);
        // Fetch rendering info from view model for rest of lines that need rendering.
        var lineInfo = this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);
        var tabSize = lineInfo.tabSize;
        var background = this._tokensColorTracker.getColor(2 /* DefaultBackground */);
        var useLighterFont = this._tokensColorTracker.backgroundIsLight();
        // Render the rest of lines
        var dy = 0;
        var renderedLines = [];
        for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {
            if (needed[lineIndex]) {
                Minimap._renderLine(imageData, background, useLighterFont, renderMinimap, this._tokensColorTracker, this._minimapCharRenderer, dy, tabSize, lineInfo.data[lineIndex]);
            }
            renderedLines[lineIndex] = new MinimapLine(dy);
            dy += minimapLineHeight;
        }
        // Save rendered data for reuse on next frame if possible
        this._lastRenderData = new RenderData(new RenderedLayout(renderingCtx.visibleRange.startLineNumber, renderingCtx.visibleRange.endLineNumber, startLineNumber, endLineNumber), imageData, renderedLines);
        // Finally, paint to the canvas
        var ctx = this._canvas.domNode.getContext('2d');
        ctx.putImageData(imageData, 0, 0);
    };
    Minimap._renderUntouchedLines = function (target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {
        var needed = [];
        if (!lastRenderData) {
            for (var i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {
                needed[i] = true;
            }
            return needed;
        }
        var _lastData = lastRenderData._get();
        var lastTargetData = _lastData.imageData.data;
        var lastStartLineNumber = _lastData.rendLineNumberStart;
        var lastLines = _lastData.lines;
        var lastLinesLength = lastLines.length;
        var WIDTH = target.width;
        var targetData = target.data;
        var copySourceStart = -1;
        var copySourceEnd = -1;
        var copyDestStart = -1;
        var copyDestEnd = -1;
        var dest_dy = 0;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineIndex = lineNumber - startLineNumber;
            var lastLineIndex = lineNumber - lastStartLineNumber;
            var source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);
            if (source_dy === -1) {
                needed[lineIndex] = true;
                dest_dy += minimapLineHeight;
                continue;
            }
            var sourceStart = source_dy * WIDTH * 4;
            var sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;
            var destStart = dest_dy * WIDTH * 4;
            var destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;
            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {
                // contiguous zone => extend copy request
                copySourceEnd = sourceEnd;
                copyDestEnd = destEnd;
            }
            else {
                if (copySourceStart !== -1) {
                    // flush existing copy request
                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
                }
                copySourceStart = sourceStart;
                copySourceEnd = sourceEnd;
                copyDestStart = destStart;
                copyDestEnd = destEnd;
            }
            needed[lineIndex] = false;
            dest_dy += minimapLineHeight;
        }
        if (copySourceStart !== -1) {
            // flush existing copy request
            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);
        }
        return needed;
    };
    Minimap._renderLine = function (target, backgroundColor, useLighterFont, renderMinimap, colorTracker, minimapCharRenderer, dy, tabSize, lineData) {
        var content = lineData.content;
        var tokens = lineData.tokens;
        var charWidth = getMinimapCharWidth(renderMinimap);
        var maxDx = target.width - charWidth;
        var dx = 0;
        var charIndex = 0;
        var tabsCharDelta = 0;
        for (var tokenIndex = 0, tokensLen = tokens.length; tokenIndex < tokensLen; tokenIndex++) {
            var token = tokens[tokenIndex];
            var tokenEndIndex = token.endIndex;
            var tokenColorId = token.getForeground();
            var tokenColor = colorTracker.getColor(tokenColorId);
            for (; charIndex < tokenEndIndex; charIndex++) {
                if (dx > maxDx) {
                    // hit edge of minimap
                    return;
                }
                var charCode = content.charCodeAt(charIndex);
                if (charCode === 9 /* Tab */) {
                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                    tabsCharDelta += insertSpacesCount - 1;
                    // No need to render anything since tab is invisible
                    dx += insertSpacesCount * charWidth;
                }
                else if (charCode === 32 /* Space */) {
                    // No need to render anything since space is invisible
                    dx += charWidth;
                }
                else {
                    if (renderMinimap === 2 /* Large */) {
                        minimapCharRenderer.x2RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);
                    }
                    else if (renderMinimap === 1 /* Small */) {
                        minimapCharRenderer.x1RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);
                    }
                    else if (renderMinimap === 4 /* LargeBlocks */) {
                        minimapCharRenderer.x2BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);
                    }
                    else {
                        // RenderMinimap.SmallBlocks
                        minimapCharRenderer.x1BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);
                    }
                    dx += charWidth;
                }
            }
        }
    };
    return Minimap;
}(viewPart_1.ViewPart));
exports.Minimap = Minimap;
