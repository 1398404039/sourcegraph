/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var viewPart_1 = require("vs/editor/browser/view/viewPart");
var styleMutator_1 = require("vs/base/browser/styleMutator");
var RenderedLinesCollection = (function () {
    function RenderedLinesCollection(createLine) {
        this._lines = [];
        this._rendLineNumberStart = 1;
        this._createLine = createLine;
    }
    RenderedLinesCollection.prototype._set = function (rendLineNumberStart, lines) {
        this._lines = lines;
        this._rendLineNumberStart = rendLineNumberStart;
    };
    RenderedLinesCollection.prototype._get = function () {
        return {
            rendLineNumberStart: this._rendLineNumberStart,
            lines: this._lines
        };
    };
    /**
     * @returns Inclusive line number that is inside this collection
     */
    RenderedLinesCollection.prototype.getStartLineNumber = function () {
        return this._rendLineNumberStart;
    };
    /**
     * @returns Inclusive line number that is inside this collection
     */
    RenderedLinesCollection.prototype.getEndLineNumber = function () {
        return this._rendLineNumberStart + this._lines.length - 1;
    };
    RenderedLinesCollection.prototype.getCount = function () {
        return this._lines.length;
    };
    RenderedLinesCollection.prototype.getLine = function (lineNumber) {
        var lineIndex = lineNumber - this._rendLineNumberStart;
        if (lineIndex < 0 || lineIndex >= this._lines.length) {
            throw new Error('Illegal value for lineNumber: ' + lineNumber);
        }
        return this._lines[lineIndex];
    };
    /**
     * @returns Lines that were removed from this collection
     */
    RenderedLinesCollection.prototype.onModelLinesDeleted = function (deleteFromLineNumber, deleteToLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return null;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        // Record what needs to be deleted, notify lines that survive after deletion
        var deleteStartIndex = 0;
        var deleteCount = 0;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {
                // this is a line to be deleted
                if (deleteCount === 0) {
                    // this is the first line to be deleted
                    deleteStartIndex = lineIndex;
                    deleteCount = 1;
                }
                else {
                    deleteCount++;
                }
            }
        }
        // Adjust this._rendLineNumberStart for lines deleted above
        if (deleteFromLineNumber < startLineNumber) {
            // Something was deleted above
            var deleteAboveCount = 0;
            if (deleteToLineNumber < startLineNumber) {
                // the entire deleted lines are above
                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;
            }
            else {
                deleteAboveCount = startLineNumber - deleteFromLineNumber;
            }
            this._rendLineNumberStart -= deleteAboveCount;
        }
        var deleted = this._lines.splice(deleteStartIndex, deleteCount);
        return deleted;
    };
    RenderedLinesCollection.prototype.onModelLineChanged = function (changedLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return false;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        // Notify lines after the change
        var notifiedSomeone = false;
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (lineNumber === changedLineNumber) {
                this._lines[lineIndex].onContentChanged();
                notifiedSomeone = true;
            }
        }
        return notifiedSomeone;
    };
    RenderedLinesCollection.prototype.onModelLinesInserted = function (insertFromLineNumber, insertToLineNumber) {
        if (this.getCount() === 0) {
            // no lines
            return null;
        }
        var insertCnt = insertToLineNumber - insertFromLineNumber + 1;
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        if (insertFromLineNumber <= startLineNumber) {
            // inserting above the viewport
            this._rendLineNumberStart += insertCnt;
            return null;
        }
        if (insertFromLineNumber > endLineNumber) {
            // inserting below the viewport
            return null;
        }
        if (insertCnt + insertFromLineNumber > endLineNumber) {
            // insert inside the viewport in such a way that all remaining lines are pushed outside
            var deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);
            return deleted;
        }
        // insert inside the viewport, push out some lines, but not all remaining lines
        var newLines = [];
        for (var i = 0; i < insertCnt; i++) {
            newLines[i] = this._createLine();
        }
        var insertIndex = insertFromLineNumber - this._rendLineNumberStart;
        var beforeLines = this._lines.slice(0, insertIndex);
        var afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);
        var deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);
        this._lines = beforeLines.concat(newLines).concat(afterLines);
        return deletedLines;
    };
    RenderedLinesCollection.prototype.onModelTokensChanged = function (ranges) {
        if (this.getCount() === 0) {
            // no lines
            return false;
        }
        var startLineNumber = this.getStartLineNumber();
        var endLineNumber = this.getEndLineNumber();
        var notifiedSomeone = false;
        for (var i = 0, len = ranges.length; i < len; i++) {
            var rng = ranges[i];
            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {
                // range outside viewport
                continue;
            }
            var from = Math.max(startLineNumber, rng.fromLineNumber);
            var to = Math.min(endLineNumber, rng.toLineNumber);
            for (var lineNumber = from; lineNumber <= to; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                this._lines[lineIndex].onTokensChanged();
                notifiedSomeone = true;
            }
        }
        return notifiedSomeone;
    };
    return RenderedLinesCollection;
}());
exports.RenderedLinesCollection = RenderedLinesCollection;
var ViewLayer = (function (_super) {
    __extends(ViewLayer, _super);
    function ViewLayer(context) {
        var _this = _super.call(this, context) || this;
        _this.domNode = _this._createDomNode();
        _this._linesCollection = new RenderedLinesCollection(function () { return _this._createLine(); });
        _this._scrollDomNode = null;
        _this._scrollDomNodeIsAbove = false;
        _this._renderer = new ViewLayerRenderer(function () { return _this._createLine(); });
        return _this;
    }
    ViewLayer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._linesCollection = null;
    };
    // ---- begin view event handlers
    ViewLayer.prototype.onConfigurationChanged = function (e) {
        var startLineNumber = this._linesCollection.getStartLineNumber();
        var endLineNumber = this._linesCollection.getEndLineNumber();
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var line = this._linesCollection.getLine(lineNumber);
            line.onConfigurationChanged(e);
        }
        return true;
    };
    ViewLayer.prototype.onLayoutChanged = function (layoutInfo) {
        return true;
    };
    ViewLayer.prototype.onScrollChanged = function (e) {
        return e.scrollTopChanged;
    };
    ViewLayer.prototype.onZonesChanged = function () {
        return true;
    };
    ViewLayer.prototype.onModelFlushed = function () {
        var _this = this;
        this._linesCollection = new RenderedLinesCollection(function () { return _this._createLine(); });
        this._scrollDomNode = null;
        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render
        return true;
    };
    ViewLayer.prototype.onModelLinesDeleted = function (e) {
        var deleted = this._linesCollection.onModelLinesDeleted(e.fromLineNumber, e.toLineNumber);
        if (deleted) {
            // Remove from DOM
            for (var i = 0, len = deleted.length; i < len; i++) {
                var lineDomNode = deleted[i].getDomNode();
                if (lineDomNode) {
                    this.domNode.domNode.removeChild(lineDomNode);
                }
            }
        }
        return true;
    };
    ViewLayer.prototype.onModelLineChanged = function (e) {
        return this._linesCollection.onModelLineChanged(e.lineNumber);
    };
    ViewLayer.prototype.onModelLinesInserted = function (e) {
        var deleted = this._linesCollection.onModelLinesInserted(e.fromLineNumber, e.toLineNumber);
        if (deleted) {
            // Remove from DOM
            for (var i = 0, len = deleted.length; i < len; i++) {
                var lineDomNode = deleted[i].getDomNode();
                if (lineDomNode) {
                    this.domNode.domNode.removeChild(lineDomNode);
                }
            }
        }
        return true;
    };
    ViewLayer.prototype.onModelTokensChanged = function (e) {
        return this._linesCollection.onModelTokensChanged(e.ranges);
    };
    // ---- end view event handlers
    ViewLayer.prototype._renderLines = function (linesViewportData) {
        var inp = this._linesCollection._get();
        var ctx = {
            domNode: this.domNode.domNode,
            rendLineNumberStart: inp.rendLineNumberStart,
            lines: inp.lines,
            linesLength: inp.lines.length,
            getInlineDecorationsForLineInViewport: function (lineNumber) { return linesViewportData.getInlineDecorationsForLineInViewport(lineNumber); },
            viewportTop: linesViewportData.viewportTop,
            viewportHeight: linesViewportData.viewportHeight,
            scrollDomNode: this._scrollDomNode,
            scrollDomNodeIsAbove: this._scrollDomNodeIsAbove
        };
        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)
        var resCtx = this._renderer.renderWithManyUpdates(ctx, linesViewportData.startLineNumber, linesViewportData.endLineNumber, linesViewportData.relativeVerticalOffset);
        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);
        this._scrollDomNode = resCtx.scrollDomNode;
        this._scrollDomNodeIsAbove = resCtx.scrollDomNodeIsAbove;
    };
    ViewLayer.prototype._createDomNode = function () {
        var domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
        domNode.setClassName('view-layer');
        domNode.setPosition('absolute');
        domNode.domNode.setAttribute('role', 'presentation');
        domNode.domNode.setAttribute('aria-hidden', 'true');
        return domNode;
    };
    return ViewLayer;
}(viewPart_1.ViewPart));
exports.ViewLayer = ViewLayer;
var ViewLayerRenderer = (function () {
    function ViewLayerRenderer(createLine) {
        this._createLine = createLine;
    }
    ViewLayerRenderer.prototype.renderWithManyUpdates = function (ctx, startLineNumber, stopLineNumber, deltaTop) {
        return this._render(ctx, startLineNumber, stopLineNumber, deltaTop);
    };
    ViewLayerRenderer.prototype._render = function (inContext, startLineNumber, stopLineNumber, deltaTop) {
        var ctx = {
            domNode: inContext.domNode,
            rendLineNumberStart: inContext.rendLineNumberStart,
            lines: inContext.lines.slice(0),
            linesLength: inContext.linesLength,
            getInlineDecorationsForLineInViewport: inContext.getInlineDecorationsForLineInViewport,
            viewportTop: inContext.viewportTop,
            viewportHeight: inContext.viewportHeight,
            scrollDomNode: inContext.scrollDomNode,
            scrollDomNodeIsAbove: inContext.scrollDomNodeIsAbove
        };
        var canRemoveScrollDomNode = true;
        if (ctx.scrollDomNode) {
            var time = this._getScrollDomNodeTime(ctx.scrollDomNode);
            if ((new Date()).getTime() - time < 1000) {
                canRemoveScrollDomNode = false;
            }
        }
        if (canRemoveScrollDomNode && ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart))) {
            // There is no overlap whatsoever
            ctx.rendLineNumberStart = startLineNumber;
            ctx.linesLength = stopLineNumber - startLineNumber + 1;
            ctx.lines = [];
            for (var x = startLineNumber; x <= stopLineNumber; x++) {
                ctx.lines[x - startLineNumber] = this._createLine();
            }
            this._finishRendering(ctx, true, deltaTop);
            ctx.scrollDomNode = null;
            return ctx;
        }
        // Update lines which will remain untouched
        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);
        if (ctx.rendLineNumberStart > startLineNumber) {
            // Insert lines before
            var fromLineNumber = startLineNumber;
            var toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);
            if (fromLineNumber <= toLineNumber) {
                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                ctx.linesLength += toLineNumber - fromLineNumber + 1;
                // Clean garbage above
                if (ctx.scrollDomNode && ctx.scrollDomNodeIsAbove) {
                    if (ctx.scrollDomNode.parentNode) {
                        ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                    }
                    ctx.scrollDomNode = null;
                }
            }
        }
        else if (ctx.rendLineNumberStart < startLineNumber) {
            // Remove lines before
            var removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);
            if (removeCnt > 0) {
                this._removeLinesBefore(ctx, removeCnt);
                ctx.linesLength -= removeCnt;
            }
        }
        ctx.rendLineNumberStart = startLineNumber;
        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {
            // Insert lines after
            var fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;
            var toLineNumber = stopLineNumber;
            if (fromLineNumber <= toLineNumber) {
                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                ctx.linesLength += toLineNumber - fromLineNumber + 1;
                // Clean garbage below
                if (ctx.scrollDomNode && !ctx.scrollDomNodeIsAbove) {
                    if (ctx.scrollDomNode.parentNode) {
                        ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                    }
                    ctx.scrollDomNode = null;
                }
            }
        }
        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {
            // Remove lines after
            var fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);
            var toLineNumber = ctx.linesLength - 1;
            var removeCnt = toLineNumber - fromLineNumber + 1;
            if (removeCnt > 0) {
                this._removeLinesAfter(ctx, removeCnt);
                ctx.linesLength -= removeCnt;
            }
        }
        this._finishRendering(ctx, false, deltaTop);
        return ctx;
    };
    ViewLayerRenderer.prototype._renderUntouchedLines = function (ctx, startIndex, endIndex, deltaTop, deltaLN) {
        for (var i = startIndex; i <= endIndex; i++) {
            var lineNumber = ctx.rendLineNumberStart + i;
            var lineDomNode = ctx.lines[i].getDomNode();
            if (lineDomNode) {
                ctx.lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
            }
        }
    };
    ViewLayerRenderer.prototype._insertLinesBefore = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
        var newLines = [];
        var newLinesLen = 0;
        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            newLines[newLinesLen++] = this._createLine();
        }
        ctx.lines = newLines.concat(ctx.lines);
    };
    ViewLayerRenderer.prototype._getScrollDomNodeTime = function (domNode) {
        var lastScrollTime = domNode.getAttribute('last-scroll-time');
        if (lastScrollTime) {
            return parseInt(lastScrollTime, 10);
        }
        return 0;
    };
    ViewLayerRenderer.prototype._removeIfNotScrollDomNode = function (ctx, domNode, isAbove) {
        var time = this._getScrollDomNodeTime(domNode);
        if (!time) {
            ctx.domNode.removeChild(domNode);
            return;
        }
        if (ctx.scrollDomNode) {
            var otherTime = this._getScrollDomNodeTime(ctx.scrollDomNode);
            if (otherTime > time) {
                // The other is the real scroll dom node
                ctx.domNode.removeChild(domNode);
                return;
            }
            if (ctx.scrollDomNode.parentNode) {
                ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
            }
            ctx.scrollDomNode = null;
        }
        ctx.scrollDomNode = domNode;
        ctx.scrollDomNodeIsAbove = isAbove;
    };
    ViewLayerRenderer.prototype._removeLinesBefore = function (ctx, removeCount) {
        for (var i = 0; i < removeCount; i++) {
            var lineDomNode = ctx.lines[i].getDomNode();
            if (lineDomNode) {
                this._removeIfNotScrollDomNode(ctx, lineDomNode, true);
            }
        }
        ctx.lines.splice(0, removeCount);
    };
    ViewLayerRenderer.prototype._insertLinesAfter = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
        var newLines = [];
        var newLinesLen = 0;
        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            newLines[newLinesLen++] = this._createLine();
        }
        ctx.lines = ctx.lines.concat(newLines);
    };
    ViewLayerRenderer.prototype._removeLinesAfter = function (ctx, removeCount) {
        var removeIndex = ctx.linesLength - removeCount;
        for (var i = 0; i < removeCount; i++) {
            var lineDomNode = ctx.lines[removeIndex + i].getDomNode();
            if (lineDomNode) {
                this._removeIfNotScrollDomNode(ctx, lineDomNode, false);
            }
        }
        ctx.lines.splice(removeIndex, removeCount);
    };
    ViewLayerRenderer._resolveInlineDecorations = function (ctx) {
        var result = [];
        for (var i = 0, len = ctx.linesLength; i < len; i++) {
            var lineNumber = i + ctx.rendLineNumberStart;
            result[i] = ctx.getInlineDecorationsForLineInViewport(lineNumber);
        }
        return result;
    };
    ViewLayerRenderer.prototype._finishRenderingNewLines = function (ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
        var lastChild = ctx.domNode.lastChild;
        if (domNodeIsEmpty || !lastChild) {
            ctx.domNode.innerHTML = newLinesHTML.join('');
        }
        else {
            lastChild.insertAdjacentHTML('afterend', newLinesHTML.join(''));
        }
        var currChild = ctx.domNode.lastChild;
        for (var i = ctx.linesLength - 1; i >= 0; i--) {
            var line = ctx.lines[i];
            if (wasNew[i]) {
                line.setDomNode(currChild);
                currChild = currChild.previousSibling;
            }
        }
    };
    ViewLayerRenderer.prototype._finishRenderingInvalidLines = function (ctx, invalidLinesHTML, wasInvalid) {
        var hugeDomNode = document.createElement('div');
        hugeDomNode.innerHTML = invalidLinesHTML.join('');
        for (var i = 0; i < ctx.linesLength; i++) {
            var line = ctx.lines[i];
            if (wasInvalid[i]) {
                var source = hugeDomNode.firstChild;
                var lineDomNode = line.getDomNode();
                lineDomNode.parentNode.replaceChild(source, lineDomNode);
                line.setDomNode(source);
            }
        }
    };
    ViewLayerRenderer.prototype._finishRendering = function (ctx, domNodeIsEmpty, deltaTop) {
        var inlineDecorations = ViewLayerRenderer._resolveInlineDecorations(ctx);
        var hadNewLine = false;
        var wasNew = [];
        var newLinesHTML = [];
        var hadInvalidLine = false;
        var wasInvalid = [];
        var invalidLinesHTML = [];
        for (var i = 0, len = ctx.linesLength; i < len; i++) {
            var line = ctx.lines[i];
            var lineNumber = i + ctx.rendLineNumberStart;
            if (line.shouldUpdateHTML(ctx.rendLineNumberStart, lineNumber, inlineDecorations[i])) {
                var lineDomNode = line.getDomNode();
                if (!lineDomNode) {
                    // Line is new
                    line.getLineOuterHTML(newLinesHTML, lineNumber, deltaTop[i]);
                    wasNew[i] = true;
                    hadNewLine = true;
                }
                else {
                    // Line is invalid
                    line.getLineOuterHTML(invalidLinesHTML, lineNumber, deltaTop[i]);
                    wasInvalid[i] = true;
                    hadInvalidLine = true;
                }
            }
        }
        if (hadNewLine) {
            this._finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew);
        }
        if (hadInvalidLine) {
            this._finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid);
        }
    };
    return ViewLayerRenderer;
}());
