/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var errors_1 = require("vs/base/common/errors");
var lifecycle_1 = require("vs/base/common/lifecycle");
var browser = require("vs/base/browser/browser");
var dom = require("vs/base/browser/dom");
var fastDomNode_1 = require("vs/base/browser/fastDomNode");
var range_1 = require("vs/editor/common/core/range");
var editorCommon = require("vs/editor/common/editorCommon");
var viewEventHandler_1 = require("vs/editor/common/viewModel/viewEventHandler");
var keyboardHandler_1 = require("vs/editor/browser/controller/keyboardHandler");
var pointerHandler_1 = require("vs/editor/browser/controller/pointerHandler");
var editorBrowser = require("vs/editor/browser/editorBrowser");
var viewController_1 = require("vs/editor/browser/view/viewController");
var viewEventDispatcher_1 = require("vs/editor/common/view/viewEventDispatcher");
var viewOverlays_1 = require("vs/editor/browser/view/viewOverlays");
var viewLayout_1 = require("vs/editor/common/viewLayout/viewLayout");
var contentWidgets_1 = require("vs/editor/browser/viewParts/contentWidgets/contentWidgets");
var currentLineHighlight_1 = require("vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight");
var currentLineMarginHighlight_1 = require("vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight");
var decorations_1 = require("vs/editor/browser/viewParts/decorations/decorations");
var glyphMargin_1 = require("vs/editor/browser/viewParts/glyphMargin/glyphMargin");
var lineNumbers_1 = require("vs/editor/browser/viewParts/lineNumbers/lineNumbers");
var indentGuides_1 = require("vs/editor/browser/viewParts/indentGuides/indentGuides");
var viewLines_1 = require("vs/editor/browser/viewParts/lines/viewLines");
var margin_1 = require("vs/editor/browser/viewParts/margin/margin");
var linesDecorations_1 = require("vs/editor/browser/viewParts/linesDecorations/linesDecorations");
var marginDecorations_1 = require("vs/editor/browser/viewParts/marginDecorations/marginDecorations");
var overlayWidgets_1 = require("vs/editor/browser/viewParts/overlayWidgets/overlayWidgets");
var decorationsOverviewRuler_1 = require("vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler");
var overviewRuler_1 = require("vs/editor/browser/viewParts/overviewRuler/overviewRuler");
var rulers_1 = require("vs/editor/browser/viewParts/rulers/rulers");
var scrollDecoration_1 = require("vs/editor/browser/viewParts/scrollDecoration/scrollDecoration");
var selections_1 = require("vs/editor/browser/viewParts/selections/selections");
var viewCursors_1 = require("vs/editor/browser/viewParts/viewCursors/viewCursors");
var viewZones_1 = require("vs/editor/browser/viewParts/viewZones/viewZones");
var viewPart_1 = require("vs/editor/browser/view/viewPart");
var viewContext_1 = require("vs/editor/common/view/viewContext");
var renderingContext_1 = require("vs/editor/common/view/renderingContext");
var viewOutgoingEvents_1 = require("vs/editor/browser/view/viewOutgoingEvents");
var viewLinesViewportData_1 = require("vs/editor/common/viewLayout/viewLinesViewportData");
var editorScrollbar_1 = require("vs/editor/browser/viewParts/editorScrollbar/editorScrollbar");
var minimap_1 = require("vs/editor/browser/viewParts/minimap/minimap");
var viewEvents = require("vs/editor/common/view/viewEvents");
var View = (function (_super) {
    __extends(View, _super);
    function View(commandService, configuration, model, triggerCursorHandler) {
        var _this = _super.call(this) || this;
        _this.triggerCursorHandler = triggerCursorHandler;
        _this._isDisposed = false;
        _this._renderAnimationFrame = null;
        _this.outgoingEvents = new viewOutgoingEvents_1.ViewOutgoingEvents(model);
        var viewController = new viewController_1.ViewController(model, triggerCursorHandler, _this.outgoingEvents, commandService);
        _this.listenersToRemove = [];
        _this.listenersToDispose = [];
        // The event dispatcher will always go through _renderOnce before dispatching any events
        _this.eventDispatcher = new viewEventDispatcher_1.ViewEventDispatcher(function (callback) { return _this._renderOnce(callback); });
        // Ensure the view is the first event handler in order to update the layout
        _this.eventDispatcher.addEventHandler(_this);
        // The layout provider has such responsibilities as:
        // - scrolling (i.e. viewport / full size) & co.
        // - whitespaces (a.k.a. view zones) management & co.
        // - line heights updating & co.
        _this.layoutProvider = new viewLayout_1.LayoutProvider(configuration, model.getLineCount(), _this.eventDispatcher);
        // The view context is passed on to most classes (basically to reduce param. counts in ctors)
        _this._context = new viewContext_1.ViewContext(configuration, model, _this.eventDispatcher);
        _this.createTextArea();
        _this.createViewParts();
        _this._setLayout();
        // Keyboard handler
        _this.keyboardHandler = new keyboardHandler_1.KeyboardHandler(_this._context, viewController, _this.createKeyboardHandlerHelper());
        // Pointer handler
        _this.pointerHandler = new pointerHandler_1.PointerHandler(_this._context, viewController, _this.createPointerHandlerHelper());
        _this.hasFocus = false;
        _this.codeEditorHelper = null;
        // The view lines rendering calls model.getLineTokens() that might emit events that its tokens have changed.
        // This delayed processing of incoming model events acts as a guard against undesired/unexpected recursion.
        _this.handleAccumulatedModelEventsTimeout = -1;
        _this.accumulatedModelEvents = [];
        _this.listenersToRemove.push(model.addEventListener(function (events) {
            _this.accumulatedModelEvents = _this.accumulatedModelEvents.concat(events);
            if (_this.handleAccumulatedModelEventsTimeout === -1) {
                _this.handleAccumulatedModelEventsTimeout = setTimeout(function () {
                    _this.handleAccumulatedModelEventsTimeout = -1;
                    _this._flushAnyAccumulatedEvents();
                });
            }
        }));
        return _this;
    }
    View.prototype._flushAnyAccumulatedEvents = function () {
        var toEmit = this.accumulatedModelEvents;
        this.accumulatedModelEvents = [];
        if (toEmit.length > 0) {
            this.eventDispatcher.emitMany(toEmit);
        }
    };
    View.prototype.createTextArea = function () {
        var _this = this;
        // Text Area (The focus will always be in the textarea when the cursor is blinking)
        this.textArea = fastDomNode_1.createFastDomNode(document.createElement('textarea'));
        viewPart_1.PartFingerprints.write(this.textArea.domNode, 6 /* TextArea */);
        this.textArea.setClassName(editorBrowser.ClassNames.TEXTAREA);
        this.textArea.setAttribute('wrap', 'off');
        this.textArea.setAttribute('autocorrect', 'off');
        this.textArea.setAttribute('autocapitalize', 'off');
        this.textArea.setAttribute('spellcheck', 'false');
        this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
        this.textArea.setAttribute('role', 'textbox');
        this.textArea.setAttribute('aria-multiline', 'true');
        this.textArea.setAttribute('aria-haspopup', 'false');
        this.textArea.setAttribute('aria-autocomplete', 'both');
        this.textArea.setTop(0);
        this.textArea.setLeft(0);
        this.listenersToDispose.push(dom.addDisposableListener(this.textArea.domNode, 'focus', function () { return _this._setHasFocus(true); }));
        this.listenersToDispose.push(dom.addDisposableListener(this.textArea.domNode, 'blur', function () { return _this._setHasFocus(false); }));
        // On top of the text area, we position a dom node to cover it up
        // (there have been reports of tiny blinking cursors)
        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)
        this.textAreaCover = fastDomNode_1.createFastDomNode(document.createElement('div'));
        if (this._context.configuration.editor.viewInfo.glyphMargin) {
            this.textAreaCover.setClassName('monaco-editor-background ' + editorBrowser.ClassNames.GLYPH_MARGIN + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER);
        }
        else {
            if (this._context.configuration.editor.viewInfo.renderLineNumbers) {
                this.textAreaCover.setClassName('monaco-editor-background ' + editorBrowser.ClassNames.LINE_NUMBERS + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER);
            }
            else {
                this.textAreaCover.setClassName('monaco-editor-background ' + editorBrowser.ClassNames.TEXTAREA_COVER);
            }
        }
        this.textAreaCover.setPosition('absolute');
        this.textAreaCover.setWidth(1);
        this.textAreaCover.setHeight(1);
        this.textAreaCover.setTop(0);
        this.textAreaCover.setLeft(0);
    };
    View.prototype.createViewParts = function () {
        var _this = this;
        // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)
        this.linesContent = fastDomNode_1.createFastDomNode(document.createElement('div'));
        this.linesContent.setClassName(editorBrowser.ClassNames.LINES_CONTENT + ' monaco-editor-background');
        this.linesContent.setPosition('absolute');
        this.domNode = fastDomNode_1.createFastDomNode(document.createElement('div'));
        this.domNode.setClassName(this._context.configuration.editor.viewInfo.editorClassName);
        this.overflowGuardContainer = fastDomNode_1.createFastDomNode(document.createElement('div'));
        viewPart_1.PartFingerprints.write(this.overflowGuardContainer.domNode, 3 /* OverflowGuard */);
        this.overflowGuardContainer.setClassName(editorBrowser.ClassNames.OVERFLOW_GUARD);
        this.viewParts = [];
        this._scrollbar = new editorScrollbar_1.EditorScrollbar(this._context, this.layoutProvider.getScrollable(), this.linesContent, this.domNode, this.overflowGuardContainer);
        this.viewParts.push(this._scrollbar);
        // View Lines
        this.viewLines = new viewLines_1.ViewLines(this._context, this.linesContent, this.layoutProvider);
        // View Zones
        this.viewZones = new viewZones_1.ViewZones(this._context, this.layoutProvider);
        this.viewParts.push(this.viewZones);
        // Decorations overview ruler
        var decorationsOverviewRuler = new decorationsOverviewRuler_1.DecorationsOverviewRuler(this._context, this.layoutProvider.getScrollHeight(), function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
        this.viewParts.push(decorationsOverviewRuler);
        var scrollDecoration = new scrollDecoration_1.ScrollDecorationViewPart(this._context);
        this.viewParts.push(scrollDecoration);
        var contentViewOverlays = new viewOverlays_1.ContentViewOverlays(this._context);
        this.viewParts.push(contentViewOverlays);
        contentViewOverlays.addDynamicOverlay(new currentLineHighlight_1.CurrentLineHighlightOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new selections_1.SelectionsOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new decorations_1.DecorationsOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new indentGuides_1.IndentGuidesOverlay(this._context));
        var marginViewOverlays = new viewOverlays_1.MarginViewOverlays(this._context);
        this.viewParts.push(marginViewOverlays);
        marginViewOverlays.addDynamicOverlay(new currentLineMarginHighlight_1.CurrentLineMarginHighlightOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new glyphMargin_1.GlyphMarginOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new marginDecorations_1.MarginViewLineDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new linesDecorations_1.LinesDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new lineNumbers_1.LineNumbersOverlay(this._context));
        var margin = new margin_1.Margin(this._context);
        margin.getDomNode().appendChild(this.viewZones.marginDomNode.domNode);
        margin.getDomNode().appendChild(marginViewOverlays.getDomNode());
        this.viewParts.push(margin);
        // Content widgets
        this.contentWidgets = new contentWidgets_1.ViewContentWidgets(this._context, this.domNode);
        this.viewParts.push(this.contentWidgets);
        this.viewCursors = new viewCursors_1.ViewCursors(this._context);
        this.viewParts.push(this.viewCursors);
        // Overlay widgets
        this.overlayWidgets = new overlayWidgets_1.ViewOverlayWidgets(this._context);
        this.viewParts.push(this.overlayWidgets);
        var rulers = new rulers_1.Rulers(this._context);
        this.viewParts.push(rulers);
        var minimap = new minimap_1.Minimap(this._context, this.layoutProvider, this._scrollbar);
        this.viewParts.push(minimap);
        // -------------- Wire dom nodes up
        if (decorationsOverviewRuler) {
            var overviewRulerData = this._scrollbar.getOverviewRulerLayoutInfo();
            overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
        }
        this.linesContent.domNode.appendChild(contentViewOverlays.getDomNode());
        this.linesContent.domNode.appendChild(rulers.domNode);
        this.linesContent.domNode.appendChild(this.viewZones.domNode.domNode);
        this.linesContent.domNode.appendChild(this.viewLines.getDomNode());
        this.linesContent.domNode.appendChild(this.contentWidgets.domNode);
        this.linesContent.domNode.appendChild(this.viewCursors.getDomNode());
        this.overflowGuardContainer.domNode.appendChild(margin.getDomNode());
        this.overflowGuardContainer.domNode.appendChild(this._scrollbar.getDomNode());
        this.overflowGuardContainer.domNode.appendChild(scrollDecoration.getDomNode());
        this.overflowGuardContainer.domNode.appendChild(this.overlayWidgets.getDomNode());
        this.overflowGuardContainer.domNode.appendChild(this.textArea.domNode);
        this.overflowGuardContainer.domNode.appendChild(this.textAreaCover.domNode);
        this.overflowGuardContainer.domNode.appendChild(minimap.getDomNode());
        this.domNode.domNode.appendChild(this.overflowGuardContainer.domNode);
        this.domNode.domNode.appendChild(this.contentWidgets.overflowingContentWidgetsDomNode);
    };
    View.prototype._flushAccumulatedAndRenderNow = function () {
        this._flushAnyAccumulatedEvents();
        this._renderNow();
    };
    View.prototype.createPointerHandlerHelper = function () {
        var _this = this;
        return {
            viewDomNode: this.domNode.domNode,
            linesContentDomNode: this.linesContent.domNode,
            focusTextArea: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.focusTextArea: View is disposed');
                }
                _this.focus();
            },
            isDirty: function () {
                return (_this.accumulatedModelEvents.length > 0);
            },
            getScrollLeft: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getScrollLeft: View is disposed');
                }
                return _this.layoutProvider.getScrollLeft();
            },
            getScrollTop: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getScrollTop: View is disposed');
                }
                return _this.layoutProvider.getScrollTop();
            },
            setScrollPosition: function (position) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.setScrollPosition: View is disposed');
                }
                _this.layoutProvider.setScrollPosition(position);
            },
            isAfterLines: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.isAfterLines: View is disposed');
                }
                return _this.layoutProvider.isAfterLines(verticalOffset);
            },
            getLineNumberAtVerticalOffset: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLineNumberAtVerticalOffset: View is disposed');
                }
                return _this.layoutProvider.getLineNumberAtVerticalOffset(verticalOffset);
            },
            getVerticalOffsetForLineNumber: function (lineNumber) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getVerticalOffsetForLineNumber: View is disposed');
                }
                return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
            },
            getWhitespaceAtVerticalOffset: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getWhitespaceAtVerticalOffset: View is disposed');
                }
                return _this.layoutProvider.getWhitespaceAtVerticalOffset(verticalOffset);
            },
            getLastViewCursorsRenderData: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLastViewCursorsRenderData: View is disposed');
                }
                return _this.viewCursors.getLastRenderData() || [];
            },
            shouldSuppressMouseDownOnViewZone: function (viewZoneId) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnViewZone: View is disposed');
                }
                return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
            },
            shouldSuppressMouseDownOnWidget: function (widgetId) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnWidget: View is disposed');
                }
                return _this.contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);
            },
            getPositionFromDOMInfo: function (spanNode, offset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getPositionFromDOMInfo: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);
            },
            visibleRangeForPosition2: function (lineNumber, column) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.visibleRangeForPosition2: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column));
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            getLineWidth: function (lineNumber) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLineWidth: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getLineWidth(lineNumber);
            }
        };
    };
    View.prototype.createKeyboardHandlerHelper = function () {
        var _this = this;
        return {
            viewDomNode: this.domNode,
            textArea: this.textArea,
            visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.keyboardHandler.visibleRangeForPositionRelativeToEditor: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column));
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            getVerticalOffsetForLineNumber: function (lineNumber) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.keyboardHandler.getVerticalOffsetForLineNumber: View is disposed');
                }
                return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
            },
            flushAnyAccumulatedEvents: function () {
                _this._flushAnyAccumulatedEvents();
            }
        };
    };
    View.prototype.setAriaActiveDescendant = function (id) {
        if (id) {
            this.textArea.setAttribute('role', 'combobox');
            if (this.textArea.getAttribute('aria-activedescendant') !== id) {
                this.textArea.setAttribute('aria-haspopup', 'true');
                this.textArea.setAttribute('aria-activedescendant', id);
            }
        }
        else {
            this.textArea.setAttribute('role', 'textbox');
            this.textArea.removeAttribute('aria-activedescendant');
            this.textArea.removeAttribute('aria-haspopup');
        }
    };
    View.prototype._setLayout = function () {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        if (browser.isChrome) {
            /* tslint:disable:no-unused-variable */
            // Access overflowGuardContainer.clientWidth to prevent relayouting bug in Chrome
            // See Bug 19676: Editor misses a layout event
            var clientWidth = this.overflowGuardContainer.domNode.clientWidth + 'px';
        }
        this.domNode.setWidth(layoutInfo.width);
        this.domNode.setHeight(layoutInfo.height);
        this.overflowGuardContainer.setWidth(layoutInfo.width);
        this.overflowGuardContainer.setHeight(layoutInfo.height);
        this.linesContent.setWidth(1000000);
        this.linesContent.setHeight(1000000);
    };
    // --- begin event handlers
    View.prototype.onConfigurationChanged = function (e) {
        if (e.viewInfo.editorClassName) {
            this.domNode.setClassName(this._context.configuration.editor.viewInfo.editorClassName);
        }
        if (e.viewInfo.ariaLabel) {
            this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
        }
        if (e.layoutInfo) {
            this._setLayout();
        }
        this.layoutProvider.onConfigurationChanged(e);
        return false;
    };
    View.prototype.onFlushed = function (e) {
        this.layoutProvider.onFlushed(this._context.model.getLineCount());
        return false;
    };
    View.prototype.onFocusChanged = function (e) {
        this.domNode.toggleClassName('focused', e.isFocused);
        if (e.isFocused) {
            this.outgoingEvents.emitViewFocusGained();
        }
        else {
            this.outgoingEvents.emitViewFocusLost();
        }
        return false;
    };
    View.prototype.onLinesDeleted = function (e) {
        this.layoutProvider.onLinesDeleted(e);
        return false;
    };
    View.prototype.onLinesInserted = function (e) {
        this.layoutProvider.onLinesInserted(e);
        return false;
    };
    View.prototype.onRevealRangeRequest = function (e) {
        return e.revealCursor ? this.revealCursor() : false;
    };
    View.prototype.onScrollChanged = function (e) {
        this.outgoingEvents.emitScrollChanged(e);
        return false;
    };
    View.prototype.onScrollRequest = function (e) {
        var currentScrollTop = this.layoutProvider.getScrollTop();
        var newScrollTop = currentScrollTop + e.deltaLines * this._context.configuration.editor.lineHeight;
        this.layoutProvider.setScrollPosition({
            scrollTop: newScrollTop
        });
        return e.revealCursor ? this.revealCursor() : false;
    };
    View.prototype.revealCursor = function () {
        this.triggerCursorHandler('revealCursor', editorCommon.Handler.CursorMove, { to: editorCommon.CursorMovePosition.ViewPortIfOutside });
        return false;
    };
    // --- end event handlers
    View.prototype.dispose = function () {
        this._isDisposed = true;
        if (this.handleAccumulatedModelEventsTimeout !== -1) {
            clearTimeout(this.handleAccumulatedModelEventsTimeout);
            this.handleAccumulatedModelEventsTimeout = -1;
        }
        if (this._renderAnimationFrame !== null) {
            this._renderAnimationFrame.dispose();
            this._renderAnimationFrame = null;
        }
        this.accumulatedModelEvents = [];
        this.eventDispatcher.removeEventHandler(this);
        this.outgoingEvents.dispose();
        this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
        this.listenersToDispose = lifecycle_1.dispose(this.listenersToDispose);
        this.keyboardHandler.dispose();
        this.pointerHandler.dispose();
        this.viewLines.dispose();
        // Destroy view parts
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            this.viewParts[i].dispose();
        }
        this.viewParts = [];
        this.layoutProvider.dispose();
    };
    View.prototype.getCodeEditorHelper = function () {
        var _this = this;
        if (!this.codeEditorHelper) {
            this.codeEditorHelper = {
                getScrollWidth: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollWidth: View is disposed');
                    }
                    return _this.layoutProvider.getScrollWidth();
                },
                getScrollLeft: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollLeft: View is disposed');
                    }
                    return _this.layoutProvider.getScrollLeft();
                },
                getScrollHeight: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollHeight: View is disposed');
                    }
                    return _this.layoutProvider.getScrollHeight();
                },
                getScrollTop: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollTop: View is disposed');
                    }
                    return _this.layoutProvider.getScrollTop();
                },
                setScrollPosition: function (position) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.setScrollPosition: View is disposed');
                    }
                    _this.layoutProvider.setScrollPosition(position);
                },
                getVerticalOffsetForPosition: function (modelLineNumber, modelColumn) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getVerticalOffsetForPosition: View is disposed');
                    }
                    var modelPosition = _this._context.model.validateModelPosition({
                        lineNumber: modelLineNumber,
                        column: modelColumn
                    });
                    var viewPosition = _this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
                    return _this.layoutProvider.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
                },
                delegateVerticalScrollbarMouseDown: function (browserEvent) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.delegateVerticalScrollbarMouseDown: View is disposed');
                    }
                    _this._scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
                },
                getOffsetForColumn: function (modelLineNumber, modelColumn) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getOffsetForColumn: View is disposed');
                    }
                    var modelPosition = _this._context.model.validateModelPosition({
                        lineNumber: modelLineNumber,
                        column: modelColumn
                    });
                    var viewPosition = _this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);
                    _this._flushAccumulatedAndRenderNow();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column));
                    if (!visibleRanges) {
                        return -1;
                    }
                    return visibleRanges[0].left;
                },
                getTargetAtClientPoint: function (clientX, clientY) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getTargetAtClientPoint: View is disposed');
                    }
                    return _this.pointerHandler.getTargetAtClientPoint(clientX, clientY);
                }
            };
        }
        return this.codeEditorHelper;
    };
    View.prototype.getCompletelyVisibleLinesRangeInViewport = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getCompletelyVisibleLinesRangeInViewport: View is disposed');
        }
        var partialData = this.layoutProvider.getLinesViewportData();
        var completelyVisibleLinesRange = new range_1.Range(partialData.completelyVisibleStartLineNumber, 1, partialData.completelyVisibleEndLineNumber, this._context.model.getLineMaxColumn(partialData.completelyVisibleEndLineNumber));
        return this._context.model.coordinatesConverter.convertViewRangeToModelRange(completelyVisibleLinesRange);
    };
    View.prototype.getInternalEventBus = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getInternalEventBus: View is disposed');
        }
        return this.outgoingEvents.getInternalEventBus();
    };
    View.prototype.saveState = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.saveState: View is disposed');
        }
        return this.layoutProvider.saveState();
    };
    View.prototype.restoreState = function (state) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.restoreState: View is disposed');
        }
        this._flushAnyAccumulatedEvents();
        return this.layoutProvider.restoreState(state);
    };
    View.prototype.focus = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.focus: View is disposed');
        }
        this.keyboardHandler.focusTextArea();
        // IE does not trigger the focus event immediately, so we must help it a little bit
        if (document.activeElement === this.textArea.domNode) {
            this._setHasFocus(true);
        }
    };
    View.prototype.isFocused = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.isFocused: View is disposed');
        }
        return this.hasFocus;
    };
    View.prototype.createOverviewRuler = function (cssClassName, minimumHeight, maximumHeight) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl.createOverviewRuler: View is disposed');
        }
        return new overviewRuler_1.OverviewRuler(this._context, cssClassName, this.layoutProvider.getScrollHeight(), minimumHeight, maximumHeight, function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
    };
    View.prototype.change = function (callback) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl.change: View is disposed');
        }
        var zonesHaveChanged = false;
        this._renderOnce(function () {
            // Handle events to avoid "adjusting" newly inserted view zones
            _this._flushAnyAccumulatedEvents();
            var changeAccessor = {
                addZone: function (zone) {
                    zonesHaveChanged = true;
                    return _this.viewZones.addZone(zone);
                },
                removeZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;
                },
                layoutZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;
                }
            };
            safeInvoke1Arg(callback, changeAccessor);
            // Invalidate changeAccessor
            changeAccessor.addZone = null;
            changeAccessor.removeZone = null;
            if (zonesHaveChanged) {
                _this.layoutProvider.onHeightMaybeChanged();
                _this._context.privateViewEventBus.emit(new viewEvents.ViewZonesChangedEvent());
            }
        });
        return zonesHaveChanged;
    };
    View.prototype.getWhitespaces = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getWhitespaces: View is disposed');
        }
        return this.layoutProvider.getWhitespaces();
    };
    View.prototype.addContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.addContentWidget: View is disposed');
        }
        this.contentWidgets.addWidget(widgetData.widget);
        this.layoutContentWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.layoutContentWidget: View is disposed');
        }
        var newPosition = widgetData.position ? widgetData.position.position : null;
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newPreference);
        this._scheduleRender();
    };
    View.prototype.removeContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.removeContentWidget: View is disposed');
        }
        this.contentWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    View.prototype.addOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.addOverlayWidget: View is disposed');
        }
        this.overlayWidgets.addWidget(widgetData.widget);
        this.layoutOverlayWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.layoutOverlayWidget: View is disposed');
        }
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
        if (shouldRender) {
            this._scheduleRender();
        }
    };
    View.prototype.removeOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.removeOverlayWidget: View is disposed');
        }
        this.overlayWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    View.prototype.render = function (now, everything) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.render: View is disposed');
        }
        if (everything) {
            // Force everything to render...
            this.viewLines.forceShouldRender();
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                var viewPart = this.viewParts[i];
                viewPart.forceShouldRender();
            }
        }
        if (now) {
            this._flushAccumulatedAndRenderNow();
        }
        else {
            this._scheduleRender();
        }
    };
    // --- end Code Editor APIs
    View.prototype._renderOnce = function (callback) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl._renderOnce: View is disposed');
        }
        return this.outgoingEvents.deferredEmit(function () {
            var r = safeInvokeNoArg(callback);
            _this._scheduleRender();
            return r;
        });
    };
    View.prototype._scheduleRender = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl._scheduleRender: View is disposed');
        }
        if (this._renderAnimationFrame === null) {
            this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
        }
    };
    View.prototype._onRenderScheduled = function () {
        this._renderAnimationFrame = null;
        this._flushAccumulatedAndRenderNow();
    };
    View.prototype._renderNow = function () {
        var _this = this;
        safeInvokeNoArg(function () { return _this._actualRender(); });
    };
    View.prototype._getViewPartsToRender = function () {
        var result = [];
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            var viewPart = this.viewParts[i];
            if (viewPart.shouldRender()) {
                result.push(viewPart);
            }
        }
        return result;
    };
    View.prototype._actualRender = function () {
        var _this = this;
        if (!dom.isInDOM(this.domNode.domNode)) {
            return;
        }
        var viewPartsToRender = this._getViewPartsToRender();
        if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {
            // Nothing to render
            this.keyboardHandler.writeToTextArea();
            return;
        }
        var partialViewportData = this.layoutProvider.getLinesViewportData();
        this._context.model.setViewport(partialViewportData.startLineNumber, partialViewportData.endLineNumber, partialViewportData.centeredLineNumber);
        var viewportData = new viewLinesViewportData_1.ViewportData(partialViewportData, this._context.model);
        if (this.viewLines.shouldRender()) {
            this.viewLines.renderText(viewportData, function () {
                _this.keyboardHandler.writeToTextArea();
            });
            this.viewLines.onDidRender();
            // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again
            viewPartsToRender = this._getViewPartsToRender();
        }
        else {
            this.keyboardHandler.writeToTextArea();
        }
        var renderingContext = new renderingContext_1.RenderingContext(this.layoutProvider, viewportData, this.viewLines);
        // Render the rest of the parts
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.prepareRender(renderingContext);
        }
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.render(renderingContext);
            viewPart.onDidRender();
        }
    };
    View.prototype._setHasFocus = function (newHasFocus) {
        if (this.hasFocus !== newHasFocus) {
            this.hasFocus = newHasFocus;
            this._context.privateViewEventBus.emit(new viewEvents.ViewFocusChangedEvent(this.hasFocus));
        }
    };
    return View;
}(viewEventHandler_1.ViewEventHandler));
exports.View = View;
function safeInvokeNoArg(func) {
    try {
        return func();
    }
    catch (e) {
        errors_1.onUnexpectedError(e);
    }
}
function safeInvoke1Arg(func, arg1) {
    try {
        return func(arg1);
    }
    catch (e) {
        errors_1.onUnexpectedError(e);
    }
}
