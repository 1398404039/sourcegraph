/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var errors_1 = require("vs/base/common/errors");
var lifecycle_1 = require("vs/base/common/lifecycle");
var timer = require("vs/base/common/timer");
var browser = require("vs/base/browser/browser");
var dom = require("vs/base/browser/dom");
var styleMutator_1 = require("vs/base/browser/styleMutator");
var range_1 = require("vs/editor/common/core/range");
var editorCommon = require("vs/editor/common/editorCommon");
var viewEventHandler_1 = require("vs/editor/common/viewModel/viewEventHandler");
var keyboardHandler_1 = require("vs/editor/browser/controller/keyboardHandler");
var pointerHandler_1 = require("vs/editor/browser/controller/pointerHandler");
var editorBrowser = require("vs/editor/browser/editorBrowser");
var viewController_1 = require("vs/editor/browser/view/viewController");
var viewEventDispatcher_1 = require("vs/editor/browser/view/viewEventDispatcher");
var viewOverlays_1 = require("vs/editor/browser/view/viewOverlays");
var layoutProvider_1 = require("vs/editor/browser/viewLayout/layoutProvider");
var contentWidgets_1 = require("vs/editor/browser/viewParts/contentWidgets/contentWidgets");
var currentLineHighlight_1 = require("vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight");
var currentLineMarginHighlight_1 = require("vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight");
var decorations_1 = require("vs/editor/browser/viewParts/decorations/decorations");
var glyphMargin_1 = require("vs/editor/browser/viewParts/glyphMargin/glyphMargin");
var lineNumbers_1 = require("vs/editor/browser/viewParts/lineNumbers/lineNumbers");
var indentGuides_1 = require("vs/editor/browser/viewParts/indentGuides/indentGuides");
var viewLines_1 = require("vs/editor/browser/viewParts/lines/viewLines");
var margin_1 = require("vs/editor/browser/viewParts/margin/margin");
var linesDecorations_1 = require("vs/editor/browser/viewParts/linesDecorations/linesDecorations");
var marginDecorations_1 = require("vs/editor/browser/viewParts/marginDecorations/marginDecorations");
var overlayWidgets_1 = require("vs/editor/browser/viewParts/overlayWidgets/overlayWidgets");
var decorationsOverviewRuler_1 = require("vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler");
var overviewRuler_1 = require("vs/editor/browser/viewParts/overviewRuler/overviewRuler");
var rulers_1 = require("vs/editor/browser/viewParts/rulers/rulers");
var scrollDecoration_1 = require("vs/editor/browser/viewParts/scrollDecoration/scrollDecoration");
var selections_1 = require("vs/editor/browser/viewParts/selections/selections");
var viewCursors_1 = require("vs/editor/browser/viewParts/viewCursors/viewCursors");
var viewZones_1 = require("vs/editor/browser/viewParts/viewZones/viewZones");
var viewContext_1 = require("vs/editor/common/view/viewContext");
var viewOutgoingEvents_1 = require("vs/editor/browser/view/viewOutgoingEvents");
var View = (function (_super) {
    __extends(View, _super);
    function View(commandService, configuration, model, triggerCursorHandler) {
        var _this = _super.call(this) || this;
        _this.triggerCursorHandler = triggerCursorHandler;
        _this._isDisposed = false;
        _this._renderAnimationFrame = null;
        _this.outgoingEvents = new viewOutgoingEvents_1.ViewOutgoingEvents(model);
        var viewController = new viewController_1.ViewController(model, triggerCursorHandler, _this.outgoingEvents, commandService);
        _this.listenersToRemove = [];
        _this.listenersToDispose = [];
        // The event dispatcher will always go through _renderOnce before dispatching any events
        _this.eventDispatcher = new viewEventDispatcher_1.ViewEventDispatcher(function (callback) { return _this._renderOnce(callback); });
        // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)
        _this.linesContent = document.createElement('div');
        _this.linesContent.className = editorBrowser.ClassNames.LINES_CONTENT + ' monaco-editor-background';
        _this.domNode = document.createElement('div');
        _this.domNode.className = configuration.editor.viewInfo.editorClassName;
        _this.overflowGuardContainer = document.createElement('div');
        _this.overflowGuardContainer.className = editorBrowser.ClassNames.OVERFLOW_GUARD;
        // The layout provider has such responsibilities as:
        // - scrolling (i.e. viewport / full size) & co.
        // - whitespaces (a.k.a. view zones) management & co.
        // - line heights updating & co.
        _this.layoutProvider = new layoutProvider_1.LayoutProvider(configuration, model, _this.eventDispatcher, _this.linesContent, _this.domNode, _this.overflowGuardContainer);
        _this.eventDispatcher.addEventHandler(_this.layoutProvider);
        // The view context is passed on to most classes (basically to reduce param. counts in ctors)
        _this._context = new viewContext_1.ViewContext(configuration, model, _this.eventDispatcher, function (eventHandler) { return _this.eventDispatcher.addEventHandler(eventHandler); }, function (eventHandler) { return _this.eventDispatcher.removeEventHandler(eventHandler); });
        _this.createTextArea();
        _this.createViewParts();
        // Keyboard handler
        _this.keyboardHandler = new keyboardHandler_1.KeyboardHandler(_this._context, viewController, _this.createKeyboardHandlerHelper());
        // Pointer handler
        _this.pointerHandler = new pointerHandler_1.PointerHandler(_this._context, viewController, _this.createPointerHandlerHelper());
        _this.hasFocus = false;
        _this.codeEditorHelper = null;
        _this.eventDispatcher.addEventHandler(_this);
        // The view lines rendering calls model.getLineTokens() that might emit events that its tokens have changed.
        // This delayed processing of incoming model events acts as a guard against undesired/unexpected recursion.
        _this.handleAccumulatedModelEventsTimeout = -1;
        _this.accumulatedModelEvents = [];
        _this.listenersToRemove.push(model.addBulkListener2(function (events) {
            _this.accumulatedModelEvents = _this.accumulatedModelEvents.concat(events);
            if (_this.handleAccumulatedModelEventsTimeout === -1) {
                _this.handleAccumulatedModelEventsTimeout = setTimeout(function () {
                    _this.handleAccumulatedModelEventsTimeout = -1;
                    _this._flushAnyAccumulatedEvents();
                });
            }
        }));
        return _this;
    }
    View.prototype._flushAnyAccumulatedEvents = function () {
        var toEmit = this.accumulatedModelEvents;
        this.accumulatedModelEvents = [];
        if (toEmit.length > 0) {
            this.eventDispatcher.emitMany(toEmit);
        }
    };
    View.prototype.createTextArea = function () {
        var _this = this;
        // Text Area (The focus will always be in the textarea when the cursor is blinking)
        this.textArea = document.createElement('textarea');
        this.textArea.className = editorBrowser.ClassNames.TEXTAREA;
        this.textArea.setAttribute('wrap', 'off');
        this.textArea.setAttribute('autocorrect', 'off');
        this.textArea.setAttribute('autocapitalize', 'off');
        this.textArea.setAttribute('spellcheck', 'false');
        this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
        this.textArea.setAttribute('role', 'textbox');
        this.textArea.setAttribute('aria-multiline', 'true');
        this.textArea.setAttribute('aria-haspopup', 'false');
        this.textArea.setAttribute('aria-autocomplete', 'both');
        styleMutator_1.StyleMutator.setTop(this.textArea, 0);
        styleMutator_1.StyleMutator.setLeft(this.textArea, 0);
        this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'focus', function () { return _this._setHasFocus(true); }));
        this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'blur', function () { return _this._setHasFocus(false); }));
        // On top of the text area, we position a dom node to cover it up
        // (there have been reports of tiny blinking cursors)
        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)
        this.textAreaCover = document.createElement('div');
        if (this._context.configuration.editor.viewInfo.glyphMargin) {
            this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.GLYPH_MARGIN + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
        }
        else {
            if (this._context.configuration.editor.viewInfo.renderLineNumbers) {
                this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.LINE_NUMBERS + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
            }
            else {
                this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.TEXTAREA_COVER;
            }
        }
        this.textAreaCover.style.position = 'absolute';
        styleMutator_1.StyleMutator.setWidth(this.textAreaCover, 1);
        styleMutator_1.StyleMutator.setHeight(this.textAreaCover, 1);
        styleMutator_1.StyleMutator.setTop(this.textAreaCover, 0);
        styleMutator_1.StyleMutator.setLeft(this.textAreaCover, 0);
    };
    View.prototype.createViewParts = function () {
        var _this = this;
        this.viewParts = [];
        // View Lines
        this.viewLines = new viewLines_1.ViewLines(this._context, this.layoutProvider);
        // View Zones
        this.viewZones = new viewZones_1.ViewZones(this._context, this.layoutProvider);
        this.viewParts.push(this.viewZones);
        // Decorations overview ruler
        var decorationsOverviewRuler = new decorationsOverviewRuler_1.DecorationsOverviewRuler(this._context, this.layoutProvider.getScrollHeight(), function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
        this.viewParts.push(decorationsOverviewRuler);
        var scrollDecoration = new scrollDecoration_1.ScrollDecorationViewPart(this._context);
        this.viewParts.push(scrollDecoration);
        var contentViewOverlays = new viewOverlays_1.ContentViewOverlays(this._context, this.layoutProvider);
        this.viewParts.push(contentViewOverlays);
        contentViewOverlays.addDynamicOverlay(new currentLineHighlight_1.CurrentLineHighlightOverlay(this._context, this.layoutProvider));
        contentViewOverlays.addDynamicOverlay(new selections_1.SelectionsOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new decorations_1.DecorationsOverlay(this._context));
        contentViewOverlays.addDynamicOverlay(new indentGuides_1.IndentGuidesOverlay(this._context));
        var marginViewOverlays = new viewOverlays_1.MarginViewOverlays(this._context, this.layoutProvider);
        this.viewParts.push(marginViewOverlays);
        marginViewOverlays.addDynamicOverlay(new currentLineMarginHighlight_1.CurrentLineMarginHighlightOverlay(this._context, this.layoutProvider));
        marginViewOverlays.addDynamicOverlay(new glyphMargin_1.GlyphMarginOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new marginDecorations_1.MarginViewLineDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new linesDecorations_1.LinesDecorationsOverlay(this._context));
        marginViewOverlays.addDynamicOverlay(new lineNumbers_1.LineNumbersOverlay(this._context));
        var margin = new margin_1.Margin(this._context, this.layoutProvider);
        margin.domNode.appendChild(this.viewZones.marginDomNode);
        margin.domNode.appendChild(marginViewOverlays.getDomNode());
        this.viewParts.push(margin);
        // Content widgets
        this.contentWidgets = new contentWidgets_1.ViewContentWidgets(this._context, this.domNode);
        this.viewParts.push(this.contentWidgets);
        this.viewCursors = new viewCursors_1.ViewCursors(this._context);
        this.viewParts.push(this.viewCursors);
        // Overlay widgets
        this.overlayWidgets = new overlayWidgets_1.ViewOverlayWidgets(this._context);
        this.viewParts.push(this.overlayWidgets);
        var rulers = new rulers_1.Rulers(this._context, this.layoutProvider);
        this.viewParts.push(rulers);
        // -------------- Wire dom nodes up
        this.linesContentContainer = this.layoutProvider.getScrollbarContainerDomNode();
        this.linesContentContainer.style.position = 'absolute';
        if (decorationsOverviewRuler) {
            var overviewRulerData = this.layoutProvider.getOverviewRulerInsertData();
            overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
        }
        this.linesContent.appendChild(contentViewOverlays.getDomNode());
        this.linesContent.appendChild(rulers.domNode);
        this.linesContent.appendChild(this.viewZones.domNode);
        this.linesContent.appendChild(this.viewLines.getDomNode());
        this.linesContent.appendChild(this.contentWidgets.domNode);
        this.linesContent.appendChild(this.viewCursors.getDomNode());
        this.overflowGuardContainer.appendChild(margin.domNode);
        this.overflowGuardContainer.appendChild(this.linesContentContainer);
        this.overflowGuardContainer.appendChild(scrollDecoration.getDomNode());
        this.overflowGuardContainer.appendChild(this.overlayWidgets.domNode);
        this.overflowGuardContainer.appendChild(this.textArea);
        this.overflowGuardContainer.appendChild(this.textAreaCover);
        this.domNode.appendChild(this.overflowGuardContainer);
        this.domNode.appendChild(this.contentWidgets.overflowingContentWidgetsDomNode);
    };
    View.prototype._flushAccumulatedAndRenderNow = function () {
        this._flushAnyAccumulatedEvents();
        this._renderNow();
    };
    View.prototype.createPointerHandlerHelper = function () {
        var _this = this;
        return {
            viewDomNode: this.domNode,
            linesContentDomNode: this.linesContent,
            focusTextArea: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.focusTextArea: View is disposed');
                }
                _this.focus();
            },
            isDirty: function () {
                return (_this.accumulatedModelEvents.length > 0);
            },
            getScrollLeft: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getScrollLeft: View is disposed');
                }
                return _this.layoutProvider.getScrollLeft();
            },
            getScrollTop: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getScrollTop: View is disposed');
                }
                return _this.layoutProvider.getScrollTop();
            },
            setScrollPosition: function (position) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.setScrollPosition: View is disposed');
                }
                _this.layoutProvider.setScrollPosition(position);
            },
            isAfterLines: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.isAfterLines: View is disposed');
                }
                return _this.layoutProvider.isAfterLines(verticalOffset);
            },
            getLineNumberAtVerticalOffset: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLineNumberAtVerticalOffset: View is disposed');
                }
                return _this.layoutProvider.getLineNumberAtVerticalOffset(verticalOffset);
            },
            getVerticalOffsetForLineNumber: function (lineNumber) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getVerticalOffsetForLineNumber: View is disposed');
                }
                return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
            },
            getWhitespaceAtVerticalOffset: function (verticalOffset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getWhitespaceAtVerticalOffset: View is disposed');
                }
                return _this.layoutProvider.getWhitespaceAtVerticalOffset(verticalOffset);
            },
            getLastViewCursorsRenderData: function () {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLastViewCursorsRenderData: View is disposed');
                }
                return _this.viewCursors.getLastRenderData() || [];
            },
            shouldSuppressMouseDownOnViewZone: function (viewZoneId) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnViewZone: View is disposed');
                }
                return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
            },
            shouldSuppressMouseDownOnWidget: function (widgetId) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnWidget: View is disposed');
                }
                return _this.contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);
            },
            getPositionFromDOMInfo: function (spanNode, offset) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getPositionFromDOMInfo: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);
            },
            visibleRangeForPosition2: function (lineNumber, column) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.visibleRangeForPosition2: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), 0);
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            getLineWidth: function (lineNumber) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.pointerHandler.getLineWidth: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                return _this.viewLines.getLineWidth(lineNumber);
            }
        };
    };
    View.prototype.createKeyboardHandlerHelper = function () {
        var _this = this;
        return {
            viewDomNode: this.domNode,
            textArea: this.textArea,
            visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {
                if (_this._isDisposed) {
                    throw new Error('ViewImpl.keyboardHandler.visibleRangeForPositionRelativeToEditor: View is disposed');
                }
                _this._flushAccumulatedAndRenderNow();
                var linesViewPortData = _this.layoutProvider.getLinesViewportData();
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), linesViewPortData.visibleRangesDeltaTop);
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            flushAnyAccumulatedEvents: function () {
                _this._flushAnyAccumulatedEvents();
            }
        };
    };
    View.prototype.setAriaActiveDescendant = function (id) {
        if (id) {
            this.textArea.setAttribute('role', 'combobox');
            if (this.textArea.getAttribute('aria-activedescendant') !== id) {
                this.textArea.setAttribute('aria-haspopup', 'true');
                this.textArea.setAttribute('aria-activedescendant', id);
            }
        }
        else {
            this.textArea.setAttribute('role', 'textbox');
            this.textArea.removeAttribute('aria-activedescendant');
            this.textArea.removeAttribute('aria-haspopup');
        }
    };
    // --- begin event handlers
    View.prototype.onLayoutChanged = function (layoutInfo) {
        if (browser.isChrome) {
            /* tslint:disable:no-unused-variable */
            // Access overflowGuardContainer.clientWidth to prevent relayouting bug in Chrome
            // See Bug 19676: Editor misses a layout event
            var clientWidth = this.overflowGuardContainer.clientWidth + 'px';
        }
        styleMutator_1.StyleMutator.setWidth(this.domNode, layoutInfo.width);
        styleMutator_1.StyleMutator.setHeight(this.domNode, layoutInfo.height);
        styleMutator_1.StyleMutator.setWidth(this.overflowGuardContainer, layoutInfo.width);
        styleMutator_1.StyleMutator.setHeight(this.overflowGuardContainer, layoutInfo.height);
        styleMutator_1.StyleMutator.setWidth(this.linesContent, 1000000);
        styleMutator_1.StyleMutator.setHeight(this.linesContent, 1000000);
        styleMutator_1.StyleMutator.setLeft(this.linesContentContainer, layoutInfo.contentLeft);
        styleMutator_1.StyleMutator.setWidth(this.linesContentContainer, layoutInfo.contentWidth);
        styleMutator_1.StyleMutator.setHeight(this.linesContentContainer, layoutInfo.contentHeight);
        this.outgoingEvents.emitViewLayoutChanged(layoutInfo);
        return false;
    };
    View.prototype.onConfigurationChanged = function (e) {
        if (e.viewInfo.editorClassName) {
            this.domNode.className = this._context.configuration.editor.viewInfo.editorClassName;
        }
        if (e.viewInfo.ariaLabel) {
            this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
        }
        return false;
    };
    View.prototype.onScrollChanged = function (e) {
        this.outgoingEvents.emitScrollChanged(e);
        return false;
    };
    View.prototype.onViewFocusChanged = function (isFocused) {
        dom.toggleClass(this.domNode, 'focused', isFocused);
        if (isFocused) {
            this.outgoingEvents.emitViewFocusGained();
        }
        else {
            this.outgoingEvents.emitViewFocusLost();
        }
        return false;
    };
    View.prototype.onCursorRevealRange = function (e) {
        return e.revealCursor ? this.revealCursor() : false;
    };
    View.prototype.onCursorScrollRequest = function (e) {
        return e.revealCursor ? this.revealCursor() : false;
    };
    View.prototype.revealCursor = function () {
        this.triggerCursorHandler('revealCursor', editorCommon.Handler.CursorMove, { to: editorCommon.CursorMovePosition.ViewPortIfOutside });
        return false;
    };
    // --- end event handlers
    View.prototype.dispose = function () {
        this._isDisposed = true;
        if (this.handleAccumulatedModelEventsTimeout !== -1) {
            clearTimeout(this.handleAccumulatedModelEventsTimeout);
            this.handleAccumulatedModelEventsTimeout = -1;
        }
        if (this._renderAnimationFrame !== null) {
            this._renderAnimationFrame.dispose();
            this._renderAnimationFrame = null;
        }
        this.accumulatedModelEvents = [];
        this.eventDispatcher.removeEventHandler(this);
        this.outgoingEvents.dispose();
        this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
        this.listenersToDispose = lifecycle_1.dispose(this.listenersToDispose);
        this.keyboardHandler.dispose();
        this.pointerHandler.dispose();
        this.viewLines.dispose();
        // Destroy IViewPart second
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            this.viewParts[i].dispose();
        }
        this.viewParts = [];
        this.layoutProvider.dispose();
    };
    View.prototype.getCodeEditorHelper = function () {
        var _this = this;
        if (!this.codeEditorHelper) {
            this.codeEditorHelper = {
                getScrollWidth: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollWidth: View is disposed');
                    }
                    return _this.layoutProvider.getScrollWidth();
                },
                getScrollLeft: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollLeft: View is disposed');
                    }
                    return _this.layoutProvider.getScrollLeft();
                },
                getScrollHeight: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollHeight: View is disposed');
                    }
                    return _this.layoutProvider.getScrollHeight();
                },
                getScrollTop: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getScrollTop: View is disposed');
                    }
                    return _this.layoutProvider.getScrollTop();
                },
                setScrollPosition: function (position) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.setScrollPosition: View is disposed');
                    }
                    _this.layoutProvider.setScrollPosition(position);
                },
                getVerticalOffsetForPosition: function (modelLineNumber, modelColumn) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getVerticalOffsetForPosition: View is disposed');
                    }
                    var modelPosition = _this._context.model.validateModelPosition({
                        lineNumber: modelLineNumber,
                        column: modelColumn
                    });
                    var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                    return _this.layoutProvider.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
                },
                delegateVerticalScrollbarMouseDown: function (browserEvent) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.delegateVerticalScrollbarMouseDown: View is disposed');
                    }
                    _this.layoutProvider.delegateVerticalScrollbarMouseDown(browserEvent);
                },
                getOffsetForColumn: function (modelLineNumber, modelColumn) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.codeEditorHelper.getOffsetForColumn: View is disposed');
                    }
                    var modelPosition = _this._context.model.validateModelPosition({
                        lineNumber: modelLineNumber,
                        column: modelColumn
                    });
                    var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                    _this._flushAccumulatedAndRenderNow();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column), 0);
                    if (!visibleRanges) {
                        return -1;
                    }
                    return visibleRanges[0].left;
                }
            };
        }
        return this.codeEditorHelper;
    };
    View.prototype.getCenteredRangeInViewport = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getCenteredRangeInViewport: View is disposed');
        }
        var viewLineNumber = this.layoutProvider.getCenteredViewLineNumberInViewport();
        var viewModel = this._context.model;
        var currentCenteredViewRange = new range_1.Range(viewLineNumber, 1, viewLineNumber, viewModel.getLineMaxColumn(viewLineNumber));
        return viewModel.convertViewRangeToModelRange(currentCenteredViewRange);
    };
    View.prototype.getCompletelyVisibleLinesRangeInViewport = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getVisibleRangeInViewportExcludingPartialRenderedLines: View is disposed');
        }
        var completelyVisibleLinesRange = this.layoutProvider.getLinesViewportData().completelyVisibleLinesRange;
        return this._context.model.convertViewRangeToModelRange(completelyVisibleLinesRange);
    };
    //	public getLineInfoProvider():view.ILineInfoProvider {
    //		return this.viewLines;
    //	}
    View.prototype.getInternalEventBus = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getInternalEventBus: View is disposed');
        }
        return this.outgoingEvents.getInternalEventBus();
    };
    View.prototype.saveState = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.saveState: View is disposed');
        }
        return this.layoutProvider.saveState();
    };
    View.prototype.restoreState = function (state) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.restoreState: View is disposed');
        }
        this._flushAnyAccumulatedEvents();
        return this.layoutProvider.restoreState(state);
    };
    View.prototype.focus = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.focus: View is disposed');
        }
        this.keyboardHandler.focusTextArea();
        // IE does not trigger the focus event immediately, so we must help it a little bit
        this._setHasFocus(true);
    };
    View.prototype.isFocused = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.isFocused: View is disposed');
        }
        return this.hasFocus;
    };
    View.prototype.createOverviewRuler = function (cssClassName, minimumHeight, maximumHeight) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl.createOverviewRuler: View is disposed');
        }
        return new overviewRuler_1.OverviewRuler(this._context, cssClassName, this.layoutProvider.getScrollHeight(), minimumHeight, maximumHeight, function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
    };
    View.prototype.change = function (callback) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl.change: View is disposed');
        }
        var zonesHaveChanged = false;
        this._renderOnce(function () {
            // Handle events to avoid "adjusting" newly inserted view zones
            _this._flushAnyAccumulatedEvents();
            var changeAccessor = {
                addZone: function (zone) {
                    zonesHaveChanged = true;
                    return _this.viewZones.addZone(zone);
                },
                removeZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;
                },
                layoutZone: function (id) {
                    if (!id) {
                        return;
                    }
                    zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;
                }
            };
            var r = safeInvoke1Arg(callback, changeAccessor);
            // Invalidate changeAccessor
            changeAccessor.addZone = null;
            changeAccessor.removeZone = null;
            if (zonesHaveChanged) {
                _this._context.privateViewEventBus.emit(editorCommon.EventType.ViewZonesChanged, null);
            }
            return r;
        });
        return zonesHaveChanged;
    };
    View.prototype.getWhitespaces = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl.getWhitespaces: View is disposed');
        }
        return this.layoutProvider.getWhitespaces();
    };
    View.prototype.addContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.addContentWidget: View is disposed');
        }
        this.contentWidgets.addWidget(widgetData.widget);
        this.layoutContentWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.layoutContentWidget: View is disposed');
        }
        var newPosition = widgetData.position ? widgetData.position.position : null;
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newPreference);
        this._scheduleRender();
    };
    View.prototype.removeContentWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.removeContentWidget: View is disposed');
        }
        this.contentWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    View.prototype.addOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.addOverlayWidget: View is disposed');
        }
        this.overlayWidgets.addWidget(widgetData.widget);
        this.layoutOverlayWidget(widgetData);
        this._scheduleRender();
    };
    View.prototype.layoutOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.layoutOverlayWidget: View is disposed');
        }
        var newPreference = widgetData.position ? widgetData.position.preference : null;
        var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
        if (shouldRender) {
            this._scheduleRender();
        }
    };
    View.prototype.removeOverlayWidget = function (widgetData) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.removeOverlayWidget: View is disposed');
        }
        this.overlayWidgets.removeWidget(widgetData.widget);
        this._scheduleRender();
    };
    View.prototype.render = function (now, everything) {
        if (this._isDisposed) {
            throw new Error('ViewImpl.render: View is disposed');
        }
        if (everything) {
            // Force a render with a layout event
            this.layoutProvider.emitLayoutChangedEvent();
        }
        if (now) {
            this._flushAccumulatedAndRenderNow();
        }
    };
    // --- end Code Editor APIs
    View.prototype._renderOnce = function (callback) {
        var _this = this;
        if (this._isDisposed) {
            throw new Error('ViewImpl._renderOnce: View is disposed');
        }
        return this.outgoingEvents.deferredEmit(function () {
            var r = safeInvokeNoArg(callback);
            _this._scheduleRender();
            return r;
        });
    };
    View.prototype._scheduleRender = function () {
        if (this._isDisposed) {
            throw new Error('ViewImpl._scheduleRender: View is disposed');
        }
        if (this._renderAnimationFrame === null) {
            this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
        }
    };
    View.prototype._onRenderScheduled = function () {
        this._renderAnimationFrame = null;
        this._flushAccumulatedAndRenderNow();
    };
    View.prototype._renderNow = function () {
        var _this = this;
        safeInvokeNoArg(function () { return _this._actualRender(); });
    };
    View.prototype.createRenderingContext = function (linesViewportData) {
        var _this = this;
        var vInfo = this.layoutProvider.getCurrentViewport();
        var deltaTop = linesViewportData.visibleRangesDeltaTop;
        var r = {
            linesViewportData: linesViewportData,
            scrollWidth: this.layoutProvider.getScrollWidth(),
            scrollHeight: this.layoutProvider.getScrollHeight(),
            visibleRange: linesViewportData.visibleRange,
            bigNumbersDelta: linesViewportData.bigNumbersDelta,
            viewportWidth: vInfo.width,
            viewportHeight: vInfo.height,
            viewportLeft: vInfo.left,
            viewportTop: vInfo.top,
            getScrolledTopFromAbsoluteTop: function (absoluteTop) {
                return _this.layoutProvider.getScrolledTopFromAbsoluteTop(absoluteTop);
            },
            getViewportVerticalOffsetForLineNumber: function (lineNumber) {
                var verticalOffset = _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
                var scrolledTop = _this.layoutProvider.getScrolledTopFromAbsoluteTop(verticalOffset);
                return scrolledTop;
            },
            getDecorationsInViewport: function () { return linesViewportData.getDecorationsInViewport(); },
            linesVisibleRangesForRange: function (range, includeNewLines) {
                return _this.viewLines.linesVisibleRangesForRange(range, includeNewLines);
            },
            visibleRangeForPosition: function (position) {
                var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), deltaTop);
                if (!visibleRanges) {
                    return null;
                }
                return visibleRanges[0];
            },
            lineIsVisible: function (lineNumber) {
                return linesViewportData.visibleRange.startLineNumber <= lineNumber && lineNumber <= linesViewportData.visibleRange.endLineNumber;
            }
        };
        return r;
    };
    View.prototype._getViewPartsToRender = function () {
        var result = [];
        for (var i = 0, len = this.viewParts.length; i < len; i++) {
            var viewPart = this.viewParts[i];
            if (viewPart.shouldRender()) {
                result.push(viewPart);
            }
        }
        return result;
    };
    View.prototype._actualRender = function () {
        var _this = this;
        if (!dom.isInDOM(this.domNode)) {
            return;
        }
        var t = timer.start(timer.Topic.EDITOR, 'View.render');
        var viewPartsToRender = this._getViewPartsToRender();
        if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {
            // Nothing to render
            this.keyboardHandler.writeToTextArea();
            t.stop();
            return;
        }
        var linesViewportData = this.layoutProvider.getLinesViewportData();
        if (this.viewLines.shouldRender()) {
            this.viewLines.renderText(linesViewportData, function () {
                _this.keyboardHandler.writeToTextArea();
            });
            this.viewLines.onDidRender();
            // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again
            viewPartsToRender = this._getViewPartsToRender();
        }
        else {
            this.keyboardHandler.writeToTextArea();
        }
        var renderingContext = this.createRenderingContext(linesViewportData);
        // Render the rest of the parts
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.prepareRender(renderingContext);
        }
        for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
            var viewPart = viewPartsToRender[i];
            viewPart.render(renderingContext);
            viewPart.onDidRender();
        }
        // Render the scrollbar
        this.layoutProvider.renderScrollbar();
        t.stop();
    };
    View.prototype._setHasFocus = function (newHasFocus) {
        if (this.hasFocus !== newHasFocus) {
            this.hasFocus = newHasFocus;
            this._context.privateViewEventBus.emit(editorCommon.EventType.ViewFocusChanged, this.hasFocus);
        }
    };
    return View;
}(viewEventHandler_1.ViewEventHandler));
exports.View = View;
function safeInvokeNoArg(func) {
    try {
        return func();
    }
    catch (e) {
        errors_1.onUnexpectedError(e);
    }
}
function safeInvoke1Arg(func, arg1) {
    try {
        return func(arg1);
    }
    catch (e) {
        errors_1.onUnexpectedError(e);
    }
}
