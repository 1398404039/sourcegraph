/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
require("./viewLines.css");
var async_1 = require("vs/base/common/async");
var range_1 = require("vs/editor/common/core/range");
var position_1 = require("vs/editor/common/core/position");
var editorCommon = require("vs/editor/common/editorCommon");
var editorBrowser_1 = require("vs/editor/browser/editorBrowser");
var viewLayer_1 = require("vs/editor/browser/view/viewLayer");
var viewLine_1 = require("vs/editor/browser/viewParts/lines/viewLine");
var configuration_1 = require("vs/editor/browser/config/configuration");
var renderingContext_1 = require("vs/editor/common/view/renderingContext");
var viewPart_1 = require("vs/editor/browser/view/viewPart");
var LastRenderedData = (function () {
    function LastRenderedData() {
        this._currentVisibleRange = new range_1.Range(1, 1, 1, 1);
    }
    LastRenderedData.prototype.getCurrentVisibleRange = function () {
        return this._currentVisibleRange;
    };
    LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {
        this._currentVisibleRange = currentVisibleRange;
    };
    return LastRenderedData;
}());
var ViewLines = (function (_super) {
    __extends(ViewLines, _super);
    function ViewLines(context, linesContent, viewLayout) {
        var _this = _super.call(this, context) || this;
        _this._linesContent = linesContent;
        _this._viewLayout = viewLayout;
        _this._textRangeRestingSpot = document.createElement('div');
        _this._visibleLines = new viewLayer_1.VisibleLinesCollection(_this);
        _this.domNode = _this._visibleLines.domNode;
        _this._lineHeight = _this._context.configuration.editor.lineHeight;
        _this._isViewportWrapping = _this._context.configuration.editor.wrappingInfo.isViewportWrapping;
        _this._revealHorizontalRightPadding = _this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
        _this._canUseTranslate3d = _this._context.configuration.editor.viewInfo.canUseTranslate3d;
        _this._viewLineOptions = new viewLine_1.ViewLineOptions(_this._context.configuration);
        viewPart_1.PartFingerprints.write(_this.domNode.domNode, 7 /* ViewLines */);
        _this.domNode.setClassName(editorBrowser_1.ClassNames.VIEW_LINES);
        configuration_1.Configuration.applyFontInfo(_this.domNode, _this._context.configuration.editor.fontInfo);
        // --- width & height
        _this._maxLineWidth = 0;
        _this._asyncUpdateLineWidths = new async_1.RunOnceScheduler(function () {
            _this._updateLineWidths();
        }, 200);
        _this._lastRenderedData = new LastRenderedData();
        _this._lastCursorRevealRangeHorizontallyEvent = null;
        return _this;
    }
    ViewLines.prototype.dispose = function () {
        this._asyncUpdateLineWidths.dispose();
        _super.prototype.dispose.call(this);
    };
    ViewLines.prototype.getDomNode = function () {
        return this.domNode.domNode;
    };
    // ---- begin IVisibleLinesHost
    ViewLines.prototype.createVisibleLine = function () {
        return new viewLine_1.ViewLine(this._viewLineOptions);
    };
    // ---- end IVisibleLinesHost
    // ---- begin view event handlers
    ViewLines.prototype.onConfigurationChanged = function (e) {
        this._visibleLines.onConfigurationChanged(e);
        if (e.wrappingInfo) {
            this._maxLineWidth = 0;
        }
        if (e.lineHeight) {
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.wrappingInfo) {
            this._isViewportWrapping = this._context.configuration.editor.wrappingInfo.isViewportWrapping;
        }
        if (e.viewInfo.revealHorizontalRightPadding) {
            this._revealHorizontalRightPadding = this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
        }
        if (e.viewInfo.canUseTranslate3d) {
            this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
        }
        if (e.fontInfo) {
            configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
        }
        var newViewLineOptions = new viewLine_1.ViewLineOptions(this._context.configuration);
        if (!this._viewLineOptions.equals(newViewLineOptions)) {
            this._viewLineOptions = newViewLineOptions;
            var startLineNumber = this._visibleLines.getStartLineNumber();
            var endLineNumber = this._visibleLines.getEndLineNumber();
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var line = this._visibleLines.getVisibleLine(lineNumber);
                line.onOptionsChanged(this._viewLineOptions);
            }
        }
        if (e.layoutInfo) {
            this._maxLineWidth = 0;
        }
        return true;
    };
    ViewLines.prototype.onDecorationsChanged = function (e) {
        if (true /*e.inlineDecorationsChanged*/) {
            var rendStartLineNumber = this._visibleLines.getStartLineNumber();
            var rendEndLineNumber = this._visibleLines.getEndLineNumber();
            for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();
            }
        }
        return true;
    };
    ViewLines.prototype.onFlushed = function (e) {
        var shouldRender = this._visibleLines.onFlushed(e);
        this._maxLineWidth = 0;
        return shouldRender;
    };
    ViewLines.prototype.onLinesChanged = function (e) {
        return this._visibleLines.onLinesChanged(e);
    };
    ViewLines.prototype.onLinesDeleted = function (e) {
        return this._visibleLines.onLinesDeleted(e);
    };
    ViewLines.prototype.onLinesInserted = function (e) {
        return this._visibleLines.onLinesInserted(e);
    };
    ViewLines.prototype.onRevealRangeRequest = function (e) {
        var newScrollTop = this._computeScrollTopToRevealRange(this._viewLayout.getCurrentViewport(), e.range, e.verticalType);
        if (e.revealHorizontal) {
            this._lastCursorRevealRangeHorizontallyEvent = e;
        }
        this._viewLayout.setScrollPosition({
            scrollTop: newScrollTop
        });
        return true;
    };
    ViewLines.prototype.onScrollChanged = function (e) {
        this.domNode.setWidth(e.scrollWidth);
        return this._visibleLines.onScrollChanged(e) || true;
    };
    ViewLines.prototype.onTokensChanged = function (e) {
        return this._visibleLines.onTokensChanged(e);
    };
    ViewLines.prototype.onZonesChanged = function (e) {
        return this._visibleLines.onZonesChanged(e);
    };
    // ---- end view event handlers
    // ----------- HELPERS FOR OTHERS
    ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
        var viewLineDomNode = this._getViewLineDomNode(spanNode);
        if (viewLineDomNode === null) {
            // Couldn't find view line node
            return null;
        }
        var lineNumber = this._getLineNumberFor(viewLineDomNode);
        if (lineNumber === -1) {
            // Couldn't find view line node
            return null;
        }
        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {
            // lineNumber is outside range
            return null;
        }
        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {
            // Line is empty
            return new position_1.Position(lineNumber, 1);
        }
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
            // Couldn't find line
            return null;
        }
        var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);
        var minColumn = this._context.model.getLineMinColumn(lineNumber);
        if (column < minColumn) {
            column = minColumn;
        }
        return new position_1.Position(lineNumber, column);
    };
    ViewLines.prototype._getViewLineDomNode = function (node) {
        while (node && node.nodeType === 1) {
            if (node.className === editorBrowser_1.ClassNames.VIEW_LINE) {
                return node;
            }
            node = node.parentElement;
        }
        return null;
    };
    /**
     * @returns the line number of this view line dom node.
     */
    ViewLines.prototype._getLineNumberFor = function (domNode) {
        var startLineNumber = this._visibleLines.getStartLineNumber();
        var endLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var line = this._visibleLines.getVisibleLine(lineNumber);
            if (domNode === line.getDomNode()) {
                return lineNumber;
            }
        }
        return -1;
    };
    ViewLines.prototype.getLineWidth = function (lineNumber) {
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
            // Couldn't find line
            return -1;
        }
        return this._visibleLines.getVisibleLine(lineNumber).getWidth();
    };
    ViewLines.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
        if (this.shouldRender()) {
            // Cannot read from the DOM because it is dirty
            // i.e. the model & the dom are out of sync, so I'd be reading something stale
            return null;
        }
        var originalEndLineNumber = range.endLineNumber;
        range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
        if (!range) {
            return null;
        }
        var visibleRanges = [];
        var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
        var nextLineModelLineNumber;
        if (includeNewLines) {
            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(range.startLineNumber, 1)).lineNumber;
        }
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                continue;
            }
            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                continue;
            }
            if (includeNewLines && lineNumber < originalEndLineNumber) {
                var currentLineModelLineNumber = nextLineModelLineNumber;
                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(lineNumber + 1, 1)).lineNumber;
                if (currentLineModelLineNumber !== nextLineModelLineNumber) {
                    visibleRangesForLine[visibleRangesForLine.length - 1].width += ViewLines.LINE_FEED_WIDTH;
                }
            }
            visibleRanges.push(new renderingContext_1.LineVisibleRanges(lineNumber, visibleRangesForLine));
        }
        if (visibleRanges.length === 0) {
            return null;
        }
        return visibleRanges;
    };
    ViewLines.prototype.visibleRangesForRange2 = function (range) {
        if (this.shouldRender()) {
            // Cannot read from the DOM because it is dirty
            // i.e. the model & the dom are out of sync, so I'd be reading something stale
            return null;
        }
        range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
        if (!range) {
            return null;
        }
        var result = [];
        var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                continue;
            }
            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                continue;
            }
            result = result.concat(visibleRangesForLine);
        }
        if (result.length === 0) {
            return null;
        }
        return result;
    };
    // --- implementation
    ViewLines.prototype._updateLineWidths = function () {
        var rendStartLineNumber = this._visibleLines.getStartLineNumber();
        var rendEndLineNumber = this._visibleLines.getEndLineNumber();
        var localMaxLineWidth = 1;
        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
            var widthInPx = this._visibleLines.getVisibleLine(lineNumber).getWidth();
            localMaxLineWidth = Math.max(localMaxLineWidth, widthInPx);
        }
        if (rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {
            // we know the max line width for all the lines
            this._maxLineWidth = 0;
        }
        this._ensureMaxLineWidth(localMaxLineWidth);
    };
    ViewLines.prototype.prepareRender = function () {
        throw new Error('Not supported');
    };
    ViewLines.prototype.render = function () {
        throw new Error('Not supported');
    };
    ViewLines.prototype.renderText = function (viewportData, onAfterLinesRendered) {
        // (1) render lines - ensures lines are in the DOM
        this._visibleLines.renderLines(viewportData);
        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);
        this.domNode.setWidth(this._viewLayout.getScrollWidth());
        this.domNode.setHeight(Math.min(this._viewLayout.getScrollHeight(), 1000000));
        // (2) execute DOM writing that forces sync layout (e.g. textArea manipulation)
        onAfterLinesRendered();
        // (3) compute horizontal scroll position:
        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now
        //  - it might change `scrollWidth` and `scrollLeft`
        if (this._lastCursorRevealRangeHorizontallyEvent) {
            var revealHorizontalRange = this._lastCursorRevealRangeHorizontallyEvent.range;
            this._lastCursorRevealRangeHorizontallyEvent = null;
            // allow `visibleRangesForRange2` to work
            this.onDidRender();
            // compute new scroll position
            var newScrollLeft = this._computeScrollLeftToRevealRange(revealHorizontalRange);
            var isViewportWrapping = this._isViewportWrapping;
            if (!isViewportWrapping) {
                // ensure `scrollWidth` is large enough
                this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);
            }
            // set `scrollLeft`
            this._viewLayout.setScrollPosition({
                scrollLeft: newScrollLeft.scrollLeft
            });
        }
        // (4) handle scrolling
        var adjustedScrollTop = this._viewLayout.getScrollTop() - viewportData.bigNumbersDelta;
        if (this._canUseTranslate3d) {
            var transform = 'translate3d(' + -this._viewLayout.getScrollLeft() + 'px, ' + -adjustedScrollTop + 'px, 0px)';
            this._linesContent.setTransform(transform);
            this._linesContent.setTop(0);
            this._linesContent.setLeft(0);
        }
        else {
            this._linesContent.setTransform('');
            this._linesContent.setTop(-adjustedScrollTop);
            this._linesContent.setLeft(-this._viewLayout.getScrollLeft());
        }
        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)
        this._asyncUpdateLineWidths.schedule();
    };
    // --- width
    ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {
        var iLineWidth = Math.ceil(lineWidth);
        if (this._maxLineWidth < iLineWidth) {
            this._maxLineWidth = iLineWidth;
            this._viewLayout.onMaxLineWidthChanged(this._maxLineWidth);
        }
    };
    ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {
        var viewportStartY = viewport.top;
        var viewportHeight = viewport.height;
        var viewportEndY = viewportStartY + viewportHeight;
        var boxStartY;
        var boxEndY;
        // Have a box that includes one extra line height (for the horizontal scrollbar)
        boxStartY = this._viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);
        boxEndY = this._viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;
        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {
            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom
            boxEndY += this._lineHeight;
        }
        var newScrollTop;
        if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {
            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
                // Box is already in the viewport... do nothing
                newScrollTop = viewportStartY;
            }
            else {
                // Box is outside the viewport... center it
                var boxMiddleY = (boxStartY + boxEndY) / 2;
                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);
            }
        }
        else {
            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);
        }
        return newScrollTop;
    };
    ViewLines.prototype._computeScrollLeftToRevealRange = function (range) {
        var maxHorizontalOffset = 0;
        if (range.startLineNumber !== range.endLineNumber) {
            // Two or more lines? => scroll to base (That's how you see most of the two lines)
            return {
                scrollLeft: 0,
                maxHorizontalOffset: maxHorizontalOffset
            };
        }
        var viewport = this._viewLayout.getCurrentViewport();
        var viewportStartX = viewport.left;
        var viewportEndX = viewportStartX + viewport.width;
        var visibleRanges = this.visibleRangesForRange2(range);
        var boxStartX = Number.MAX_VALUE;
        var boxEndX = 0;
        if (!visibleRanges) {
            // Unknown
            return {
                scrollLeft: viewportStartX,
                maxHorizontalOffset: maxHorizontalOffset
            };
        }
        for (var i = 0; i < visibleRanges.length; i++) {
            var visibleRange = visibleRanges[i];
            if (visibleRange.left < boxStartX) {
                boxStartX = visibleRange.left;
            }
            if (visibleRange.left + visibleRange.width > boxEndX) {
                boxEndX = visibleRange.left + visibleRange.width;
            }
        }
        maxHorizontalOffset = boxEndX;
        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);
        boxEndX += this._revealHorizontalRightPadding;
        var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);
        return {
            scrollLeft: newScrollLeft,
            maxHorizontalOffset: maxHorizontalOffset
        };
    };
    ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {
        viewportStart = viewportStart | 0;
        viewportEnd = viewportEnd | 0;
        boxStart = boxStart | 0;
        boxEnd = boxEnd | 0;
        revealAtStart = !!revealAtStart;
        revealAtEnd = !!revealAtEnd;
        var viewportLength = viewportEnd - viewportStart;
        var boxLength = boxEnd - boxStart;
        if (boxLength < viewportLength) {
            // The box would fit in the viewport
            if (revealAtStart) {
                return boxStart;
            }
            if (revealAtEnd) {
                return Math.max(0, boxEnd - viewportLength);
            }
            if (boxStart < viewportStart) {
                // The box is above the viewport
                return boxStart;
            }
            else if (boxEnd > viewportEnd) {
                // The box is below the viewport
                return Math.max(0, boxEnd - viewportLength);
            }
        }
        else {
            // The box would not fit in the viewport
            // Reveal the beginning of the box
            return boxStart;
        }
        return viewportStart;
    };
    return ViewLines;
}(viewPart_1.ViewPart));
/**
 * Width to extends a line to render the line feed at the end of the line
 */
ViewLines.LINE_FEED_WIDTH = 10;
/**
 * Adds this ammount of pixels to the right of lines (no-one wants to type near the edge of the viewport)
 */
ViewLines.HORIZONTAL_EXTRA_PX = 30;
exports.ViewLines = ViewLines;
