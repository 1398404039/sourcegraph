/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var lifecycle_1 = require("vs/base/common/lifecycle");
var dom = require("vs/base/browser/dom");
var scrollableElement_1 = require("vs/base/browser/ui/scrollbar/scrollableElement");
var editorBrowser_1 = require("vs/editor/browser/editorBrowser");
var viewPart_1 = require("vs/editor/browser/view/viewPart");
var fastDomNode_1 = require("vs/base/browser/fastDomNode");
var EditorScrollbar = (function (_super) {
    __extends(EditorScrollbar, _super);
    function EditorScrollbar(context, scrollable, linesContent, viewDomNode, overflowGuardDomNode) {
        var _this = _super.call(this, context) || this;
        _this.toDispose = [];
        _this.scrollable = scrollable;
        var viewInfo = _this._context.configuration.editor.viewInfo;
        var configScrollbarOpts = viewInfo.scrollbar;
        var scrollbarOptions = {
            canUseTranslate3d: viewInfo.canUseTranslate3d,
            listenOnDomNode: viewDomNode.domNode,
            className: editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + viewInfo.theme,
            useShadows: false,
            lazyRender: true,
            vertical: configScrollbarOpts.vertical,
            horizontal: configScrollbarOpts.horizontal,
            verticalHasArrows: configScrollbarOpts.verticalHasArrows,
            horizontalHasArrows: configScrollbarOpts.horizontalHasArrows,
            verticalScrollbarSize: configScrollbarOpts.verticalScrollbarSize,
            verticalSliderSize: configScrollbarOpts.verticalSliderSize,
            horizontalScrollbarSize: configScrollbarOpts.horizontalScrollbarSize,
            horizontalSliderSize: configScrollbarOpts.horizontalSliderSize,
            handleMouseWheel: configScrollbarOpts.handleMouseWheel,
            arrowSize: configScrollbarOpts.arrowSize,
            mouseWheelScrollSensitivity: configScrollbarOpts.mouseWheelScrollSensitivity,
        };
        _this.scrollbar = new scrollableElement_1.ScrollableElement(linesContent.domNode, scrollbarOptions, _this.scrollable);
        viewPart_1.PartFingerprints.write(_this.scrollbar.getDomNode(), 5 /* ScrollableElement */);
        _this.toDispose.push(_this.scrollbar);
        _this.scrollbarDomNode = fastDomNode_1.createFastDomNode(_this.scrollbar.getDomNode());
        _this.scrollbarDomNode.setPosition('absolute');
        _this._setLayout();
        // When having a zone widget that calls .focus() on one of its dom elements,
        // the browser will try desperately to reveal that dom node, unexpectedly
        // changing the .scrollTop of this.linesContent
        var onBrowserDesperateReveal = function (domNode, lookAtScrollTop, lookAtScrollLeft) {
            var scrollState = _this.scrollable.getState();
            var newScrollPosition = {};
            if (lookAtScrollTop) {
                var deltaTop = domNode.scrollTop;
                if (deltaTop) {
                    newScrollPosition.scrollTop = scrollState.scrollTop + deltaTop;
                    domNode.scrollTop = 0;
                }
            }
            if (lookAtScrollLeft) {
                var deltaLeft = domNode.scrollLeft;
                if (deltaLeft) {
                    newScrollPosition.scrollLeft = scrollState.scrollLeft + deltaLeft;
                    domNode.scrollLeft = 0;
                }
            }
            _this.scrollable.updateState(newScrollPosition);
        };
        // I've seen this happen both on the view dom node & on the lines content dom node.
        _this.toDispose.push(dom.addDisposableListener(viewDomNode.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(viewDomNode.domNode, true, true); }));
        _this.toDispose.push(dom.addDisposableListener(linesContent.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(linesContent.domNode, true, false); }));
        _this.toDispose.push(dom.addDisposableListener(overflowGuardDomNode.domNode, 'scroll', function (e) { return onBrowserDesperateReveal(overflowGuardDomNode.domNode, true, false); }));
        return _this;
    }
    EditorScrollbar.prototype.dispose = function () {
        this.toDispose = lifecycle_1.dispose(this.toDispose);
    };
    EditorScrollbar.prototype._setLayout = function () {
        var layoutInfo = this._context.configuration.editor.layoutInfo;
        this.scrollbarDomNode.setLeft(layoutInfo.contentLeft);
        this.scrollbarDomNode.setWidth(layoutInfo.contentWidth + layoutInfo.minimapWidth);
        this.scrollbarDomNode.setHeight(layoutInfo.contentHeight);
    };
    EditorScrollbar.prototype.getOverviewRulerLayoutInfo = function () {
        return this.scrollbar.getOverviewRulerLayoutInfo();
    };
    EditorScrollbar.prototype.getDomNode = function () {
        return this.scrollbarDomNode.domNode;
    };
    EditorScrollbar.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
        this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
    };
    EditorScrollbar.prototype.getVerticalSliderVerticalCenter = function () {
        return this.scrollbar.getVerticalSliderVerticalCenter();
    };
    // --- begin event handlers
    EditorScrollbar.prototype.onConfigurationChanged = function (e) {
        var viewInfo = this._context.configuration.editor.viewInfo;
        this.scrollbar.updateClassName(editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + viewInfo.theme);
        if (e.viewInfo.scrollbar || e.viewInfo.canUseTranslate3d) {
            var newOpts = {
                canUseTranslate3d: viewInfo.canUseTranslate3d,
                handleMouseWheel: viewInfo.scrollbar.handleMouseWheel,
                mouseWheelScrollSensitivity: viewInfo.scrollbar.mouseWheelScrollSensitivity
            };
            this.scrollbar.updateOptions(newOpts);
        }
        if (e.layoutInfo) {
            this._setLayout();
        }
        return true;
    };
    EditorScrollbar.prototype.onCursorPositionChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onCursorSelectionChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onDecorationsChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onFlushed = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onFocusChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onLineMappingChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onLinesChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onLinesDeleted = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onLinesInserted = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onRevealRangeRequest = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onScrollChanged = function (e) {
        return true;
    };
    EditorScrollbar.prototype.onScrollRequest = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onTokensChanged = function (e) {
        return false;
    };
    EditorScrollbar.prototype.onZonesChanged = function (e) {
        return false;
    };
    // --- end event handlers
    EditorScrollbar.prototype.prepareRender = function (ctx) {
        // Nothing to do
    };
    EditorScrollbar.prototype.render = function (ctx) {
        this.scrollbar.renderNow();
    };
    return EditorScrollbar;
}(viewPart_1.ViewPart));
exports.EditorScrollbar = EditorScrollbar;
