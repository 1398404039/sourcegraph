/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var viewLineToken_1 = require("vs/editor/common/core/viewLineToken");
var lineDecorations_1 = require("vs/editor/common/viewLayout/lineDecorations");
var strings = require("vs/base/common/strings");
var RenderWhitespace;
(function (RenderWhitespace) {
    RenderWhitespace[RenderWhitespace["None"] = 0] = "None";
    RenderWhitespace[RenderWhitespace["Boundary"] = 1] = "Boundary";
    RenderWhitespace[RenderWhitespace["All"] = 2] = "All";
})(RenderWhitespace = exports.RenderWhitespace || (exports.RenderWhitespace = {}));
var LinePart = (function () {
    function LinePart(endIndex, type) {
        this.endIndex = endIndex;
        this.type = type;
    }
    return LinePart;
}());
var RenderLineInput = (function () {
    function RenderLineInput(useMonospaceOptimizations, lineContent, mightContainRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters) {
        this.useMonospaceOptimizations = useMonospaceOptimizations;
        this.lineContent = lineContent;
        this.mightContainRTL = mightContainRTL;
        this.fauxIndentLength = fauxIndentLength;
        this.lineTokens = lineTokens;
        this.lineDecorations = lineDecorations;
        this.tabSize = tabSize;
        this.spaceWidth = spaceWidth;
        this.stopRenderingLineAfter = stopRenderingLineAfter;
        this.renderWhitespace = (renderWhitespace === 'all'
            ? 2 /* All */
            : renderWhitespace === 'boundary'
                ? 1 /* Boundary */
                : 0 /* None */);
        this.renderControlCharacters = renderControlCharacters;
    }
    RenderLineInput.prototype.equals = function (other) {
        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations
            && this.lineContent === other.lineContent
            && this.mightContainRTL === other.mightContainRTL
            && this.fauxIndentLength === other.fauxIndentLength
            && this.tabSize === other.tabSize
            && this.spaceWidth === other.spaceWidth
            && this.stopRenderingLineAfter === other.stopRenderingLineAfter
            && this.renderWhitespace === other.renderWhitespace
            && this.renderControlCharacters === other.renderControlCharacters
            && lineDecorations_1.LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)
            && viewLineToken_1.ViewLineToken.equalsArr(this.lineTokens, other.lineTokens));
    };
    return RenderLineInput;
}());
exports.RenderLineInput = RenderLineInput;
var CharacterMappingConstants;
(function (CharacterMappingConstants) {
    CharacterMappingConstants[CharacterMappingConstants["PART_INDEX_MASK"] = 4294901760] = "PART_INDEX_MASK";
    CharacterMappingConstants[CharacterMappingConstants["CHAR_INDEX_MASK"] = 65535] = "CHAR_INDEX_MASK";
    CharacterMappingConstants[CharacterMappingConstants["CHAR_INDEX_OFFSET"] = 0] = "CHAR_INDEX_OFFSET";
    CharacterMappingConstants[CharacterMappingConstants["PART_INDEX_OFFSET"] = 16] = "PART_INDEX_OFFSET";
})(CharacterMappingConstants = exports.CharacterMappingConstants || (exports.CharacterMappingConstants = {}));
/**
 * Provides a both direction mapping between a line's character and its rendered position.
 */
var CharacterMapping = (function () {
    function CharacterMapping(length, partCount) {
        this.length = length;
        this._data = new Uint32Array(this.length);
        this._partLengths = new Uint16Array(partCount);
    }
    CharacterMapping.getPartIndex = function (partData) {
        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;
    };
    CharacterMapping.getCharIndex = function (partData) {
        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;
    };
    CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex) {
        var partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)
            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
        this._data[charOffset] = partData;
    };
    CharacterMapping.prototype.setPartLength = function (partIndex, length) {
        this._partLengths[partIndex] = length;
    };
    CharacterMapping.prototype.getPartLengths = function () {
        return this._partLengths;
    };
    CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {
        if (this.length === 0) {
            return 0;
        }
        if (charOffset < 0) {
            return this._data[0];
        }
        if (charOffset >= this.length) {
            return this._data[this.length - 1];
        }
        return this._data[charOffset];
    };
    CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {
        if (this.length === 0) {
            return 0;
        }
        var searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)
            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
        var min = 0;
        var max = this.length - 1;
        while (min + 1 < max) {
            var mid = ((min + max) >>> 1);
            var midEntry = this._data[mid];
            if (midEntry === searchEntry) {
                return mid;
            }
            else if (midEntry > searchEntry) {
                max = mid;
            }
            else {
                min = mid;
            }
        }
        if (min === max) {
            return min;
        }
        var minEntry = this._data[min];
        var maxEntry = this._data[max];
        if (minEntry === searchEntry) {
            return min;
        }
        if (maxEntry === searchEntry) {
            return max;
        }
        var minPartIndex = CharacterMapping.getPartIndex(minEntry);
        var minCharIndex = CharacterMapping.getCharIndex(minEntry);
        var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);
        var maxCharIndex;
        if (minPartIndex !== maxPartIndex) {
            // sitting between parts
            maxCharIndex = partLength;
        }
        else {
            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);
        }
        var minEntryDistance = charIndex - minCharIndex;
        var maxEntryDistance = maxCharIndex - charIndex;
        if (minEntryDistance <= maxEntryDistance) {
            return min;
        }
        return max;
    };
    return CharacterMapping;
}());
exports.CharacterMapping = CharacterMapping;
var RenderLineOutput = (function () {
    function RenderLineOutput(characterMapping, html, containsRTL, containsForeignElements) {
        this.characterMapping = characterMapping;
        this.html = html;
        this.containsRTL = containsRTL;
        this.containsForeignElements = containsForeignElements;
    }
    return RenderLineOutput;
}());
exports.RenderLineOutput = RenderLineOutput;
function renderViewLine(input) {
    if (input.lineContent.length === 0) {
        return new RenderLineOutput(new CharacterMapping(0, 0), 
        // This is basically for IE's hit test to work
        '<span><span>&nbsp;</span></span>', false, false);
    }
    return _renderLine(resolveRenderLineInput(input));
}
exports.renderViewLine = renderViewLine;
var ResolvedRenderLineInput = (function () {
    function ResolvedRenderLineInput(fontIsMonospace, lineContent, len, isOverflowing, parts, containsForeignElements, tabSize, containsRTL, spaceWidth, renderWhitespace, renderControlCharacters) {
        this.fontIsMonospace = fontIsMonospace;
        this.lineContent = lineContent;
        this.len = len;
        this.isOverflowing = isOverflowing;
        this.parts = parts;
        this.containsForeignElements = containsForeignElements;
        this.tabSize = tabSize;
        this.containsRTL = containsRTL;
        this.spaceWidth = spaceWidth;
        this.renderWhitespace = renderWhitespace;
        this.renderControlCharacters = renderControlCharacters;
        //
    }
    return ResolvedRenderLineInput;
}());
function resolveRenderLineInput(input) {
    var useMonospaceOptimizations = input.useMonospaceOptimizations;
    var lineContent = input.lineContent;
    var isOverflowing;
    var len;
    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {
        isOverflowing = true;
        len = input.stopRenderingLineAfter;
    }
    else {
        isOverflowing = false;
        len = lineContent.length;
    }
    var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);
    if (input.renderWhitespace === 2 /* All */ || input.renderWhitespace === 1 /* Boundary */) {
        tokens = _applyRenderWhitespace(lineContent, len, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.renderWhitespace === 1 /* Boundary */);
    }
    var containsForeignElements = false;
    if (input.lineDecorations.length > 0) {
        for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {
            var lineDecoration = input.lineDecorations[i];
            if (lineDecoration.insertsBeforeOrAfter) {
                containsForeignElements = true;
                break;
            }
        }
        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);
    }
    var containsRTL = false;
    if (input.mightContainRTL) {
        containsRTL = strings.containsRTL(lineContent);
    }
    if (!containsRTL) {
        tokens = splitLargeTokens(lineContent, tokens);
    }
    return new ResolvedRenderLineInput(useMonospaceOptimizations, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);
}
/**
 * In the rendering phase, characters are always looped until token.endIndex.
 * Ensure that all tokens end before `len` and the last one ends precisely at `len`.
 */
function transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {
    var result = [], resultLen = 0;
    // The faux indent part of the line should have no token type
    if (fauxIndentLength > 0) {
        result[resultLen++] = new LinePart(fauxIndentLength, '');
    }
    for (var tokenIndex = 0, tokensLen = tokens.length; tokenIndex < tokensLen; tokenIndex++) {
        var token = tokens[tokenIndex];
        var endIndex = token.endIndex;
        if (endIndex <= fauxIndentLength) {
            // The faux indent part of the line should have no token type
            continue;
        }
        var type = token.getType();
        if (endIndex >= len) {
            result[resultLen++] = new LinePart(len, type);
            break;
        }
        result[resultLen++] = new LinePart(endIndex, type);
    }
    return result;
}
/**
 * written as a const enum to get value inlining.
 */
var Constants;
(function (Constants) {
    Constants[Constants["LongToken"] = 50] = "LongToken";
})(Constants || (Constants = {}));
/**
 * See https://github.com/Microsoft/vscode/issues/6885.
 * It appears that having very large spans causes very slow reading of character positions.
 * So here we try to avoid that.
 */
function splitLargeTokens(lineContent, tokens) {
    var lastTokenEndIndex = 0;
    var result = [], resultLen = 0;
    for (var i = 0, len = tokens.length; i < len; i++) {
        var token = tokens[i];
        var tokenEndIndex = token.endIndex;
        var diff = (tokenEndIndex - lastTokenEndIndex);
        if (diff > 50 /* LongToken */) {
            var tokenType = token.type;
            var piecesCount = Math.ceil(diff / 50 /* LongToken */);
            for (var j = 1; j < piecesCount; j++) {
                var pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);
                var lastCharInPiece = lineContent.charCodeAt(pieceEndIndex - 1);
                if (strings.isHighSurrogate(lastCharInPiece)) {
                    // Don't cut in the middle of a surrogate pair
                    pieceEndIndex--;
                }
                result[resultLen++] = new LinePart(pieceEndIndex, tokenType);
            }
            result[resultLen++] = new LinePart(tokenEndIndex, tokenType);
        }
        else {
            result[resultLen++] = token;
        }
        lastTokenEndIndex = tokenEndIndex;
    }
    return result;
}
/**
 * Whitespace is rendered by "replacing" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.
 * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.
 * The rendering phase will generate `style="width:..."` for these tokens.
 */
function _applyRenderWhitespace(lineContent, len, tokens, fauxIndentLength, tabSize, useMonospaceOptimizations, onlyBoundary) {
    var result = [], resultLen = 0;
    var tokenIndex = 0;
    var tokenType = tokens[tokenIndex].type;
    var tokenEndIndex = tokens[tokenIndex].endIndex;
    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
    var lastNonWhitespaceIndex;
    if (firstNonWhitespaceIndex === -1) {
        // The entire line is whitespace
        firstNonWhitespaceIndex = len;
        lastNonWhitespaceIndex = len;
    }
    else {
        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
    }
    var tmpIndent = 0;
    for (var charIndex = 0; charIndex < fauxIndentLength; charIndex++) {
        var chCode = lineContent.charCodeAt(charIndex);
        if (chCode === 9 /* Tab */) {
            tmpIndent = tabSize;
        }
        else {
            tmpIndent++;
        }
    }
    tmpIndent = tmpIndent % tabSize;
    var wasInWhitespace = false;
    for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {
        var chCode = lineContent.charCodeAt(charIndex);
        var isInWhitespace = void 0;
        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {
            // in leading or trailing whitespace
            isInWhitespace = true;
        }
        else if (chCode === 9 /* Tab */) {
            // a tab character is rendered both in all and boundary cases
            isInWhitespace = true;
        }
        else if (chCode === 32 /* Space */) {
            // hit a space character
            if (onlyBoundary) {
                // rendering only boundary whitespace
                if (wasInWhitespace) {
                    isInWhitespace = true;
                }
                else {
                    var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);
                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);
                }
            }
            else {
                isInWhitespace = true;
            }
        }
        else {
            isInWhitespace = false;
        }
        if (wasInWhitespace) {
            // was in whitespace token
            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {
                // leaving whitespace token or entering a new indent
                result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');
                tmpIndent = tmpIndent % tabSize;
            }
        }
        else {
            // was in regular token
            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {
                result[resultLen++] = new LinePart(charIndex, tokenType);
                tmpIndent = tmpIndent % tabSize;
            }
        }
        if (chCode === 9 /* Tab */) {
            tmpIndent = tabSize;
        }
        else {
            tmpIndent++;
        }
        wasInWhitespace = isInWhitespace;
        if (charIndex === tokenEndIndex) {
            tokenIndex++;
            tokenType = tokens[tokenIndex].type;
            tokenEndIndex = tokens[tokenIndex].endIndex;
        }
    }
    if (wasInWhitespace) {
        // was in whitespace token
        result[resultLen++] = new LinePart(len, 'vs-whitespace');
    }
    else {
        // was in regular token
        result[resultLen++] = new LinePart(len, tokenType);
    }
    return result;
}
/**
 * Inline decorations are "merged" on top of tokens.
 * Special care must be taken when multiple inline decorations are at play and they overlap.
 */
function _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {
    _lineDecorations.sort(lineDecorations_1.LineDecoration.compare);
    var lineDecorations = lineDecorations_1.LineDecorationsNormalizer.normalize(_lineDecorations);
    var lineDecorationsLen = lineDecorations.length;
    var lineDecorationIndex = 0;
    var result = [], resultLen = 0, lastResultEndIndex = 0;
    for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {
        var token = tokens[tokenIndex];
        var tokenEndIndex = token.endIndex;
        var tokenType = token.type;
        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {
            var lineDecoration = lineDecorations[lineDecorationIndex];
            if (lineDecoration.startOffset > lastResultEndIndex) {
                lastResultEndIndex = lineDecoration.startOffset;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);
            }
            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {
                // This line decoration ends before this token ends
                lastResultEndIndex = lineDecoration.endOffset + 1;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);
                lineDecorationIndex++;
            }
            else {
                // This line decoration continues on to the next token
                lastResultEndIndex = tokenEndIndex;
                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);
                break;
            }
        }
        if (tokenEndIndex > lastResultEndIndex) {
            lastResultEndIndex = tokenEndIndex;
            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);
        }
    }
    return result;
}
/**
 * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).
 * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).
 */
function _renderLine(input) {
    var fontIsMonospace = input.fontIsMonospace;
    var containsForeignElements = input.containsForeignElements;
    var lineContent = input.lineContent;
    var len = input.len;
    var isOverflowing = input.isOverflowing;
    var parts = input.parts;
    var tabSize = input.tabSize;
    var containsRTL = input.containsRTL;
    var spaceWidth = input.spaceWidth;
    var renderWhitespace = input.renderWhitespace;
    var renderControlCharacters = input.renderControlCharacters;
    var characterMapping = new CharacterMapping(len + 1, parts.length);
    var charIndex = 0;
    var tabsCharDelta = 0;
    var charOffsetInPart = 0;
    var out = '<span>';
    for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {
        var part = parts[partIndex];
        var partEndIndex = part.endIndex;
        var partType = part.type;
        var partRendersWhitespace = (renderWhitespace !== 0 /* None */ && (partType.indexOf('vs-whitespace') >= 0));
        charOffsetInPart = 0;
        if (partRendersWhitespace) {
            var partContentCnt = 0;
            var partContent = '';
            for (; charIndex < partEndIndex; charIndex++) {
                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart);
                var charCode = lineContent.charCodeAt(charIndex);
                if (charCode === 9 /* Tab */) {
                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                    tabsCharDelta += insertSpacesCount - 1;
                    charOffsetInPart += insertSpacesCount - 1;
                    if (insertSpacesCount > 0) {
                        partContent += '&rarr;';
                        partContentCnt++;
                        insertSpacesCount--;
                    }
                    while (insertSpacesCount > 0) {
                        partContent += '&nbsp;';
                        partContentCnt++;
                        insertSpacesCount--;
                    }
                }
                else {
                    // must be CharCode.Space
                    partContent += '&middot;';
                    partContentCnt++;
                }
                charOffsetInPart++;
            }
            characterMapping.setPartLength(partIndex, partContentCnt);
            if (fontIsMonospace) {
                out += "<span class=\"" + partType + "\">" + partContent + "</span>";
            }
            else {
                out += "<span class=\"" + partType + "\" style=\"width:" + spaceWidth * partContentCnt + "px\">" + partContent + "</span>";
            }
        }
        else {
            var partContentCnt = 0;
            var partContent = '';
            for (; charIndex < partEndIndex; charIndex++) {
                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart);
                var charCode = lineContent.charCodeAt(charIndex);
                switch (charCode) {
                    case 9 /* Tab */:
                        var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                        tabsCharDelta += insertSpacesCount - 1;
                        charOffsetInPart += insertSpacesCount - 1;
                        while (insertSpacesCount > 0) {
                            partContent += '&nbsp;';
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                        break;
                    case 32 /* Space */:
                        partContent += '&nbsp;';
                        partContentCnt++;
                        break;
                    case 60 /* LessThan */:
                        partContent += '&lt;';
                        partContentCnt++;
                        break;
                    case 62 /* GreaterThan */:
                        partContent += '&gt;';
                        partContentCnt++;
                        break;
                    case 38 /* Ampersand */:
                        partContent += '&amp;';
                        partContentCnt++;
                        break;
                    case 0 /* Null */:
                        partContent += '&#00;';
                        partContentCnt++;
                        break;
                    case 65279 /* UTF8_BOM */:
                    case 8232 /* LINE_SEPARATOR_2028 */:
                        partContent += '\ufffd';
                        partContentCnt++;
                        break;
                    case 13 /* CarriageReturn */:
                        // zero width space, because carriage return would introduce a line break
                        partContent += '&#8203';
                        partContentCnt++;
                        break;
                    default:
                        if (renderControlCharacters && charCode < 32) {
                            partContent += String.fromCharCode(9216 + charCode);
                            partContentCnt++;
                        }
                        else {
                            partContent += String.fromCharCode(charCode);
                            partContentCnt++;
                        }
                }
                charOffsetInPart++;
            }
            characterMapping.setPartLength(partIndex, partContentCnt);
            if (containsRTL) {
                out += "<span dir=\"ltr\" class=\"" + partType + "\">" + partContent + "</span>";
            }
            else {
                out += "<span class=\"" + partType + "\">" + partContent + "</span>";
            }
        }
    }
    // When getting client rects for the last character, we will position the
    // text range at the end of the span, insteaf of at the beginning of next span
    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart);
    if (isOverflowing) {
        out += "<span>&hellip;</span>";
    }
    out += '</span>';
    return new RenderLineOutput(characterMapping, out, containsRTL, containsForeignElements);
}
