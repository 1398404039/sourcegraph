import { OrderGuaranteeEventEmitter } from 'vs/base/common/eventEmitter';
import { Position } from 'vs/editor/common/core/position';
import { Range } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { ModelLine } from 'vs/editor/common/model/modelLine';
import { PrefixSumComputer } from 'vs/editor/common/viewModel/prefixSumComputer';
import { IndentRange } from 'vs/editor/common/model/indentRanges';
import { ITextSource, IRawTextSource } from 'vs/editor/common/model/textSource';
export declare const LONG_LINE_BOUNDARY = 1000;
export interface ITextModelCreationData {
    readonly text: ITextSource;
    readonly options: editorCommon.TextModelResolvedOptions;
}
export declare class TextModel extends OrderGuaranteeEventEmitter implements editorCommon.ITextModel {
    private static MODEL_SYNC_LIMIT;
    private static MODEL_TOKENIZATION_LIMIT;
    static DEFAULT_CREATION_OPTIONS: editorCommon.ITextModelCreationOptions;
    static createFromString(text: string, options?: editorCommon.ITextModelCreationOptions): TextModel;
    static resolveCreationData(rawTextSource: IRawTextSource, options: editorCommon.ITextModelCreationOptions): ITextModelCreationData;
    _lines: ModelLine[];
    protected _EOL: string;
    protected _isDisposed: boolean;
    protected _isDisposing: boolean;
    protected _options: editorCommon.TextModelResolvedOptions;
    protected _lineStarts: PrefixSumComputer;
    private _indentRanges;
    private _versionId;
    /**
     * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)
     */
    private _alternativeVersionId;
    private _BOM;
    protected _mightContainRTL: boolean;
    protected _mightContainNonBasicASCII: boolean;
    private _shouldSimplifyMode;
    private _shouldDenyMode;
    constructor(allowedEventTypes: string[], rawTextSource: IRawTextSource, creationOptions: editorCommon.ITextModelCreationOptions);
    protected _assertNotDisposed(): void;
    isTooLargeForHavingAMode(): boolean;
    isTooLargeForHavingARichMode(): boolean;
    getOptions(): editorCommon.TextModelResolvedOptions;
    updateOptions(_newOpts: editorCommon.ITextModelUpdateOptions): void;
    detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
    private static _normalizeIndentationFromWhitespace(str, tabSize, insertSpaces);
    static normalizeIndentation(str: string, tabSize: number, insertSpaces: boolean): string;
    normalizeIndentation(str: string): string;
    getOneIndent(): string;
    getVersionId(): number;
    mightContainRTL(): boolean;
    mightContainNonBasicASCII(): boolean;
    getAlternativeVersionId(): number;
    private _ensureLineStarts();
    getOffsetAt(rawPosition: editorCommon.IPosition): number;
    getPositionAt(offset: number): Position;
    protected _increaseVersionId(): void;
    protected _setVersionId(newVersionId: number): void;
    protected _overwriteAlternativeVersionId(newAlternativeVersionId: number): void;
    isDisposed(): boolean;
    dispose(): void;
    protected _createContentChangedFlushEvent(): editorCommon.IModelContentChangedFlushEvent;
    protected _emitContentChanged2(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, rangeLength: number, text: string, isUndoing: boolean, isRedoing: boolean): void;
    protected _resetValue(newValue: ITextSource): void;
    equals(other: ITextSource): boolean;
    setValue(value: string): void;
    setValueFromTextSource(newValue: ITextSource): void;
    getValue(eol?: editorCommon.EndOfLinePreference, preserveBOM?: boolean): string;
    getValueLength(eol?: editorCommon.EndOfLinePreference, preserveBOM?: boolean): number;
    getEmptiedValueInRange(rawRange: editorCommon.IRange, fillCharacter?: string, eol?: editorCommon.EndOfLinePreference): string;
    private _repeatCharacter(fillCharacter, count);
    getValueInRange(rawRange: editorCommon.IRange, eol?: editorCommon.EndOfLinePreference): string;
    getValueLengthInRange(rawRange: editorCommon.IRange, eol?: editorCommon.EndOfLinePreference): number;
    isDominatedByLongLines(): boolean;
    getLineCount(): number;
    getLineContent(lineNumber: number): string;
    getIndentLevel(lineNumber: number): number;
    protected _resetIndentRanges(): void;
    private _getIndentRanges();
    getIndentRanges(): IndentRange[];
    private _toValidLineIndentGuide(lineNumber, indentGuide);
    getLineIndentGuide(lineNumber: number): number;
    getLinesContent(): string[];
    getEOL(): string;
    setEOL(eol: editorCommon.EndOfLineSequence): void;
    getLineMinColumn(lineNumber: number): number;
    getLineMaxColumn(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    validateLineNumber(lineNumber: number): number;
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    private _validatePosition(_lineNumber, _column, strict);
    validatePosition(position: editorCommon.IPosition): Position;
    validateRange(_range: editorCommon.IRange): Range;
    modifyPosition(rawPosition: editorCommon.IPosition, offset: number): Position;
    getFullModelRange(): Range;
    protected _emitModelContentChangedFlushEvent(e: editorCommon.IModelContentChangedFlushEvent): void;
    private _constructLines(textSource);
    private _getEndOfLine(eol);
    findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): editorCommon.FindMatch[];
    findNextMatch(searchString: string, rawSearchStart: editorCommon.IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): editorCommon.FindMatch;
    findPreviousMatch(searchString: string, rawSearchStart: editorCommon.IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): editorCommon.FindMatch;
}
