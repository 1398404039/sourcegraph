/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var strings = require("vs/base/common/strings");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var textModel_1 = require("vs/editor/common/model/textModel");
var selection_1 = require("vs/editor/common/core/selection");
var range_1 = require("vs/editor/common/core/range");
var CursorConfiguration = (function () {
    function CursorConfiguration(oneIndent, modelOptions, configuration, modeConfiguration) {
        var c = configuration.editor;
        this.tabSize = modelOptions.tabSize;
        this.insertSpaces = modelOptions.insertSpaces;
        this.oneIndent = oneIndent;
        this.pageSize = Math.floor(c.layoutInfo.height / c.fontInfo.lineHeight) - 2;
        this.useTabStops = c.useTabStops;
        this.wordSeparators = c.wordSeparators;
        this.autoClosingBrackets = c.autoClosingBrackets;
        this.autoClosingPairsOpen = modeConfiguration.autoClosingPairsOpen;
        this.autoClosingPairsClose = modeConfiguration.autoClosingPairsClose;
        this.surroundingPairs = modeConfiguration.surroundingPairs;
        this.electricChars = modeConfiguration.electricChars;
    }
    CursorConfiguration.shouldRecreate = function (e) {
        return (e.layoutInfo
            || e.wordSeparators
            || e.autoClosingBrackets
            || e.useTabStops);
    };
    CursorConfiguration.prototype.normalizeIndentation = function (str) {
        return textModel_1.TextModel.normalizeIndentation(str, this.tabSize, this.insertSpaces);
    };
    return CursorConfiguration;
}());
exports.CursorConfiguration = CursorConfiguration;
/**
 * Represents the cursor state on either the model or on the view model.
 */
var SingleCursorState = (function () {
    function SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {
        this.selectionStart = selectionStart;
        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;
        this.position = position;
        this.leftoverVisibleColumns = leftoverVisibleColumns;
        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);
    }
    SingleCursorState.prototype.equals = function (other) {
        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns
            && this.leftoverVisibleColumns === other.leftoverVisibleColumns
            && this.position.equals(other.position)
            && this.selectionStart.equalsRange(other.selectionStart));
    };
    SingleCursorState.prototype.hasSelection = function () {
        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());
    };
    SingleCursorState.prototype.withSelectionStartLeftoverVisibleColumns = function (selectionStartLeftoverVisibleColumns) {
        return new SingleCursorState(this.selectionStart, selectionStartLeftoverVisibleColumns, this.position, this.leftoverVisibleColumns);
    };
    SingleCursorState.prototype.withSelectionStart = function (selectionStart) {
        return new SingleCursorState(selectionStart, 0, this.position, this.leftoverVisibleColumns);
    };
    SingleCursorState.prototype.collapse = function () {
        return new SingleCursorState(new range_1.Range(this.position.lineNumber, this.position.column, this.position.lineNumber, this.position.column), 0, this.position, 0);
    };
    SingleCursorState.prototype.move = function (inSelectionMode, position, leftoverVisibleColumns) {
        if (inSelectionMode) {
            // move just position
            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);
        }
        else {
            // move everything
            return new SingleCursorState(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), leftoverVisibleColumns, position, leftoverVisibleColumns);
        }
    };
    SingleCursorState._computeSelection = function (selectionStart, position) {
        var startLineNumber, startColumn, endLineNumber, endColumn;
        if (selectionStart.isEmpty()) {
            startLineNumber = selectionStart.startLineNumber;
            startColumn = selectionStart.startColumn;
            endLineNumber = position.lineNumber;
            endColumn = position.column;
        }
        else {
            if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {
                startLineNumber = selectionStart.endLineNumber;
                startColumn = selectionStart.endColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
            else {
                startLineNumber = selectionStart.startLineNumber;
                startColumn = selectionStart.startColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
        }
        return new selection_1.Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    };
    return SingleCursorState;
}());
exports.SingleCursorState = SingleCursorState;
var EditOperationResult = (function () {
    function EditOperationResult(command, opts) {
        this.command = command;
        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;
        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;
        this.isAutoWhitespaceCommand = false;
        this.shouldRevealHorizontal = true;
        this.cursorPositionChangeReason = editorCommon_1.CursorChangeReason.NotSet;
        if (typeof opts.isAutoWhitespaceCommand !== 'undefined') {
            this.isAutoWhitespaceCommand = opts.isAutoWhitespaceCommand;
        }
        if (typeof opts.shouldRevealHorizontal !== 'undefined') {
            this.shouldRevealHorizontal = opts.shouldRevealHorizontal;
        }
        if (typeof opts.cursorPositionChangeReason !== 'undefined') {
            this.cursorPositionChangeReason = opts.cursorPositionChangeReason;
        }
    }
    return EditOperationResult;
}());
exports.EditOperationResult = EditOperationResult;
/**
 * Common operations that work and make sense both on the model and on the view model.
 */
var CursorColumns = (function () {
    function CursorColumns() {
    }
    CursorColumns.isLowSurrogate = function (model, lineNumber, charOffset) {
        var lineContent = model.getLineContent(lineNumber);
        if (charOffset < 0 || charOffset >= lineContent.length) {
            return false;
        }
        return strings.isLowSurrogate(lineContent.charCodeAt(charOffset));
    };
    CursorColumns.isHighSurrogate = function (model, lineNumber, charOffset) {
        var lineContent = model.getLineContent(lineNumber);
        if (charOffset < 0 || charOffset >= lineContent.length) {
            return false;
        }
        return strings.isHighSurrogate(lineContent.charCodeAt(charOffset));
    };
    CursorColumns.isInsideSurrogatePair = function (model, lineNumber, column) {
        return this.isHighSurrogate(model, lineNumber, column - 2);
    };
    CursorColumns.visibleColumnFromColumn = function (lineContent, column, tabSize) {
        var endOffset = lineContent.length;
        if (endOffset > column - 1) {
            endOffset = column - 1;
        }
        var result = 0;
        for (var i = 0; i < endOffset; i++) {
            var charCode = lineContent.charCodeAt(i);
            if (charCode === 9 /* Tab */) {
                result = this.nextTabStop(result, tabSize);
            }
            else {
                result = result + 1;
            }
        }
        return result;
    };
    CursorColumns.visibleColumnFromColumn2 = function (config, model, position) {
        return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);
    };
    CursorColumns.columnFromVisibleColumn = function (lineContent, visibleColumn, tabSize) {
        if (visibleColumn <= 0) {
            return 1;
        }
        var lineLength = lineContent.length;
        var beforeVisibleColumn = 0;
        for (var i = 0; i < lineLength; i++) {
            var charCode = lineContent.charCodeAt(i);
            var afterVisibleColumn = void 0;
            if (charCode === 9 /* Tab */) {
                afterVisibleColumn = this.nextTabStop(beforeVisibleColumn, tabSize);
            }
            else {
                afterVisibleColumn = beforeVisibleColumn + 1;
            }
            if (afterVisibleColumn >= visibleColumn) {
                var prevDelta = visibleColumn - beforeVisibleColumn;
                var afterDelta = afterVisibleColumn - visibleColumn;
                if (afterDelta < prevDelta) {
                    return i + 2;
                }
                else {
                    return i + 1;
                }
            }
            beforeVisibleColumn = afterVisibleColumn;
        }
        // walked the entire string
        return lineLength + 1;
    };
    CursorColumns.columnFromVisibleColumn2 = function (config, model, lineNumber, visibleColumn) {
        var result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);
        var minColumn = model.getLineMinColumn(lineNumber);
        if (result < minColumn) {
            return minColumn;
        }
        var maxColumn = model.getLineMaxColumn(lineNumber);
        if (result > maxColumn) {
            return maxColumn;
        }
        return result;
    };
    /**
     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
     */
    CursorColumns.nextTabStop = function (visibleColumn, tabSize) {
        return visibleColumn + tabSize - visibleColumn % tabSize;
    };
    /**
     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
     */
    CursorColumns.prevTabStop = function (column, tabSize) {
        return column - 1 - (column - 1) % tabSize;
    };
    return CursorColumns;
}());
exports.CursorColumns = CursorColumns;
