/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require("vs/base/common/errors");
var replaceCommand_1 = require("vs/editor/common/commands/replaceCommand");
var cursorCommon_1 = require("vs/editor/common/controller/cursorCommon");
var range_1 = require("vs/editor/common/core/range");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var strings = require("vs/base/common/strings");
var shiftCommand_1 = require("vs/editor/common/commands/shiftCommand");
var languageConfigurationRegistry_1 = require("vs/editor/common/modes/languageConfigurationRegistry");
var languageConfiguration_1 = require("vs/editor/common/modes/languageConfiguration");
var surroundSelectionCommand_1 = require("vs/editor/common/commands/surroundSelectionCommand");
var TypeOperations = (function () {
    function TypeOperations() {
    }
    TypeOperations.indent = function (config, model, cursor) {
        return new cursorCommon_1.EditOperationResult(new shiftCommand_1.ShiftCommand(cursor.selection, {
            isUnshift: false,
            tabSize: config.tabSize,
            oneIndent: config.oneIndent
        }), {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true,
            shouldRevealHorizontal: false
        });
    };
    TypeOperations.outdent = function (config, model, cursor) {
        return new cursorCommon_1.EditOperationResult(new shiftCommand_1.ShiftCommand(cursor.selection, {
            isUnshift: true,
            tabSize: config.tabSize,
            oneIndent: config.oneIndent
        }), {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true,
            shouldRevealHorizontal: false
        });
    };
    TypeOperations.shiftIndent = function (config, indentation, count) {
        count = count || 1;
        var desiredIndentCount = shiftCommand_1.ShiftCommand.shiftIndentCount(indentation, indentation.length + count, config.tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    };
    TypeOperations.unshiftIndent = function (config, indentation, count) {
        count = count || 1;
        var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + count, config.tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    };
    TypeOperations.paste = function (config, model, cursor, text, pasteOnNewLine) {
        var position = cursor.position;
        var selection = cursor.selection;
        if (pasteOnNewLine && text.indexOf('\n') !== text.length - 1) {
            pasteOnNewLine = false;
        }
        if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {
            pasteOnNewLine = false;
        }
        if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {
            pasteOnNewLine = false;
        }
        if (pasteOnNewLine) {
            // Paste entire line at the beginning of line
            var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, 1);
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, text), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true,
                cursorPositionChangeReason: editorCommon_1.CursorChangeReason.Paste
            });
        }
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(selection, text), {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true,
            cursorPositionChangeReason: editorCommon_1.CursorChangeReason.Paste
        });
    };
    TypeOperations._goodIndentForLine = function (config, model, lineNumber) {
        var expectedIndentAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentActionForLine(model, lineNumber);
        if (expectedIndentAction) {
            if (expectedIndentAction.action) {
                var indentation = expectedIndentAction.indentation;
                if (expectedIndentAction.action === languageConfiguration_1.IndentAction.Indent) {
                    indentation = TypeOperations.shiftIndent(config, indentation);
                }
                if (expectedIndentAction.action === languageConfiguration_1.IndentAction.Outdent) {
                    indentation = TypeOperations.unshiftIndent(config, indentation);
                }
                indentation = config.normalizeIndentation(indentation);
                if (indentation.length === 0) {
                    return '';
                }
                else {
                    return indentation;
                }
            }
            else {
                return expectedIndentAction.indentation;
            }
        }
        return null;
    };
    TypeOperations._replaceJumpToNextIndent = function (config, model, selection) {
        var typeText = '';
        var position = selection.getStartPosition();
        if (config.insertSpaces) {
            var visibleColumnFromColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);
            var tabSize = config.tabSize;
            var spacesCnt = tabSize - (visibleColumnFromColumn % tabSize);
            for (var i = 0; i < spacesCnt; i++) {
                typeText += ' ';
            }
        }
        else {
            typeText = '\t';
        }
        return new replaceCommand_1.ReplaceCommand(selection, typeText);
    };
    TypeOperations.tab = function (config, model, cursor) {
        var selection = cursor.selection;
        if (selection.isEmpty()) {
            var lineText = model.getLineContent(selection.startLineNumber);
            if (/^\s*$/.test(lineText)) {
                var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);
                goodIndent = goodIndent || '\t';
                var possibleTypeText = config.normalizeIndentation(goodIndent);
                if (!strings.startsWith(lineText, possibleTypeText)) {
                    var command = new replaceCommand_1.ReplaceCommand(new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText);
                    return new cursorCommon_1.EditOperationResult(command, {
                        shouldPushStackElementBefore: false,
                        shouldPushStackElementAfter: false,
                        isAutoWhitespaceCommand: true
                    });
                }
            }
            return new cursorCommon_1.EditOperationResult(this._replaceJumpToNextIndent(config, model, selection), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false,
                isAutoWhitespaceCommand: true
            });
        }
        else {
            if (selection.startLineNumber === selection.endLineNumber) {
                var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);
                if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {
                    // This is a single line selection that is not the entire line
                    return new cursorCommon_1.EditOperationResult(this._replaceJumpToNextIndent(config, model, selection), {
                        shouldPushStackElementBefore: false,
                        shouldPushStackElementAfter: false
                    });
                }
            }
            return this.indent(config, model, cursor);
        }
    };
    TypeOperations.replacePreviousChar = function (config, model, cursor, txt, replaceCharCnt) {
        var pos = cursor.position;
        var startColumn = Math.max(1, pos.column - replaceCharCnt);
        var range = new range_1.Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(range, txt), {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations.typeCommand = function (range, text, keepPosition) {
        if (keepPosition) {
            return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, text);
        }
        else {
            return new replaceCommand_1.ReplaceCommand(range, text);
        }
    };
    TypeOperations._enter = function (config, model, keepPosition, range) {
        var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, range);
        var enterAction = r.enterAction;
        var indentation = r.indentation;
        var beforeText = '';
        if (!r.ignoreCurrentLine) {
            // textBeforeEnter doesn't match unIndentPattern.
            var goodIndent = this._goodIndentForLine(config, model, range.startLineNumber);
            if (goodIndent !== null && goodIndent === r.indentation) {
                if (enterAction.outdentCurrentLine) {
                    goodIndent = TypeOperations.unshiftIndent(config, goodIndent);
                }
                var lineText = model.getLineContent(range.startLineNumber);
                if (config.normalizeIndentation(goodIndent) !== config.normalizeIndentation(indentation)) {
                    beforeText = config.normalizeIndentation(goodIndent) + lineText.substring(indentation.length, range.startColumn - 1);
                    indentation = goodIndent;
                    range = new range_1.Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);
                }
            }
        }
        if (enterAction.removeText) {
            indentation = indentation.substring(0, indentation.length - enterAction.removeText);
        }
        var executeCommand;
        if (enterAction.indentAction === languageConfiguration_1.IndentAction.None) {
            // Nothing special
            executeCommand = TypeOperations.typeCommand(range, beforeText + '\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);
        }
        else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) {
            // Indent once
            executeCommand = TypeOperations.typeCommand(range, beforeText + '\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);
        }
        else if (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent) {
            // Ultra special
            var normalIndent = config.normalizeIndentation(indentation);
            var increasedIndent = config.normalizeIndentation(indentation + enterAction.appendText);
            var typeText = beforeText + '\n' + increasedIndent + '\n' + normalIndent;
            if (keepPosition) {
                executeCommand = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, typeText);
            }
            else {
                executeCommand = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length);
            }
        }
        else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {
            var actualIndentation = TypeOperations.unshiftIndent(config, indentation);
            executeCommand = TypeOperations.typeCommand(range, beforeText + '\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);
        }
        return new cursorCommon_1.EditOperationResult(executeCommand, {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: false,
            isAutoWhitespaceCommand: true
        });
    };
    TypeOperations._typeInterceptorEnter = function (config, model, cursor, ch) {
        if (ch !== '\n') {
            return null;
        }
        return TypeOperations._enter(config, model, false, cursor.selection);
    };
    TypeOperations._typeInterceptorAutoClosingCloseChar = function (config, model, cursor, ch) {
        if (!config.autoClosingBrackets) {
            return null;
        }
        var selection = cursor.selection;
        if (!selection.isEmpty() || !config.autoClosingPairsClose.hasOwnProperty(ch)) {
            return null;
        }
        var position = cursor.position;
        var lineText = model.getLineContent(position.lineNumber);
        var beforeCharacter = lineText.charAt(position.column - 1);
        if (beforeCharacter !== ch) {
            return null;
        }
        var typeSelection = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, ch), {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations._typeInterceptorAutoClosingOpenChar = function (config, model, cursor, ch) {
        if (!config.autoClosingBrackets) {
            return null;
        }
        var selection = cursor.selection;
        if (!selection.isEmpty() || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {
            return null;
        }
        var position = cursor.position;
        var lineText = model.getLineContent(position.lineNumber);
        var beforeCharacter = lineText.charAt(position.column - 1);
        // Only consider auto closing the pair if a space follows or if another autoclosed pair follows
        if (beforeCharacter) {
            var thisBraceIsSymmetric = (config.autoClosingPairsOpen[ch] === ch);
            var isBeforeCloseBrace = false;
            for (var otherCloseBrace in config.autoClosingPairsClose) {
                var otherBraceIsSymmetric = (config.autoClosingPairsOpen[otherCloseBrace] === otherCloseBrace);
                if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {
                    continue;
                }
                if (beforeCharacter === otherCloseBrace) {
                    isBeforeCloseBrace = true;
                    break;
                }
            }
            if (!isBeforeCloseBrace && !/\s/.test(beforeCharacter)) {
                return null;
            }
        }
        model.forceTokenization(position.lineNumber);
        var lineTokens = model.getLineTokens(position.lineNumber);
        var shouldAutoClosePair = false;
        try {
            shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
        if (!shouldAutoClosePair) {
            return null;
        }
        var closeCharacter = config.autoClosingPairsOpen[ch];
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length), {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations._typeInterceptorSurroundSelection = function (config, model, cursor, ch) {
        if (!config.autoClosingBrackets) {
            return null;
        }
        var selection = cursor.selection;
        if (selection.isEmpty() || !config.surroundingPairs.hasOwnProperty(ch)) {
            return null;
        }
        var selectionContainsOnlyWhitespace = true;
        for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {
            var lineText = model.getLineContent(lineNumber);
            var startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);
            var endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);
            for (var charIndex = startIndex; charIndex < endIndex; charIndex++) {
                var charCode = lineText.charCodeAt(charIndex);
                if (charCode !== 9 /* Tab */ && charCode !== 32 /* Space */) {
                    selectionContainsOnlyWhitespace = false;
                    // Break outer loop
                    lineNumber = selection.endLineNumber + 1;
                    // Break inner loop
                    charIndex = endIndex;
                }
            }
        }
        if (selectionContainsOnlyWhitespace) {
            return null;
        }
        var closeCharacter = config.surroundingPairs[ch];
        return new cursorCommon_1.EditOperationResult(new surroundSelectionCommand_1.SurroundSelectionCommand(selection, ch, closeCharacter), {
            shouldPushStackElementBefore: true,
            shouldPushStackElementAfter: true
        });
    };
    TypeOperations._typeInterceptorElectricChar = function (config, model, cursor, ch) {
        if (!config.electricChars.hasOwnProperty(ch)) {
            return null;
        }
        var position = cursor.position;
        model.forceTokenization(position.lineNumber);
        var lineTokens = model.getLineTokens(position.lineNumber);
        var electricAction;
        try {
            electricAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
        if (!electricAction) {
            return null;
        }
        if (electricAction.appendText) {
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithOffsetCursorState(cursor.selection, ch + electricAction.appendText, 0, -electricAction.appendText.length), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: true
            });
        }
        if (electricAction.matchOpenBracket) {
            var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;
            var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {
                lineNumber: position.lineNumber,
                column: endColumn
            });
            if (match) {
                if (match.startLineNumber === position.lineNumber) {
                    // matched something on the same line => no change in indentation
                    return null;
                }
                var matchLine = model.getLineContent(match.startLineNumber);
                var matchLineIndentation = strings.getLeadingWhitespace(matchLine);
                var newIndentation = config.normalizeIndentation(matchLineIndentation);
                var lineText = model.getLineContent(position.lineNumber);
                var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;
                var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);
                var typeText = newIndentation + prefix + ch;
                var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, position.column);
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, typeText), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: true
                });
            }
        }
        return null;
    };
    TypeOperations.typeWithInterceptors = function (config, model, cursor, ch) {
        var r = null;
        r = r || this._typeInterceptorEnter(config, model, cursor, ch);
        r = r || this._typeInterceptorAutoClosingCloseChar(config, model, cursor, ch);
        r = r || this._typeInterceptorAutoClosingOpenChar(config, model, cursor, ch);
        r = r || this._typeInterceptorSurroundSelection(config, model, cursor, ch);
        r = r || this._typeInterceptorElectricChar(config, model, cursor, ch);
        r = r || this.typeWithoutInterceptors(config, model, cursor, ch);
        return r;
    };
    TypeOperations.typeWithoutInterceptors = function (config, model, cursor, str) {
        return new cursorCommon_1.EditOperationResult(TypeOperations.typeCommand(cursor.selection, str, false), {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        });
    };
    TypeOperations.lineInsertBefore = function (config, model, cursor) {
        var lineNumber = cursor.position.lineNumber;
        if (lineNumber === 1) {
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithoutChangingPosition(new range_1.Range(1, 1, 1, 1), '\n'), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true
            });
        }
        lineNumber--;
        var column = model.getLineMaxColumn(lineNumber);
        return this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));
    };
    TypeOperations.lineInsertAfter = function (config, model, cursor) {
        var position = cursor.position;
        var column = model.getLineMaxColumn(position.lineNumber);
        return this._enter(config, model, false, new range_1.Range(position.lineNumber, column, position.lineNumber, column));
    };
    TypeOperations.lineBreakInsert = function (config, model, cursor) {
        return this._enter(config, model, true, cursor.selection);
    };
    return TypeOperations;
}());
exports.TypeOperations = TypeOperations;
