/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var characterPair_1 = require("vs/editor/common/modes/supports/characterPair");
var electricCharacter_1 = require("vs/editor/common/modes/supports/electricCharacter");
var onEnter_1 = require("vs/editor/common/modes/supports/onEnter");
var richEditBrackets_1 = require("vs/editor/common/modes/supports/richEditBrackets");
var event_1 = require("vs/base/common/event");
var errors_1 = require("vs/base/common/errors");
var strings = require("vs/base/common/strings");
var wordHelper_1 = require("vs/editor/common/model/wordHelper");
var supports_1 = require("vs/editor/common/modes/supports");
var range_1 = require("vs/editor/common/core/range");
var languageConfiguration_1 = require("vs/editor/common/modes/languageConfiguration");
var RichEditSupport = (function () {
    function RichEditSupport(languageIdentifier, previous, rawConf) {
        var prev = null;
        if (previous) {
            prev = previous._conf;
        }
        this._conf = RichEditSupport._mergeConf(prev, rawConf);
        if (this._conf.brackets) {
            this.brackets = new richEditBrackets_1.RichEditBrackets(languageIdentifier, this._conf.brackets);
        }
        this.onEnter = RichEditSupport._handleOnEnter(this._conf);
        this.comments = RichEditSupport._handleComments(this._conf);
        this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);
        this.electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, this.characterPair.getAutoClosingPairs(), this._conf.__electricCharacterSupport);
        this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;
        this.indentationRules = this._conf.indentationRules;
    }
    RichEditSupport._mergeConf = function (prev, current) {
        return {
            comments: (prev ? current.comments || prev.comments : current.comments),
            brackets: (prev ? current.brackets || prev.brackets : current.brackets),
            wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
            indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
            onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
            autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
            surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
            __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
        };
    };
    RichEditSupport._handleOnEnter = function (conf) {
        // on enter
        var onEnter = {};
        var empty = true;
        if (conf.brackets) {
            empty = false;
            onEnter.brackets = conf.brackets;
        }
        if (conf.indentationRules) {
            empty = false;
            onEnter.indentationRules = conf.indentationRules;
        }
        if (conf.onEnterRules) {
            empty = false;
            onEnter.regExpRules = conf.onEnterRules;
        }
        if (!empty) {
            return new onEnter_1.OnEnterSupport(onEnter);
        }
        return null;
    };
    RichEditSupport._handleComments = function (conf) {
        var commentRule = conf.comments;
        if (!commentRule) {
            return null;
        }
        // comment configuration
        var comments = {};
        if (commentRule.lineComment) {
            comments.lineCommentToken = commentRule.lineComment;
        }
        if (commentRule.blockComment) {
            var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
            comments.blockCommentStartToken = blockStart;
            comments.blockCommentEndToken = blockEnd;
        }
        return comments;
    };
    return RichEditSupport;
}());
exports.RichEditSupport = RichEditSupport;
var LanguageConfigurationRegistryImpl = (function () {
    function LanguageConfigurationRegistryImpl() {
        this._onDidChange = new event_1.Emitter();
        this.onDidChange = this._onDidChange.event;
        this._entries = [];
    }
    LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {
        var _this = this;
        var previous = this._getRichEditSupport(languageIdentifier.id);
        var current = new RichEditSupport(languageIdentifier, previous, configuration);
        this._entries[languageIdentifier.id] = current;
        this._onDidChange.fire(void 0);
        return {
            dispose: function () {
                if (_this._entries[languageIdentifier.id] === current) {
                    _this._entries[languageIdentifier.id] = previous;
                    _this._onDidChange.fire(void 0);
                }
            }
        };
    };
    LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {
        return this._entries[languageId] || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentationRules = function (languageId) {
        var value = this._entries[languageId];
        if (!value) {
            return null;
        }
        return value.indentationRules || null;
    };
    // begin electricCharacter
    LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.electricCharacter || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {
        var electricCharacterSupport = this._getElectricCharacterSupport(languageId);
        if (!electricCharacterSupport) {
            return [];
        }
        return electricCharacterSupport.getElectricCharacters();
    };
    /**
     * Should return opening bracket type to match indentation with
     */
    LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {
        var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
        var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
        if (!electricCharacterSupport) {
            return null;
        }
        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
    };
    // end electricCharacter
    LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.comments || null;
    };
    // begin characterPair
    LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.characterPair || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {
        var characterPairSupport = this._getCharacterPairSupport(languageId);
        if (!characterPairSupport) {
            return [];
        }
        return characterPairSupport.getAutoClosingPairs();
    };
    LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {
        var characterPairSupport = this._getCharacterPairSupport(languageId);
        if (!characterPairSupport) {
            return [];
        }
        return characterPairSupport.getSurroundingPairs();
    };
    LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {
        var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
        var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);
        if (!characterPairSupport) {
            return false;
        }
        return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
    };
    // end characterPair
    LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return wordHelper_1.ensureValidWordDefinition(null);
        }
        return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);
    };
    // begin onEnter
    LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.onEnter || null;
    };
    LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
        var r = this.getEnterAction(model, new range_1.Range(lineNumber, column, lineNumber, column));
        return r ? r.enterAction : null;
    };
    LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {
        var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
        var ignoreCurrentLine = false;
        var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber);
        var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);
        if (!onEnterSupport) {
            return {
                enterAction: { indentAction: languageConfiguration_1.IndentAction.None, appendText: '' },
                indentation: indentation,
                ignoreCurrentLine: false
            };
        }
        var scopedLineText = scopedLineTokens.getLineContent();
        var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        var afterEnterText;
        // selection support
        if (range.isEmpty()) {
            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
        }
        else {
            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber);
            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - endScopedLineTokens.firstCharOffset);
        }
        var lineNumber = range.startLineNumber;
        // if the text before the cursor/range start position is empty or matches `unIndentedLinePattern`
        // this line is actually ignored after the enter action
        if (onEnterSupport.shouldIgnore(beforeEnterText)) {
            ignoreCurrentLine = true;
            var lastLineNumber = this.getLastValidLine(model, lineNumber, onEnterSupport);
            if (lastLineNumber <= 0) {
                return {
                    enterAction: { indentAction: languageConfiguration_1.IndentAction.None, appendText: '' },
                    indentation: '',
                    ignoreCurrentLine: ignoreCurrentLine
                };
            }
            scopedLineTokens = this.getScopedLineTokens(model, lastLineNumber);
            beforeEnterText = this.getLineContent(model, lastLineNumber);
            lineNumber = lastLineNumber;
            indentation = this.getIndentationAtPosition(model, lineNumber, model.getLineMaxColumn(lineNumber));
        }
        var oneLineAboveText = '';
        if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
            // This is not the first line and the entire line belongs to this mode
            var lastLineNumber = this.getLastValidLine(model, lineNumber, onEnterSupport);
            if (lastLineNumber >= 1) {
                // No previous line with content found
                var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lastLineNumber);
                if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
                    // The line above ends with text belonging to the same mode
                    oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
                }
            }
        }
        var enterResult = null;
        try {
            enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
        if (!enterResult) {
            enterResult = { indentAction: languageConfiguration_1.IndentAction.None, appendText: '' };
        }
        else {
            // Here we add `\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.
            if (!enterResult.appendText) {
                if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                    (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                    enterResult.appendText = '\t';
                }
                else {
                    enterResult.appendText = '';
                }
            }
        }
        return {
            enterAction: enterResult,
            indentation: indentation,
            ignoreCurrentLine: ignoreCurrentLine
        };
    };
    LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {
        var lineText = model.getLineContent(lineNumber);
        var indentation = strings.getLeadingWhitespace(lineText);
        if (indentation.length > column - 1) {
            indentation = indentation.substring(0, column - 1);
        }
        return indentation;
    };
    LanguageConfigurationRegistryImpl.prototype.getLastValidLine = function (model, lineNumber, onEnterSupport) {
        if (lineNumber > 1) {
            var lastLineNumber = lineNumber - 1;
            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                var lineText = model.getLineContent(lastLineNumber);
                if (!onEnterSupport.shouldIgnore(lineText) && onEnterSupport.containNonWhitespace(lineText)) {
                    break;
                }
            }
            if (lastLineNumber >= 1) {
                return lastLineNumber;
            }
        }
        return -1;
    };
    LanguageConfigurationRegistryImpl.prototype.getLineContent = function (model, lineNumber) {
        var scopedLineTokens = this.getScopedLineTokens(model, lineNumber);
        var column = model.getLineMaxColumn(lineNumber);
        var scopedLineText = scopedLineTokens.getLineContent();
        var lineText = scopedLineText.substr(0, column - 1 - scopedLineTokens.firstCharOffset);
        return lineText;
    };
    LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber) {
        model.forceTokenization(lineNumber);
        var lineTokens = model.getLineTokens(lineNumber);
        var column = model.getLineMaxColumn(lineNumber);
        var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column - 1);
        return scopedLineTokens;
    };
    LanguageConfigurationRegistryImpl.prototype.getGoodIndentActionForLine = function (model, lineNumber) {
        var onEnterSupport = this._getOnEnterSupport(model.getLanguageIdentifier().id);
        if (!onEnterSupport) {
            return null;
        }
        /**
         * In order to get correct indentation for current line
         * we need to loop backwards the content from current line until
         * 1. a line contains non whitespace characters,
         * 2. and the line doesn't match `unIndentedLinePattern` pattern
         */
        var lastLineNumber = this.getLastValidLine(model, lineNumber, onEnterSupport);
        if (lastLineNumber < 1) {
            // No previous line with content found
            return null;
        }
        // it's Okay that lineNumber > model.getLineCount(), a good example is guessing the indentation of next potential line
        // when the cursor is at the end of file.
        if (lineNumber <= model.getLineCount()) {
            var currentLineScopedLineTokens = this.getScopedLineTokens(model, lineNumber);
            var lastLineScopedLineTokens = this.getScopedLineTokens(model, lastLineNumber);
            if (currentLineScopedLineTokens.languageId !== lastLineScopedLineTokens.languageId) {
                // The language mode of last valid line is not the same as current line.
                return null;
            }
        }
        var lineText = model.getLineContent(lastLineNumber);
        var oneLineAboveText;
        if (lastLineNumber > 1) {
            oneLineAboveText = model.getLineContent(lastLineNumber - 1);
        }
        var indentation = strings.getLeadingWhitespace(lineText);
        var onEnterAction = onEnterSupport.onEnter(oneLineAboveText, lineText, '');
        return {
            indentation: indentation,
            action: onEnterAction ? onEnterAction.indentAction : null
        };
    };
    // end onEnter
    LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {
        var value = this._getRichEditSupport(languageId);
        if (!value) {
            return null;
        }
        return value.brackets || null;
    };
    return LanguageConfigurationRegistryImpl;
}());
exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;
exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
