/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var lifecycle_1 = require("vs/base/common/lifecycle");
var strings = require("vs/base/common/strings");
var position_1 = require("vs/editor/common/core/position");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var editorCommon = require("vs/editor/common/editorCommon");
var modes_1 = require("vs/editor/common/modes");
var textToHtmlTokenizer_1 = require("vs/editor/common/modes/textToHtmlTokenizer");
var viewModelCursors_1 = require("vs/editor/common/viewModel/viewModelCursors");
var viewModelDecorations_1 = require("vs/editor/common/viewModel/viewModelDecorations");
var viewModel_1 = require("vs/editor/common/viewModel/viewModel");
var viewEvents = require("vs/editor/common/view/viewEvents");
var errors = require("vs/base/common/errors");
var minimapCharRenderer_1 = require("vs/editor/common/view/minimapCharRenderer");
var CoordinatesConverter = (function () {
    function CoordinatesConverter(lines) {
        this._lines = lines;
    }
    // View -> Model conversion and related methods
    CoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {
        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
    };
    CoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {
        var start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
        var end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
        return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    CoordinatesConverter.prototype.convertViewSelectionToModelSelection = function (viewSelection) {
        var selectionStart = this._lines.convertViewPositionToModelPosition(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn);
        var position = this._lines.convertViewPositionToModelPosition(viewSelection.positionLineNumber, viewSelection.positionColumn);
        return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
    };
    CoordinatesConverter.prototype.validateViewPosition = function (viewPosition, expectedModelPosition) {
        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);
    };
    CoordinatesConverter.prototype.validateViewRange = function (viewRange, expectedModelRange) {
        var validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());
        var validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());
        return new range_1.Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);
    };
    // Model -> View conversion and related methods
    CoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {
        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
    };
    CoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {
        var start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);
        var end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);
        return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    CoordinatesConverter.prototype.convertModelSelectionToViewSelection = function (modelSelection) {
        var selectionStart = this._lines.convertModelPositionToViewPosition(modelSelection.selectionStartLineNumber, modelSelection.selectionStartColumn);
        var position = this._lines.convertModelPositionToViewPosition(modelSelection.positionLineNumber, modelSelection.positionColumn);
        return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
    };
    CoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {
        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);
    };
    return CoordinatesConverter;
}());
exports.CoordinatesConverter = CoordinatesConverter;
var ViewModel = (function () {
    function ViewModel(lines, editorId, configuration, model) {
        var _this = this;
        this.lines = lines;
        this.editorId = editorId;
        this.configuration = configuration;
        this.model = model;
        this.configuration.setMaxLineNumber(this.model.getLineCount());
        this.coordinatesConverter = new CoordinatesConverter(this.lines);
        this._lastCursorPosition = new position_1.Position(1, 1);
        this._renderCustomLineNumbers = this.configuration.editor.viewInfo.renderCustomLineNumbers;
        this._renderRelativeLineNumbers = this.configuration.editor.viewInfo.renderRelativeLineNumbers;
        this._centeredViewLine = -1;
        this.decorations = new viewModelDecorations_1.ViewModelDecorations(this.editorId, this.model, this.configuration, this.coordinatesConverter);
        this.decorations.reset();
        this.cursors = new viewModelCursors_1.ViewModelCursors(this.configuration, this.coordinatesConverter);
        this.listenersToRemove = [];
        this._toDispose = [];
        this.listenersToRemove.push(this.model.addBulkListener(function (events) { return _this.onEvents(events); }));
        this._toDispose.push(this.configuration.onDidChange(function (e) {
            _this.onEvents([new eventEmitter_1.EmitterEvent(editorCommon.EventType.ConfigurationChanged, e)]);
        }));
        this._toDispose.push(minimapCharRenderer_1.MinimapTokensColorTracker.getInstance().onDidChange(function () {
            _this._emit([new viewEvents.ViewTokensColorsChangedEvent()]);
        }));
        this._listeners = [];
    }
    ViewModel.prototype.setHiddenAreas = function (ranges) {
        var eventsCollector = new viewModel_1.ViewEventsCollector();
        this._setHiddenAreas(eventsCollector, ranges);
        this._emit(eventsCollector.finalize());
    };
    ViewModel.prototype._setHiddenAreas = function (eventsCollector, ranges) {
        var lineMappingChanged = this.lines.setHiddenAreas(eventsCollector, ranges);
        if (lineMappingChanged) {
            eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());
            this.decorations.onLineMappingChanged(eventsCollector);
            this.cursors.onLineMappingChanged(eventsCollector);
        }
    };
    ViewModel.prototype.dispose = function () {
        this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
        this._toDispose = lifecycle_1.dispose(this._toDispose);
        this.decorations.dispose();
        this.lines.dispose();
        this._listeners = [];
    };
    ViewModel.prototype.addEventListener = function (listener) {
        var _this = this;
        this._listeners.push(listener);
        return {
            dispose: function () {
                var listeners = _this._listeners;
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        };
    };
    ViewModel.prototype._emit = function (events) {
        var listeners = this._listeners.slice(0);
        for (var i = 0, len = listeners.length; i < len; i++) {
            safeInvokeListener(listeners[i], events);
        }
    };
    ViewModel.prototype._onTabSizeChange = function (eventsCollector, newTabSize) {
        var lineMappingChanged = this.lines.setTabSize(eventsCollector, newTabSize);
        if (lineMappingChanged) {
            eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());
            this.decorations.onLineMappingChanged(eventsCollector);
            this.cursors.onLineMappingChanged(eventsCollector);
        }
        return lineMappingChanged;
    };
    ViewModel.prototype._onWrappingIndentChange = function (eventsCollector, newWrappingIndent) {
        var lineMappingChanged = this.lines.setWrappingIndent(eventsCollector, newWrappingIndent);
        if (lineMappingChanged) {
            eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());
            this.decorations.onLineMappingChanged(eventsCollector);
            this.cursors.onLineMappingChanged(eventsCollector);
        }
        return lineMappingChanged;
    };
    ViewModel.prototype._restoreCenteredModelRange = function (eventsCollector, range) {
        // modelLine -> viewLine
        var newCenteredViewRange = this.coordinatesConverter.convertModelRangeToViewRange(range);
        // Send a reveal event to restore the centered content
        eventsCollector.emit(new viewEvents.ViewRevealRangeRequestEvent(newCenteredViewRange, 1 /* Center */, false, false));
    };
    ViewModel.prototype._onWrappingColumnChange = function (eventsCollector, newWrappingColumn, columnsForFullWidthChar) {
        var lineMappingChanged = this.lines.setWrappingColumn(eventsCollector, newWrappingColumn, columnsForFullWidthChar);
        if (lineMappingChanged) {
            eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());
            this.decorations.onLineMappingChanged(eventsCollector);
            this.cursors.onLineMappingChanged(eventsCollector);
        }
        return lineMappingChanged;
    };
    ViewModel.prototype.addEventSource = function (eventSource) {
        var _this = this;
        this.listenersToRemove.push(eventSource.addBulkListener2(function (events) { return _this.onEvents(events); }));
    };
    ViewModel.prototype.onEvents = function (events) {
        var eventsCollector = new viewModel_1.ViewEventsCollector();
        this._onEvents(eventsCollector, events);
        this._emit(eventsCollector.finalize());
    };
    ViewModel._containsModelContentChangeEvent = function (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            var eventType = events[i].getType();
            if (eventType === editorCommon.EventType.ModelRawContentChanged) {
                return true;
            }
        }
        return false;
    };
    ViewModel._containsWrappingRelatedEvents = function (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            var eventType = events[i].getType();
            if (eventType === editorCommon.EventType.ModelOptionsChanged) {
                return true;
            }
            if (eventType === editorCommon.EventType.ConfigurationChanged) {
                return true;
            }
        }
        return false;
    };
    ViewModel.prototype.getCenteredRangeInViewport = function () {
        if (this._centeredViewLine === -1) {
            // Never got rendered or not rendered since last content change event
            return null;
        }
        var viewLineNumber = this._centeredViewLine;
        var currentCenteredViewRange = new range_1.Range(viewLineNumber, this.getLineMinColumn(viewLineNumber), viewLineNumber, this.getLineMaxColumn(viewLineNumber));
        return this.coordinatesConverter.convertViewRangeToModelRange(currentCenteredViewRange);
    };
    ViewModel.prototype._onEvents = function (eventsCollector, events) {
        var containsModelContentChangeEvent = ViewModel._containsModelContentChangeEvent(events);
        if (containsModelContentChangeEvent) {
            this._centeredViewLine = -1;
            this.configuration.setMaxLineNumber(this.model.getLineCount());
        }
        // We might need to restore the current centered view range in the following circumstances:
        // All of these changes might lead to a new line mapping:
        // (a) model tabSize changed
        // (b) wrappingIndent changed
        // (c) wrappingColumn changed
        // (d) fontInfo changed
        // However, we cannot restore the current centered line if the model has changed its content
        // because we cannot convert the view range to a model range.
        var previousCenteredModelRange = null;
        if (!containsModelContentChangeEvent && ViewModel._containsWrappingRelatedEvents(events)) {
            previousCenteredModelRange = this.getCenteredRangeInViewport();
        }
        var hadOtherModelChange = false;
        var hadModelLineChangeThatChangedLineMapping = false;
        var revealPreviousCenteredModelRange = false;
        for (var i = 0, len = events.length; i < len; i++) {
            var e = events[i];
            var data = e.getData();
            switch (e.getType()) {
                case editorCommon.EventType.ModelRawContentChanged:
                    var modelContentChangedEvent = data;
                    switch (modelContentChangedEvent.changeType) {
                        case editorCommon.EventType.ModelRawContentChangedFlush:
                            this.onModelFlushed(eventsCollector, modelContentChangedEvent);
                            hadOtherModelChange = true;
                            break;
                        case editorCommon.EventType.ModelRawContentChangedLinesDeleted:
                            this.onModelLinesDeleted(eventsCollector, modelContentChangedEvent);
                            hadOtherModelChange = true;
                            break;
                        case editorCommon.EventType.ModelRawContentChangedLinesInserted:
                            this.onModelLinesInserted(eventsCollector, modelContentChangedEvent);
                            hadOtherModelChange = true;
                            break;
                        case editorCommon.EventType.ModelRawContentChangedLineChanged:
                            hadModelLineChangeThatChangedLineMapping = this.onModelLineChanged(eventsCollector, modelContentChangedEvent);
                            break;
                        default:
                            console.info('ViewModel received unknown event: ');
                            console.info(e);
                    }
                    break;
                case editorCommon.EventType.ModelTokensChanged:
                    this.onModelTokensChanged(eventsCollector, data);
                    break;
                case editorCommon.EventType.ModelLanguageChanged:
                    // That's ok, a model tokens changed event will follow shortly
                    break;
                case editorCommon.EventType.ModelContentChanged2:
                    // Ignore
                    break;
                case editorCommon.EventType.ModelOptionsChanged:
                    // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here
                    var prevLineCount = this.lines.getViewLineCount();
                    var tabSizeChanged = this._onTabSizeChange(eventsCollector, this.model.getOptions().tabSize);
                    var newLineCount = this.lines.getViewLineCount();
                    if (tabSizeChanged && prevLineCount !== newLineCount) {
                        revealPreviousCenteredModelRange = true;
                    }
                    break;
                case editorCommon.EventType.ModelDecorationsChanged:
                    this.onModelDecorationsChanged(eventsCollector, data);
                    break;
                case editorCommon.EventType.ModelDispose:
                    // Ignore, since the editor will take care of this and destroy the view shortly
                    break;
                case editorCommon.EventType.CursorPositionChanged:
                    this.onCursorPositionChanged(eventsCollector, data);
                    this._lastCursorPosition = data.position;
                    break;
                case editorCommon.EventType.CursorSelectionChanged:
                    this.onCursorSelectionChanged(eventsCollector, data);
                    break;
                case editorCommon.EventType.CursorRevealRange:
                    this.onCursorRevealRange(eventsCollector, data);
                    break;
                case editorCommon.EventType.CursorScrollRequest:
                    this.onCursorScrollRequest(eventsCollector, data);
                    break;
                case editorCommon.EventType.ConfigurationChanged:
                    revealPreviousCenteredModelRange = this._onWrappingIndentChange(eventsCollector, this.configuration.editor.wrappingInfo.wrappingIndent) || revealPreviousCenteredModelRange;
                    revealPreviousCenteredModelRange = this._onWrappingColumnChange(eventsCollector, this.configuration.editor.wrappingInfo.wrappingColumn, this.configuration.editor.fontInfo.typicalFullwidthCharacterWidth / this.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth) || revealPreviousCenteredModelRange;
                    this._renderCustomLineNumbers = this.configuration.editor.viewInfo.renderCustomLineNumbers;
                    this._renderRelativeLineNumbers = this.configuration.editor.viewInfo.renderRelativeLineNumbers;
                    if (data.readOnly) {
                        // Must read again all decorations due to readOnly filtering
                        this.decorations.reset();
                        eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());
                    }
                    eventsCollector.emit(new viewEvents.ViewConfigurationChangedEvent(data));
                    break;
                default:
                    console.info('View received unknown event: ');
                    console.info(e);
            }
        }
        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {
            eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());
            this.decorations.onLineMappingChanged(eventsCollector);
            this.cursors.onLineMappingChanged(eventsCollector);
        }
        if (revealPreviousCenteredModelRange && previousCenteredModelRange) {
            this._restoreCenteredModelRange(eventsCollector, previousCenteredModelRange);
        }
    };
    // --- begin inbound event conversion
    ViewModel.prototype.onModelFlushed = function (eventsCollector, e) {
        this.lines.onModelFlushed(eventsCollector, e.versionId);
        this.decorations.reset();
    };
    ViewModel.prototype.onModelDecorationsChanged = function (eventsCollector, e) {
        this.decorations.onModelDecorationsChanged(eventsCollector, e);
    };
    ViewModel.prototype.onModelLinesDeleted = function (eventsCollector, e) {
        this.lines.onModelLinesDeleted(eventsCollector, e.versionId, e.fromLineNumber, e.toLineNumber);
    };
    ViewModel.prototype.onModelTokensChanged = function (eventsCollector, e) {
        var viewRanges = [];
        for (var i = 0, len = e.ranges.length; i < len; i++) {
            var modelRange = e.ranges[i];
            var viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.fromLineNumber, 1)).lineNumber;
            var viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;
            viewRanges[i] = {
                fromLineNumber: viewStartLineNumber,
                toLineNumber: viewEndLineNumber
            };
        }
        eventsCollector.emit(new viewEvents.ViewTokensChangedEvent(viewRanges));
    };
    ViewModel.prototype.onModelLineChanged = function (eventsCollector, e) {
        var lineMappingChanged = this.lines.onModelLineChanged(eventsCollector, e.versionId, e.lineNumber, e.detail);
        return lineMappingChanged;
    };
    ViewModel.prototype.onModelLinesInserted = function (eventsCollector, e) {
        this.lines.onModelLinesInserted(eventsCollector, e.versionId, e.fromLineNumber, e.toLineNumber, e.detail.split('\n'));
    };
    ViewModel.prototype.onCursorPositionChanged = function (eventsCollector, e) {
        this.cursors.onCursorPositionChanged(eventsCollector, e);
    };
    ViewModel.prototype.onCursorSelectionChanged = function (eventsCollector, e) {
        this.cursors.onCursorSelectionChanged(eventsCollector, e);
    };
    ViewModel.prototype.onCursorRevealRange = function (eventsCollector, e) {
        // Ensure event has viewRange
        if (!e.viewRange) {
            e = {
                range: e.range,
                viewRange: this.coordinatesConverter.convertModelRangeToViewRange(e.range),
                verticalType: e.verticalType,
                revealHorizontal: e.revealHorizontal,
                revealCursor: e.revealCursor,
            };
        }
        this.cursors.onCursorRevealRange(eventsCollector, e);
    };
    ViewModel.prototype.onCursorScrollRequest = function (eventsCollector, e) {
        this.cursors.onCursorScrollRequest(eventsCollector, e);
    };
    // --- end inbound event conversion
    ViewModel.prototype.getTabSize = function () {
        return this.model.getOptions().tabSize;
    };
    ViewModel.prototype.getLineCount = function () {
        return this.lines.getViewLineCount();
    };
    /**
     * Gives a hint that a lot of requests are about to come in for these line numbers.
     */
    ViewModel.prototype.setViewport = function (startLineNumber, endLineNumber, centeredLineNumber) {
        this._centeredViewLine = centeredLineNumber;
        this.lines.warmUpLookupCache(startLineNumber, endLineNumber);
    };
    ViewModel.prototype.getLineIndentGuide = function (lineNumber) {
        return this.lines.getViewLineIndentGuide(lineNumber);
    };
    ViewModel.prototype.getLineContent = function (lineNumber) {
        return this.lines.getViewLineContent(lineNumber);
    };
    ViewModel.prototype.getLineMinColumn = function (lineNumber) {
        return this.lines.getViewLineMinColumn(lineNumber);
    };
    ViewModel.prototype.getLineMaxColumn = function (lineNumber) {
        return this.lines.getViewLineMaxColumn(lineNumber);
    };
    ViewModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 1;
    };
    ViewModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
            return 0;
        }
        return result + 2;
    };
    ViewModel.prototype.getLineRenderLineNumber = function (viewLineNumber) {
        var modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(viewLineNumber, 1));
        if (modelPosition.column !== 1) {
            return '';
        }
        var modelLineNumber = modelPosition.lineNumber;
        if (this._renderCustomLineNumbers) {
            return this._renderCustomLineNumbers(modelLineNumber);
        }
        if (this._renderRelativeLineNumbers) {
            var diff = Math.abs(this._lastCursorPosition.lineNumber - modelLineNumber);
            if (diff === 0) {
                return '<span class="relative-current-line-number">' + modelLineNumber + '</span>';
            }
            return String(diff);
        }
        return String(modelLineNumber);
    };
    ViewModel.prototype.getDecorationsInViewport = function (visibleRange) {
        return this.decorations.getDecorationsViewportData(visibleRange).decorations;
    };
    ViewModel.prototype.getViewLineRenderingData = function (visibleRange, lineNumber) {
        var mightContainRTL = this.model.mightContainRTL();
        var mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();
        var tabSize = this.getTabSize();
        var lineData = this.lines.getViewLineData(lineNumber);
        var allInlineDecorations = this.decorations.getDecorationsViewportData(visibleRange).inlineDecorations;
        var inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];
        return new viewModel_1.ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize);
    };
    ViewModel.prototype.getMinimapLinesRenderingData = function (startLineNumber, endLineNumber, needed) {
        var result = this.lines.getViewLinesData(startLineNumber, endLineNumber, needed);
        return new viewModel_1.MinimapLinesRenderingData(this.getTabSize(), result);
    };
    ViewModel.prototype.getAllOverviewRulerDecorations = function () {
        return this.decorations.getAllOverviewRulerDecorations();
    };
    ViewModel.prototype.getEOL = function () {
        return this.model.getEOL();
    };
    ViewModel.prototype.getValueInRange = function (range, eol) {
        var modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);
        return this.model.getValueInRange(modelRange, eol);
    };
    ViewModel.prototype.getModelLineContent = function (modelLineNumber) {
        return this.model.getLineContent(modelLineNumber);
    };
    ViewModel.prototype.getModelLineMaxColumn = function (modelLineNumber) {
        return this.model.getLineMaxColumn(modelLineNumber);
    };
    ViewModel.prototype.validateModelPosition = function (position) {
        return this.model.validatePosition(position);
    };
    ViewModel.prototype.getPlainTextToCopy = function (ranges, enableEmptySelectionClipboard) {
        var newLineCharacter = this.getEOL();
        if (ranges.length === 1) {
            var range = ranges[0];
            if (range.isEmpty()) {
                if (enableEmptySelectionClipboard) {
                    var modelLineNumber = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(range.startLineNumber, 1)).lineNumber;
                    return this.getModelLineContent(modelLineNumber) + newLineCharacter;
                }
                else {
                    return '';
                }
            }
            return this.getValueInRange(range, editorCommon.EndOfLinePreference.TextDefined);
        }
        else {
            ranges = ranges.slice(0).sort(range_1.Range.compareRangesUsingStarts);
            var result = [];
            for (var i = 0; i < ranges.length; i++) {
                result.push(this.getValueInRange(ranges[i], editorCommon.EndOfLinePreference.TextDefined));
            }
            return result.join(newLineCharacter);
        }
    };
    ViewModel.prototype.getHTMLToCopy = function (viewRanges, enableEmptySelectionClipboard) {
        if (this.model.getLanguageIdentifier().id === 1 /* PlainText */) {
            return null;
        }
        if (viewRanges.length !== 1) {
            // no multiple selection support at this time
            return null;
        }
        var range = this.coordinatesConverter.convertViewRangeToModelRange(viewRanges[0]);
        if (range.isEmpty()) {
            if (!enableEmptySelectionClipboard) {
                // nothing to copy
                return null;
            }
            var lineNumber = range.startLineNumber;
            range = new range_1.Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));
        }
        var fontInfo = this.configuration.editor.fontInfo;
        var colorMap = this._getColorMap();
        return ("<div style=\""
            + ("color: " + colorMap[1 /* DefaultForeground */] + ";")
            + ("background-color: " + colorMap[2 /* DefaultBackground */] + ";")
            + ("font-family: " + fontInfo.fontFamily + ";")
            + ("font-weight: " + fontInfo.fontWeight + ";")
            + ("font-size: " + fontInfo.fontSize + "px;")
            + ("line-height: " + fontInfo.lineHeight + "px")
            + "\">"
            + this._getHTMLToCopy(range, colorMap)
            + '</div>');
    };
    ViewModel.prototype._getHTMLToCopy = function (modelRange, colorMap) {
        var startLineNumber = modelRange.startLineNumber;
        var startColumn = modelRange.startColumn;
        var endLineNumber = modelRange.endLineNumber;
        var endColumn = modelRange.endColumn;
        var tabSize = this.getTabSize();
        var result = '';
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var lineTokens = this.model.getLineTokens(lineNumber);
            var lineContent = lineTokens.getLineContent();
            var startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);
            var endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);
            if (lineContent === '') {
                result += '<br>';
            }
            else {
                result += textToHtmlTokenizer_1.tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize);
            }
        }
        return result;
    };
    ViewModel.prototype._getColorMap = function () {
        var colorMap = modes_1.TokenizationRegistry.getColorMap();
        var result = [null];
        for (var i = 1, len = colorMap.length; i < len; i++) {
            result[i] = colorMap[i].toRGBHex();
        }
        return result;
    };
    return ViewModel;
}());
exports.ViewModel = ViewModel;
function safeInvokeListener(listener, events) {
    try {
        listener(events);
    }
    catch (e) {
        errors.onUnexpectedError(e);
    }
}
