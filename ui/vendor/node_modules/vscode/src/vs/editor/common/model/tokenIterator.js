/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var position_1 = require("vs/editor/common/core/position");
var TokenInfo = (function () {
    function TokenInfo(actual, lineNumber) {
        this._actual = actual;
        this.lineNumber = lineNumber;
        this.startColumn = this._actual.startOffset + 1;
        this.endColumn = this._actual.endOffset + 1;
        this.type = this._actual.tokenType;
    }
    return TokenInfo;
}());
function findClosestNonEmptyLine(model, position) {
    var lineNumber = position.lineNumber;
    if (model.getLineMaxColumn(lineNumber) !== 1) {
        return position;
    }
    var lineCount = model.getLineCount();
    // we need to go up or down
    var distance = 1;
    while (true) {
        var aboveLineNumber = lineNumber - distance;
        var belowLineNumber = lineNumber + distance;
        if (aboveLineNumber < 1 && belowLineNumber > lineCount) {
            // No more lines above or below
            break;
        }
        if (aboveLineNumber >= 1) {
            var aboveMaxColumn = model.getLineMaxColumn(aboveLineNumber);
            if (aboveMaxColumn !== 1) {
                // bingo!
                return new position_1.Position(aboveLineNumber, aboveMaxColumn);
            }
        }
        if (belowLineNumber <= lineCount) {
            var belowMaxColumn = model.getLineMaxColumn(belowLineNumber);
            if (belowMaxColumn !== 1) {
                // bingo!
                return new position_1.Position(belowLineNumber, 1);
            }
        }
        distance++;
    }
    return null;
}
var TokenIterator = (function () {
    function TokenIterator(model, position) {
        this._model = model;
        this._lineCount = this._model.getLineCount();
        this._prev = null;
        this._next = null;
        position = findClosestNonEmptyLine(model, position);
        if (position) {
            this._model.forceTokenization(position.lineNumber);
            var lineTokens = this._model.getLineTokens(position.lineNumber);
            var currentToken = lineTokens.findTokenAtOffset(position.column - 1);
            if (currentToken) {
                this._prev = this._next = new TokenInfo(currentToken, position.lineNumber);
            }
        }
    }
    TokenIterator.prototype._advanceNext = function () {
        if (!this._next) {
            return;
        }
        var lineNumber = this._next.lineNumber;
        var next = this._next._actual.next();
        while (!next && lineNumber < this._lineCount) {
            lineNumber++;
            this._model.forceTokenization(lineNumber);
            var currentLineTokens = this._model.getLineTokens(lineNumber);
            next = currentLineTokens.firstToken();
        }
        this._prev = this._next;
        if (next) {
            this._next = new TokenInfo(next, lineNumber);
        }
        else {
            this._next = null;
        }
    };
    TokenIterator.prototype._advancePrev = function () {
        if (!this._prev) {
            return;
        }
        var lineNumber = this._prev.lineNumber;
        var prev = this._prev._actual.prev();
        while (!prev && lineNumber > 1) {
            lineNumber--;
            this._model.forceTokenization(lineNumber);
            var currentLineTokens = this._model.getLineTokens(lineNumber);
            prev = currentLineTokens.lastToken();
        }
        this._next = this._prev;
        if (prev) {
            this._prev = new TokenInfo(prev, lineNumber);
        }
        else {
            this._prev = null;
        }
    };
    TokenIterator.prototype.hasNext = function () {
        return this._next !== null;
    };
    TokenIterator.prototype.next = function () {
        var result = this._next;
        this._advanceNext();
        return result;
    };
    TokenIterator.prototype.hasPrev = function () {
        return this._prev !== null;
    };
    TokenIterator.prototype.prev = function () {
        var result = this._prev;
        this._advancePrev();
        return result;
    };
    TokenIterator.prototype._invalidate = function () {
        // replace all public functions with errors
        var errorFn = function () {
            throw new Error('iteration isn\'t valid anymore');
        };
        this.hasNext = errorFn;
        this.next = errorFn;
        this.hasPrev = errorFn;
        this.prev = errorFn;
    };
    return TokenIterator;
}());
exports.TokenIterator = TokenIterator;
