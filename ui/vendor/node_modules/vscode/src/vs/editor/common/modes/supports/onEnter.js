/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require("vs/base/common/errors");
var strings = require("vs/base/common/strings");
var languageConfiguration_1 = require("vs/editor/common/modes/languageConfiguration");
var OnEnterSupport = (function () {
    function OnEnterSupport(opts) {
        opts = opts || {};
        opts.brackets = opts.brackets || [
            ['(', ')'],
            ['{', '}'],
            ['[', ']']
        ];
        this._brackets = opts.brackets.map(function (bracket) {
            return {
                open: bracket[0],
                openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                close: bracket[1],
                closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
            };
        });
        this._regExpRules = opts.regExpRules || [];
        this._indentationRules = opts.indentationRules;
    }
    OnEnterSupport.prototype.onEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
        // (1): `regExpRules`
        for (var i = 0, len = this._regExpRules.length; i < len; i++) {
            var rule = this._regExpRules[i];
            if (rule.beforeText.test(beforeEnterText)) {
                if (rule.afterText) {
                    if (rule.afterText.test(afterEnterText)) {
                        return rule.action;
                    }
                }
                else {
                    return rule.action;
                }
            }
        }
        // (2): Special indent-outdent
        if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
            for (var i = 0, len = this._brackets.length; i < len; i++) {
                var bracket = this._brackets[i];
                if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                    return { indentAction: languageConfiguration_1.IndentAction.IndentOutdent };
                }
            }
        }
        // (3): Indentation Support
        if (this._indentationRules) {
            var indentOffset = null;
            var outdentCurrentLine = false;
            if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(beforeEnterText)) {
                indentOffset = 1;
            }
            if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(beforeEnterText)) {
                indentOffset = 1;
            }
            /**
             * Since the indentation of `beforeEnterText` might not be correct, we still provide the correct indent action
             * even if there is nothing to outdent from.
             */
            if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(afterEnterText)) {
                indentOffset = indentOffset ? indentOffset - 1 : -1;
            }
            if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(oneLineAboveText)) {
                indentOffset = indentOffset ? indentOffset - 1 : -1;
            }
            if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(beforeEnterText)) {
                outdentCurrentLine = true;
            }
            if (indentOffset !== null || outdentCurrentLine) {
                // this means at least one indentation rule is matched so we should handle it
                indentOffset = indentOffset || 0;
                switch (indentOffset) {
                    case -1:
                        return { indentAction: languageConfiguration_1.IndentAction.Outdent, outdentCurrentLine: outdentCurrentLine };
                    case 0:
                        return { indentAction: languageConfiguration_1.IndentAction.None, outdentCurrentLine: outdentCurrentLine };
                    case 1:
                        return { indentAction: languageConfiguration_1.IndentAction.Indent, outdentCurrentLine: outdentCurrentLine };
                }
            }
        }
        // (4): Open bracket based logic
        if (beforeEnterText.length > 0) {
            for (var i = 0, len = this._brackets.length; i < len; i++) {
                var bracket = this._brackets[i];
                if (bracket.openRegExp.test(beforeEnterText)) {
                    return { indentAction: languageConfiguration_1.IndentAction.Indent };
                }
            }
        }
        return null;
    };
    OnEnterSupport.prototype.containNonWhitespace = function (text) {
        // the text doesn't contain any non-whitespace character.
        var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(text);
        if (nonWhitespaceIdx >= 0) {
            return true;
        }
        return false;
    };
    OnEnterSupport.prototype.shouldIgnore = function (text) {
        // the text matches `unIndentedLinePattern`
        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
            return true;
        }
        return false;
    };
    OnEnterSupport._createOpenBracketRegExp = function (bracket) {
        var str = strings.escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(0))) {
            str = '\\b' + str;
        }
        str += '\\s*$';
        return OnEnterSupport._safeRegExp(str);
    };
    OnEnterSupport._createCloseBracketRegExp = function (bracket) {
        var str = strings.escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(str.length - 1))) {
            str = str + '\\b';
        }
        str = '^\\s*' + str;
        return OnEnterSupport._safeRegExp(str);
    };
    OnEnterSupport._safeRegExp = function (def) {
        try {
            return new RegExp(def);
        }
        catch (err) {
            errors_1.onUnexpectedError(err);
            return null;
        }
    };
    return OnEnterSupport;
}());
exports.OnEnterSupport = OnEnterSupport;
