import { IDisposable } from 'vs/base/common/lifecycle';
import * as modes from 'vs/editor/common/modes';
import { IModeService } from 'vs/editor/common/services/modeService';
import { AbstractState } from 'vs/editor/common/modes/abstractState';
export interface ILeavingNestedModeData {
    /**
     * The part of the line that will be tokenized by the nested mode
     */
    nestedModeBuffer: string;
    /**
     * The part of the line that will be tokenized by the parent mode when it continues after the nested mode
     */
    bufferAfterNestedMode: string;
    /**
     * The state that will be used for continuing tokenization by the parent mode after the nested mode
     */
    stateAfterNestedMode: AbstractState;
}
export interface IModeLocator {
    getMode(mimetypeOrModeId: string): modes.IMode;
}
export interface ITokenizationCustomization {
    getInitialState(): AbstractState;
    enterNestedMode?: (state: AbstractState) => boolean;
    getNestedMode?: (state: AbstractState, locator: IModeLocator) => modes.IMode;
    /**
     * Return null if the line does not leave the nested mode
     */
    getLeavingNestedModeData?: (line: string, state: modes.IState) => ILeavingNestedModeData;
}
export declare class TokenizationSupport implements modes.ITokenizationSupport, IDisposable {
    static MAX_EMBEDDED_LEVELS: number;
    private customization;
    private defaults;
    private supportsNestedModes;
    private _modeService;
    private _modeId;
    private _embeddedModes;
    private _tokenizationRegistryListener;
    constructor(modeService: IModeService, modeId: string, customization: ITokenizationCustomization, supportsNestedModes: boolean);
    dispose(): void;
    getInitialState(): modes.IState;
    tokenize(line: string, state: modes.IState, deltaOffset?: number, stopAtOffset?: number): modes.ILineTokens;
    /**
     * Precondition is: nestedModeState.getModeId() !== this._modeId
     * This means we are in a nested mode when parsing starts on this line.
     */
    private _nestedTokenize(buffer, nestedModeState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions);
    /**
     * Precondition is: state.getMode() === this
     * This means we are in the current mode when parsing starts on this line.
     */
    private _myTokenize(buffer, myState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions);
    private _getEmbeddedLevel(state);
    private _enterNestedMode(state);
    private _getNestedMode(state);
    private _getNestedModeInitialState(state);
    private _getLeavingNestedModeData(line, state);
}
