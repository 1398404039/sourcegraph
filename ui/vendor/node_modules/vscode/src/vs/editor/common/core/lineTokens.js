/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var tokensBinaryEncoding_1 = require("vs/editor/common/model/tokensBinaryEncoding");
var modeTransition_1 = require("vs/editor/common/core/modeTransition");
/**
 * A standard token type. Values are 2^x such that a bit mask can be used.
 */
var StandardTokenType;
(function (StandardTokenType) {
    StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
    StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
    StandardTokenType[StandardTokenType["String"] = 2] = "String";
    StandardTokenType[StandardTokenType["RegEx"] = 4] = "RegEx";
})(StandardTokenType = exports.StandardTokenType || (exports.StandardTokenType = {}));
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex)\b/;
function toStandardTokenType(tokenType) {
    var m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
    if (!m) {
        return 0 /* Other */;
    }
    switch (m[1]) {
        case 'comment':
            return 1 /* Comment */;
        case 'string':
            return 2 /* String */;
        case 'regex':
            return 4 /* RegEx */;
    }
    throw new Error('Unexpected match for standard token type!');
}
var LineToken = (function () {
    function LineToken(source, tokenIndex, modeIndex) {
        this._source = source;
        this._tokenIndex = tokenIndex;
        this._modeIndex = modeIndex;
        this.startOffset = this._source.getTokenStartOffset(this._tokenIndex);
        this.endOffset = this._source.getTokenEndOffset(this._tokenIndex);
        this.standardType = this._source.getStandardTokenType(this._tokenIndex);
        this.modeId = this._source.modeTransitions[this._modeIndex].modeId;
        this.hasPrev = (this._tokenIndex > 0);
        this.hasNext = (this._tokenIndex + 1 < this._source.getTokenCount());
    }
    LineToken.prototype.prev = function () {
        if (!this.hasPrev) {
            return null;
        }
        if (this._modeIndex === 0) {
            return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex);
        }
        var modeTransitions = this._source.modeTransitions;
        var currentModeTransition = modeTransitions[this._modeIndex];
        var prevStartOffset = this._source.getTokenStartOffset(this._tokenIndex - 1);
        if (prevStartOffset < currentModeTransition.startIndex) {
            // Going to previous mode transition
            return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex - 1);
        }
        return new LineToken(this._source, this._tokenIndex - 1, this._modeIndex);
    };
    LineToken.prototype.next = function () {
        if (!this.hasNext) {
            return null;
        }
        var modeTransitions = this._source.modeTransitions;
        if (this._modeIndex === modeTransitions.length - 1) {
            return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex);
        }
        var nextModeTransition = modeTransitions[this._modeIndex + 1];
        var nextStartOffset = this._source.getTokenStartOffset(this._tokenIndex + 1);
        if (nextStartOffset >= nextModeTransition.startIndex) {
            // Going to next mode transition
            return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex + 1);
        }
        return new LineToken(this._source, this._tokenIndex + 1, this._modeIndex);
    };
    return LineToken;
}());
exports.LineToken = LineToken;
var LineTokens = (function () {
    function LineTokens(map, tokens, modeTransitions, text) {
        this._map = map;
        this._tokens = tokens;
        this.modeTransitions = modeTransitions;
        this._text = text;
        this._textLength = this._text.length;
    }
    LineTokens.prototype.getTokenCount = function () {
        return this._tokens.length;
    };
    LineTokens.prototype.getLineContent = function () {
        return this._text;
    };
    LineTokens.prototype.getTokenStartOffset = function (tokenIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex]);
    };
    /**
     * Deprecated. Do not use.
     * @deprecated
     */
    LineTokens.prototype.getTokenType = function (tokenIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.getType(this._map, this._tokens[tokenIndex]);
    };
    LineTokens.prototype.getStandardTokenType = function (tokenIndex) {
        return toStandardTokenType(this.getTokenType(tokenIndex));
    };
    LineTokens.prototype.getTokenEndOffset = function (tokenIndex) {
        if (tokenIndex + 1 < this._tokens.length) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex + 1]);
        }
        return this._textLength;
    };
    /**
     * Find the token containing offset `offset`.
     *    For example, with the following tokens [0, 5), [5, 9), [9, infinity)
     *    Searching for 0, 1, 2, 3 or 4 will return 0.
     *    Searching for 5, 6, 7 or 8 will return 1.
     *    Searching for 9, 10, 11, ... will return 2.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    LineTokens.prototype.findTokenIndexAtOffset = function (offset) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.findIndexOfOffset(this._tokens, offset);
    };
    LineTokens.prototype.findTokenAtOffset = function (offset) {
        if (this._textLength === 0) {
            return null;
        }
        var tokenIndex = this.findTokenIndexAtOffset(offset);
        var modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(this.modeTransitions, offset);
        return new LineToken(this, tokenIndex, modeIndex);
    };
    LineTokens.prototype.firstToken = function () {
        if (this._textLength === 0) {
            return null;
        }
        return new LineToken(this, 0, 0);
    };
    LineTokens.prototype.lastToken = function () {
        if (this._textLength === 0) {
            return null;
        }
        return new LineToken(this, this._tokens.length - 1, this.modeTransitions.length - 1);
    };
    LineTokens.prototype.inflate = function () {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.inflateArr(this._map, this._tokens);
    };
    LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaStartIndex) {
        return tokensBinaryEncoding_1.TokensBinaryEncoding.sliceAndInflate(this._map, this._tokens, startOffset, endOffset, deltaStartIndex);
    };
    return LineTokens;
}());
exports.LineTokens = LineTokens;
