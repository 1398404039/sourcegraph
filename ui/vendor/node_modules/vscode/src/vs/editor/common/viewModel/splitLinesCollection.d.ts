import { Position } from 'vs/editor/common/core/position';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { LineTokens } from 'vs/editor/common/core/lineTokens';
import { ViewLineData, ViewEventsCollector } from 'vs/editor/common/viewModel/viewModel';
export declare class OutputPosition {
    _outputPositionBrand: void;
    outputLineIndex: number;
    outputOffset: number;
    constructor(outputLineIndex: number, outputOffset: number);
}
export interface ILineMapping {
    getOutputLineCount(): number;
    getWrappedLinesIndent(): string;
    getInputOffsetOfOutputPosition(outputLineIndex: number, outputOffset: number): number;
    getOutputPositionOfInputOffset(inputOffset: number): OutputPosition;
}
export interface ILineMapperFactory {
    createLineMapping(lineText: string, tabSize: number, wrappingColumn: number, columnsForFullWidthChar: number, wrappingIndent: editorCommon.WrappingIndent): ILineMapping;
}
export interface IModel {
    getLineTokens(lineNumber: number): LineTokens;
    getLineContent(lineNumber: number): string;
    getLineMinColumn(lineNumber: number): number;
    getLineMaxColumn(lineNumber: number): number;
}
export interface ISplitLine {
    isVisible(): boolean;
    setVisible(isVisible: boolean): ISplitLine;
    getViewLineCount(): number;
    getViewLineContent(model: IModel, modelLineNumber: number, outputLineIndex: number): string;
    getViewLineMinColumn(model: IModel, modelLineNumber: number, outputLineIndex: number): number;
    getViewLineMaxColumn(model: IModel, modelLineNumber: number, outputLineIndex: number): number;
    getViewLineData(model: IModel, modelLineNumber: number, outputLineIndex: number): ViewLineData;
    getViewLinesData(model: IModel, modelLineNumber: number, fromOuputLineIndex: number, toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: ViewLineData[]): void;
    getModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number;
    getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position;
}
export declare class SplitLine implements ISplitLine {
    private positionMapper;
    private outputLineCount;
    private wrappedIndent;
    private wrappedIndentLength;
    private _isVisible;
    constructor(positionMapper: ILineMapping, isVisible: boolean);
    isVisible(): boolean;
    setVisible(isVisible: boolean): ISplitLine;
    getViewLineCount(): number;
    private getInputStartOffsetOfOutputLineIndex(outputLineIndex);
    private getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);
    getViewLineContent(model: IModel, modelLineNumber: number, outputLineIndex: number): string;
    getViewLineMinColumn(model: IModel, modelLineNumber: number, outputLineIndex: number): number;
    getViewLineMaxColumn(model: IModel, modelLineNumber: number, outputLineIndex: number): number;
    getViewLineData(model: IModel, modelLineNumber: number, outputLineIndex: number): ViewLineData;
    getViewLinesData(model: IModel, modelLineNumber: number, fromOuputLineIndex: number, toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: ViewLineData[]): void;
    getModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number;
    getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position;
}
export declare class SplitLinesCollection {
    private model;
    private _validModelVersionId;
    private wrappingColumn;
    private columnsForFullWidthChar;
    private wrappingIndent;
    private tabSize;
    private lines;
    private prefixSumComputer;
    private linePositionMapperFactory;
    private hiddenAreasIds;
    constructor(model: editorCommon.IModel, linePositionMapperFactory: ILineMapperFactory, tabSize: number, wrappingColumn: number, columnsForFullWidthChar: number, wrappingIndent: editorCommon.WrappingIndent);
    dispose(): void;
    private _ensureValidState();
    private _constructLines(resetHiddenAreas);
    private getHiddenAreas();
    private _reduceRanges(_ranges);
    setHiddenAreas(eventsCollector: ViewEventsCollector, _ranges: editorCommon.IRange[]): boolean;
    modelPositionIsVisible(modelLineNumber: number, modelColumn: number): boolean;
    setTabSize(eventsCollector: ViewEventsCollector, newTabSize: number): boolean;
    setWrappingIndent(eventsCollector: ViewEventsCollector, newWrappingIndent: editorCommon.WrappingIndent): boolean;
    setWrappingColumn(eventsCollector: ViewEventsCollector, newWrappingColumn: number, columnsForFullWidthChar: number): boolean;
    onModelFlushed(eventsCollector: ViewEventsCollector, versionId: number): void;
    onModelLinesDeleted(eventsCollector: ViewEventsCollector, versionId: number, fromLineNumber: number, toLineNumber: number): void;
    onModelLinesInserted(eventsCollector: ViewEventsCollector, versionId: number, fromLineNumber: number, toLineNumber: number, text: string[]): void;
    onModelLineChanged(eventsCollector: ViewEventsCollector, versionId: number, lineNumber: number, newText: string): boolean;
    getViewLineCount(): number;
    private _toValidViewLineNumber(viewLineNumber);
    /**
     * Gives a hint that a lot of requests are about to come in for these line numbers.
     */
    warmUpLookupCache(viewStartLineNumber: number, viewEndLineNumber: number): void;
    getViewLineIndentGuide(viewLineNumber: number): number;
    getViewLineContent(viewLineNumber: number): string;
    getViewLineMinColumn(viewLineNumber: number): number;
    getViewLineMaxColumn(viewLineNumber: number): number;
    getViewLineData(viewLineNumber: number): ViewLineData;
    getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): ViewLineData[];
    validateViewPosition(viewLineNumber: number, viewColumn: number, expectedModelPosition: Position): Position;
    convertViewPositionToModelPosition(viewLineNumber: number, viewColumn: number): Position;
    convertModelPositionToViewPosition(_modelLineNumber: number, _modelColumn: number): Position;
}
