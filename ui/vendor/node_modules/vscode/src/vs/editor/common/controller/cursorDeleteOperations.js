/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var replaceCommand_1 = require("vs/editor/common/commands/replaceCommand");
var cursorCommon_1 = require("vs/editor/common/controller/cursorCommon");
var range_1 = require("vs/editor/common/core/range");
var cursorMoveOperations_1 = require("vs/editor/common/controller/cursorMoveOperations");
var strings = require("vs/base/common/strings");
var DeleteOperations = (function () {
    function DeleteOperations() {
    }
    DeleteOperations.deleteRight = function (config, model, cursor) {
        var deleteSelection = cursor.selection;
        if (deleteSelection.isEmpty()) {
            var position = cursor.position;
            var rightOfPosition = cursorMoveOperations_1.MoveOperations.right(config, model, position.lineNumber, position.column);
            deleteSelection = new range_1.Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);
        }
        if (deleteSelection.isEmpty()) {
            // Probably at end of file => ignore
            return null;
        }
        var shouldPushStackElementBefore = false;
        if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
            shouldPushStackElementBefore = true;
        }
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
            shouldPushStackElementBefore: shouldPushStackElementBefore,
            shouldPushStackElementAfter: false
        });
    };
    DeleteOperations.deleteAllRight = function (config, model, cursor) {
        var selection = cursor.selection;
        if (selection.isEmpty()) {
            var position = cursor.position;
            var lineNumber = position.lineNumber;
            var column = position.column;
            var maxColumn = model.getLineMaxColumn(lineNumber);
            if (column === maxColumn) {
                // Ignore deleting at end of file
                return null;
            }
            var deleteSelection = new range_1.Range(lineNumber, column, lineNumber, maxColumn);
            if (!deleteSelection.isEmpty()) {
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false
                });
            }
        }
        return this.deleteRight(config, model, cursor);
    };
    DeleteOperations.autoClosingPairDelete = function (config, model, cursor) {
        if (!config.autoClosingBrackets) {
            return null;
        }
        if (!cursor.selection.isEmpty()) {
            return null;
        }
        var position = cursor.position;
        var lineText = model.getLineContent(position.lineNumber);
        var character = lineText[position.column - 2];
        if (!config.autoClosingPairsOpen.hasOwnProperty(character)) {
            return null;
        }
        var afterCharacter = lineText[position.column - 1];
        var closeCharacter = config.autoClosingPairsOpen[character];
        if (afterCharacter !== closeCharacter) {
            return null;
        }
        var deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
            shouldPushStackElementBefore: false,
            shouldPushStackElementAfter: false
        });
    };
    DeleteOperations.deleteLeft = function (config, model, cursor) {
        var r = this.autoClosingPairDelete(config, model, cursor);
        if (r) {
            // This was a case for an auto-closing pair delete
            return r;
        }
        var deleteSelection = cursor.selection;
        if (deleteSelection.isEmpty()) {
            var position = cursor.position;
            if (config.useTabStops && position.column > 1) {
                var lineContent = model.getLineContent(position.lineNumber);
                var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
                var lastIndentationColumn = (firstNonWhitespaceIndex === -1
                    ? lineContent.length + 1
                    : firstNonWhitespaceIndex + 1);
                if (position.column <= lastIndentationColumn) {
                    var fromVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);
                    var toVisibleColumn = cursorCommon_1.CursorColumns.prevTabStop(fromVisibleColumn, config.tabSize);
                    var toColumn = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);
                    deleteSelection = new range_1.Range(position.lineNumber, toColumn, position.lineNumber, position.column);
                }
                else {
                    deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);
                }
            }
            else {
                var leftOfPosition = cursorMoveOperations_1.MoveOperations.left(config, model, position.lineNumber, position.column);
                deleteSelection = new range_1.Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);
            }
        }
        if (deleteSelection.isEmpty()) {
            // Probably at beginning of file => ignore
            return null;
        }
        var shouldPushStackElementBefore = false;
        if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
            shouldPushStackElementBefore = true;
        }
        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
            shouldPushStackElementBefore: shouldPushStackElementBefore,
            shouldPushStackElementAfter: false
        });
    };
    DeleteOperations.cut = function (config, model, cursor, enableEmptySelectionClipboard) {
        var selection = cursor.selection;
        if (selection.isEmpty()) {
            if (enableEmptySelectionClipboard) {
                // This is a full line cut
                var position = cursor.position;
                var startLineNumber = void 0, startColumn = void 0, endLineNumber = void 0, endColumn = void 0;
                if (position.lineNumber < model.getLineCount()) {
                    // Cutting a line in the middle of the model
                    startLineNumber = position.lineNumber;
                    startColumn = 1;
                    endLineNumber = position.lineNumber + 1;
                    endColumn = 1;
                }
                else if (position.lineNumber > 1) {
                    // Cutting the last line & there are more than 1 lines in the model
                    startLineNumber = position.lineNumber - 1;
                    startColumn = model.getLineMaxColumn(position.lineNumber - 1);
                    endLineNumber = position.lineNumber;
                    endColumn = model.getLineMaxColumn(position.lineNumber);
                }
                else {
                    // Cutting the single line that the model contains
                    startLineNumber = position.lineNumber;
                    startColumn = 1;
                    endLineNumber = position.lineNumber;
                    endColumn = model.getLineMaxColumn(position.lineNumber);
                }
                var deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
                if (!deleteSelection.isEmpty()) {
                    return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                        shouldPushStackElementBefore: true,
                        shouldPushStackElementAfter: true
                    });
                }
                else {
                    return null;
                }
            }
            else {
                // Cannot cut empty selection
                return null;
            }
        }
        else {
            // Delete left or right, they will both result in the selection being deleted
            return this.deleteRight(config, model, cursor);
        }
    };
    return DeleteOperations;
}());
exports.DeleteOperations = DeleteOperations;
