import { MarkedString } from 'vs/base/common/htmlContent';
import { Range } from 'vs/editor/common/core/range';
import * as editorCommon from 'vs/editor/common/editorCommon';
import { MarkersTracker, LineMarker } from 'vs/editor/common/model/modelLine';
import { TextModelWithMarkers } from 'vs/editor/common/model/textModelWithMarkers';
export declare class InternalDecoration implements editorCommon.IModelDecoration {
    _internalDecorationBrand: void;
    readonly id: string;
    readonly internalId: number;
    readonly ownerId: number;
    readonly startMarker: LineMarker;
    readonly endMarker: LineMarker;
    options: ModelDecorationOptions;
    isForValidation: boolean;
    range: Range;
    constructor(id: string, internalId: number, ownerId: number, range: Range, startMarker: LineMarker, endMarker: LineMarker, options: ModelDecorationOptions);
    setOptions(options: ModelDecorationOptions): void;
    setRange(multiLineDecorationsMap: {
        [key: string]: InternalDecoration;
    }, range: Range): void;
}
export declare class TextModelWithDecorations extends TextModelWithMarkers implements editorCommon.ITextModelWithDecorations {
    /**
     * Used to workaround broken clients that might attempt using a decoration id generated by a different model.
     * It is not globally unique in order to limit it to one character.
     */
    private readonly _instanceId;
    private _lastDecorationId;
    private _currentDecorationsTracker;
    private _currentDecorationsTrackerCnt;
    private _currentMarkersTracker;
    private _currentMarkersTrackerCnt;
    private _decorations;
    private _internalDecorations;
    private _multiLineDecorationsMap;
    constructor(allowedEventTypes: string[], rawText: editorCommon.IRawText, languageId: string);
    dispose(): void;
    protected _resetValue(newValue: editorCommon.IRawText): void;
    private static _shouldStartMarkerSticksToPreviousCharacter(stickiness);
    private static _shouldEndMarkerSticksToPreviousCharacter(stickiness);
    _getTrackedRangesCount(): number;
    changeDecorations<T>(callback: (changeAccessor: editorCommon.IModelDecorationsChangeAccessor) => T, ownerId?: number): T;
    private _changeDecorations<T>(decorationsTracker, ownerId, callback);
    deltaDecorations(oldDecorations: string[], newDecorations: editorCommon.IModelDeltaDecoration[], ownerId?: number): string[];
    removeAllDecorationsWithOwnerId(ownerId: number): void;
    getDecorationOptions(decorationId: string): editorCommon.IModelDecorationOptions;
    getDecorationRange(decorationId: string): Range;
    getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    /**
     * Fetch only multi-line decorations that intersect with the given line number range
     */
    private _getMultiLineDecorations(filterRange, filterOwnerId, filterOutValidation);
    private _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation);
    getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    getDecorationsInRange(range: editorCommon.IRange, ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    getAllDecorations(ownerId?: number, filterOutValidation?: boolean): editorCommon.IModelDecoration[];
    protected _acquireMarkersTracker(): MarkersTracker;
    protected _releaseMarkersTracker(): void;
    /**
     * Handle changed markers (i.e. update decorations ranges and return the changed decorations, unique and sorted by id)
     */
    private _handleTrackedMarkers(markersTracker);
    private static _createRangeFromMarkers(startPosition, endPosition);
    private _acquireDecorationsTracker();
    private _releaseDecorationsTracker();
    private _handleTrackedDecorations(decorationsTracker);
    private emitModelDecorationsChangedEvent(e);
    private _normalizeDeltaDecorations(deltaDecorations);
    private _externalDecorationId(internalId);
    private _addDecorationImpl(decorationsTracker, ownerId, _range, options);
    private _addDecorationsImpl(decorationsTracker, ownerId, newDecorations);
    private _changeDecorationImpl(decorationsTracker, decorationId, newRange);
    private _changeDecorationOptionsImpl(decorationsTracker, decorationId, options);
    private _removeDecorationImpl(decorationsTracker, decorationId);
    private _removeDecorationsImpl(decorationsTracker, decorationIds);
    private _resolveOldDecorations(oldDecorations);
    private _deltaDecorationsImpl(decorationsTracker, ownerId, oldDecorationsIds, newDecorations);
}
export declare class ModelDecorationOptions implements editorCommon.IModelDecorationOptions {
    stickiness: editorCommon.TrackedRangeStickiness;
    className: string;
    glyphMarginHoverMessage: string;
    hoverMessage: MarkedString | MarkedString[];
    isWholeLine: boolean;
    showInOverviewRuler: string;
    overviewRuler: editorCommon.IModelDecorationOverviewRulerOptions;
    glyphMarginClassName: string;
    linesDecorationsClassName: string;
    marginClassName: string;
    inlineClassName: string;
    beforeContentClassName: string;
    afterContentClassName: string;
    constructor(options: editorCommon.IModelDecorationOptions);
    private static _overviewRulerEquals(a, b);
    equals(other: ModelDecorationOptions): boolean;
}
