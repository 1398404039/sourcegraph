/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require("vs/base/common/async");
var event_1 = require("vs/base/common/event");
var lifecycle_1 = require("vs/base/common/lifecycle");
var textAreaState_1 = require("vs/editor/common/controller/textAreaState");
var range_1 = require("vs/editor/common/core/range");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var ReadFromTextArea;
(function (ReadFromTextArea) {
    ReadFromTextArea[ReadFromTextArea["Type"] = 0] = "Type";
    ReadFromTextArea[ReadFromTextArea["Paste"] = 1] = "Paste";
})(ReadFromTextArea || (ReadFromTextArea = {}));
var TextAreaHandler = (function (_super) {
    __extends(TextAreaHandler, _super);
    function TextAreaHandler(Browser, strategy, textArea, model, flushAnyAccumulatedEvents) {
        var _this = _super.call(this) || this;
        _this._onKeyDown = _this._register(new event_1.Emitter());
        _this.onKeyDown = _this._onKeyDown.event;
        _this._onKeyUp = _this._register(new event_1.Emitter());
        _this.onKeyUp = _this._onKeyUp.event;
        _this._onCut = _this._register(new event_1.Emitter());
        _this.onCut = _this._onCut.event;
        _this._onPaste = _this._register(new event_1.Emitter());
        _this.onPaste = _this._onPaste.event;
        _this._onType = _this._register(new event_1.Emitter());
        _this.onType = _this._onType.event;
        _this._onCompositionStart = _this._register(new event_1.Emitter());
        _this.onCompositionStart = _this._onCompositionStart.event;
        _this._onCompositionUpdate = _this._register(new event_1.Emitter());
        _this.onCompositionUpdate = _this._onCompositionUpdate.event;
        _this._onCompositionEnd = _this._register(new event_1.Emitter());
        _this.onCompositionEnd = _this._onCompositionEnd.event;
        _this.Browser = Browser;
        _this.textArea = textArea;
        _this.model = model;
        _this.flushAnyAccumulatedEvents = flushAnyAccumulatedEvents;
        _this.selection = new range_1.Range(1, 1, 1, 1);
        _this.selections = [new range_1.Range(1, 1, 1, 1)];
        _this._nextCommand = 0 /* Type */;
        _this.asyncTriggerCut = new async_1.RunOnceScheduler(function () { return _this._onCut.fire(); }, 0);
        _this.lastCopiedValue = null;
        _this.lastCopiedValueIsFromEmptySelection = false;
        _this.textAreaState = textAreaState_1.createTextAreaState(strategy);
        _this.hasFocus = false;
        _this.lastCompositionEndTime = 0;
        _this._register(_this.textArea.onKeyDown(function (e) { return _this._onKeyDownHandler(e); }));
        _this._register(_this.textArea.onKeyUp(function (e) { return _this._onKeyUp.fire(e); }));
        _this._register(_this.textArea.onKeyPress(function (e) { return _this._onKeyPressHandler(e); }));
        _this.textareaIsShownAtCursor = false;
        _this._register(_this.textArea.onCompositionStart(function (e) {
            if (_this.textareaIsShownAtCursor) {
                return;
            }
            _this.textareaIsShownAtCursor = true;
            // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
            if (!_this.Browser.isEdgeOrIE) {
                _this.setTextAreaState('compositionstart', _this.textAreaState.toEmpty());
            }
            _this._onCompositionStart.fire({
                showAtLineNumber: _this.selection.startLineNumber,
                showAtColumn: _this.selection.startColumn
            });
        }));
        _this._register(_this.textArea.onCompositionUpdate(function (e) {
            _this.textAreaState = _this.textAreaState.fromText(e.data);
            var typeInput = _this.textAreaState.updateComposition();
            _this._onType.fire(typeInput);
            _this._onCompositionUpdate.fire(e);
        }));
        var readFromTextArea = function () {
            _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
            var typeInput = _this.textAreaState.deduceInput();
            // console.log('==> DEDUCED INPUT: ' + JSON.stringify(typeInput));
            if (_this._nextCommand === 0 /* Type */) {
                if (typeInput.text !== '') {
                    _this._onType.fire(typeInput);
                }
            }
            else {
                _this.executePaste(typeInput.text);
                _this._nextCommand = 0 /* Type */;
            }
        };
        _this._register(_this.textArea.onCompositionEnd(function (e) {
            // console.log('onCompositionEnd: ' + e.data);
            _this.textAreaState = _this.textAreaState.fromText(e.data);
            var typeInput = _this.textAreaState.updateComposition();
            _this._onType.fire(typeInput);
            // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)
            // we cannot assume the text at the end consists only of the composited text
            if (Browser.isEdgeOrIE || Browser.isChrome) {
                _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
            }
            _this.lastCompositionEndTime = (new Date()).getTime();
            if (!_this.textareaIsShownAtCursor) {
                return;
            }
            _this.textareaIsShownAtCursor = false;
            _this._onCompositionEnd.fire();
        }));
        _this._register(_this.textArea.onInput(function () {
            // console.log('onInput: ' + this.textArea.getValue());
            if (_this.textareaIsShownAtCursor) {
                // console.log('::ignoring input event because the textarea is shown at cursor: ' + this.textArea.getValue());
                return;
            }
            readFromTextArea();
        }));
        // --- Clipboard operations
        _this._register(_this.textArea.onCut(function (e) {
            // Ensure we have the latest selection => ask all pending events to be sent
            _this.flushAnyAccumulatedEvents();
            _this._ensureClipboardGetsEditorSelection(e);
            _this.asyncTriggerCut.schedule();
        }));
        _this._register(_this.textArea.onCopy(function (e) {
            // Ensure we have the latest selection => ask all pending events to be sent
            _this.flushAnyAccumulatedEvents();
            _this._ensureClipboardGetsEditorSelection(e);
        }));
        _this._register(_this.textArea.onPaste(function (e) {
            if (e.canUseTextData()) {
                _this.executePaste(e.getTextData());
            }
            else {
                if (_this.textArea.getSelectionStart() !== _this.textArea.getSelectionEnd()) {
                    // Clean up the textarea, to get a clean paste
                    _this.setTextAreaState('paste', _this.textAreaState.toEmpty());
                }
                _this._nextCommand = 1 /* Paste */;
            }
        }));
        _this._writePlaceholderAndSelectTextArea('ctor');
        return _this;
    }
    TextAreaHandler.prototype.dispose = function () {
        this.asyncTriggerCut.dispose();
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    TextAreaHandler.prototype.setStrategy = function (strategy) {
        this.textAreaState = this.textAreaState.toStrategy(strategy);
    };
    TextAreaHandler.prototype.setHasFocus = function (isFocused) {
        if (this.hasFocus === isFocused) {
            // no change
            return;
        }
        this.hasFocus = isFocused;
        if (this.hasFocus) {
            this._writePlaceholderAndSelectTextArea('focusgain');
        }
    };
    TextAreaHandler.prototype.setCursorSelections = function (primary, secondary) {
        this.selection = primary;
        this.selections = [primary].concat(secondary);
        this._writePlaceholderAndSelectTextArea('selection changed');
    };
    // --- end event handlers
    TextAreaHandler.prototype.setTextAreaState = function (reason, textAreaState) {
        if (!this.hasFocus) {
            textAreaState = textAreaState.resetSelection();
        }
        textAreaState.applyToTextArea(reason, this.textArea, this.hasFocus);
        this.textAreaState = textAreaState;
    };
    TextAreaHandler.prototype._onKeyDownHandler = function (e) {
        if (e.equals(9 /* Escape */)) {
            // Prevent default always for `Esc`, otherwise it will generate a keypress
            // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx
            e.preventDefault();
        }
        this._onKeyDown.fire(e);
    };
    TextAreaHandler.prototype._onKeyPressHandler = function (e) {
        if (!this.hasFocus) {
            // Sometimes, when doing Alt-Tab, in FF, a 'keypress' is sent before a 'focus'
            return;
        }
    };
    // ------------- Operations that are always executed asynchronously
    TextAreaHandler.prototype.executePaste = function (txt) {
        if (txt === '') {
            return;
        }
        var pasteOnNewLine = false;
        if (this.Browser.enableEmptySelectionClipboard) {
            pasteOnNewLine = (txt === this.lastCopiedValue && this.lastCopiedValueIsFromEmptySelection);
        }
        this._onPaste.fire({
            text: txt,
            pasteOnNewLine: pasteOnNewLine
        });
    };
    TextAreaHandler.prototype.writePlaceholderAndSelectTextAreaSync = function () {
        this._writePlaceholderAndSelectTextArea('focusTextArea');
    };
    TextAreaHandler.prototype._writePlaceholderAndSelectTextArea = function (reason) {
        if (!this.textareaIsShownAtCursor) {
            // Do not write to the textarea if it is visible.
            if (this.Browser.isIPad) {
                // Do not place anything in the textarea for the iPad
                this.setTextAreaState(reason, this.textAreaState.toEmpty());
            }
            else {
                this.setTextAreaState(reason, this.textAreaState.fromEditorSelection(this.model, this.selection));
            }
        }
    };
    // ------------- Clipboard operations
    TextAreaHandler.prototype._ensureClipboardGetsEditorSelection = function (e) {
        var whatToCopy = this._getPlainTextToCopy();
        if (e.canUseTextData()) {
            e.setTextData(whatToCopy);
        }
        else {
            this.setTextAreaState('copy or cut', this.textAreaState.fromText(whatToCopy));
        }
        if (this.Browser.enableEmptySelectionClipboard) {
            if (this.Browser.isFirefox) {
                // When writing "LINE\r\n" to the clipboard and then pasting,
                // Firefox pastes "LINE\n", so let's work around this quirk
                this.lastCopiedValue = whatToCopy.replace(/\r\n/g, '\n');
            }
            else {
                this.lastCopiedValue = whatToCopy;
            }
            var selections = this.selections;
            this.lastCopiedValueIsFromEmptySelection = (selections.length === 1 && selections[0].isEmpty());
        }
    };
    TextAreaHandler.prototype._getPlainTextToCopy = function () {
        var newLineCharacter = this.model.getEOL();
        var selections = this.selections;
        if (selections.length === 1) {
            var range = selections[0];
            if (range.isEmpty()) {
                if (this.Browser.enableEmptySelectionClipboard) {
                    var modelLineNumber = this.model.convertViewPositionToModelPosition(range.startLineNumber, 1).lineNumber;
                    return this.model.getModelLineContent(modelLineNumber) + newLineCharacter;
                }
                else {
                    return '';
                }
            }
            return this.model.getValueInRange(range, editorCommon_1.EndOfLinePreference.TextDefined);
        }
        else {
            selections = selections.slice(0).sort(range_1.Range.compareRangesUsingStarts);
            var result = [];
            for (var i = 0; i < selections.length; i++) {
                result.push(this.model.getValueInRange(selections[i], editorCommon_1.EndOfLinePreference.TextDefined));
            }
            return result.join(newLineCharacter);
        }
    };
    return TextAreaHandler;
}(lifecycle_1.Disposable));
exports.TextAreaHandler = TextAreaHandler;
