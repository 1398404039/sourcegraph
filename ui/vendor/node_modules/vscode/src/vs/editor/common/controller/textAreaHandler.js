/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var async_1 = require("vs/base/common/async");
var strings = require("vs/base/common/strings");
var event_1 = require("vs/base/common/event");
var lifecycle_1 = require("vs/base/common/lifecycle");
var textAreaState_1 = require("vs/editor/common/controller/textAreaState");
var range_1 = require("vs/editor/common/core/range");
exports.CopyOptions = {
    forceCopyWithSyntaxHighlighting: false
};
var ReadFromTextArea;
(function (ReadFromTextArea) {
    ReadFromTextArea[ReadFromTextArea["Type"] = 0] = "Type";
    ReadFromTextArea[ReadFromTextArea["Paste"] = 1] = "Paste";
})(ReadFromTextArea || (ReadFromTextArea = {}));
// See https://github.com/Microsoft/monaco-editor/issues/320
var isChromev55 = (navigator.userAgent.indexOf('Chrome/55.') >= 0
    && navigator.userAgent.indexOf('Edge/') === -1);
var TextAreaHandler = (function (_super) {
    __extends(TextAreaHandler, _super);
    function TextAreaHandler(Browser, strategy, textArea, model, flushAnyAccumulatedEvents) {
        var _this = _super.call(this) || this;
        _this._onKeyDown = _this._register(new event_1.Emitter());
        _this.onKeyDown = _this._onKeyDown.event;
        _this._onKeyUp = _this._register(new event_1.Emitter());
        _this.onKeyUp = _this._onKeyUp.event;
        _this._onCut = _this._register(new event_1.Emitter());
        _this.onCut = _this._onCut.event;
        _this._onPaste = _this._register(new event_1.Emitter());
        _this.onPaste = _this._onPaste.event;
        _this._onType = _this._register(new event_1.Emitter());
        _this.onType = _this._onType.event;
        _this._onCompositionStart = _this._register(new event_1.Emitter());
        _this.onCompositionStart = _this._onCompositionStart.event;
        _this._onCompositionUpdate = _this._register(new event_1.Emitter());
        _this.onCompositionUpdate = _this._onCompositionUpdate.event;
        _this._onCompositionEnd = _this._register(new event_1.Emitter());
        _this.onCompositionEnd = _this._onCompositionEnd.event;
        _this.Browser = Browser;
        _this.textArea = textArea;
        _this.model = model;
        _this.flushAnyAccumulatedEvents = flushAnyAccumulatedEvents;
        _this.selection = new range_1.Range(1, 1, 1, 1);
        _this.selections = [new range_1.Range(1, 1, 1, 1)];
        _this._nextCommand = 0 /* Type */;
        _this.asyncTriggerCut = new async_1.RunOnceScheduler(function () { return _this._onCut.fire(); }, 0);
        _this.lastCopiedValue = null;
        _this.lastCopiedValueIsFromEmptySelection = false;
        _this.textAreaState = textAreaState_1.createTextAreaState(strategy);
        _this.hasFocus = false;
        _this.lastCompositionEndTime = 0;
        _this._register(_this.textArea.onKeyDown(function (e) { return _this._onKeyDownHandler(e); }));
        _this._register(_this.textArea.onKeyUp(function (e) { return _this._onKeyUp.fire(e); }));
        _this._register(_this.textArea.onKeyPress(function (e) { return _this._onKeyPressHandler(e); }));
        _this.textareaIsShownAtCursor = false;
        _this._register(_this.textArea.onCompositionStart(function (e) {
            if (_this.textareaIsShownAtCursor) {
                return;
            }
            _this.textareaIsShownAtCursor = true;
            // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
            if (!_this.Browser.isEdgeOrIE) {
                _this.setTextAreaState('compositionstart', _this.textAreaState.toEmpty(), false);
            }
            _this._onCompositionStart.fire({
                showAtLineNumber: _this.selection.startLineNumber,
                showAtColumn: _this.selection.startColumn
            });
        }));
        _this._register(_this.textArea.onCompositionUpdate(function (e) {
            if (isChromev55) {
                // See https://github.com/Microsoft/monaco-editor/issues/320
                // where compositionupdate .data is broken in Chrome v55
                // See https://bugs.chromium.org/p/chromium/issues/detail?id=677050#c9
                e = {
                    locale: e.locale,
                    data: _this.textArea.getValue()
                };
            }
            _this.textAreaState = _this.textAreaState.fromText(e.data);
            var typeInput = _this.textAreaState.updateComposition();
            _this._onType.fire(typeInput);
            _this._onCompositionUpdate.fire(e);
        }));
        var readFromTextArea = function () {
            var tempTextAreaState = _this.textAreaState.fromTextArea(_this.textArea);
            var typeInput = tempTextAreaState.deduceInput();
            if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {
                // Ignore invalid input but keep it around for next time
                return;
            }
            _this.textAreaState = tempTextAreaState;
            // console.log('==> DEDUCED INPUT: ' + JSON.stringify(typeInput));
            if (_this._nextCommand === 0 /* Type */) {
                if (typeInput.text !== '') {
                    _this._onType.fire(typeInput);
                }
            }
            else {
                _this.executePaste(typeInput.text);
                _this._nextCommand = 0 /* Type */;
            }
        };
        _this._register(_this.textArea.onCompositionEnd(function (e) {
            // console.log('onCompositionEnd: ' + e.data);
            _this.textAreaState = _this.textAreaState.fromText(e.data);
            var typeInput = _this.textAreaState.updateComposition();
            _this._onType.fire(typeInput);
            // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)
            // we cannot assume the text at the end consists only of the composited text
            if (Browser.isEdgeOrIE || Browser.isChrome) {
                _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
            }
            _this.lastCompositionEndTime = (new Date()).getTime();
            if (!_this.textareaIsShownAtCursor) {
                return;
            }
            _this.textareaIsShownAtCursor = false;
            _this._onCompositionEnd.fire();
        }));
        _this._register(_this.textArea.onInput(function () {
            // console.log('onInput: ' + this.textArea.getValue());
            if (_this.textareaIsShownAtCursor) {
                // console.log('::ignoring input event because the textarea is shown at cursor: ' + this.textArea.getValue());
                return;
            }
            readFromTextArea();
        }));
        // --- Clipboard operations
        _this._register(_this.textArea.onCut(function (e) {
            // Ensure we have the latest selection => ask all pending events to be sent
            _this.flushAnyAccumulatedEvents();
            _this._ensureClipboardGetsEditorSelection(e);
            _this.asyncTriggerCut.schedule();
        }));
        _this._register(_this.textArea.onCopy(function (e) {
            // Ensure we have the latest selection => ask all pending events to be sent
            _this.flushAnyAccumulatedEvents();
            _this._ensureClipboardGetsEditorSelection(e);
        }));
        _this._register(_this.textArea.onPaste(function (e) {
            if (e.canUseTextData()) {
                _this.executePaste(e.getTextData());
            }
            else {
                if (_this.textArea.getSelectionStart() !== _this.textArea.getSelectionEnd()) {
                    // Clean up the textarea, to get a clean paste
                    _this.setTextAreaState('paste', _this.textAreaState.toEmpty(), false);
                }
                _this._nextCommand = 1 /* Paste */;
            }
        }));
        _this._writePlaceholderAndSelectTextArea('ctor', false);
        return _this;
    }
    TextAreaHandler.prototype.dispose = function () {
        this.asyncTriggerCut.dispose();
        _super.prototype.dispose.call(this);
    };
    // --- begin event handlers
    TextAreaHandler.prototype.setStrategy = function (strategy) {
        this.textAreaState = this.textAreaState.toStrategy(strategy);
    };
    TextAreaHandler.prototype.setHasFocus = function (isFocused) {
        if (this.hasFocus === isFocused) {
            // no change
            return;
        }
        this.hasFocus = isFocused;
        if (this.hasFocus) {
            this._writePlaceholderAndSelectTextArea('focusgain', false);
        }
    };
    TextAreaHandler.prototype.setCursorSelections = function (primary, secondary) {
        this.selection = primary;
        this.selections = [primary].concat(secondary);
        this._writePlaceholderAndSelectTextArea('selection changed', false);
    };
    // --- end event handlers
    TextAreaHandler.prototype.setTextAreaState = function (reason, textAreaState, forceFocus) {
        if (!this.hasFocus) {
            textAreaState = textAreaState.resetSelection();
        }
        textAreaState.applyToTextArea(reason, this.textArea, this.hasFocus || forceFocus);
        this.textAreaState = textAreaState;
    };
    TextAreaHandler.prototype._onKeyDownHandler = function (e) {
        if (e.equals(9 /* Escape */)) {
            // Prevent default always for `Esc`, otherwise it will generate a keypress
            // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx
            e.preventDefault();
        }
        this._onKeyDown.fire(e);
    };
    TextAreaHandler.prototype._onKeyPressHandler = function (e) {
        if (!this.hasFocus) {
            // Sometimes, when doing Alt-Tab, in FF, a 'keypress' is sent before a 'focus'
            return;
        }
    };
    // ------------- Operations that are always executed asynchronously
    TextAreaHandler.prototype.executePaste = function (txt) {
        if (txt === '') {
            return;
        }
        var pasteOnNewLine = false;
        if (this.Browser.enableEmptySelectionClipboard) {
            pasteOnNewLine = (txt === this.lastCopiedValue && this.lastCopiedValueIsFromEmptySelection);
        }
        this._onPaste.fire({
            text: txt,
            pasteOnNewLine: pasteOnNewLine
        });
    };
    TextAreaHandler.prototype.focusTextArea = function () {
        this._writePlaceholderAndSelectTextArea('focusTextArea', true);
    };
    TextAreaHandler.prototype._writePlaceholderAndSelectTextArea = function (reason, forceFocus) {
        if (!this.textareaIsShownAtCursor) {
            // Do not write to the textarea if it is visible.
            if (this.Browser.isIPad) {
                // Do not place anything in the textarea for the iPad
                this.setTextAreaState(reason, this.textAreaState.toEmpty(), forceFocus);
            }
            else {
                this.setTextAreaState(reason, this.textAreaState.fromEditorSelection(this.model, this.selection), forceFocus);
            }
        }
    };
    // ------------- Clipboard operations
    TextAreaHandler.prototype._ensureClipboardGetsEditorSelection = function (e) {
        var whatToCopy = this.model.getPlainTextToCopy(this.selections, this.Browser.enableEmptySelectionClipboard);
        if (e.canUseTextData()) {
            var whatHTMLToCopy = null;
            if (!this.Browser.isEdgeOrIE && (whatToCopy.length < 65536 || exports.CopyOptions.forceCopyWithSyntaxHighlighting)) {
                whatHTMLToCopy = this.model.getHTMLToCopy(this.selections, this.Browser.enableEmptySelectionClipboard);
            }
            e.setTextData(whatToCopy, whatHTMLToCopy);
        }
        else {
            this.setTextAreaState('copy or cut', this.textAreaState.fromText(whatToCopy), false);
        }
        if (this.Browser.enableEmptySelectionClipboard) {
            if (this.Browser.isFirefox) {
                // When writing "LINE\r\n" to the clipboard and then pasting,
                // Firefox pastes "LINE\n", so let's work around this quirk
                this.lastCopiedValue = whatToCopy.replace(/\r\n/g, '\n');
            }
            else {
                this.lastCopiedValue = whatToCopy;
            }
            var selections = this.selections;
            this.lastCopiedValueIsFromEmptySelection = (selections.length === 1 && selections[0].isEmpty());
        }
    };
    return TextAreaHandler;
}(lifecycle_1.Disposable));
exports.TextAreaHandler = TextAreaHandler;
