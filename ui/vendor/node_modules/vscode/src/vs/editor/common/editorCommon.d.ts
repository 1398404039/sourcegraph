import { BulkListenerCallback } from 'vs/base/common/eventEmitter';
import { MarkedString } from 'vs/base/common/htmlContent';
import URI from 'vs/base/common/uri';
import { TPromise } from 'vs/base/common/winjs.base';
import { ServicesAccessor, IConstructorSignature1 } from 'vs/platform/instantiation/common/instantiation';
import { LanguageId, LanguageIdentifier, StandardTokenType } from 'vs/editor/common/modes';
import { LineTokens } from 'vs/editor/common/core/lineTokens';
import { ScrollbarVisibility } from 'vs/base/common/scrollable';
import { IDisposable } from 'vs/base/common/lifecycle';
import { Position } from 'vs/editor/common/core/position';
import { Range } from 'vs/editor/common/core/range';
import { Selection } from 'vs/editor/common/core/selection';
import { IndentRange } from 'vs/editor/common/model/indentRanges';
import { ICommandHandlerDescription } from 'vs/platform/commands/common/commands';
import { ContextKeyExpr, RawContextKey } from 'vs/platform/contextkey/common/contextkey';
import { FontInfo } from 'vs/editor/common/config/fontInfo';
import { ITextSource } from 'vs/editor/common/model/textSource';
/**
 * @internal
 */
export interface Event<T> {
    (listener: (e: T) => any, thisArg?: any): IDisposable;
}
/**
 * A position in the editor. This interface is suitable for serialization.
 */
export interface IPosition {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
}
/**
 * A range in the editor. This interface is suitable for serialization.
 */
export interface IRange {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
}
/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
export interface ISelection {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
}
/**
 * Configuration options for editor scrollbars
 */
export interface IEditorScrollbarOptions {
    /**
     * The size of arrows (if displayed).
     * Defaults to 11.
     */
    arrowSize?: number;
    /**
     * Render vertical scrollbar.
     * Accepted values: 'auto', 'visible', 'hidden'.
     * Defaults to 'auto'.
     */
    vertical?: string;
    /**
     * Render horizontal scrollbar.
     * Accepted values: 'auto', 'visible', 'hidden'.
     * Defaults to 'auto'.
     */
    horizontal?: string;
    /**
     * Cast horizontal and vertical shadows when the content is scrolled.
     * Defaults to true.
     */
    useShadows?: boolean;
    /**
     * Render arrows at the top and bottom of the vertical scrollbar.
     * Defaults to false.
     */
    verticalHasArrows?: boolean;
    /**
     * Render arrows at the left and right of the horizontal scrollbar.
     * Defaults to false.
     */
    horizontalHasArrows?: boolean;
    /**
     * Listen to mouse wheel events and react to them by scrolling.
     * Defaults to true.
     */
    handleMouseWheel?: boolean;
    /**
     * Height in pixels for the horizontal scrollbar.
     * Defaults to 10 (px).
     */
    horizontalScrollbarSize?: number;
    /**
     * Width in pixels for the vertical scrollbar.
     * Defaults to 10 (px).
     */
    verticalScrollbarSize?: number;
    /**
     * Width in pixels for the vertical slider.
     * Defaults to `verticalScrollbarSize`.
     */
    verticalSliderSize?: number;
    /**
     * Height in pixels for the horizontal slider.
     * Defaults to `horizontalScrollbarSize`.
     */
    horizontalSliderSize?: number;
}
/**
 * Configuration options for editor minimap
 */
export interface IEditorMinimapOptions {
    /**
     * Enable the rendering of the minimap.
     * Defaults to false.
     */
    enabled?: boolean;
    /**
     * Render the actual text on a line (as opposed to color blocks).
     * Defaults to true.
     */
    renderCharacters?: boolean;
    /**
     * Limit the width of the minimap to render at most a certain number of columns.
     * Defaults to 120.
     */
    maxColumn?: number;
}
/**
 * Describes how to indent wrapped lines.
 */
export declare enum WrappingIndent {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    None = 0,
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    Same = 1,
    /**
     * Indent => wrapped lines get +1 indentation as the parent.
     */
    Indent = 2,
}
export declare type LineNumbersOption = 'on' | 'off' | 'relative' | ((lineNumber: number) => string);
/**
 * Configuration options for the editor.
 */
export interface IEditorOptions {
    /**
     * Enable experimental screen reader support.
     * Defaults to `true`.
     */
    experimentalScreenReader?: boolean;
    /**
     * The aria label for the editor's textarea (when it is focused).
     */
    ariaLabel?: string;
    /**
     * Render vertical lines at the specified columns.
     * Defaults to empty array.
     */
    rulers?: number[];
    /**
     * A string containing the word separators used when doing word navigation.
     * Defaults to `~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?
     */
    wordSeparators?: string;
    /**
     * Enable Linux primary clipboard.
     * Defaults to true.
     */
    selectionClipboard?: boolean;
    /**
     * Control the rendering of line numbers.
     * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
     * Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
     * Otherwise, line numbers will not be rendered.
     * Defaults to true.
     */
    lineNumbers?: LineNumbersOption;
    /**
     * Should the corresponding line be selected when clicking on the line number?
     * Defaults to true.
     */
    selectOnLineNumbers?: boolean;
    /**
     * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
     * Defaults to 5.
     */
    lineNumbersMinChars?: number;
    /**
     * Enable the rendering of the glyph margin.
     * Defaults to true in vscode and to false in monaco-editor.
     */
    glyphMargin?: boolean;
    /**
     * The width reserved for line decorations (in px).
     * Line decorations are placed between line numbers and the editor content.
     * You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
     * Defaults to 10.
     */
    lineDecorationsWidth?: number | string;
    /**
     * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
     * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
     * Defaults to 30 (px).
     */
    revealHorizontalRightPadding?: number;
    /**
     * Render the editor selection with rounded borders.
     * Defaults to true.
     */
    roundedSelection?: boolean;
    /**
     * Theme to be used for rendering.
     * The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
     * You can create custom themes via `monaco.editor.defineTheme`.
     */
    theme?: string;
    /**
     * Should the editor be read only.
     * Defaults to false.
     */
    readOnly?: boolean;
    /**
     * Control the behavior and rendering of the scrollbars.
     */
    scrollbar?: IEditorScrollbarOptions;
    /**
     * Control the behavior and rendering of the minimap.
     */
    minimap?: IEditorMinimapOptions;
    /**
     * Display overflow widgets as `fixed`.
     * Defaults to `false`.
     */
    fixedOverflowWidgets?: boolean;
    /**
     * The number of vertical lanes the overview ruler should render.
     * Defaults to 2.
     */
    overviewRulerLanes?: number;
    /**
     * Controls if a border should be drawn around the overview ruler.
     * Defaults to `true`.
     */
    overviewRulerBorder?: boolean;
    /**
     * Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
     * Defaults to 'blink'.
     */
    cursorBlinking?: string;
    /**
     * Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
     * Defaults to false.
     */
    mouseWheelZoom?: boolean;
    /**
     * Control the mouse pointer style, either 'text' or 'default' or 'copy'
     * Defaults to 'text'
     * @internal
     */
    mouseStyle?: 'text' | 'default' | 'copy';
    /**
     * Control the cursor style, either 'block' or 'line'.
     * Defaults to 'line'.
     */
    cursorStyle?: string;
    /**
     * Enable font ligatures.
     * Defaults to false.
     */
    fontLigatures?: boolean;
    /**
     * Disable the use of `translate3d`.
     * Defaults to false.
     */
    disableTranslate3d?: boolean;
    /**
     * Disable the optimizations for monospace fonts.
     * Defaults to false.
     */
    disableMonospaceOptimizations?: boolean;
    /**
     * Should the cursor be hidden in the overview ruler.
     * Defaults to false.
     */
    hideCursorInOverviewRuler?: boolean;
    /**
     * Enable that scrolling can go one screen size after the last line.
     * Defaults to true.
     */
    scrollBeyondLastLine?: boolean;
    /**
     * Enable that the editor will install an interval to check if its container dom node size has changed.
     * Enabling this might have a severe performance impact.
     * Defaults to false.
     */
    automaticLayout?: boolean;
    /**
     * Control the wrapping of the editor.
     * When `wordWrap` = "off", the lines will never wrap.
     * When `wordWrap` = "on", the lines will wrap at the viewport width.
     * When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
     * When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
     * Defaults to "off".
     */
    wordWrap?: 'off' | 'on' | 'wordWrapColumn' | 'bounded';
    /**
     * Control the wrapping of the editor.
     * When `wordWrap` = "off", the lines will never wrap.
     * When `wordWrap` = "on", the lines will wrap at the viewport width.
     * When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
     * When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
     * Defaults to 80.
     */
    wordWrapColumn?: number;
    /**
     * Force word wrapping when the text appears to be of a minified/generated file.
     * Defaults to true.
     */
    wordWrapMinified?: boolean;
    /**
     * Control indentation of wrapped lines. Can be: 'none', 'same' or 'indent'.
     * Defaults to 'same' in vscode and to 'none' in monaco-editor.
     */
    wrappingIndent?: string;
    /**
     * Configure word wrapping characters. A break will be introduced before these characters.
     * Defaults to '{([+'.
     */
    wordWrapBreakBeforeCharacters?: string;
    /**
     * Configure word wrapping characters. A break will be introduced after these characters.
     * Defaults to ' \t})]?|&,;'.
     */
    wordWrapBreakAfterCharacters?: string;
    /**
     * Configure word wrapping characters. A break will be introduced after these characters only if no `wordWrapBreakBeforeCharacters` or `wordWrapBreakAfterCharacters` were found.
     * Defaults to '.'.
     */
    wordWrapBreakObtrusiveCharacters?: string;
    /**
     * Performance guard: Stop rendering a line after x characters.
     * Defaults to 10000.
     * Use -1 to never stop rendering
     */
    stopRenderingLineAfter?: number;
    /**
     * Enable hover.
     * Defaults to true.
     */
    hover?: boolean;
    /**
     * Enable custom contextmenu.
     * Defaults to true.
     */
    contextmenu?: boolean;
    /**
     * A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
     * Defaults to 1.
     */
    mouseWheelScrollSensitivity?: number;
    /**
     * Enable quick suggestions (shadow suggestions)
     * Defaults to true.
     */
    quickSuggestions?: boolean;
    /**
     * Quick suggestions show delay (in ms)
     * Defaults to 500 (ms)
     */
    quickSuggestionsDelay?: number;
    /**
     * Enables parameter hints
     */
    parameterHints?: boolean;
    /**
     * Render icons in suggestions box.
     * Defaults to true.
     */
    iconsInSuggestions?: boolean;
    /**
     * Enable auto closing brackets.
     * Defaults to true.
     */
    autoClosingBrackets?: boolean;
    /**
     * Enable format on type.
     * Defaults to false.
     */
    formatOnType?: boolean;
    /**
     * Enable format on paste.
     * Defaults to false.
     */
    formatOnPaste?: boolean;
    /**
     * Controls if the editor should allow to move selections via drag and drop.
     * Defaults to false.
     */
    dragAndDrop?: boolean;
    /**
     * Enable the suggestion box to pop-up on trigger characters.
     * Defaults to true.
     */
    suggestOnTriggerCharacters?: boolean;
    /**
     * Accept suggestions on ENTER.
     * Defaults to true.
     */
    acceptSuggestionOnEnter?: boolean;
    /**
     * Accept suggestions on provider defined characters.
     * Defaults to true.
     */
    acceptSuggestionOnCommitCharacter?: boolean;
    /**
     * Enable snippet suggestions. Default to 'true'.
     */
    snippetSuggestions?: 'top' | 'bottom' | 'inline' | 'none';
    /**
     * Copying without a selection copies the current line.
     */
    emptySelectionClipboard?: boolean;
    /**
     * Enable word based suggestions. Defaults to 'true'
     */
    wordBasedSuggestions?: boolean | {
        strings?: boolean;
        comments?: boolean;
        default?: boolean;
    };
    /**
     * The font size for the suggest widget.
     * Defaults to the editor font size.
     */
    suggestFontSize?: number;
    /**
     * The line height for the suggest widget.
     * Defaults to the editor line height.
     */
    suggestLineHeight?: number;
    /**
     * Enable selection highlight.
     * Defaults to true.
     */
    selectionHighlight?: boolean;
    /**
     * Enable semantic occurrences highlight.
     * Defaults to true.
     */
    occurrencesHighlight?: boolean;
    /**
     * Show code lens
     * Defaults to true.
     */
    codeLens?: boolean;
    /**
     * @deprecated - use codeLens instead
     * @internal
     */
    referenceInfos?: boolean;
    /**
     * Enable code folding
     * Defaults to true in vscode and to false in monaco-editor.
     */
    folding?: boolean;
    /**
     * Enable highlighting of matching brackets.
     * Defaults to true.
     */
    matchBrackets?: boolean;
    /**
     * Enable rendering of whitespace.
     * Defaults to none.
     */
    renderWhitespace?: 'none' | 'boundary' | 'all';
    /**
     * Enable rendering of control characters.
     * Defaults to false.
     */
    renderControlCharacters?: boolean;
    /**
     * Enable rendering of indent guides.
     * Defaults to false.
     */
    renderIndentGuides?: boolean;
    /**
     * Enable rendering of current line highlight.
     * Defaults to all.
     */
    renderLineHighlight?: 'none' | 'gutter' | 'line' | 'all';
    /**
     * Inserting and deleting whitespace follows tab stops.
     */
    useTabStops?: boolean;
    /**
     * The font family
     */
    fontFamily?: string;
    /**
     * The font weight
     */
    fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | 'initial' | 'inherit' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';
    /**
     * The font size
     */
    fontSize?: number;
    /**
     * The line height
     */
    lineHeight?: number;
}
/**
 * Configuration options for the diff editor.
 */
export interface IDiffEditorOptions extends IEditorOptions {
    /**
     * Allow the user to resize the diff editor split view.
     * Defaults to true.
     */
    enableSplitViewResizing?: boolean;
    /**
     * Render the differences in two side-by-side editors.
     * Defaults to true.
     */
    renderSideBySide?: boolean;
    /**
     * Compute the diff by ignoring leading/trailing whitespace
     * Defaults to true.
     */
    ignoreTrimWhitespace?: boolean;
    /**
     * Render +/- indicators for added/deleted changes.
     * Defaults to true.
     */
    renderIndicators?: boolean;
    /**
     * Original model should be editable?
     * Defaults to false.
     */
    originalEditable?: boolean;
}
export declare class InternalEditorScrollbarOptions {
    readonly _internalEditorScrollbarOptionsBrand: void;
    readonly arrowSize: number;
    readonly vertical: ScrollbarVisibility;
    readonly horizontal: ScrollbarVisibility;
    readonly useShadows: boolean;
    readonly verticalHasArrows: boolean;
    readonly horizontalHasArrows: boolean;
    readonly handleMouseWheel: boolean;
    readonly horizontalScrollbarSize: number;
    readonly horizontalSliderSize: number;
    readonly verticalScrollbarSize: number;
    readonly verticalSliderSize: number;
    readonly mouseWheelScrollSensitivity: number;
    /**
     * @internal
     */
    constructor(source: {
        arrowSize: number;
        vertical: ScrollbarVisibility;
        horizontal: ScrollbarVisibility;
        useShadows: boolean;
        verticalHasArrows: boolean;
        horizontalHasArrows: boolean;
        handleMouseWheel: boolean;
        horizontalScrollbarSize: number;
        horizontalSliderSize: number;
        verticalScrollbarSize: number;
        verticalSliderSize: number;
        mouseWheelScrollSensitivity: number;
    });
    /**
     * @internal
     */
    equals(other: InternalEditorScrollbarOptions): boolean;
    /**
     * @internal
     */
    clone(): InternalEditorScrollbarOptions;
}
export declare class InternalEditorMinimapOptions {
    readonly _internalEditorMinimapOptionsBrand: void;
    readonly enabled: boolean;
    readonly renderCharacters: boolean;
    readonly maxColumn: number;
    /**
     * @internal
     */
    constructor(source: {
        enabled: boolean;
        renderCharacters: boolean;
        maxColumn: number;
    });
    /**
     * @internal
     */
    equals(other: InternalEditorMinimapOptions): boolean;
    /**
     * @internal
     */
    clone(): InternalEditorMinimapOptions;
}
export declare class EditorWrappingInfo {
    readonly _editorWrappingInfoBrand: void;
    readonly isViewportWrapping: boolean;
    readonly wrappingColumn: number;
    readonly wrappingIndent: WrappingIndent;
    readonly wordWrapBreakBeforeCharacters: string;
    readonly wordWrapBreakAfterCharacters: string;
    readonly wordWrapBreakObtrusiveCharacters: string;
    /**
     * @internal
     */
    constructor(source: {
        isViewportWrapping: boolean;
        wrappingColumn: number;
        wrappingIndent: WrappingIndent;
        wordWrapBreakBeforeCharacters: string;
        wordWrapBreakAfterCharacters: string;
        wordWrapBreakObtrusiveCharacters: string;
    });
    /**
     * @internal
     */
    equals(other: EditorWrappingInfo): boolean;
    /**
     * @internal
     */
    clone(): EditorWrappingInfo;
}
export declare class InternalEditorViewOptions {
    readonly _internalEditorViewOptionsBrand: void;
    readonly theme: string;
    readonly canUseTranslate3d: boolean;
    readonly disableMonospaceOptimizations: boolean;
    readonly experimentalScreenReader: boolean;
    readonly rulers: number[];
    readonly ariaLabel: string;
    readonly renderLineNumbers: boolean;
    readonly renderCustomLineNumbers: (lineNumber: number) => string;
    readonly renderRelativeLineNumbers: boolean;
    readonly selectOnLineNumbers: boolean;
    readonly glyphMargin: boolean;
    readonly revealHorizontalRightPadding: number;
    readonly roundedSelection: boolean;
    readonly overviewRulerLanes: number;
    readonly overviewRulerBorder: boolean;
    readonly cursorBlinking: TextEditorCursorBlinkingStyle;
    readonly mouseWheelZoom: boolean;
    readonly cursorStyle: TextEditorCursorStyle;
    readonly hideCursorInOverviewRuler: boolean;
    readonly scrollBeyondLastLine: boolean;
    readonly editorClassName: string;
    readonly stopRenderingLineAfter: number;
    readonly renderWhitespace: 'none' | 'boundary' | 'all';
    readonly renderControlCharacters: boolean;
    readonly renderIndentGuides: boolean;
    readonly renderLineHighlight: 'none' | 'gutter' | 'line' | 'all';
    readonly scrollbar: InternalEditorScrollbarOptions;
    readonly minimap: InternalEditorMinimapOptions;
    readonly fixedOverflowWidgets: boolean;
    /**
     * @internal
     */
    constructor(source: {
        theme: string;
        canUseTranslate3d: boolean;
        disableMonospaceOptimizations: boolean;
        experimentalScreenReader: boolean;
        rulers: number[];
        ariaLabel: string;
        renderLineNumbers: boolean;
        renderCustomLineNumbers: (lineNumber: number) => string;
        renderRelativeLineNumbers: boolean;
        selectOnLineNumbers: boolean;
        glyphMargin: boolean;
        revealHorizontalRightPadding: number;
        roundedSelection: boolean;
        overviewRulerLanes: number;
        overviewRulerBorder: boolean;
        cursorBlinking: TextEditorCursorBlinkingStyle;
        mouseWheelZoom: boolean;
        cursorStyle: TextEditorCursorStyle;
        hideCursorInOverviewRuler: boolean;
        scrollBeyondLastLine: boolean;
        editorClassName: string;
        stopRenderingLineAfter: number;
        renderWhitespace: 'none' | 'boundary' | 'all';
        renderControlCharacters: boolean;
        renderIndentGuides: boolean;
        renderLineHighlight: 'none' | 'gutter' | 'line' | 'all';
        scrollbar: InternalEditorScrollbarOptions;
        minimap: InternalEditorMinimapOptions;
        fixedOverflowWidgets: boolean;
    });
    private static _toSortedIntegerArray(source);
    private static _numberArraysEqual(a, b);
    /**
     * @internal
     */
    equals(other: InternalEditorViewOptions): boolean;
    /**
     * @internal
     */
    createChangeEvent(newOpts: InternalEditorViewOptions): IViewConfigurationChangedEvent;
    /**
     * @internal
     */
    clone(): InternalEditorViewOptions;
}
export interface IViewConfigurationChangedEvent {
    readonly theme: boolean;
    readonly canUseTranslate3d: boolean;
    readonly disableMonospaceOptimizations: boolean;
    readonly experimentalScreenReader: boolean;
    readonly rulers: boolean;
    readonly ariaLabel: boolean;
    readonly renderLineNumbers: boolean;
    readonly renderCustomLineNumbers: boolean;
    readonly renderRelativeLineNumbers: boolean;
    readonly selectOnLineNumbers: boolean;
    readonly glyphMargin: boolean;
    readonly revealHorizontalRightPadding: boolean;
    readonly roundedSelection: boolean;
    readonly overviewRulerLanes: boolean;
    readonly overviewRulerBorder: boolean;
    readonly cursorBlinking: boolean;
    readonly mouseWheelZoom: boolean;
    readonly cursorStyle: boolean;
    readonly hideCursorInOverviewRuler: boolean;
    readonly scrollBeyondLastLine: boolean;
    readonly editorClassName: boolean;
    readonly stopRenderingLineAfter: boolean;
    readonly renderWhitespace: boolean;
    readonly renderControlCharacters: boolean;
    readonly renderIndentGuides: boolean;
    readonly renderLineHighlight: boolean;
    readonly scrollbar: boolean;
    readonly minimap: boolean;
    readonly fixedOverflowWidgets: boolean;
}
export declare class EditorContribOptions {
    readonly selectionClipboard: boolean;
    readonly hover: boolean;
    readonly contextmenu: boolean;
    readonly quickSuggestions: boolean;
    readonly quickSuggestionsDelay: number;
    readonly parameterHints: boolean;
    readonly iconsInSuggestions: boolean;
    readonly formatOnType: boolean;
    readonly formatOnPaste: boolean;
    readonly suggestOnTriggerCharacters: boolean;
    readonly acceptSuggestionOnEnter: boolean;
    readonly acceptSuggestionOnCommitCharacter: boolean;
    readonly snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
    readonly emptySelectionClipboard: boolean;
    readonly wordBasedSuggestions: boolean | {
        strings?: boolean;
        comments?: boolean;
        default?: boolean;
    };
    readonly suggestFontSize: number;
    readonly suggestLineHeight: number;
    readonly selectionHighlight: boolean;
    readonly occurrencesHighlight: boolean;
    readonly codeLens: boolean;
    readonly folding: boolean;
    readonly matchBrackets: boolean;
    /**
     * @internal
     */
    constructor(source: {
        selectionClipboard: boolean;
        hover: boolean;
        contextmenu: boolean;
        quickSuggestions: boolean;
        quickSuggestionsDelay: number;
        parameterHints: boolean;
        iconsInSuggestions: boolean;
        formatOnType: boolean;
        formatOnPaste: boolean;
        suggestOnTriggerCharacters: boolean;
        acceptSuggestionOnEnter: boolean;
        acceptSuggestionOnCommitCharacter: boolean;
        snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
        emptySelectionClipboard: boolean;
        wordBasedSuggestions: boolean | {
            strings?: boolean;
            comments?: boolean;
            default?: boolean;
        };
        suggestFontSize: number;
        suggestLineHeight: number;
        selectionHighlight: boolean;
        occurrencesHighlight: boolean;
        codeLens: boolean;
        folding: boolean;
        matchBrackets: boolean;
    });
    /**
     * @internal
     */
    equals(other: EditorContribOptions): boolean;
    /**
     * @internal
     */
    clone(): EditorContribOptions;
}
/**
 * Internal configuration options (transformed or computed) for the editor.
 */
export declare class InternalEditorOptions {
    readonly _internalEditorOptionsBrand: void;
    readonly lineHeight: number;
    readonly readOnly: boolean;
    readonly wordSeparators: string;
    readonly autoClosingBrackets: boolean;
    readonly useTabStops: boolean;
    readonly tabFocusMode: boolean;
    readonly dragAndDrop: boolean;
    readonly layoutInfo: EditorLayoutInfo;
    readonly fontInfo: FontInfo;
    readonly viewInfo: InternalEditorViewOptions;
    readonly wrappingInfo: EditorWrappingInfo;
    readonly contribInfo: EditorContribOptions;
    /**
     * @internal
     */
    constructor(source: {
        lineHeight: number;
        readOnly: boolean;
        wordSeparators: string;
        autoClosingBrackets: boolean;
        useTabStops: boolean;
        tabFocusMode: boolean;
        dragAndDrop: boolean;
        layoutInfo: EditorLayoutInfo;
        fontInfo: FontInfo;
        viewInfo: InternalEditorViewOptions;
        wrappingInfo: EditorWrappingInfo;
        contribInfo: EditorContribOptions;
    });
    /**
     * @internal
     */
    equals(other: InternalEditorOptions): boolean;
    /**
     * @internal
     */
    createChangeEvent(newOpts: InternalEditorOptions): IConfigurationChangedEvent;
    /**
     * @internal
     */
    clone(): InternalEditorOptions;
}
/**
 * An event describing that the configuration of the editor has changed.
 */
export interface IConfigurationChangedEvent {
    readonly lineHeight: boolean;
    readonly readOnly: boolean;
    readonly wordSeparators: boolean;
    readonly autoClosingBrackets: boolean;
    readonly useTabStops: boolean;
    readonly tabFocusMode: boolean;
    readonly dragAndDrop: boolean;
    readonly layoutInfo: boolean;
    readonly fontInfo: boolean;
    readonly viewInfo: IViewConfigurationChangedEvent;
    readonly wrappingInfo: boolean;
    readonly contribInfo: boolean;
}
/**
 * Vertical Lane in the overview ruler of the editor.
 */
export declare enum OverviewRulerLane {
    Left = 1,
    Center = 2,
    Right = 4,
    Full = 7,
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
export interface IModelDecorationOverviewRulerOptions {
    /**
     * CSS color to render in the overview ruler.
     * e.g.: rgba(100, 100, 100, 0.5)
     */
    color: string;
    /**
     * CSS color to render in the overview ruler.
     * e.g.: rgba(100, 100, 100, 0.5)
     */
    darkColor: string;
    /**
     * The position in the overview ruler.
     */
    position: OverviewRulerLane;
}
/**
 * Options for a model decoration.
 */
export interface IModelDecorationOptions {
    /**
     * Customize the growing behaviour of the decoration when typing at the edges of the decoration.
     * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    stickiness?: TrackedRangeStickiness;
    /**
     * CSS class name describing the decoration.
     */
    className?: string;
    /**
     * Message to be rendered when hovering over the glyph margin decoration.
     */
    glyphMarginHoverMessage?: MarkedString | MarkedString[];
    /**
     * Array of MarkedString to render as the decoration message.
     */
    hoverMessage?: MarkedString | MarkedString[];
    /**
     * Should the decoration expand to encompass a whole line.
     */
    isWholeLine?: boolean;
    /**
     * @deprecated : Use `overviewRuler` instead
     */
    showInOverviewRuler?: string;
    /**
     * If set, render this decoration in the overview ruler.
     */
    overviewRuler?: IModelDecorationOverviewRulerOptions;
    /**
     * If set, the decoration will be rendered in the glyph margin with this CSS class name.
     */
    glyphMarginClassName?: string;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name.
     */
    linesDecorationsClassName?: string;
    /**
     * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
     */
    marginClassName?: string;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     * Please use this only for CSS rules that must impact the text. For example, use `className`
     * to have a background color decoration.
     */
    inlineClassName?: string;
    /**
     * If set, the decoration will be rendered before the text with this CSS class name.
     */
    beforeContentClassName?: string;
    /**
     * If set, the decoration will be rendered after the text with this CSS class name.
     */
    afterContentClassName?: string;
}
/**
 * New model decorations.
 */
export interface IModelDeltaDecoration {
    /**
     * Range that this decoration covers.
     */
    range: IRange;
    /**
     * Options associated with this decoration.
     */
    options: IModelDecorationOptions;
}
/**
 * A decoration in the model.
 */
export interface IModelDecoration {
    /**
     * Identifier for a decoration.
     */
    readonly id: string;
    /**
     * Identifier for a decoration's owener.
     */
    readonly ownerId: number;
    /**
     * Range that this decoration covers.
     */
    readonly range: Range;
    /**
     * Options associated with this decoration.
     */
    readonly options: IModelDecorationOptions;
    /**
     * A flag describing if this is a problem decoration (e.g. warning/error).
     */
    readonly isForValidation: boolean;
}
/**
 * An accessor that can add, change or remove model decorations.
 * @internal
 */
export interface IModelDecorationsChangeAccessor {
    /**
     * Add a new decoration.
     * @param range Range that this decoration covers.
     * @param options Options associated with this decoration.
     * @return An unique identifier associated with this decoration.
     */
    addDecoration(range: IRange, options: IModelDecorationOptions): string;
    /**
     * Change the range that an existing decoration covers.
     * @param id The unique identifier associated with the decoration.
     * @param newRange The new range that this decoration covers.
     */
    changeDecoration(id: string, newRange: IRange): void;
    /**
     * Change the options associated with an existing decoration.
     * @param id The unique identifier associated with the decoration.
     * @param newOptions The new options associated with this decoration.
     */
    changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
    /**
     * Remove an existing decoration.
     * @param id The unique identifier associated with the decoration.
     */
    removeDecoration(id: string): void;
    /**
     * Perform a minimum ammount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
}
/**
 * Word inside a model.
 */
export interface IWordAtPosition {
    /**
     * The word.
     */
    readonly word: string;
    /**
     * The column where the word starts.
     */
    readonly startColumn: number;
    /**
     * The column where the word ends.
     */
    readonly endColumn: number;
}
/**
 * Range of a word inside a model.
 * @internal
 */
export interface IWordRange {
    /**
     * The index where the word starts.
     */
    readonly start: number;
    /**
     * The index where the word ends.
     */
    readonly end: number;
}
/**
 * @internal
 */
export interface ITokenInfo {
    readonly type: StandardTokenType;
    readonly lineNumber: number;
    readonly startColumn: number;
    readonly endColumn: number;
}
/**
 * @internal
 */
export interface ITokenIterator {
    hasNext(): boolean;
    next(): ITokenInfo;
    hasPrev(): boolean;
    prev(): ITokenInfo;
}
/**
 * End of line character preference.
 */
export declare enum EndOfLinePreference {
    /**
     * Use the end of line character identified in the text buffer.
     */
    TextDefined = 0,
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2,
}
/**
 * The default end of line to use when instantiating models.
 */
export declare enum DefaultEndOfLine {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2,
}
/**
 * End of line character preference.
 */
export declare enum EndOfLineSequence {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 0,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 1,
}
/**
 * An identifier for a single edit operation.
 */
export interface ISingleEditOperationIdentifier {
    /**
     * Identifier major
     */
    major: number;
    /**
     * Identifier minor
     */
    minor: number;
}
/**
 * A builder and helper for edit operations for a command.
 */
export interface IEditOperationBuilder {
    /**
     * Add a new edit operation (a replace operation).
     * @param range The range to replace (delete). May be empty to represent a simple insert.
     * @param text The text to replace with. May be null to represent a simple delete.
     */
    addEditOperation(range: Range, text: string): void;
    /**
     * Track `selection` when applying edit operations.
     * A best effort will be made to not grow/expand the selection.
     * An empty selection will clamp to a nearby character.
     * @param selection The selection to track.
     * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
     *           should clamp to the previous or the next character.
     * @return A unique identifer.
     */
    trackSelection(selection: Selection, trackPreviousOnEmpty?: boolean): string;
}
/**
 * A helper for computing cursor state after a command.
 */
export interface ICursorStateComputerData {
    /**
     * Get the inverse edit operations of the added edit operations.
     */
    getInverseEditOperations(): IIdentifiedSingleEditOperation[];
    /**
     * Get a previously tracked selection.
     * @param id The unique identifier returned by `trackSelection`.
     * @return The selection.
     */
    getTrackedSelection(id: string): Selection;
}
/**
 * A command that modifies text / cursor state on a model.
 */
export interface ICommand {
    /**
     * Get the edit operations needed to execute this command.
     * @param model The model the command will execute on.
     * @param builder A helper to collect the needed edit operations and to track selections.
     */
    getEditOperations(model: ITokenizedModel, builder: IEditOperationBuilder): void;
    /**
     * Compute the cursor state after the edit operations were applied.
     * @param model The model the commad has executed on.
     * @param helper A helper to get inverse edit operations and to get previously tracked selections.
     * @return The cursor state after the command executed.
     */
    computeCursorState(model: ITokenizedModel, helper: ICursorStateComputerData): Selection;
}
/**
 * A single edit operation, that acts as a simple replace.
 * i.e. Replace text at `range` with `text` in model.
 */
export interface ISingleEditOperation {
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: IRange;
    /**
     * The text to replace with. This can be null to emulate a simple delete.
     */
    text: string;
    /**
     * This indicates that this operation has "insert" semantics.
     * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
     */
    forceMoveMarkers?: boolean;
}
/**
 * A single edit operation, that has an identifier.
 */
export interface IIdentifiedSingleEditOperation {
    /**
     * An identifier associated with this single edit operation.
     */
    identifier: ISingleEditOperationIdentifier;
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: Range;
    /**
     * The text to replace with. This can be null to emulate a simple delete.
     */
    text: string;
    /**
     * This indicates that this operation has "insert" semantics.
     * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
     */
    forceMoveMarkers: boolean;
    /**
     * This indicates that this operation is inserting automatic whitespace
     * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
     */
    isAutoWhitespaceEdit?: boolean;
}
/**
 * A callback that can compute the cursor state after applying a series of edit operations.
 */
export interface ICursorStateComputer {
    /**
     * A callback that can compute the resulting cursors state after some edit operations have been executed.
     */
    (inverseEditOperations: IIdentifiedSingleEditOperation[]): Selection[];
}
export declare class TextModelResolvedOptions {
    _textModelResolvedOptionsBrand: void;
    readonly tabSize: number;
    readonly insertSpaces: boolean;
    readonly defaultEOL: DefaultEndOfLine;
    readonly trimAutoWhitespace: boolean;
    /**
     * @internal
     */
    constructor(src: {
        tabSize: number;
        insertSpaces: boolean;
        defaultEOL: DefaultEndOfLine;
        trimAutoWhitespace: boolean;
    });
    /**
     * @internal
     */
    equals(other: TextModelResolvedOptions): boolean;
    /**
     * @internal
     */
    createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent;
}
/**
 * @internal
 */
export interface ITextModelCreationOptions {
    tabSize: number;
    insertSpaces: boolean;
    detectIndentation: boolean;
    trimAutoWhitespace: boolean;
    defaultEOL: DefaultEndOfLine;
}
export interface ITextModelUpdateOptions {
    tabSize?: number;
    insertSpaces?: boolean;
    trimAutoWhitespace?: boolean;
}
export interface IModelOptionsChangedEvent {
    readonly tabSize: boolean;
    readonly insertSpaces: boolean;
    readonly trimAutoWhitespace: boolean;
}
/**
 * A textual read-only model.
 */
export interface ITextModel {
    /**
     * @internal
     */
    mightContainRTL(): boolean;
    /**
     * @internal
     */
    mightContainNonBasicASCII(): boolean;
    getOptions(): TextModelResolvedOptions;
    /**
     * Get the current version id of the model.
     * Anytime a change happens to the model (even undo/redo),
     * the version id is incremented.
     */
    getVersionId(): number;
    /**
     * Get the alternative version id of the model.
     * This alternative version id is not always incremented,
     * it will return the same values in the case of undo-redo.
     */
    getAlternativeVersionId(): number;
    /**
     * Replace the entire text buffer value contained in this model.
     */
    setValue(newValue: string): void;
    /**
     * Replace the entire text buffer value contained in this model.
     * @internal
     */
    setValueFromTextSource(newValue: ITextSource): void;
    /**
     * Get the text stored in this model.
     * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
     * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
     * @return The text.
     */
    getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
    /**
     * Get the length of the text stored in this model.
     */
    getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
    /**
     * Check if the raw text stored in this model equals another raw text.
     * @internal
     */
    equals(other: ITextSource): boolean;
    /**
     * Get the text in a certain range.
     * @param range The range describing what text to get.
     * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
     * @return The text.
     */
    getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
    /**
     * Get the length of text in a certain range.
     * @param range The range describing what text length to get.
     * @return The text length.
     */
    getValueLengthInRange(range: IRange): number;
    /**
     * Splits characters in two buckets. First bucket (A) is of characters that
     * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of
     * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.
     * If count(B) > count(A) return true. Returns false otherwise.
     * @internal
     */
    isDominatedByLongLines(): boolean;
    /**
     * Get the number of lines in the model.
     */
    getLineCount(): number;
    /**
     * Get the text for a certain line.
     */
    getLineContent(lineNumber: number): string;
    /**
     * @internal
     */
    getIndentLevel(lineNumber: number): number;
    /**
     * @internal
     */
    getIndentRanges(): IndentRange[];
    /**
     * @internal
     */
    getLineIndentGuide(lineNumber: number): number;
    /**
     * Get the text for all lines.
     */
    getLinesContent(): string[];
    /**
     * Get the end of line sequence predominantly used in the text buffer.
     * @return EOL char sequence (e.g.: '\n' or '\r\n').
     */
    getEOL(): string;
    /**
     * Change the end of line sequence used in the text buffer.
     */
    setEOL(eol: EndOfLineSequence): void;
    /**
     * Get the minimum legal column for line at `lineNumber`
     */
    getLineMinColumn(lineNumber: number): number;
    /**
     * Get the maximum legal column for line at `lineNumber`
     */
    getLineMaxColumn(lineNumber: number): number;
    /**
     * Returns the column before the first non whitespace character for line at `lineNumber`.
     * Returns 0 if line is empty or contains only whitespace.
     */
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    /**
     * Returns the column after the last non whitespace character for line at `lineNumber`.
     * Returns 0 if line is empty or contains only whitespace.
     */
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    /**
     * Create a valid position,
     */
    validatePosition(position: IPosition): Position;
    /**
     * Advances the given position by the given offest (negative offsets are also accepted)
     * and returns it as a new valid position.
     *
     * If the offset and position are such that their combination goes beyond the beginning or
     * end of the model, throws an exception.
     *
     * If the ofsset is such that the new position would be in the middle of a multi-byte
     * line terminator, throws an exception.
     */
    modifyPosition(position: IPosition, offset: number): Position;
    /**
     * Create a valid range.
     */
    validateRange(range: IRange): Range;
    /**
     * Converts the position to a zero-based offset.
     *
     * The position will be [adjusted](#TextDocument.validatePosition).
     *
     * @param position A position.
     * @return A valid zero-based offset.
     */
    getOffsetAt(position: IPosition): number;
    /**
     * Converts a zero-based offset to a position.
     *
     * @param offset A zero-based offset.
     * @return A valid [position](#Position).
     */
    getPositionAt(offset: number): Position;
    /**
     * Get a range covering the entire model
     */
    getFullModelRange(): Range;
    /**
     * Returns iff the model was disposed or not.
     */
    isDisposed(): boolean;
    /**
     * No mode supports allowed on this model because it is simply too large.
     * (even tokenization would cause too much memory pressure)
     * @internal
     */
    isTooLargeForHavingAMode(): boolean;
    /**
     * Only basic mode supports allowed on this model because it is simply too large.
     * (tokenization is allowed and other basic supports)
     * @internal
     */
    isTooLargeForHavingARichMode(): boolean;
    /**
     * Search the model.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wholeWord Force the matching to match entire words only.
     * @param captureMatches The result will contain the captured groups.
     * @param limitResultCount Limit the number of results
     * @return The ranges where the matches are. It is empty if not matches have been found.
     */
    findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
    /**
     * Search the model.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchScope Limit the searching to only search inside this range.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wholeWord Force the matching to match entire words only.
     * @param captureMatches The result will contain the captured groups.
     * @param limitResultCount Limit the number of results
     * @return The ranges where the matches are. It is empty if no matches have been found.
     */
    findMatches(searchString: string, searchScope: IRange, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
    /**
     * Search the model for the next match. Loops to the beginning of the model if needed.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchStart Start the searching at the specified position.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wholeWord Force the matching to match entire words only.
     * @param captureMatches The result will contain the captured groups.
     * @return The range where the next match is. It is null if no next match has been found.
     */
    findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
    /**
     * Search the model for the previous match. Loops to the end of the model if needed.
     * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
     * @param searchStart Start the searching at the specified position.
     * @param isRegex Used to indicate that `searchString` is a regular expression.
     * @param matchCase Force the matching to match lower/upper case exactly.
     * @param wholeWord Force the matching to match entire words only.
     * @param captureMatches The result will contain the captured groups.
     * @return The range where the previous match is. It is null if no previous match has been found.
     */
    findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
}
export declare class FindMatch {
    _findMatchBrand: void;
    readonly range: Range;
    readonly matches: string[];
    /**
     * @internal
     */
    constructor(range: Range, matches: string[]);
}
export interface IReadOnlyModel extends ITextModel {
    /**
     * Gets the resource associated with this editor model.
     */
    readonly uri: URI;
    /**
     * Get the language associated with this model.
     * @internal
     */
    getLanguageIdentifier(): LanguageIdentifier;
    /**
     * Get the language associated with this model.
     */
    getModeId(): string;
    /**
     * Get the word under or besides `position`.
     * @param position The position to look for a word.
     * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
     * @return The word under or besides `position`. Might be null.
     */
    getWordAtPosition(position: IPosition): IWordAtPosition;
    /**
     * Get the word under or besides `position` trimmed to `position`.column
     * @param position The position to look for a word.
     * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
     * @return The word under or besides `position`. Will never be null.
     */
    getWordUntilPosition(position: IPosition): IWordAtPosition;
}
/**
 * @internal
 */
export interface IFoundBracket {
    range: Range;
    open: string;
    close: string;
    isOpen: boolean;
}
/**
 * A model that is tokenized.
 */
export interface ITokenizedModel extends ITextModel {
    /**
     * Force tokenization information for `lineNumber` to be accurate.
     * @internal
     */
    forceTokenization(lineNumber: number): void;
    /**
     * Get the tokens for the line `lineNumber`.
     * The tokens might be inaccurate. Use `forceTokenization` to ensure accurate tokens.
     * @internal
     */
    getLineTokens(lineNumber: number): LineTokens;
    /**
     * Get the language associated with this model.
     * @internal
     */
    getLanguageIdentifier(): LanguageIdentifier;
    /**
     * Get the language associated with this model.
     */
    getModeId(): string;
    /**
     * Set the current language mode associated with the model.
     * @internal
     */
    setMode(languageIdentifier: LanguageIdentifier): void;
    /**
     * Returns the real (inner-most) language mode at a given position.
     * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.
     * @internal
     */
    getLanguageIdAtPosition(lineNumber: number, column: number): LanguageId;
    /**
     * Get the word under or besides `position`.
     * @param position The position to look for a word.
     * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
     * @return The word under or besides `position`. Might be null.
     */
    getWordAtPosition(position: IPosition): IWordAtPosition;
    /**
     * Get the word under or besides `position` trimmed to `position`.column
     * @param position The position to look for a word.
     * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
     * @return The word under or besides `position`. Will never be null.
     */
    getWordUntilPosition(position: IPosition): IWordAtPosition;
    /**
     * Returns an iterator that can be used to read
     * next and previous tokens from the provided position.
     * The iterator is made available through the callback
     * function and can't be used afterwards.
     * @internal
     */
    tokenIterator(position: IPosition, callback: (it: ITokenIterator) => any): any;
    /**
     * Find the matching bracket of `request` up, counting brackets.
     * @param request The bracket we're searching for
     * @param position The position at which to start the search.
     * @return The range of the matching bracket, or null if the bracket match was not found.
     * @internal
     */
    findMatchingBracketUp(bracket: string, position: IPosition): Range;
    /**
     * Given a `position`, if the position is on top or near a bracket,
     * find the matching bracket of that bracket and return the ranges of both brackets.
     * @param position The position at which to look for a bracket.
     * @internal
     */
    matchBracket(position: IPosition): [Range, Range];
}
/**
 * A model that can track markers.
 */
export interface ITextModelWithMarkers extends ITextModel {
    /**
     * @internal
     */
    _addMarker(internalDecorationId: number, lineNumber: number, column: number, stickToPreviousCharacter: boolean): string;
    /**
     * @internal
     */
    _changeMarker(id: string, newLineNumber: number, newColumn: number): void;
    /**
     * @internal
     */
    _changeMarkerStickiness(id: string, newStickToPreviousCharacter: boolean): void;
    /**
     * @internal
     */
    _getMarker(id: string): Position;
    /**
     * @internal
     */
    _removeMarker(id: string): void;
}
/**
 * Describes the behaviour of decorations when typing/editing near their edges.
 */
export declare enum TrackedRangeStickiness {
    AlwaysGrowsWhenTypingAtEdges = 0,
    NeverGrowsWhenTypingAtEdges = 1,
    GrowsOnlyWhenTypingBefore = 2,
    GrowsOnlyWhenTypingAfter = 3,
}
/**
 * A model that can have decorations.
 */
export interface ITextModelWithDecorations {
    /**
     * Change the decorations. The callback will be called with a change accessor
     * that becomes invalid as soon as the callback finishes executing.
     * This allows for all events to be queued up until the change
     * is completed. Returns whatever the callback returns.
     * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
     * @internal
     */
    changeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T;
    /**
     * Perform a minimum ammount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
    /**
     * Remove all decorations that have been added with this specific ownerId.
     * @param ownerId The owner id to search for.
     * @internal
     */
    removeAllDecorationsWithOwnerId(ownerId: number): void;
    /**
     * Get the options associated with a decoration.
     * @param id The decoration id.
     * @return The decoration options or null if the decoration was not found.
     */
    getDecorationOptions(id: string): IModelDecorationOptions;
    /**
     * Get the range associated with a decoration.
     * @param id The decoration id.
     * @return The decoration range or null if the decoration was not found.
     */
    getDecorationRange(id: string): Range;
    /**
     * Gets all the decorations for the line `lineNumber` as an array.
     * @param lineNumber The line number
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
     * @param startLineNumber The start line number
     * @param endLineNumber The end line number
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
     * So for now it returns all the decorations on the same line as `range`.
     * @param range The range to search in
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     * @return An array with the decorations
     */
    getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
    /**
     * Gets all the decorations as an array.
     * @param ownerId If set, it will ignore decorations belonging to other owners.
     * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
     */
    getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
}
/**
 * An editable text model.
 */
export interface IEditableTextModel extends ITextModelWithMarkers {
    /**
     * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
     */
    normalizeIndentation(str: string): string;
    /**
     * Get what is considered to be one indent (e.g. a tab character or 4 spaces, etc.).
     */
    getOneIndent(): string;
    /**
     * Change the options of this model.
     */
    updateOptions(newOpts: ITextModelUpdateOptions): void;
    /**
     * Detect the indentation options for this model from its content.
     */
    detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
    /**
     * Push a stack element onto the undo stack. This acts as an undo/redo point.
     * The idea is to use `pushEditOperations` to edit the model and then to
     * `pushStackElement` to create an undo/redo stop point.
     */
    pushStackElement(): void;
    /**
     * Push edit operations, basically editing the model. This is the preferred way
     * of editing the model. The edit operations will land on the undo stack.
     * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.
     * @param editOperations The edit operations.
     * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
     * @return The cursor state returned by the `cursorStateComputer`.
     */
    pushEditOperations(beforeCursorState: Selection[], editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[];
    /**
     * Edit the model without adding the edits to the undo stack.
     * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
     * @param operations The edit operations.
     * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.
     */
    applyEdits(operations: IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];
    /**
     * Undo edit operations until the first previous stop point created by `pushStackElement`.
     * The inverse edit operations will be pushed on the redo stack.
     * @internal
     */
    undo(): Selection[];
    /**
     * Redo edit operations until the next stop point created by `pushStackElement`.
     * The inverse edit operations will be pushed on the undo stack.
     * @internal
     */
    redo(): Selection[];
    /**
     * Set an editable range on the model.
     * @internal
     */
    setEditableRange(range: IRange): void;
    /**
     * Check if the model has an editable range.
     * @internal
     */
    hasEditableRange(): boolean;
    /**
     * Get the editable range on the model.
     * @internal
     */
    getEditableRange(): Range;
}
/**
 * A model.
 */
export interface IModel extends IReadOnlyModel, IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithDecorations, IEditorModel {
    /**
     * @deprecated Please use `onDidChangeContent` instead.
     * An event emitted when the contents of the model have changed.
     * @internal
     * @event
     */
    onDidChangeRawContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the contents of the model have changed.
     * @event
     */
    onDidChangeContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
    /**
     * An event emitted when decorations of the model have changed.
     * @event
     */
    onDidChangeDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the model options have changed.
     * @event
     */
    onDidChangeOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the language associated with the model has changed.
     * @event
     */
    onDidChangeLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
    /**
     * An event emitted right before disposing the model.
     * @event
     */
    onWillDispose(listener: () => void): IDisposable;
    /**
     * @internal
     */
    addBulkListener(listener: BulkListenerCallback): IDisposable;
    /**
     * A unique identifier associated with this model.
     */
    readonly id: string;
    /**
     * Destroy this model. This will unbind the model from the mode
     * and make all necessary clean-up to release this object to the GC.
     * @internal
     */
    destroy(): void;
    /**
     * Destroy this model. This will unbind the model from the mode
     * and make all necessary clean-up to release this object to the GC.
     */
    dispose(): void;
    /**
     * @internal
     */
    onBeforeAttached(): void;
    /**
     * @internal
     */
    onBeforeDetached(): void;
    /**
     * Returns iff this model is attached to an editor or not.
     * @internal
     */
    isAttachedToEditor(): boolean;
}
/**
 * An event describing that the current mode associated with a model has changed.
 */
export interface IModelLanguageChangedEvent {
    /**
     * Previous language
     */
    readonly oldLanguage: string;
    /**
     * New language
     */
    readonly newLanguage: string;
}
/**
 * An event describing a change in the text of a model.
 */
export interface IModelContentChangedEvent2 {
    /**
     * The range that got replaced.
     */
    readonly range: IRange;
    /**
     * The length of the range that got replaced.
     */
    readonly rangeLength: number;
    /**
     * The new text for the range.
     */
    readonly text: string;
    /**
     * The (new) end-of-line character.
     */
    readonly eol: string;
    /**
     * The new version id the model has transitioned to.
     */
    versionId: number;
    /**
     * Flag that indicates that this event was generated while undoing.
     */
    readonly isUndoing: boolean;
    /**
     * Flag that indicates that this event was generated while redoing.
     */
    readonly isRedoing: boolean;
}
/**
 * An event describing a change in the text of a model.
 * @internal
 */
export interface IModelContentChangedEvent {
    /**
     * The event type. It can be used to detect the actual event type:
     * 		EditorCommon.EventType.ModelContentChangedFlush => IModelContentChangedFlushEvent
     * 		EditorCommon.EventType.ModelContentChangedLinesDeleted => IModelContentChangedLineChangedEvent
     * 		EditorCommon.EventType.ModelContentChangedLinesInserted => IModelContentChangedLinesDeletedEvent
     * 		EditorCommon.EventType.ModelContentChangedLineChanged => IModelContentChangedLinesInsertedEvent
     */
    readonly changeType: string;
    /**
     * The new version id the model has transitioned to.
     */
    versionId: number;
    /**
     * Flag that indicates that this event was generated while undoing.
     */
    readonly isUndoing: boolean;
    /**
     * Flag that indicates that this event was generated while redoing.
     */
    readonly isRedoing: boolean;
}
/**
 * An event describing that a model has been reset to a new value.
 * @internal
 */
export interface IModelContentChangedFlushEvent extends IModelContentChangedEvent {
}
/**
 * An event describing that a line has changed in a model.
 * @internal
 */
export interface IModelContentChangedLineChangedEvent extends IModelContentChangedEvent {
    /**
     * The line that has changed.
     */
    readonly lineNumber: number;
    /**
     * The new value of the line.
     */
    readonly detail: string;
}
/**
 * An event describing that line(s) have been deleted in a model.
 * @internal
 */
export interface IModelContentChangedLinesDeletedEvent extends IModelContentChangedEvent {
    /**
     * At what line the deletion began (inclusive).
     */
    readonly fromLineNumber: number;
    /**
     * At what line the deletion stopped (inclusive).
     */
    readonly toLineNumber: number;
}
/**
 * An event describing that line(s) have been inserted in a model.
 * @internal
 */
export interface IModelContentChangedLinesInsertedEvent extends IModelContentChangedEvent {
    /**
     * Before what line did the insertion begin
     */
    readonly fromLineNumber: number;
    /**
     * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
     */
    readonly toLineNumber: number;
    /**
     * The text that was inserted
     */
    readonly detail: string;
}
/**
 * An event describing that model decorations have changed.
 */
export interface IModelDecorationsChangedEvent {
    /**
     * Lists of ids for added decorations.
     */
    readonly addedDecorations: string[];
    /**
     * Lists of ids for changed decorations.
     */
    readonly changedDecorations: string[];
    /**
     * List of ids for removed decorations.
     */
    readonly removedDecorations: string[];
}
/**
 * An event describing that some ranges of lines have been tokenized (their tokens have changed).
 */
export interface IModelTokensChangedEvent {
    readonly ranges: {
        /**
         * The start of the range (inclusive)
         */
        readonly fromLineNumber: number;
        /**
         * The end of the range (inclusive)
         */
        readonly toLineNumber: number;
    }[];
}
/**
 * Describes the reason the cursor has changed its position.
 */
export declare enum CursorChangeReason {
    /**
     * Unknown or not set.
     */
    NotSet = 0,
    /**
     * A `model.setValue()` was called.
     */
    ContentFlush = 1,
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    RecoverFromMarkers = 2,
    /**
     * There was an explicit user gesture.
     */
    Explicit = 3,
    /**
     * There was a Paste.
     */
    Paste = 4,
    /**
     * There was an Undo.
     */
    Undo = 5,
    /**
     * There was a Redo.
     */
    Redo = 6,
}
/**
 * An event describing that the cursor position has changed.
 */
export interface ICursorPositionChangedEvent {
    /**
     * Primary cursor's position.
     */
    readonly position: Position;
    /**
     * Primary cursor's view position
     */
    readonly viewPosition: Position;
    /**
     * Secondary cursors' position.
     */
    readonly secondaryPositions: Position[];
    /**
     * Secondary cursors' view position.
     */
    readonly secondaryViewPositions: Position[];
    /**
     * Reason.
     */
    readonly reason: CursorChangeReason;
    /**
     * Source of the call that caused the event.
     */
    readonly source: string;
    /**
     * Is the primary cursor in the editable range?
     */
    readonly isInEditableRange: boolean;
}
/**
 * An event describing that the cursor selection has changed.
 */
export interface ICursorSelectionChangedEvent {
    /**
     * The primary selection.
     */
    readonly selection: Selection;
    /**
     * The primary selection in view coordinates.
     */
    readonly viewSelection: Selection;
    /**
     * The secondary selections.
     */
    readonly secondarySelections: Selection[];
    /**
     * The secondary selections in view coordinates.
     */
    readonly secondaryViewSelections: Selection[];
    /**
     * Source of the call that caused the event.
     */
    readonly source: string;
    /**
     * Reason.
     */
    readonly reason: CursorChangeReason;
}
/**
 * @internal
 */
export declare const enum VerticalRevealType {
    Simple = 0,
    Center = 1,
    CenterIfOutsideViewport = 2,
    Top = 3,
    Bottom = 4,
}
/**
 * An event describing a request to reveal a specific range in the view of the editor.
 * @internal
 */
export interface ICursorRevealRangeEvent {
    /**
     * Range to be reavealed.
     */
    readonly range: Range;
    /**
     * View range to be reavealed.
     */
    readonly viewRange: Range;
    readonly verticalType: VerticalRevealType;
    /**
     * If true: there should be a horizontal & vertical revealing
     * If false: there should be just a vertical revealing
     */
    readonly revealHorizontal: boolean;
    /**
     * If true: cursor is revealed if outside viewport
     */
    readonly revealCursor: boolean;
}
/**
 * @internal
 */
export interface ICursorScrollRequestEvent {
    readonly deltaLines: number;
    readonly revealCursor: boolean;
}
/**
 * An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
 */
export interface IModelChangedEvent {
    /**
     * The `uri` of the previous model or null.
     */
    readonly oldModelUrl: URI;
    /**
     * The `uri` of the new model or null.
     */
    readonly newModelUrl: URI;
}
/**
 * @internal
 */
export interface IEditorWhitespace {
    readonly id: number;
    readonly afterLineNumber: number;
    readonly heightInLines: number;
}
/**
 * A description for the overview ruler position.
 */
export declare class OverviewRulerPosition {
    readonly _overviewRulerPositionBrand: void;
    /**
     * Width of the overview ruler
     */
    readonly width: number;
    /**
     * Height of the overview ruler
     */
    readonly height: number;
    /**
     * Top position for the overview ruler
     */
    readonly top: number;
    /**
     * Right position for the overview ruler
     */
    readonly right: number;
    /**
     * @internal
     */
    constructor(source: {
        width: number;
        height: number;
        top: number;
        right: number;
    });
    /**
     * @internal
     */
    equals(other: OverviewRulerPosition): boolean;
    /**
     * @internal
     */
    clone(): OverviewRulerPosition;
}
export declare enum RenderMinimap {
    None = 0,
    Small = 1,
    Large = 2,
    SmallBlocks = 3,
    LargeBlocks = 4,
}
/**
 * The internal layout details of the editor.
 */
export declare class EditorLayoutInfo {
    readonly _editorLayoutInfoBrand: void;
    /**
     * Full editor width.
     */
    readonly width: number;
    /**
     * Full editor height.
     */
    readonly height: number;
    /**
     * Left position for the glyph margin.
     */
    readonly glyphMarginLeft: number;
    /**
     * The width of the glyph margin.
     */
    readonly glyphMarginWidth: number;
    /**
     * The height of the glyph margin.
     */
    readonly glyphMarginHeight: number;
    /**
     * Left position for the line numbers.
     */
    readonly lineNumbersLeft: number;
    /**
     * The width of the line numbers.
     */
    readonly lineNumbersWidth: number;
    /**
     * The height of the line numbers.
     */
    readonly lineNumbersHeight: number;
    /**
     * Left position for the line decorations.
     */
    readonly decorationsLeft: number;
    /**
     * The width of the line decorations.
     */
    readonly decorationsWidth: number;
    /**
     * The height of the line decorations.
     */
    readonly decorationsHeight: number;
    /**
     * Left position for the content (actual text)
     */
    readonly contentLeft: number;
    /**
     * The width of the content (actual text)
     */
    readonly contentWidth: number;
    /**
     * The height of the content (actual height)
     */
    readonly contentHeight: number;
    /**
     * The width of the minimap
     */
    readonly minimapWidth: number;
    /**
     * Minimap render type
     */
    readonly renderMinimap: RenderMinimap;
    /**
     * The number of columns (of typical characters) fitting on a viewport line.
     */
    readonly viewportColumn: number;
    /**
     * The width of the vertical scrollbar.
     */
    readonly verticalScrollbarWidth: number;
    /**
     * The height of the horizontal scrollbar.
     */
    readonly horizontalScrollbarHeight: number;
    /**
     * The position of the overview ruler.
     */
    readonly overviewRuler: OverviewRulerPosition;
    /**
     * @internal
     */
    constructor(source: {
        width: number;
        height: number;
        glyphMarginLeft: number;
        glyphMarginWidth: number;
        glyphMarginHeight: number;
        lineNumbersLeft: number;
        lineNumbersWidth: number;
        lineNumbersHeight: number;
        decorationsLeft: number;
        decorationsWidth: number;
        decorationsHeight: number;
        contentLeft: number;
        contentWidth: number;
        contentHeight: number;
        renderMinimap: RenderMinimap;
        minimapWidth: number;
        viewportColumn: number;
        verticalScrollbarWidth: number;
        horizontalScrollbarHeight: number;
        overviewRuler: OverviewRulerPosition;
    });
    /**
     * @internal
     */
    equals(other: EditorLayoutInfo): boolean;
    /**
     * @internal
     */
    clone(): EditorLayoutInfo;
}
/**
 * Options for creating the editor.
 */
export interface ICodeEditorWidgetCreationOptions extends IEditorOptions {
    /**
     * The initial model associated with this code editor.
     */
    model?: IModel;
}
/**
 * An editor model.
 */
export interface IEditorModel {
}
/**
 * An editor view state.
 */
export interface IEditorViewState {
}
export interface IDimension {
    width: number;
    height: number;
}
/**
 * A (serializable) state of the cursors.
 */
export interface ICursorState {
    inSelectionMode: boolean;
    selectionStart: IPosition;
    position: IPosition;
}
/**
 * A (serializable) state of the view.
 */
export interface IViewState {
    scrollTop: number;
    scrollTopWithoutViewZones: number;
    scrollLeft: number;
}
/**
 * A (serializable) state of the code editor.
 */
export interface ICodeEditorViewState extends IEditorViewState {
    cursorState: ICursorState[];
    viewState: IViewState;
    contributionsState: {
        [id: string]: any;
    };
}
/**
 * Type of hit element with the mouse in the editor.
 */
export declare enum MouseTargetType {
    /**
     * Mouse is on top of an unknown element.
     */
    UNKNOWN = 0,
    /**
     * Mouse is on top of the textarea used for input.
     */
    TEXTAREA = 1,
    /**
     * Mouse is on top of the glyph margin
     */
    GUTTER_GLYPH_MARGIN = 2,
    /**
     * Mouse is on top of the line numbers
     */
    GUTTER_LINE_NUMBERS = 3,
    /**
     * Mouse is on top of the line decorations
     */
    GUTTER_LINE_DECORATIONS = 4,
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    GUTTER_VIEW_ZONE = 5,
    /**
     * Mouse is on top of text in the content.
     */
    CONTENT_TEXT = 6,
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    CONTENT_EMPTY = 7,
    /**
     * Mouse is on top of a view zone in the content.
     */
    CONTENT_VIEW_ZONE = 8,
    /**
     * Mouse is on top of a content widget.
     */
    CONTENT_WIDGET = 9,
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    OVERVIEW_RULER = 10,
    /**
     * Mouse is on top of a scrollbar.
     */
    SCROLLBAR = 11,
    /**
     * Mouse is on top of an overlay widget.
     */
    OVERLAY_WIDGET = 12,
    /**
     * Mouse is outside of the editor.
     */
    OUTSIDE_EDITOR = 13,
}
/**
 * A model for the diff editor.
 */
export interface IDiffEditorModel extends IEditorModel {
    /**
     * Original model.
     */
    original: IModel;
    /**
     * Modified model.
     */
    modified: IModel;
}
/**
 * (Serializable) View state for the diff editor.
 */
export interface IDiffEditorViewState extends IEditorViewState {
    original: ICodeEditorViewState;
    modified: ICodeEditorViewState;
}
/**
 * A change
 */
export interface IChange {
    readonly originalStartLineNumber: number;
    readonly originalEndLineNumber: number;
    readonly modifiedStartLineNumber: number;
    readonly modifiedEndLineNumber: number;
}
/**
 * A character level change.
 */
export interface ICharChange extends IChange {
    readonly originalStartColumn: number;
    readonly originalEndColumn: number;
    readonly modifiedStartColumn: number;
    readonly modifiedEndColumn: number;
}
/**
 * A line change
 */
export interface ILineChange extends IChange {
    readonly charChanges: ICharChange[];
}
/**
 * Information about a line in the diff editor
 */
export interface IDiffLineInformation {
    readonly equivalentLineNumber: number;
}
/**
 * @internal
 */
export declare namespace EditorContextKeys {
    /**
     * A context key that is set when the editor's text has focus (cursor is blinking).
     * @internal
     */
    const TextFocus: RawContextKey<boolean>;
    /**
     * A context key that is set when the editor's text or an editor's widget has focus.
     * @internal
     */
    const Focus: RawContextKey<boolean>;
    /**
     * A context key that is set when the editor's text is readonly.
     * @internal
     */
    const ReadOnly: RawContextKey<boolean>;
    /**
     * @internal
     */
    const Writable: ContextKeyExpr;
    /**
     * A context key that is set when the editor has a non-collapsed selection.
     * @internal
     */
    const HasNonEmptySelection: RawContextKey<boolean>;
    /**
     * @internal
     */
    const HasOnlyEmptySelection: ContextKeyExpr;
    /**
     * A context key that is set when the editor has multiple selections (multiple cursors).
     * @internal
     */
    const HasMultipleSelections: RawContextKey<boolean>;
    /**
     * @internal
     */
    const HasSingleSelection: ContextKeyExpr;
    /**
     * @internal
     */
    const TabMovesFocus: RawContextKey<boolean>;
    /**
     * @internal
     */
    const TabDoesNotMoveFocus: ContextKeyExpr;
    /**
     * A context key that is set to the language associated with the model associated with the editor.
     * @internal
     */
    const LanguageId: RawContextKey<string>;
}
/**
 * @internal
 */
export declare namespace ModeContextKeys {
    /**
     * @internal
     */
    const hasCompletionItemProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasCodeActionsProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasCodeLensProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasDefinitionProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasImplementationProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasTypeDefinitionProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasHoverProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasDocumentHighlightProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasDocumentSymbolProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasReferenceProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasWorkspaceReferenceProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasRenameProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasDocumentFormattingProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasDocumentSelectionFormattingProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const hasSignatureHelpProvider: RawContextKey<boolean>;
    /**
     * @internal
     */
    const isInEmbeddedEditor: RawContextKey<boolean>;
}
/**
 * @internal
 */
export interface IConfiguration {
    readonly onDidChange: Event<IConfigurationChangedEvent>;
    readonly editor: InternalEditorOptions;
    setMaxLineNumber(maxLineNumber: number): void;
}
export interface IScrollEvent {
    readonly scrollTop: number;
    readonly scrollLeft: number;
    readonly scrollWidth: number;
    readonly scrollHeight: number;
    readonly scrollTopChanged: boolean;
    readonly scrollLeftChanged: boolean;
    readonly scrollWidthChanged: boolean;
    readonly scrollHeightChanged: boolean;
}
export interface INewScrollPosition {
    scrollLeft?: number;
    scrollTop?: number;
}
/**
 * @internal
 */
export interface IViewWhitespaceViewportData {
    readonly id: number;
    readonly afterLineNumber: number;
    readonly verticalOffset: number;
    readonly height: number;
}
/**
 * @internal
 */
export declare class Viewport {
    readonly _viewportBrand: void;
    readonly top: number;
    readonly left: number;
    readonly width: number;
    readonly height: number;
    constructor(top: number, left: number, width: number, height: number);
}
/**
 * Description of an action contribution
 */
export interface IActionDescriptor {
    /**
     * An unique identifier of the contributed action.
     */
    id: string;
    /**
     * A label of the action that will be presented to the user.
     */
    label: string;
    /**
     * Precondition rule.
     */
    precondition?: string;
    /**
     * An array of keybindings for the action.
     */
    keybindings?: number[];
    /**
     * The keybinding rule (condition on top of precondition).
     */
    keybindingContext?: string;
    /**
     * Control if the action should show up in the context menu and where.
     * The context menu of the editor has these default:
     *   navigation - The navigation group comes first in all cases.
     *   1_modification - This group comes next and contains commands that modify your code.
     *   9_cutcopypaste - The last default group with the basic editing commands.
     * You can also create your own group.
     * Defaults to null (don't show in context menu).
     */
    contextMenuGroupId?: string;
    /**
     * Control the order in the context menu group.
     */
    contextMenuOrder?: number;
    /**
     * Method that will be executed when the action is triggered.
     * @param editor The editor instance is passed in as a convinience
     */
    run(editor: ICommonCodeEditor): void | TPromise<void>;
}
/**
 * @internal
 */
export declare type ICommonEditorContributionCtor = IConstructorSignature1<ICommonCodeEditor, IEditorContribution>;
export interface IEditorAction {
    readonly id: string;
    readonly label: string;
    readonly alias: string;
    isSupported(): boolean;
    run(): TPromise<void>;
}
/**
 * An editor.
 */
export interface IEditor {
    /**
     * @deprecated. Please use `onDidChangeModelContent` instead.
     * An event emitted when the content of the current model has changed.
     * @internal
     * @event
     */
    onDidChangeModelRawContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the content of the current model has changed.
     * @event
     */
    onDidChangeModelContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
    /**
     * An event emitted when the language of the current model has changed.
     * @event
     */
    onDidChangeModelLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the options of the current model has changed.
     * @event
     */
    onDidChangeModelOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
     * @event
     */
    onDidChangeConfiguration(listener: (e: IConfigurationChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the cursor position has changed.
     * @event
     */
    onDidChangeCursorPosition(listener: (e: ICursorPositionChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the cursor selection has changed.
     * @event
     */
    onDidChangeCursorSelection(listener: (e: ICursorSelectionChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the editor has been disposed.
     * @event
     */
    onDidDispose(listener: () => void): IDisposable;
    /**
     * Dispose the editor.
     */
    dispose(): void;
    /**
     * Get a unique id for this editor instance.
     */
    getId(): string;
    /**
     * Get the editor type. Please see `EditorType`.
     * This is to avoid an instanceof check
     */
    getEditorType(): string;
    /**
     * Destroy the editor.
     * @internal
     */
    destroy(): void;
    /**
     * Update the editor's options after the editor has been created.
     */
    updateOptions(newOptions: IEditorOptions): void;
    /**
     * Indicates that the editor becomes visible.
     * @internal
     */
    onVisible(): void;
    /**
     * Indicates that the editor becomes hidden.
     * @internal
     */
    onHide(): void;
    /**
     * Instructs the editor to remeasure its container. This method should
     * be called when the container of the editor gets resized.
     */
    layout(dimension?: IDimension): void;
    /**
     * Brings browser focus to the editor text
     */
    focus(): void;
    /**
     * Returns true if this editor has keyboard focus (e.g. cursor is blinking).
     */
    isFocused(): boolean;
    /**
     * Returns all actions associated with this editor.
     */
    getActions(): IEditorAction[];
    /**
     * Returns all actions associated with this editor.
     */
    getSupportedActions(): IEditorAction[];
    /**
     * Saves current view state of the editor in a serializable object.
     */
    saveViewState(): IEditorViewState;
    /**
     * Restores the view state of the editor from a serializable object generated by `saveViewState`.
     */
    restoreViewState(state: IEditorViewState): void;
    /**
     * Given a position, returns a column number that takes tab-widths into account.
     */
    getVisibleColumnFromPosition(position: IPosition): number;
    /**
     * Returns the primary position of the cursor.
     */
    getPosition(): Position;
    /**
     * Set the primary position of the cursor. This will remove any secondary cursors.
     * @param position New primary cursor's position
     */
    setPosition(position: IPosition): void;
    /**
     * Scroll vertically as necessary and reveal a line.
     */
    revealLine(lineNumber: number): void;
    /**
     * Scroll vertically as necessary and reveal a line centered vertically.
     */
    revealLineInCenter(lineNumber: number): void;
    /**
     * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
     */
    revealLineInCenterIfOutsideViewport(lineNumber: number): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position.
     */
    revealPosition(position: IPosition): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
     */
    revealPositionInCenter(position: IPosition): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
     */
    revealPositionInCenterIfOutsideViewport(position: IPosition): void;
    /**
     * Returns the primary selection of the editor.
     */
    getSelection(): Selection;
    /**
     * Returns all the selections of the editor.
     */
    getSelections(): Selection[];
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     */
    setSelection(selection: IRange): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     */
    setSelection(selection: Range): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     */
    setSelection(selection: ISelection): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     */
    setSelection(selection: Selection): void;
    /**
     * Set the selections for all the cursors of the editor.
     * Cursors will be removed or added, as necessary.
     */
    setSelections(selections: ISelection[]): void;
    /**
     * Scroll vertically as necessary and reveal lines.
     */
    revealLines(startLineNumber: number, endLineNumber: number): void;
    /**
     * Scroll vertically as necessary and reveal lines centered vertically.
     */
    revealLinesInCenter(lineNumber: number, endLineNumber: number): void;
    /**
     * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
     */
    revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range.
     */
    revealRange(range: IRange): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
     */
    revealRangeInCenter(range: IRange): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
     */
    revealRangeAtTop(range: IRange): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
     */
    revealRangeInCenterIfOutsideViewport(range: IRange): void;
    /**
     * Directly trigger a handler or an editor action.
     * @param source The source of the call.
     * @param handlerId The id of the handler or the id of a contribution.
     * @param payload Extra data to be sent to the handler.
     */
    trigger(source: string, handlerId: string, payload: any): void;
    /**
     * Gets the current model attached to this editor.
     */
    getModel(): IEditorModel;
    /**
     * Sets the current model attached to this editor.
     * If the previous model was created by the editor via the value key in the options
     * literal object, it will be destroyed. Otherwise, if the previous model was set
     * via setModel, or the model key in the options literal object, the previous model
     * will not be destroyed.
     * It is safe to call setModel(null) to simply detach the current model from the editor.
     */
    setModel(model: IEditorModel | undefined): void;
    /**
     * Change the decorations. All decorations added through this changeAccessor
     * will get the ownerId of the editor (meaning they will not show up in other
     * editors).
     * @see IModel.changeDecorations
     * @internal
     */
    changeDecorations(callback: (changeAccessor: IModelDecorationsChangeAccessor) => any): any;
}
/**
 * @internal
 */
export interface ICodeEditorState {
    validate(editor: ICommonCodeEditor): boolean;
}
/**
 * @internal
 */
export declare enum CodeEditorStateFlag {
    Value = 0,
    Selection = 1,
    Position = 2,
    Scroll = 3,
}
/**
 * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
 */
export interface IEditorContribution {
    /**
     * Get a unique identifier for this contribution.
     */
    getId(): string;
    /**
     * Dispose this contribution.
     */
    dispose(): void;
    /**
     * Store view state.
     */
    saveViewState?(): any;
    /**
     * Restore view state.
     */
    restoreViewState?(state: any): void;
}
/**
 * @internal
 */
export interface IThemeDecorationRenderOptions {
    backgroundColor?: string;
    outline?: string;
    outlineColor?: string;
    outlineStyle?: string;
    outlineWidth?: string;
    border?: string;
    borderColor?: string;
    borderRadius?: string;
    borderSpacing?: string;
    borderStyle?: string;
    borderWidth?: string;
    textDecoration?: string;
    cursor?: string;
    color?: string;
    letterSpacing?: string;
    gutterIconPath?: string | URI;
    gutterIconSize?: string;
    overviewRulerColor?: string;
    before?: IContentDecorationRenderOptions;
    after?: IContentDecorationRenderOptions;
}
/**
 * @internal
 */
export interface IContentDecorationRenderOptions {
    contentText?: string;
    contentIconPath?: string | URI;
    border?: string;
    textDecoration?: string;
    color?: string;
    backgroundColor?: string;
    margin?: string;
    width?: string;
    height?: string;
}
/**
 * @internal
 */
export interface IDecorationRenderOptions extends IThemeDecorationRenderOptions {
    isWholeLine?: boolean;
    overviewRulerLane?: OverviewRulerLane;
    light?: IThemeDecorationRenderOptions;
    dark?: IThemeDecorationRenderOptions;
}
/**
 * @internal
 */
export interface IThemeDecorationInstanceRenderOptions {
    before?: IContentDecorationRenderOptions;
    after?: IContentDecorationRenderOptions;
}
/**
 * @internal
 */
export interface IDecorationInstanceRenderOptions extends IThemeDecorationInstanceRenderOptions {
    light?: IThemeDecorationInstanceRenderOptions;
    dark?: IThemeDecorationInstanceRenderOptions;
}
/**
 * @internal
 */
export interface IDecorationOptions {
    range: IRange;
    hoverMessage?: MarkedString | MarkedString[];
    renderOptions?: IDecorationInstanceRenderOptions;
}
export interface ICommonCodeEditor extends IEditor {
    /**
     * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
     * @event
     */
    onDidChangeModel(listener: (e: IModelChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the decorations of the current model have changed.
     * @event
     */
    onDidChangeModelDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
    /**
     * An event emitted when the text inside this editor gained focus (i.e. cursor blinking).
     * @event
     */
    onDidFocusEditorText(listener: () => void): IDisposable;
    /**
     * An event emitted when the text inside this editor lost focus.
     * @event
     */
    onDidBlurEditorText(listener: () => void): IDisposable;
    /**
     * An event emitted when the text inside this editor or an editor widget gained focus.
     * @event
     */
    onDidFocusEditor(listener: () => void): IDisposable;
    /**
     * An event emitted when the text inside this editor or an editor widget lost focus.
     * @event
     */
    onDidBlurEditor(listener: () => void): IDisposable;
    /**
     * An event emitted before interpreting typed characters (on the keyboard).
     * @event
     * @internal
     */
    onWillType(listener: (text: string) => void): IDisposable;
    /**
     * An event emitted before interpreting typed characters (on the keyboard).
     * @event
     * @internal
     */
    onDidType(listener: (text: string) => void): IDisposable;
    /**
     * An event emitted when users paste text in the editor.
     * @event
     * @internal
     */
    onDidPaste(listener: (range: Range) => void): IDisposable;
    /**
     * Returns true if this editor or one of its widgets has keyboard focus.
     */
    hasWidgetFocus(): boolean;
    /**
     * Get a contribution of this editor.
     * @id Unique identifier of the contribution.
     * @return The contribution or null if contribution not found.
     */
    getContribution<T extends IEditorContribution>(id: string): T;
    /**
     * @internal
     */
    captureState(...flags: CodeEditorStateFlag[]): ICodeEditorState;
    /**
     * Execute `fn` with the editor's services.
     * @internal
     */
    invokeWithinContext<T>(fn: (accessor: ServicesAccessor) => T): T;
    /**
     * Type the getModel() of IEditor.
     */
    getModel(): IModel;
    /**
     * Returns the current editor's configuration
     */
    getConfiguration(): InternalEditorOptions;
    /**
     * Returns the 'raw' editor's configuration, as it was applied over the defaults, but without any computed members.
     * @internal
     */
    getRawConfiguration(): IEditorOptions;
    /**
     * Get value of the current model attached to this editor.
     * @see IModel.getValue
     */
    getValue(options?: {
        preserveBOM: boolean;
        lineEnding: string;
    }): string;
    /**
     * Set the value of the current model attached to this editor.
     * @see IModel.setValue
     */
    setValue(newValue: string): void;
    /**
     * Get the scrollWidth of the editor's viewport.
     */
    getScrollWidth(): number;
    /**
     * Get the scrollLeft of the editor's viewport.
     */
    getScrollLeft(): number;
    /**
     * Get the scrollHeight of the editor's viewport.
     */
    getScrollHeight(): number;
    /**
     * Get the scrollTop of the editor's viewport.
     */
    getScrollTop(): number;
    /**
     * Change the scrollLeft of the editor's viewport.
     */
    setScrollLeft(newScrollLeft: number): void;
    /**
     * Change the scrollTop of the editor's viewport.
     */
    setScrollTop(newScrollTop: number): void;
    /**
     * Change the scroll position of the editor's viewport.
     */
    setScrollPosition(position: INewScrollPosition): void;
    /**
     * Get an action that is a contribution to this editor.
     * @id Unique identifier of the contribution.
     * @return The action or null if action not found.
     */
    getAction(id: string): IEditorAction;
    /**
     * Execute a command on the editor.
     * @param source The source of the call.
     * @param command The command to execute
     */
    executeCommand(source: string, command: ICommand): void;
    /**
     * Push an "undo stop" in the undo-redo stack.
     */
    pushUndoStop(): boolean;
    /**
     * Execute edits on the editor.
     * @param source The source of the call.
     * @param edits The edits to execute.
     * @param endCursoState Cursor state after the edits were applied.
     */
    executeEdits(source: string, edits: IIdentifiedSingleEditOperation[], endCursoState?: Selection[]): boolean;
    /**
     * Execute multiple (concommitent) commands on the editor.
     * @param source The source of the call.
     * @param command The commands to execute
     */
    executeCommands(source: string, commands: ICommand[]): void;
    /**
     * Get all the decorations on a line (filtering out decorations from other editors).
     */
    getLineDecorations(lineNumber: number): IModelDecoration[];
    /**
     * All decorations added through this call will get the ownerId of this editor.
     * @see IModel.deltaDecorations
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
    /**
     * @internal
     */
    setDecorations(decorationTypeKey: string, ranges: IDecorationOptions[]): void;
    /**
     * @internal
     */
    removeDecorations(decorationTypeKey: string): void;
    /**
     * Get the layout info for the editor.
     */
    getLayoutInfo(): EditorLayoutInfo;
    /**
     * @internal
     */
    getTelemetryData(): {
        [key: string]: any;
    };
}
export interface ICommonDiffEditor extends IEditor {
    /**
     * An event emitted when the diff information computed by this diff editor has been updated.
     * @event
     */
    onDidUpdateDiff(listener: () => void): IDisposable;
    /**
     * Type the getModel() of IEditor.
     */
    getModel(): IDiffEditorModel;
    /**
     * Get the `original` editor.
     */
    getOriginalEditor(): ICommonCodeEditor;
    /**
     * Get the `modified` editor.
     */
    getModifiedEditor(): ICommonCodeEditor;
    /**
     * Get the computed diff information.
     */
    getLineChanges(): ILineChange[];
    /**
     * Get information based on computed diff about a line number from the original model.
     * If the diff computation is not finished or the model is missing, will return null.
     */
    getDiffLineInformationForOriginal(lineNumber: number): IDiffLineInformation;
    /**
     * Get information based on computed diff about a line number from the modified model.
     * If the diff computation is not finished or the model is missing, will return null.
     */
    getDiffLineInformationForModified(lineNumber: number): IDiffLineInformation;
    /**
     * @see ICodeEditor.getValue
     */
    getValue(options?: {
        preserveBOM: boolean;
        lineEnding: string;
    }): string;
    /**
     * Returns whether the diff editor is ignoring trim whitespace or not.
     * @internal
     */
    readonly ignoreTrimWhitespace: boolean;
    /**
     * Returns whether the diff editor is rendering side by side or not.
     * @internal
     */
    readonly renderSideBySide: boolean;
    /**
     * Returns whether the diff editor is rendering +/- indicators or not.
     * @internal
     */
    readonly renderIndicators: boolean;
}
/**
 * The type of the `IEditor`.
 */
export declare var EditorType: {
    ICodeEditor: string;
    IDiffEditor: string;
};
/**
 *@internal
 */
export declare function isCommonCodeEditor(thing: any): thing is ICommonCodeEditor;
/**
 *@internal
 */
export declare function isCommonDiffEditor(thing: any): thing is ICommonDiffEditor;
/**
 * @internal
 */
export declare var ClassName: {
    EditorWarningDecoration: string;
    EditorErrorDecoration: string;
};
/**
 * @internal
 */
export declare var EventType: {
    Disposed: string;
    ConfigurationChanged: string;
    ModelDispose: string;
    ModelChanged: string;
    ModelTokensChanged: string;
    ModelLanguageChanged: string;
    ModelOptionsChanged: string;
    ModelRawContentChanged: string;
    ModelContentChanged2: string;
    ModelRawContentChangedFlush: string;
    ModelRawContentChangedLinesDeleted: string;
    ModelRawContentChangedLinesInserted: string;
    ModelRawContentChangedLineChanged: string;
    EditorTextBlur: string;
    EditorTextFocus: string;
    EditorFocus: string;
    EditorBlur: string;
    ModelDecorationsChanged: string;
    CursorPositionChanged: string;
    CursorSelectionChanged: string;
    CursorRevealRange: string;
    CursorScrollRequest: string;
    ViewFocusGained: string;
    ViewFocusLost: string;
    ViewZonesChanged: string;
    ContextMenu: string;
    MouseDown: string;
    MouseUp: string;
    MouseMove: string;
    MouseLeave: string;
    MouseDrag: string;
    MouseDrop: string;
    KeyDown: string;
    KeyUp: string;
    WillType: string;
    DidType: string;
    DidPaste: string;
    EditorLayout: string;
    DiffUpdated: string;
};
/**
 * Positions in the view for cursor move command.
 */
export declare const CursorMovePosition: {
    Left: string;
    Right: string;
    Up: string;
    Down: string;
    WrappedLineStart: string;
    WrappedLineFirstNonWhitespaceCharacter: string;
    WrappedLineColumnCenter: string;
    WrappedLineEnd: string;
    WrappedLineLastNonWhitespaceCharacter: string;
    ViewPortTop: string;
    ViewPortCenter: string;
    ViewPortBottom: string;
    ViewPortIfOutside: string;
};
/**
 * Units for Cursor move 'by' argument
 */
export declare const CursorMoveByUnit: {
    Line: string;
    WrappedLine: string;
    Character: string;
    HalfLine: string;
};
/**
 * Arguments for Cursor move command
 */
export interface CursorMoveArguments {
    to: string;
    select?: boolean;
    by?: string;
    value?: number;
}
/**
 * Directions in the view for editor scroll command.
 */
export declare const EditorScrollDirection: {
    Up: string;
    Down: string;
};
/**
 * Units for editor scroll 'by' argument
 */
export declare const EditorScrollByUnit: {
    Line: string;
    WrappedLine: string;
    Page: string;
    HalfPage: string;
};
/**
 * Arguments for editor scroll command
 */
export interface EditorScrollArguments {
    to: string;
    by?: string;
    value?: number;
    revealCursor?: boolean;
}
/**
 * Arguments for reveal line command
 */
export interface RevealLineArguments {
    lineNumber?: number;
    at?: string;
}
/**
 * Values for reveal line 'at' argument
 */
export declare const RevealLineAtArgument: {
    Top: string;
    Center: string;
    Bottom: string;
};
/**
 * @internal
 */
export declare var CommandDescription: {
    CursorMove: ICommandHandlerDescription;
    EditorScroll: ICommandHandlerDescription;
    RevealLine: ICommandHandlerDescription;
};
/**
 * Built-in commands.
 */
export declare var Handler: {
    ExecuteCommand: string;
    ExecuteCommands: string;
    CursorLeft: string;
    CursorLeftSelect: string;
    CursorWordLeft: string;
    CursorWordStartLeft: string;
    CursorWordEndLeft: string;
    CursorWordLeftSelect: string;
    CursorWordStartLeftSelect: string;
    CursorWordEndLeftSelect: string;
    CursorRight: string;
    CursorRightSelect: string;
    CursorWordRight: string;
    CursorWordStartRight: string;
    CursorWordEndRight: string;
    CursorWordRightSelect: string;
    CursorWordStartRightSelect: string;
    CursorWordEndRightSelect: string;
    CursorUp: string;
    CursorUpSelect: string;
    CursorDown: string;
    CursorDownSelect: string;
    CursorPageUp: string;
    CursorPageUpSelect: string;
    CursorPageDown: string;
    CursorPageDownSelect: string;
    CursorHome: string;
    CursorHomeSelect: string;
    CursorEnd: string;
    CursorEndSelect: string;
    ExpandLineSelection: string;
    CursorTop: string;
    CursorTopSelect: string;
    CursorBottom: string;
    CursorBottomSelect: string;
    CursorColumnSelectLeft: string;
    CursorColumnSelectRight: string;
    CursorColumnSelectUp: string;
    CursorColumnSelectPageUp: string;
    CursorColumnSelectDown: string;
    CursorColumnSelectPageDown: string;
    CursorMove: string;
    AddCursorDown: string;
    AddCursorUp: string;
    CursorUndo: string;
    MoveTo: string;
    MoveToSelect: string;
    ColumnSelect: string;
    CreateCursor: string;
    LastCursorMoveToSelect: string;
    Type: string;
    ReplacePreviousChar: string;
    CompositionStart: string;
    CompositionEnd: string;
    Paste: string;
    Tab: string;
    Indent: string;
    Outdent: string;
    DeleteLeft: string;
    DeleteRight: string;
    DeleteWordLeft: string;
    DeleteWordStartLeft: string;
    DeleteWordEndLeft: string;
    DeleteWordRight: string;
    DeleteWordStartRight: string;
    DeleteWordEndRight: string;
    RemoveSecondaryCursors: string;
    CancelSelection: string;
    Cut: string;
    Undo: string;
    Redo: string;
    WordSelect: string;
    WordSelectDrag: string;
    LastCursorWordSelect: string;
    LineSelect: string;
    LineSelectDrag: string;
    LastCursorLineSelect: string;
    LastCursorLineSelectDrag: string;
    LineInsertBefore: string;
    LineInsertAfter: string;
    LineBreakInsert: string;
    SelectAll: string;
    EditorScroll: string;
    ScrollLineUp: string;
    ScrollLineDown: string;
    ScrollPageUp: string;
    ScrollPageDown: string;
    RevealLine: string;
};
/**
 * The style in which the editor's cursor should be rendered.
 */
export declare enum TextEditorCursorStyle {
    /**
     * As a vertical line (sitting between two characters).
     */
    Line = 1,
    /**
     * As a block (sitting on top of a character).
     */
    Block = 2,
    /**
     * As a horizontal line (sitting under a character).
     */
    Underline = 3,
    /**
     * As a thin vertical line (sitting between two characters).
     */
    LineThin = 4,
    /**
     * As an outlined block (sitting on top of a character).
     */
    BlockOutline = 5,
    /**
     * As a thin horizontal line (sitting under a character).
     */
    UnderlineThin = 6,
}
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
export declare enum TextEditorCursorBlinkingStyle {
    /**
     * Hidden
     */
    Hidden = 0,
    /**
     * Blinking
     */
    Blink = 1,
    /**
     * Blinking with smooth fading
     */
    Smooth = 2,
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    Phase = 3,
    /**
     * Expand collapse animation on the y axis
     */
    Expand = 4,
    /**
     * No-Blinking
     */
    Solid = 5,
}
/**
 * @internal
 */
export declare function cursorStyleToString(cursorStyle: TextEditorCursorStyle): string;
/**
 * @internal
 */
export declare class ColorZone {
    _colorZoneBrand: void;
    from: number;
    to: number;
    colorId: number;
    position: OverviewRulerLane;
    constructor(from: number, to: number, colorId: number, position: OverviewRulerLane);
}
/**
 * A zone in the overview ruler
 * @internal
 */
export declare class OverviewRulerZone {
    _overviewRulerZoneBrand: void;
    startLineNumber: number;
    endLineNumber: number;
    position: OverviewRulerLane;
    forceHeight: number;
    private _color;
    private _darkColor;
    private _colorZones;
    constructor(startLineNumber: number, endLineNumber: number, position: OverviewRulerLane, forceHeight: number, color: string, darkColor: string);
    getColor(useDarkColor: boolean): string;
    equals(other: OverviewRulerZone): boolean;
    compareTo(other: OverviewRulerZone): number;
    setColorZones(colorZones: ColorZone[]): void;
    getColorZones(): ColorZone[];
}
