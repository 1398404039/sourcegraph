/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var strings = require("vs/base/common/strings");
var position_1 = require("vs/editor/common/core/position");
var range_1 = require("vs/editor/common/core/range");
var editorCommon = require("vs/editor/common/editorCommon");
var modelLine_1 = require("vs/editor/common/model/modelLine");
var indentationGuesser_1 = require("vs/editor/common/model/indentationGuesser");
var defaultConfig_1 = require("vs/editor/common/config/defaultConfig");
var prefixSumComputer_1 = require("vs/editor/common/viewModel/prefixSumComputer");
var indentRanges_1 = require("vs/editor/common/model/indentRanges");
var textModelSearch_1 = require("vs/editor/common/model/textModelSearch");
var textSource_1 = require("vs/editor/common/model/textSource");
var LIMIT_FIND_COUNT = 999;
exports.LONG_LINE_BOUNDARY = 1000;
var TextModel = (function (_super) {
    __extends(TextModel, _super);
    function TextModel(allowedEventTypes, rawTextSource, creationOptions) {
        var _this = this;
        allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged, editorCommon.EventType.ModelOptionsChanged, editorCommon.EventType.ModelContentChanged2);
        _this = _super.call(this, allowedEventTypes) || this;
        var textModelData = TextModel.resolveCreationData(rawTextSource, creationOptions);
        _this._shouldSimplifyMode = (textModelData.text.length > TextModel.MODEL_SYNC_LIMIT);
        _this._shouldDenyMode = (textModelData.text.length > TextModel.MODEL_TOKENIZATION_LIMIT);
        _this._options = new editorCommon.TextModelResolvedOptions(textModelData.options);
        _this._constructLines(textModelData.text);
        _this._setVersionId(1);
        _this._isDisposed = false;
        _this._isDisposing = false;
        return _this;
    }
    TextModel.createFromString = function (text, options) {
        if (options === void 0) { options = TextModel.DEFAULT_CREATION_OPTIONS; }
        return new TextModel([], textSource_1.RawTextSource.fromString(text), options);
    };
    TextModel.resolveCreationData = function (rawTextSource, options) {
        var textSource = textSource_1.TextSource.fromRawTextSource(rawTextSource, options.defaultEOL);
        var resolvedOpts;
        if (options.detectIndentation) {
            var guessedIndentation = indentationGuesser_1.guessIndentation(textSource.lines, options.tabSize, options.insertSpaces);
            resolvedOpts = new editorCommon.TextModelResolvedOptions({
                tabSize: guessedIndentation.tabSize,
                insertSpaces: guessedIndentation.insertSpaces,
                trimAutoWhitespace: options.trimAutoWhitespace,
                defaultEOL: options.defaultEOL
            });
        }
        else {
            resolvedOpts = new editorCommon.TextModelResolvedOptions({
                tabSize: options.tabSize,
                insertSpaces: options.insertSpaces,
                trimAutoWhitespace: options.trimAutoWhitespace,
                defaultEOL: options.defaultEOL
            });
        }
        return {
            text: textSource,
            options: resolvedOpts
        };
    };
    TextModel.prototype._assertNotDisposed = function () {
        if (this._isDisposed) {
            throw new Error('Model is disposed!');
        }
    };
    TextModel.prototype.isTooLargeForHavingAMode = function () {
        this._assertNotDisposed();
        return this._shouldDenyMode;
    };
    TextModel.prototype.isTooLargeForHavingARichMode = function () {
        this._assertNotDisposed();
        return this._shouldSimplifyMode;
    };
    TextModel.prototype.getOptions = function () {
        this._assertNotDisposed();
        return this._options;
    };
    TextModel.prototype.updateOptions = function (_newOpts) {
        this._assertNotDisposed();
        var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;
        var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;
        var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
        var newOpts = new editorCommon.TextModelResolvedOptions({
            tabSize: tabSize,
            insertSpaces: insertSpaces,
            defaultEOL: this._options.defaultEOL,
            trimAutoWhitespace: trimAutoWhitespace
        });
        if (this._options.equals(newOpts)) {
            return;
        }
        var e = this._options.createChangeEvent(newOpts);
        this._options = newOpts;
        if (e.tabSize) {
            var newTabSize = this._options.tabSize;
            for (var i = 0, len = this._lines.length; i < len; i++) {
                this._lines[i].updateTabSize(newTabSize);
            }
        }
        this.emit(editorCommon.EventType.ModelOptionsChanged, e);
    };
    TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
        this._assertNotDisposed();
        var lines = this._lines.map(function (line) { return line.text; });
        var guessedIndentation = indentationGuesser_1.guessIndentation(lines, defaultTabSize, defaultInsertSpaces);
        this.updateOptions({
            insertSpaces: guessedIndentation.insertSpaces,
            tabSize: guessedIndentation.tabSize
        });
    };
    TextModel._normalizeIndentationFromWhitespace = function (str, tabSize, insertSpaces) {
        var spacesCnt = 0;
        for (var i = 0; i < str.length; i++) {
            if (str.charAt(i) === '\t') {
                spacesCnt += tabSize;
            }
            else {
                spacesCnt++;
            }
        }
        var result = '';
        if (!insertSpaces) {
            var tabsCnt = Math.floor(spacesCnt / tabSize);
            spacesCnt = spacesCnt % tabSize;
            for (var i = 0; i < tabsCnt; i++) {
                result += '\t';
            }
        }
        for (var i = 0; i < spacesCnt; i++) {
            result += ' ';
        }
        return result;
    };
    TextModel.normalizeIndentation = function (str, tabSize, insertSpaces) {
        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
        if (firstNonWhitespaceIndex === -1) {
            firstNonWhitespaceIndex = str.length;
        }
        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), tabSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);
    };
    TextModel.prototype.normalizeIndentation = function (str) {
        this._assertNotDisposed();
        return TextModel.normalizeIndentation(str, this._options.tabSize, this._options.insertSpaces);
    };
    TextModel.prototype.getOneIndent = function () {
        this._assertNotDisposed();
        var tabSize = this._options.tabSize;
        var insertSpaces = this._options.insertSpaces;
        if (insertSpaces) {
            var result = '';
            for (var i = 0; i < tabSize; i++) {
                result += ' ';
            }
            return result;
        }
        else {
            return '\t';
        }
    };
    TextModel.prototype.getVersionId = function () {
        this._assertNotDisposed();
        return this._versionId;
    };
    TextModel.prototype.mightContainRTL = function () {
        return this._mightContainRTL;
    };
    TextModel.prototype.mightContainNonBasicASCII = function () {
        return this._mightContainNonBasicASCII;
    };
    TextModel.prototype.getAlternativeVersionId = function () {
        this._assertNotDisposed();
        return this._alternativeVersionId;
    };
    TextModel.prototype._ensureLineStarts = function () {
        if (!this._lineStarts) {
            var eolLength = this._EOL.length;
            var linesLength = this._lines.length;
            var lineStartValues = new Uint32Array(linesLength);
            for (var i = 0; i < linesLength; i++) {
                lineStartValues[i] = this._lines[i].text.length + eolLength;
            }
            this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
        }
    };
    TextModel.prototype.getOffsetAt = function (rawPosition) {
        this._assertNotDisposed();
        var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);
        this._ensureLineStarts();
        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + position.column - 1;
    };
    TextModel.prototype.getPositionAt = function (offset) {
        this._assertNotDisposed();
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        var out = this._lineStarts.getIndexOf(offset);
        var lineLength = this._lines[out.index].text.length;
        // Ensure we return a valid position
        return new position_1.Position(out.index + 1, Math.min(out.remainder + 1, lineLength + 1));
    };
    TextModel.prototype._increaseVersionId = function () {
        this._setVersionId(this._versionId + 1);
    };
    TextModel.prototype._setVersionId = function (newVersionId) {
        this._versionId = newVersionId;
        this._alternativeVersionId = this._versionId;
    };
    TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
        this._alternativeVersionId = newAlternativeVersionId;
    };
    TextModel.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    TextModel.prototype.dispose = function () {
        this._isDisposed = true;
        // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
        this._lines = null;
        this._EOL = null;
        this._BOM = null;
        _super.prototype.dispose.call(this);
    };
    TextModel.prototype._createContentChangedFlushEvent = function () {
        return {
            changeType: editorCommon.EventType.ModelRawContentChangedFlush,
            versionId: this._versionId,
            // TODO@Alex -> remove these fields from here
            isUndoing: false,
            isRedoing: false
        };
    };
    TextModel.prototype._emitContentChanged2 = function (startLineNumber, startColumn, endLineNumber, endColumn, rangeLength, text, isUndoing, isRedoing) {
        var e = {
            range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
            rangeLength: rangeLength,
            text: text,
            eol: this._EOL,
            versionId: this.getVersionId(),
            isUndoing: isUndoing,
            isRedoing: isRedoing
        };
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelContentChanged2, e);
        }
    };
    TextModel.prototype._resetValue = function (newValue) {
        this._constructLines(newValue);
        this._increaseVersionId();
    };
    TextModel.prototype.equals = function (other) {
        this._assertNotDisposed();
        if (this._BOM !== other.BOM) {
            return false;
        }
        if (this._EOL !== other.EOL) {
            return false;
        }
        if (this._lines.length !== other.lines.length) {
            return false;
        }
        for (var i = 0, len = this._lines.length; i < len; i++) {
            if (this._lines[i].text !== other.lines[i]) {
                return false;
            }
        }
        return true;
    };
    TextModel.prototype.setValue = function (value) {
        this._assertNotDisposed();
        if (value === null) {
            // There's nothing to do
            return;
        }
        var textSource = textSource_1.TextSource.fromString(value, this._options.defaultEOL);
        this.setValueFromTextSource(textSource);
    };
    TextModel.prototype.setValueFromTextSource = function (newValue) {
        this._assertNotDisposed();
        if (newValue === null) {
            // There's nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        this._resetValue(newValue);
        this._emitModelContentChangedFlushEvent(this._createContentChangedFlushEvent());
        this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
    };
    TextModel.prototype.getValue = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        this._assertNotDisposed();
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._BOM + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.getValueLength = function (eol, preserveBOM) {
        if (preserveBOM === void 0) { preserveBOM = false; }
        this._assertNotDisposed();
        var fullModelRange = this.getFullModelRange();
        var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
        if (preserveBOM) {
            return this._BOM.length + fullModelValue;
        }
        return fullModelValue;
    };
    TextModel.prototype.getEmptiedValueInRange = function (rawRange, fillCharacter, eol) {
        if (fillCharacter === void 0) { fillCharacter = ''; }
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        this._assertNotDisposed();
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return '';
        }
        if (range.startLineNumber === range.endLineNumber) {
            return this._repeatCharacter(fillCharacter, range.endColumn - range.startColumn);
        }
        var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
        resultLines.push(this._repeatCharacter(fillCharacter, this._lines[startLineIndex].text.length - range.startColumn + 1));
        for (var i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._repeatCharacter(fillCharacter, this._lines[i].text.length));
        }
        resultLines.push(this._repeatCharacter(fillCharacter, range.endColumn - 1));
        return resultLines.join(lineEnding);
    };
    TextModel.prototype._repeatCharacter = function (fillCharacter, count) {
        var r = '';
        for (var i = 0; i < count; i++) {
            r += fillCharacter;
        }
        return r;
    };
    TextModel.prototype.getValueInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        this._assertNotDisposed();
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return '';
        }
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].text.substring(range.startColumn - 1, range.endColumn - 1);
        }
        var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
        resultLines.push(this._lines[startLineIndex].text.substring(range.startColumn - 1));
        for (var i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i].text);
        }
        resultLines.push(this._lines[endLineIndex].text.substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    };
    TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
        if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
        this._assertNotDisposed();
        var range = this.validateRange(rawRange);
        if (range.isEmpty()) {
            return 0;
        }
        if (range.startLineNumber === range.endLineNumber) {
            return (range.endColumn - range.startColumn);
        }
        var startOffset = this.getOffsetAt(new position_1.Position(range.startLineNumber, range.startColumn));
        var endOffset = this.getOffsetAt(new position_1.Position(range.endLineNumber, range.endColumn));
        return endOffset - startOffset;
    };
    TextModel.prototype.isDominatedByLongLines = function () {
        this._assertNotDisposed();
        var smallLineCharCount = 0, longLineCharCount = 0, i, len, lines = this._lines, lineLength;
        for (i = 0, len = this._lines.length; i < len; i++) {
            lineLength = lines[i].text.length;
            if (lineLength >= exports.LONG_LINE_BOUNDARY) {
                longLineCharCount += lineLength;
            }
            else {
                smallLineCharCount += lineLength;
            }
        }
        return (longLineCharCount > smallLineCharCount);
    };
    TextModel.prototype.getLineCount = function () {
        this._assertNotDisposed();
        return this._lines.length;
    };
    TextModel.prototype.getLineContent = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].text;
    };
    TextModel.prototype.getIndentLevel = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].getIndentLevel();
    };
    TextModel.prototype._resetIndentRanges = function () {
        this._indentRanges = null;
    };
    TextModel.prototype._getIndentRanges = function () {
        if (!this._indentRanges) {
            this._indentRanges = indentRanges_1.computeRanges(this);
        }
        return this._indentRanges;
    };
    TextModel.prototype.getIndentRanges = function () {
        this._assertNotDisposed();
        var indentRanges = this._getIndentRanges();
        return indentRanges_1.IndentRange.deepCloneArr(indentRanges);
    };
    TextModel.prototype._toValidLineIndentGuide = function (lineNumber, indentGuide) {
        var lineIndentLevel = this._lines[lineNumber - 1].getIndentLevel();
        if (lineIndentLevel === -1) {
            return indentGuide;
        }
        var maxIndentGuide = Math.ceil(lineIndentLevel / this._options.tabSize);
        return Math.min(maxIndentGuide, indentGuide);
    };
    TextModel.prototype.getLineIndentGuide = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var indentRanges = this._getIndentRanges();
        for (var i = indentRanges.length - 1; i >= 0; i--) {
            var rng = indentRanges[i];
            if (rng.startLineNumber === lineNumber) {
                return this._toValidLineIndentGuide(lineNumber, Math.ceil(rng.indent / this._options.tabSize));
            }
            if (rng.startLineNumber < lineNumber && lineNumber <= rng.endLineNumber) {
                return this._toValidLineIndentGuide(lineNumber, 1 + Math.floor(rng.indent / this._options.tabSize));
            }
            if (rng.endLineNumber + 1 === lineNumber) {
                var bestIndent = rng.indent;
                while (i > 0) {
                    i--;
                    rng = indentRanges[i];
                    if (rng.endLineNumber + 1 === lineNumber) {
                        bestIndent = rng.indent;
                    }
                }
                return this._toValidLineIndentGuide(lineNumber, Math.ceil(bestIndent / this._options.tabSize));
            }
        }
        return 0;
    };
    TextModel.prototype.getLinesContent = function () {
        this._assertNotDisposed();
        var r = [];
        for (var i = 0, len = this._lines.length; i < len; i++) {
            r[i] = this._lines[i].text;
        }
        return r;
    };
    TextModel.prototype.getEOL = function () {
        this._assertNotDisposed();
        return this._EOL;
    };
    TextModel.prototype.setEOL = function (eol) {
        this._assertNotDisposed();
        var newEOL = (eol === editorCommon.EndOfLineSequence.CRLF ? '\r\n' : '\n');
        if (this._EOL === newEOL) {
            // Nothing to do
            return;
        }
        var oldFullModelRange = this.getFullModelRange();
        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        var endLineNumber = this.getLineCount();
        var endColumn = this.getLineMaxColumn(endLineNumber);
        this._EOL = newEOL;
        this._lineStarts = null;
        this._increaseVersionId();
        this._emitModelContentChangedFlushEvent(this._createContentChangedFlushEvent());
        this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
    };
    TextModel.prototype.getLineMinColumn = function (lineNumber) {
        this._assertNotDisposed();
        return 1;
    };
    TextModel.prototype.getLineMaxColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        return this._lines[lineNumber - 1].text.length + 1;
    };
    TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var result = strings.firstNonWhitespaceIndex(this._lines[lineNumber - 1].text);
        if (result === -1) {
            return 0;
        }
        return result + 1;
    };
    TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        var result = strings.lastNonWhitespaceIndex(this._lines[lineNumber - 1].text);
        if (result === -1) {
            return 0;
        }
        return result + 2;
    };
    TextModel.prototype.validateLineNumber = function (lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1) {
            lineNumber = 1;
        }
        if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
        }
        return lineNumber;
    };
    /**
     * @param strict Do NOT allow a position inside a high-low surrogate pair
     */
    TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {
        var lineNumber = Math.floor(typeof _lineNumber === 'number' ? _lineNumber : 1);
        var column = Math.floor(typeof _column === 'number' ? _column : 1);
        if (lineNumber < 1) {
            return new position_1.Position(1, 1);
        }
        if (lineNumber > this._lines.length) {
            return new position_1.Position(this._lines.length, this.getLineMaxColumn(this._lines.length));
        }
        if (column <= 1) {
            return new position_1.Position(lineNumber, 1);
        }
        var maxColumn = this.getLineMaxColumn(lineNumber);
        if (column >= maxColumn) {
            return new position_1.Position(lineNumber, maxColumn);
        }
        if (strict) {
            // If the position would end up in the middle of a high-low surrogate pair,
            // we move it to before the pair
            // !!At this point, column > 1
            var charCodeBefore = this._lines[lineNumber - 1].text.charCodeAt(column - 2);
            if (strings.isHighSurrogate(charCodeBefore)) {
                return new position_1.Position(lineNumber, column - 1);
            }
        }
        return new position_1.Position(lineNumber, column);
    };
    TextModel.prototype.validatePosition = function (position) {
        this._assertNotDisposed();
        return this._validatePosition(position.lineNumber, position.column, true);
    };
    TextModel.prototype.validateRange = function (_range) {
        this._assertNotDisposed();
        var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);
        var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);
        var startLineNumber = start.lineNumber;
        var startColumn = start.column;
        var endLineNumber = end.lineNumber;
        var endColumn = end.column;
        var startLineText = this._lines[startLineNumber - 1].text;
        var endLineText = this._lines[endLineNumber - 1].text;
        var charCodeBeforeStart = (startColumn > 1 ? startLineText.charCodeAt(startColumn - 2) : 0);
        var charCodeBeforeEnd = (endColumn > 1 && endColumn <= endLineText.length ? endLineText.charCodeAt(endColumn - 2) : 0);
        var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);
        var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);
        if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        if (startLineNumber === endLineNumber && startColumn === endColumn) {
            // do not expand a collapsed range, simply move it to a valid location
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
        }
        if (startInsideSurrogatePair && endInsideSurrogatePair) {
            // expand range at both ends
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
        }
        if (startInsideSurrogatePair) {
            // only expand range at the start
            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
        }
        // only expand range at the end
        return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
    };
    TextModel.prototype.modifyPosition = function (rawPosition, offset) {
        this._assertNotDisposed();
        return this.getPositionAt(this.getOffsetAt(rawPosition) + offset);
    };
    TextModel.prototype.getFullModelRange = function () {
        this._assertNotDisposed();
        var lineCount = this.getLineCount();
        return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
    };
    TextModel.prototype._emitModelContentChangedFlushEvent = function (e) {
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelRawContentChanged, e);
        }
    };
    TextModel.prototype._constructLines = function (textSource) {
        var tabSize = this._options.tabSize;
        var rawLines = textSource.lines;
        var modelLines = [];
        for (var i = 0, len = rawLines.length; i < len; i++) {
            modelLines[i] = new modelLine_1.ModelLine(i + 1, rawLines[i], tabSize);
        }
        this._BOM = textSource.BOM;
        this._mightContainRTL = textSource.containsRTL;
        this._mightContainNonBasicASCII = !textSource.isBasicASCII;
        this._EOL = textSource.EOL;
        this._lines = modelLines;
        this._lineStarts = null;
        this._resetIndentRanges();
    };
    TextModel.prototype._getEndOfLine = function (eol) {
        switch (eol) {
            case editorCommon.EndOfLinePreference.LF:
                return '\n';
            case editorCommon.EndOfLinePreference.CRLF:
                return '\r\n';
            case editorCommon.EndOfLinePreference.TextDefined:
                return this.getEOL();
        }
        throw new Error('Unknown EOL preference');
    };
    TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wholeWord, captureMatches, limitResultCount) {
        if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
        this._assertNotDisposed();
        var searchRange = this.getFullModelRange();
        return textModelSearch_1.TextModelSearch.findMatches(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchRange, captureMatches, limitResultCount);
    };
    TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord, captureMatches) {
        this._assertNotDisposed();
        var searchStart = this.validatePosition(rawSearchStart);
        return textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchStart, captureMatches);
    };
    TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord, captureMatches) {
        this._assertNotDisposed();
        var searchStart = this.validatePosition(rawSearchStart);
        return textModelSearch_1.TextModelSearch.findPreviousMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchStart, captureMatches);
    };
    return TextModel;
}(eventEmitter_1.OrderGuaranteeEventEmitter));
TextModel.MODEL_SYNC_LIMIT = 5 * 1024 * 1024; // 5 MB
TextModel.MODEL_TOKENIZATION_LIMIT = 20 * 1024 * 1024; // 20 MB
TextModel.DEFAULT_CREATION_OPTIONS = {
    tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
    insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
    detectIndentation: false,
    defaultEOL: editorCommon.DefaultEndOfLine.LF,
    trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
};
exports.TextModel = TextModel;
