import * as modes from 'vs/editor/common/modes';
import * as monarchCommon from 'vs/editor/common/modes/monarch/monarchCommon';
import { IModeService } from 'vs/editor/common/services/modeService';
import { TokenizationResult, TokenizationResult2 } from 'vs/editor/common/core/token';
import { IStandaloneColorService } from 'vs/editor/common/services/standaloneColorService';
/**
 * Reuse the same stack elements up to a certain depth.
 */
export declare class MonarchStackElementFactory {
    private static _INSTANCE;
    static create(parent: MonarchStackElement, state: string): MonarchStackElement;
    private readonly _maxCacheDepth;
    private readonly _entries;
    constructor(maxCacheDepth: number);
    create(parent: MonarchStackElement, state: string): MonarchStackElement;
}
export declare class MonarchStackElement {
    readonly parent: MonarchStackElement;
    readonly state: string;
    readonly depth: number;
    constructor(parent: MonarchStackElement, state: string);
    static getStackElementId(element: MonarchStackElement): string;
    private static _equals(a, b);
    equals(other: MonarchStackElement): boolean;
    push(state: string): MonarchStackElement;
    pop(): MonarchStackElement;
    popall(): MonarchStackElement;
    switchTo(state: string): MonarchStackElement;
}
export declare class EmbeddedModeData {
    readonly modeId: string;
    readonly state: modes.IState;
    constructor(modeId: string, state: modes.IState);
    equals(other: EmbeddedModeData): boolean;
    clone(): EmbeddedModeData;
}
/**
 * Reuse the same line states up to a certain depth.
 */
export declare class MonarchLineStateFactory {
    private static _INSTANCE;
    static create(stack: MonarchStackElement, embeddedModeData: EmbeddedModeData): MonarchLineState;
    private readonly _maxCacheDepth;
    private readonly _entries;
    constructor(maxCacheDepth: number);
    create(stack: MonarchStackElement, embeddedModeData: EmbeddedModeData): MonarchLineState;
}
export declare class MonarchLineState implements modes.IState {
    readonly stack: MonarchStackElement;
    readonly embeddedModeData: EmbeddedModeData;
    constructor(stack: MonarchStackElement, embeddedModeData: EmbeddedModeData);
    clone(): modes.IState;
    equals(other: modes.IState): boolean;
}
export declare class MonarchTokenizer implements modes.ITokenizationSupport {
    private readonly _modeService;
    private readonly _standaloneColorService;
    private readonly _modeId;
    private readonly _lexer;
    private _embeddedModes;
    private _tokenizationRegistryListener;
    constructor(modeService: IModeService, standaloneColorService: IStandaloneColorService, modeId: string, lexer: monarchCommon.ILexer);
    dispose(): void;
    getInitialState(): modes.IState;
    tokenize(line: string, lineState: modes.IState, offsetDelta: number): TokenizationResult;
    tokenize2(line: string, lineState: modes.IState, offsetDelta: number): TokenizationResult2;
    private _tokenize(line, lineState, offsetDelta, collector);
    private _findLeavingNestedModeOffset(line, state);
    private _nestedTokenize(line, lineState, offsetDelta, tokensCollector);
    private _myTokenize(line, lineState, offsetDelta, tokensCollector);
    private _getNestedEmbeddedModeData(mimetypeOrModeId);
    private _locateMode(mimetypeOrModeId);
}
export declare function createTokenizationSupport(modeService: IModeService, standaloneColorService: IStandaloneColorService, modeId: string, lexer: monarchCommon.ILexer): modes.ITokenizationSupport;
