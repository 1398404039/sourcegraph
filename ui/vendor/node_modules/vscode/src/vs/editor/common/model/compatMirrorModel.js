/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var editorCommon = require('vs/editor/common/editorCommon');
var modelLine_1 = require('vs/editor/common/model/modelLine');
var textModelWithTokens_1 = require('vs/editor/common/model/textModelWithTokens');
var NO_TAB_SIZE = 0;
var CompatMirrorModel = (function (_super) {
    __extends(CompatMirrorModel, _super);
    function CompatMirrorModel(versionId, value, languageId, associatedResource) {
        _super.call(this, ['changed', editorCommon.EventType.ModelDispose], value, languageId);
        this._setVersionId(versionId);
        this._associatedResource = associatedResource;
    }
    CompatMirrorModel.prototype.dispose = function () {
        this.emit(editorCommon.EventType.ModelDispose);
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(CompatMirrorModel.prototype, "uri", {
        get: function () {
            return this._associatedResource;
        },
        enumerable: true,
        configurable: true
    });
    CompatMirrorModel.prototype._constructLines = function (rawText) {
        _super.prototype._constructLines.call(this, rawText);
        // Force EOL to be \n
        this._EOL = '\n';
    };
    CompatMirrorModel.prototype.onEvents = function (events) {
        var changed = false;
        for (var i = 0, len = events.contentChanged.length; i < len; i++) {
            var contentChangedEvent = events.contentChanged[i];
            this._setVersionId(contentChangedEvent.versionId);
            switch (contentChangedEvent.changeType) {
                case editorCommon.EventType.ModelRawContentChangedFlush:
                    this._onLinesFlushed(contentChangedEvent);
                    changed = true;
                    break;
                case editorCommon.EventType.ModelRawContentChangedLinesDeleted:
                    this._onLinesDeleted(contentChangedEvent);
                    changed = true;
                    break;
                case editorCommon.EventType.ModelRawContentChangedLinesInserted:
                    this._onLinesInserted(contentChangedEvent);
                    changed = true;
                    break;
                case editorCommon.EventType.ModelRawContentChangedLineChanged:
                    this._onLineChanged(contentChangedEvent);
                    changed = true;
                    break;
            }
        }
        if (changed) {
            this.emit('changed', {});
        }
    };
    CompatMirrorModel.prototype._onLinesFlushed = function (e) {
        // Flush my lines
        this._constructLines(e.detail);
        this._resetTokenizationState();
    };
    CompatMirrorModel.prototype._onLineChanged = function (e) {
        this._lines[e.lineNumber - 1].applyEdits({}, [{
                startColumn: 1,
                endColumn: Number.MAX_VALUE,
                text: e.detail,
                forceMoveMarkers: false
            }], NO_TAB_SIZE);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.changeValue(e.lineNumber - 1, this._lines[e.lineNumber - 1].text.length + this._EOL.length);
        }
        this._invalidateLine(e.lineNumber - 1);
    };
    CompatMirrorModel.prototype._onLinesDeleted = function (e) {
        var fromLineIndex = e.fromLineNumber - 1, toLineIndex = e.toLineNumber - 1;
        // Save first line's state
        var firstLineState = this._lines[fromLineIndex].getState();
        this._lines.splice(fromLineIndex, toLineIndex - fromLineIndex + 1);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.removeValues(fromLineIndex, toLineIndex - fromLineIndex + 1);
        }
        if (fromLineIndex < this._lines.length) {
            // This check is always true in real world, but the tests forced this
            // Restore first line's state
            this._lines[fromLineIndex].setState(firstLineState);
            // Invalidate line
            this._invalidateLine(fromLineIndex);
        }
    };
    CompatMirrorModel.prototype._onLinesInserted = function (e) {
        var lineIndex, i, splitLines = e.detail.split('\n');
        var newLengths = [];
        for (lineIndex = e.fromLineNumber - 1, i = 0; lineIndex < e.toLineNumber; lineIndex++, i++) {
            this._lines.splice(lineIndex, 0, new modelLine_1.ModelLine(0, splitLines[i], NO_TAB_SIZE));
            newLengths.push(splitLines[i].length + this._EOL.length);
        }
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.insertValues(e.fromLineNumber - 1, newLengths);
        }
        if (e.fromLineNumber >= 2) {
            // This check is always true in real world, but the tests forced this
            this._invalidateLine(e.fromLineNumber - 2);
        }
    };
    return CompatMirrorModel;
}(textModelWithTokens_1.TextModelWithTokens));
exports.CompatMirrorModel = CompatMirrorModel;
