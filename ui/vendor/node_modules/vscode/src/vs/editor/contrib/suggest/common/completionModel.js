/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var arrays_1 = require("vs/base/common/arrays");
var strings_1 = require("vs/base/common/strings");
var filters_1 = require("vs/base/common/filters");
var LineContext = (function () {
    function LineContext() {
    }
    return LineContext;
}());
exports.LineContext = LineContext;
var CompletionModel = (function () {
    function CompletionModel(items, column, lineContext) {
        this._items = items;
        this._column = column;
        this._lineContext = lineContext;
    }
    Object.defineProperty(CompletionModel.prototype, "lineContext", {
        get: function () {
            return this._lineContext;
        },
        set: function (value) {
            if (this._lineContext.leadingLineContent !== value.leadingLineContent
                || this._lineContext.characterCountDelta !== value.characterCountDelta) {
                this._lineContext = value;
                this._filteredItems = undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "items", {
        get: function () {
            this._ensureCachedState();
            return this._filteredItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "topScoreIdx", {
        get: function () {
            this._ensureCachedState();
            return this._topScoreIdx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "incomplete", {
        get: function () {
            this._ensureCachedState();
            return this._isIncomplete;
        },
        enumerable: true,
        configurable: true
    });
    CompletionModel.prototype.resolveIncompleteInfo = function () {
        var incomplete = [];
        var complete = [];
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            if (!item.container.incomplete) {
                complete.push(item);
            }
            else if (incomplete.indexOf(item.support) < 0) {
                incomplete.push(item.support);
            }
        }
        return { incomplete: incomplete, complete: complete };
    };
    Object.defineProperty(CompletionModel.prototype, "stats", {
        get: function () {
            this._ensureCachedState();
            return this._stats;
        },
        enumerable: true,
        configurable: true
    });
    CompletionModel.prototype._ensureCachedState = function () {
        if (!this._filteredItems) {
            this._createCachedState();
        }
    };
    CompletionModel.prototype._createCachedState = function () {
        this._filteredItems = [];
        this._topScoreIdx = -1;
        this._isIncomplete = false;
        this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };
        var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;
        var word = '';
        var topScore = -1;
        for (var _i = 0, _b = this._items; _i < _b.length; _i++) {
            var item = _b[_i];
            var suggestion = item.suggestion, container = item.container;
            // collect those supports that signaled having
            // an incomplete result
            this._isIncomplete = this._isIncomplete || container.incomplete;
            // 'word' is that remainder of the current line that we
            // filter and score against. In theory each suggestion uses a
            // differnet word, but in practice not - that's why we cache
            var wordLen = suggestion.overwriteBefore + characterCountDelta - (item.position.column - this._column);
            if (word.length !== wordLen) {
                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);
            }
            var match = false;
            // compute highlights based on 'label'
            item.highlights = filters_1.fuzzyContiguousFilter(word, suggestion.label);
            match = item.highlights !== null;
            // no match on label nor codeSnippet -> check on filterText
            if (!match && typeof suggestion.filterText === 'string') {
                if (!arrays_1.isFalsyOrEmpty(filters_1.fuzzyContiguousFilter(word, suggestion.filterText))) {
                    match = true;
                    // try to compute highlights by stripping none-word
                    // characters from the end of the string
                    item.highlights = filters_1.fuzzyContiguousFilter(word.replace(/^\W+|\W+$/, ''), suggestion.label);
                }
            }
            if (!match) {
                continue;
            }
            this._filteredItems.push(item);
            // compute score against word
            var score = CompletionModel._scoreByHighlight(item, word);
            if (score > topScore) {
                topScore = score;
                this._topScoreIdx = this._filteredItems.length - 1;
            }
            // update stats
            this._stats.suggestionCount++;
            switch (suggestion.type) {
                case 'snippet':
                    this._stats.snippetCount++;
                    break;
                case 'text':
                    this._stats.textCount++;
                    break;
            }
        }
    };
    CompletionModel._scoreByHighlight = function (item, currentWord) {
        var highlights = item.highlights, suggestion = item.suggestion;
        if (arrays_1.isFalsyOrEmpty(highlights)) {
            return 0;
        }
        var caseSensitiveMatches = 0;
        var caseInsensitiveMatches = 0;
        var firstMatchStart = 0;
        var len = Math.min(CompletionModel._base, suggestion.label.length);
        var currentWordOffset = 0;
        for (var pos = 0, idx = 0; pos < len; pos++) {
            var highlight = highlights[idx];
            if (pos === highlight.start) {
                // reached a highlight: find highlighted part
                // and count case-sensitive /case-insensitive matches
                var part = suggestion.label.substring(highlight.start, highlight.end);
                currentWordOffset = strings_1.indexOfIgnoreCase(currentWord, part, currentWordOffset);
                if (currentWordOffset >= 0) {
                    do {
                        if (suggestion.label[pos] === currentWord[currentWordOffset]) {
                            caseSensitiveMatches += 1;
                        }
                        else {
                            caseInsensitiveMatches += 1;
                        }
                        pos += 1;
                        currentWordOffset += 1;
                    } while (pos < highlight.end);
                }
                // proceed with next highlight, store first start,
                // exit loop when no highlight is available
                if (idx === 0) {
                    firstMatchStart = highlight.start;
                }
                idx += 1;
                if (idx >= highlights.length) {
                    break;
                }
            }
        }
        // combine the 4 scoring values into one
        // value using base_100. Values further left
        // are more important
        return (Math.pow(CompletionModel._base, 3)) * caseSensitiveMatches
            + (Math.pow(CompletionModel._base, 2)) * caseInsensitiveMatches
            + (Math.pow(CompletionModel._base, 1)) * (CompletionModel._base - firstMatchStart)
            + (Math.pow(CompletionModel._base, 0)) * (CompletionModel._base - highlights.length);
    };
    return CompletionModel;
}());
CompletionModel._base = 100;
exports.CompletionModel = CompletionModel;
