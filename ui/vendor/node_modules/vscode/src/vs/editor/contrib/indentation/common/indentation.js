/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var nls = require("vs/nls");
var winjs_base_1 = require("vs/base/common/winjs.base");
var strings = require("vs/base/common/strings");
var editorCommon_1 = require("vs/editor/common/editorCommon");
var editorCommonExtensions_1 = require("vs/editor/common/editorCommonExtensions");
var quickOpen_1 = require("vs/platform/quickOpen/common/quickOpen");
var modelService_1 = require("vs/editor/common/services/modelService");
var range_1 = require("vs/editor/common/core/range");
var selection_1 = require("vs/editor/common/core/selection");
var editOperation_1 = require("vs/editor/common/core/editOperation");
var textModel_1 = require("vs/editor/common/model/textModel");
var languageConfigurationRegistry_1 = require("vs/editor/common/modes/languageConfigurationRegistry");
var shiftCommand_1 = require("vs/editor/common/commands/shiftCommand");
function shiftIndent(tabSize, indentation, count) {
    count = count || 1;
    var desiredIndentCount = shiftCommand_1.ShiftCommand.shiftIndentCount(indentation, indentation.length + count, tabSize);
    var newIndentation = '';
    for (var i = 0; i < desiredIndentCount; i++) {
        newIndentation += '\t';
    }
    return newIndentation;
}
exports.shiftIndent = shiftIndent;
function unshiftIndent(tabSize, indentation, count) {
    count = count || 1;
    var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + count, tabSize);
    var newIndentation = '';
    for (var i = 0; i < desiredIndentCount; i++) {
        newIndentation += '\t';
    }
    return newIndentation;
}
exports.unshiftIndent = unshiftIndent;
function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
        // Model is empty
        return undefined;
    }
    var indentationRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);
    if (!indentationRules) {
        return undefined;
    }
    endLineNumber = Math.min(endLineNumber, model.getLineCount());
    // Skip `unIndentedLinePattern` lines
    while (startLineNumber <= endLineNumber) {
        if (!indentationRules.unIndentedLinePattern) {
            break;
        }
        var text = model.getLineContent(startLineNumber);
        if (!indentationRules.unIndentedLinePattern.test(text)) {
            break;
        }
        startLineNumber++;
    }
    if (startLineNumber > endLineNumber - 1) {
        return undefined;
    }
    var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
    var indentEdits = [];
    // indentation being passed to lines below
    var globalIndent;
    // Calculate indentation for the first line
    // If there is no passed-in indentation, we use the indentation of the first line as base.
    var currentLineText = model.getLineContent(startLineNumber);
    var adjustedLineContent = currentLineText;
    if (inheritedIndent !== undefined && inheritedIndent !== null) {
        globalIndent = inheritedIndent;
        var oldIndentation = strings.getLeadingWhitespace(currentLineText);
        adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
            globalIndent = unshiftIndent(tabSize, globalIndent);
            adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
        }
        if (currentLineText !== adjustedLineContent) {
            indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(globalIndent, tabSize, insertSpaces)));
        }
    }
    else {
        globalIndent = strings.getLeadingWhitespace(currentLineText);
    }
    // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.
    var idealIndentForNextLine = globalIndent;
    if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
        idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
        globalIndent = shiftIndent(tabSize, globalIndent);
    }
    else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
        idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
    }
    startLineNumber++;
    // Calculate indentation adjustment for all following lines
    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
        var text = model.getLineContent(lineNumber);
        var oldIndentation = strings.getLeadingWhitespace(text);
        var adjustedLineContent_1 = idealIndentForNextLine + text.substring(oldIndentation.length);
        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent_1)) {
            idealIndentForNextLine = unshiftIndent(tabSize, idealIndentForNextLine);
            globalIndent = unshiftIndent(tabSize, globalIndent);
        }
        if (oldIndentation !== idealIndentForNextLine) {
            indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(idealIndentForNextLine, tabSize, insertSpaces)));
        }
        // calculate idealIndentForNextLine
        if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
            // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines
            // but don't change globalIndent and idealIndentForNextLine.
            continue;
        }
        else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent_1)) {
            globalIndent = shiftIndent(tabSize, globalIndent);
            idealIndentForNextLine = globalIndent;
        }
        else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent_1)) {
            idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
        }
        else {
            idealIndentForNextLine = globalIndent;
        }
    }
    return indentEdits;
}
exports.getReindentEditOperations = getReindentEditOperations;
var IndentationToSpacesAction = IndentationToSpacesAction_1 = (function (_super) {
    __extends(IndentationToSpacesAction, _super);
    function IndentationToSpacesAction() {
        return _super.call(this, {
            id: IndentationToSpacesAction_1.ID,
            label: nls.localize('indentationToSpaces', "Convert Indentation to Spaces"),
            alias: 'Convert Indentation to Spaces',
            precondition: editorCommon_1.EditorContextKeys.Writable
        }) || this;
    }
    IndentationToSpacesAction.prototype.run = function (accessor, editor) {
        var model = editor.getModel();
        if (!model) {
            return;
        }
        var modelOpts = model.getOptions();
        var command = new IndentationToSpacesCommand(editor.getSelection(), modelOpts.tabSize);
        editor.executeCommands(this.id, [command]);
        model.updateOptions({
            insertSpaces: true
        });
    };
    return IndentationToSpacesAction;
}(editorCommonExtensions_1.EditorAction));
IndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';
IndentationToSpacesAction = IndentationToSpacesAction_1 = __decorate([
    editorCommonExtensions_1.editorAction
], IndentationToSpacesAction);
exports.IndentationToSpacesAction = IndentationToSpacesAction;
var IndentationToTabsAction = IndentationToTabsAction_1 = (function (_super) {
    __extends(IndentationToTabsAction, _super);
    function IndentationToTabsAction() {
        return _super.call(this, {
            id: IndentationToTabsAction_1.ID,
            label: nls.localize('indentationToTabs', "Convert Indentation to Tabs"),
            alias: 'Convert Indentation to Tabs',
            precondition: editorCommon_1.EditorContextKeys.Writable
        }) || this;
    }
    IndentationToTabsAction.prototype.run = function (accessor, editor) {
        var model = editor.getModel();
        if (!model) {
            return;
        }
        var modelOpts = model.getOptions();
        var command = new IndentationToTabsCommand(editor.getSelection(), modelOpts.tabSize);
        editor.executeCommands(this.id, [command]);
        model.updateOptions({
            insertSpaces: false
        });
    };
    return IndentationToTabsAction;
}(editorCommonExtensions_1.EditorAction));
IndentationToTabsAction.ID = 'editor.action.indentationToTabs';
IndentationToTabsAction = IndentationToTabsAction_1 = __decorate([
    editorCommonExtensions_1.editorAction
], IndentationToTabsAction);
exports.IndentationToTabsAction = IndentationToTabsAction;
var ChangeIndentationSizeAction = (function (_super) {
    __extends(ChangeIndentationSizeAction, _super);
    function ChangeIndentationSizeAction(insertSpaces, opts) {
        var _this = _super.call(this, opts) || this;
        _this.insertSpaces = insertSpaces;
        return _this;
    }
    ChangeIndentationSizeAction.prototype.run = function (accessor, editor) {
        var _this = this;
        var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
        var modelService = accessor.get(modelService_1.IModelService);
        var model = editor.getModel();
        if (!model) {
            return undefined;
        }
        var creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language);
        var picks = [1, 2, 3, 4, 5, 6, 7, 8].map(function (n) { return ({
            id: n.toString(),
            label: n.toString(),
            // add description for tabSize value set in the configuration
            description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', "Configured Tab Size") : null
        }); });
        // auto focus the tabSize set for the current editor
        var autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
        return winjs_base_1.TPromise.timeout(50 /* quick open is sensitive to being opened so soon after another */).then(function () {
            return quickOpenService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, "Select Tab Size for Current File"), autoFocus: { autoFocusIndex: autoFocusIndex } }).then(function (pick) {
                if (pick) {
                    model.updateOptions({
                        tabSize: parseInt(pick.label, 10),
                        insertSpaces: _this.insertSpaces
                    });
                }
            });
        });
    };
    return ChangeIndentationSizeAction;
}(editorCommonExtensions_1.EditorAction));
exports.ChangeIndentationSizeAction = ChangeIndentationSizeAction;
var IndentUsingTabs = IndentUsingTabs_1 = (function (_super) {
    __extends(IndentUsingTabs, _super);
    function IndentUsingTabs() {
        return _super.call(this, false, {
            id: IndentUsingTabs_1.ID,
            label: nls.localize('indentUsingTabs', "Indent Using Tabs"),
            alias: 'Indent Using Tabs',
            precondition: null
        }) || this;
    }
    return IndentUsingTabs;
}(ChangeIndentationSizeAction));
IndentUsingTabs.ID = 'editor.action.indentUsingTabs';
IndentUsingTabs = IndentUsingTabs_1 = __decorate([
    editorCommonExtensions_1.editorAction
], IndentUsingTabs);
exports.IndentUsingTabs = IndentUsingTabs;
var IndentUsingSpaces = IndentUsingSpaces_1 = (function (_super) {
    __extends(IndentUsingSpaces, _super);
    function IndentUsingSpaces() {
        return _super.call(this, true, {
            id: IndentUsingSpaces_1.ID,
            label: nls.localize('indentUsingSpaces', "Indent Using Spaces"),
            alias: 'Indent Using Spaces',
            precondition: null
        }) || this;
    }
    return IndentUsingSpaces;
}(ChangeIndentationSizeAction));
IndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';
IndentUsingSpaces = IndentUsingSpaces_1 = __decorate([
    editorCommonExtensions_1.editorAction
], IndentUsingSpaces);
exports.IndentUsingSpaces = IndentUsingSpaces;
var DetectIndentation = DetectIndentation_1 = (function (_super) {
    __extends(DetectIndentation, _super);
    function DetectIndentation() {
        return _super.call(this, {
            id: DetectIndentation_1.ID,
            label: nls.localize('detectIndentation', "Detect Indentation from Content"),
            alias: 'Detect Indentation from Content',
            precondition: null
        }) || this;
    }
    DetectIndentation.prototype.run = function (accessor, editor) {
        var modelService = accessor.get(modelService_1.IModelService);
        var model = editor.getModel();
        if (!model) {
            return;
        }
        var creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language);
        model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
    };
    return DetectIndentation;
}(editorCommonExtensions_1.EditorAction));
DetectIndentation.ID = 'editor.action.detectIndentation';
DetectIndentation = DetectIndentation_1 = __decorate([
    editorCommonExtensions_1.editorAction
], DetectIndentation);
exports.DetectIndentation = DetectIndentation;
var ReindentLinesAction = (function (_super) {
    __extends(ReindentLinesAction, _super);
    function ReindentLinesAction() {
        return _super.call(this, {
            id: 'editor.action.reindentlines',
            label: nls.localize('editor.reindentlines', "Reindent Lines"),
            alias: 'Reindent Lines',
            precondition: editorCommon_1.EditorContextKeys.Writable
        }) || this;
    }
    ReindentLinesAction.prototype.run = function (accessor, editor) {
        var model = editor.getModel();
        if (!model) {
            return;
        }
        var edits = getReindentEditOperations(model, 1, model.getLineCount());
        if (edits) {
            editor.executeEdits(this.id, edits);
        }
    };
    return ReindentLinesAction;
}(editorCommonExtensions_1.EditorAction));
ReindentLinesAction = __decorate([
    editorCommonExtensions_1.editorAction
], ReindentLinesAction);
exports.ReindentLinesAction = ReindentLinesAction;
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
        // Model is empty
        return;
    }
    var spaces = '';
    for (var i = 0; i < tabSize; i++) {
        spaces += ' ';
    }
    var content = model.getLinesContent();
    for (var i = 0; i < content.length; i++) {
        var lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(i + 1);
        if (lastIndentationColumn === 0) {
            lastIndentationColumn = model.getLineMaxColumn(i + 1);
        }
        var text = (tabsToSpaces ? content[i].substr(0, lastIndentationColumn).replace(/\t/ig, spaces) :
            content[i].substr(0, lastIndentationColumn).replace(new RegExp(spaces, 'gi'), '\t')) +
            content[i].substr(lastIndentationColumn);
        builder.addEditOperation(new range_1.Range(i + 1, 1, i + 1, model.getLineMaxColumn(i + 1)), text);
    }
}
var IndentationToSpacesCommand = (function () {
    function IndentationToSpacesCommand(selection, tabSize) {
        this.selection = selection;
        this.tabSize = tabSize;
    }
    IndentationToSpacesCommand.prototype.getEditOperations = function (model, builder) {
        this.selectionId = builder.trackSelection(this.selection);
        getIndentationEditOperations(model, builder, this.tabSize, true);
    };
    IndentationToSpacesCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this.selectionId);
    };
    return IndentationToSpacesCommand;
}());
exports.IndentationToSpacesCommand = IndentationToSpacesCommand;
var IndentationToTabsCommand = (function () {
    function IndentationToTabsCommand(selection, tabSize) {
        this.selection = selection;
        this.tabSize = tabSize;
    }
    IndentationToTabsCommand.prototype.getEditOperations = function (model, builder) {
        this.selectionId = builder.trackSelection(this.selection);
        getIndentationEditOperations(model, builder, this.tabSize, false);
    };
    IndentationToTabsCommand.prototype.computeCursorState = function (model, helper) {
        return helper.getTrackedSelection(this.selectionId);
    };
    return IndentationToTabsCommand;
}());
exports.IndentationToTabsCommand = IndentationToTabsCommand;
var IndentationToSpacesAction_1, IndentationToTabsAction_1, IndentUsingTabs_1, IndentUsingSpaces_1, DetectIndentation_1;
