/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var lifecycle_1 = require("vs/base/common/lifecycle");
var position_1 = require("vs/editor/common/core/position");
var async_1 = require("vs/base/common/async");
var editorCommon = require("vs/editor/common/editorCommon");
var editorCommonExtensions_1 = require("vs/editor/common/editorCommonExtensions");
var configuration_1 = require("vs/platform/configuration/common/configuration");
var EditorContextKeys = editorCommon.EditorContextKeys;
var SelectBracketAction = (function (_super) {
    __extends(SelectBracketAction, _super);
    function SelectBracketAction() {
        return _super.call(this, {
            id: 'editor.action.jumpToBracket',
            label: nls.localize('smartSelect.jumpBracket', "Go to Bracket"),
            alias: 'Go to Bracket',
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 88 /* US_BACKSLASH */
            }
        }) || this;
    }
    SelectBracketAction.prototype.run = function (accessor, editor) {
        var controller = BracketMatchingController.get(editor);
        if (!controller) {
            return;
        }
        controller.jumpToBracket();
    };
    return SelectBracketAction;
}(editorCommonExtensions_1.EditorAction));
SelectBracketAction = __decorate([
    editorCommonExtensions_1.editorAction
], SelectBracketAction);
var BracketsData = (function () {
    function BracketsData(position, brackets) {
        this.position = position;
        this.brackets = brackets;
    }
    return BracketsData;
}());
var BracketMatchingController = BracketMatchingController_1 = (function (_super) {
    __extends(BracketMatchingController, _super);
    function BracketMatchingController(editor, configurationService) {
        var _this = _super.call(this) || this;
        _this.configurationService = configurationService;
        _this._editor = editor;
        _this._lastBracketsData = [];
        _this._lastVersionId = 0;
        _this._decorations = [];
        _this._updateBracketsSoon = _this._register(new async_1.RunOnceScheduler(function () { return _this._updateBrackets(); }, 50));
        _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;
        _this._updateBracketsSoon.schedule();
        _this._register(editor.onDidChangeCursorPosition(function (e) { return _this._updateBracketsSoon.schedule(); }));
        _this._register(editor.onDidChangeModel(function (e) { _this._decorations = []; _this._updateBracketsSoon.schedule(); }));
        _this._register(editor.onDidChangeConfiguration(function (e) {
            _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;
            if (!_this._matchBrackets && _this._decorations.length > 0) {
                // Remove existing decorations if bracket matching is off
                _this._decorations = _this._editor.deltaDecorations(_this._decorations, []);
            }
            _this._updateBracketsSoon.schedule();
        }));
        return _this;
    }
    BracketMatchingController.get = function (editor) {
        return editor.getContribution(BracketMatchingController_1.ID);
    };
    BracketMatchingController.prototype.getId = function () {
        return BracketMatchingController_1.ID;
    };
    BracketMatchingController.prototype.jumpToBracket = function () {
        var model = this._editor.getModel();
        if (!model) {
            return;
        }
        var selection = this._editor.getSelection();
        if (!selection.isEmpty()) {
            return;
        }
        var position = selection.getStartPosition();
        var brackets = model.matchBracket(position);
        if (!brackets) {
            return;
        }
        var resultingPosition = null;
        if (brackets[0].containsPosition(position)) {
            resultingPosition = brackets[1].getStartPosition();
        }
        else if (brackets[1].containsPosition(position)) {
            resultingPosition = brackets[0].getStartPosition();
        }
        if (resultingPosition) {
            this._editor.setPosition(resultingPosition);
            this._editor.revealPosition(resultingPosition);
        }
    };
    BracketMatchingController.prototype._updateBrackets = function () {
        if (!this._matchBrackets) {
            return;
        }
        this._recomputeBrackets();
        var newDecorations = [], newDecorationsLen = 0;
        for (var i = 0, len = this._lastBracketsData.length; i < len; i++) {
            var brackets = this._lastBracketsData[i].brackets;
            if (brackets) {
                newDecorations[newDecorationsLen++] = { range: brackets[0], options: BracketMatchingController_1._DECORATION_OPTIONS };
                newDecorations[newDecorationsLen++] = { range: brackets[1], options: BracketMatchingController_1._DECORATION_OPTIONS };
            }
        }
        this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
    };
    BracketMatchingController.prototype._recomputeBrackets = function () {
        var model = this._editor.getModel();
        if (!model) {
            // no model => no brackets!
            this._lastBracketsData = [];
            this._lastVersionId = 0;
            return;
        }
        var versionId = model.getVersionId();
        var previousData = [];
        if (this._lastVersionId === versionId) {
            // use the previous data only if the model is at the same version id
            previousData = this._lastBracketsData;
        }
        var selections = this._editor.getSelections();
        var positions = [], positionsLen = 0;
        for (var i = 0, len = selections.length; i < len; i++) {
            var selection = selections[i];
            if (selection.isEmpty()) {
                // will bracket match a cursor only if the selection is collapsed
                positions[positionsLen++] = selection.getStartPosition();
            }
        }
        // sort positions for `previousData` cache hits
        if (positions.length > 1) {
            positions.sort(position_1.Position.compare);
        }
        var newData = [], newDataLen = 0;
        var previousIndex = 0, previousLen = previousData.length;
        for (var i = 0, len = positions.length; i < len; i++) {
            var position = positions[i];
            while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
                previousIndex++;
            }
            if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
                newData[newDataLen++] = previousData[previousIndex];
            }
            else {
                var brackets = model.matchBracket(position);
                newData[newDataLen++] = new BracketsData(position, brackets);
            }
        }
        this._lastBracketsData = newData;
        this._lastVersionId = versionId;
    };
    return BracketMatchingController;
}(lifecycle_1.Disposable));
BracketMatchingController.ID = 'editor.contrib.bracketMatchingController';
BracketMatchingController._DECORATION_OPTIONS = {
    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
    className: 'bracket-match'
};
BracketMatchingController = BracketMatchingController_1 = __decorate([
    editorCommonExtensions_1.commonEditorContribution,
    __param(1, configuration_1.IConfigurationService)
], BracketMatchingController);
exports.BracketMatchingController = BracketMatchingController;
var BracketMatchingController_1;
