/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
require("./list.css");
var lifecycle_1 = require("vs/base/common/lifecycle");
var types_1 = require("vs/base/common/types");
var decorators_1 = require("vs/base/common/decorators");
var DOM = require("vs/base/browser/dom");
var touch_1 = require("vs/base/browser/touch");
var keyboardEvent_1 = require("vs/base/browser/keyboardEvent");
var event_1 = require("vs/base/common/event");
var event_2 = require("vs/base/browser/event");
var listView_1 = require("./listView");
var CombinedSpliceable = (function () {
    function CombinedSpliceable(spliceables) {
        this.spliceables = spliceables;
    }
    CombinedSpliceable.prototype.splice = function (start, deleteCount, elements) {
        this.spliceables.forEach(function (s) { return s.splice(start, deleteCount, elements); });
    };
    return CombinedSpliceable;
}());
var TraitRenderer = (function () {
    function TraitRenderer(controller, renderer) {
        this.controller = controller;
        this.renderer = renderer;
    }
    Object.defineProperty(TraitRenderer.prototype, "templateId", {
        get: function () {
            return this.renderer.templateId;
        },
        enumerable: true,
        configurable: true
    });
    TraitRenderer.prototype.renderTemplate = function (container) {
        var data = this.renderer.renderTemplate(container);
        return { container: container, data: data };
    };
    TraitRenderer.prototype.renderElement = function (element, index, templateData) {
        this.controller.renderElement(element, index, templateData.container);
        this.renderer.renderElement(element, index, templateData.data);
    };
    TraitRenderer.prototype.disposeTemplate = function (templateData) {
        return this.renderer.disposeTemplate(templateData.data);
    };
    return TraitRenderer;
}());
var Trait = (function () {
    function Trait(_trait) {
        this._trait = _trait;
        this._onChange = new event_1.Emitter();
        this.indexes = [];
    }
    Object.defineProperty(Trait.prototype, "onChange", {
        get: function () { return this._onChange.event; },
        enumerable: true,
        configurable: true
    });
    Trait.prototype.splice = function (start, deleteCount, elements) {
        var diff = elements.length - deleteCount;
        var end = start + deleteCount;
        var indexes = this.indexes.filter(function (i) { return i < start; }).concat(elements.reduce(function (r, hasTrait, i) { return hasTrait ? r.concat([i + start]) : r; }, []), this.indexes.filter(function (i) { return i >= end; }).map(function (i) { return i + diff; }));
        this.set(indexes);
    };
    Trait.prototype.renderElement = function (element, index, container) {
        DOM.toggleClass(container, this._trait, this.contains(index));
    };
    Trait.prototype.set = function (indexes) {
        var result = this.indexes;
        this.indexes = indexes;
        this._onChange.fire({ indexes: indexes });
        return result;
    };
    Trait.prototype.get = function () {
        return this.indexes;
    };
    Trait.prototype.contains = function (index) {
        return this.indexes.some(function (i) { return i === index; });
    };
    Trait.prototype.wrapRenderer = function (renderer) {
        return new TraitRenderer(this, renderer);
    };
    Trait.prototype.dispose = function () {
        this.indexes = null;
        this._onChange = lifecycle_1.dispose(this._onChange);
    };
    return Trait;
}());
var FocusTrait = (function (_super) {
    __extends(FocusTrait, _super);
    function FocusTrait(getDomId) {
        var _this = _super.call(this, 'focused') || this;
        _this.getDomId = getDomId;
        return _this;
    }
    FocusTrait.prototype.renderElement = function (element, index, container) {
        _super.prototype.renderElement.call(this, element, index, container);
        container.setAttribute('role', 'treeitem');
        container.setAttribute('id', this.getDomId(index));
    };
    return FocusTrait;
}(Trait));
/**
 * The TraitSpliceable is used as a util class to be able
 * to preserve traits across splice calls, given an identity
 * provider.
 */
var TraitSpliceable = (function () {
    function TraitSpliceable(trait, view, getId) {
        this.trait = trait;
        this.view = view;
        this.getId = getId;
    }
    TraitSpliceable.prototype.splice = function (start, deleteCount, elements) {
        var _this = this;
        if (!this.getId) {
            return this.trait.splice(start, deleteCount, elements.map(function (e) { return false; }));
        }
        var pastElementsWithTrait = this.trait.get().map(function (i) { return _this.getId(_this.view.element(i)); });
        var elementsWithTrait = elements.map(function (e) { return pastElementsWithTrait.indexOf(_this.getId(e)) > -1; });
        this.trait.splice(start, deleteCount, elementsWithTrait);
    };
    return TraitSpliceable;
}());
var KeyboardController = (function () {
    function KeyboardController(list, view) {
        this.list = list;
        this.view = view;
        this.disposables = [];
        var onKeyDown = event_1.chain(event_2.domEvent(view.domNode, 'keydown'))
            .map(function (e) { return new keyboardEvent_1.StandardKeyboardEvent(e); });
        onKeyDown.filter(function (e) { return e.keyCode === 3 /* Enter */; }).on(this.onEnter, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 16 /* UpArrow */; }).on(this.onUpArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 18 /* DownArrow */; }).on(this.onDownArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 11 /* PageUp */; }).on(this.onPageUpArrow, this, this.disposables);
        onKeyDown.filter(function (e) { return e.keyCode === 12 /* PageDown */; }).on(this.onPageDownArrow, this, this.disposables);
    }
    KeyboardController.prototype.onEnter = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.open(this.list.getFocus());
    };
    KeyboardController.prototype.onUpArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusPrevious();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onDownArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusNext();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onPageUpArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusPreviousPage();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.onPageDownArrow = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.list.focusNextPage();
        this.list.reveal(this.list.getFocus()[0]);
        this.view.domNode.focus();
    };
    KeyboardController.prototype.dispose = function () {
        this.disposables = lifecycle_1.dispose(this.disposables);
    };
    return KeyboardController;
}());
var MouseController = (function () {
    function MouseController(list, view) {
        var _this = this;
        this.list = list;
        this.view = view;
        this.disposables = [];
        this.disposables.push(view.addListener('mousedown', function (e) { return _this.onMouseDown(e); }));
        this.disposables.push(view.addListener('click', function (e) { return _this.onPointer(e); }));
        this.disposables.push(view.addListener(touch_1.EventType.Tap, function (e) { return _this.onPointer(e); }));
    }
    MouseController.prototype.onMouseDown = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    MouseController.prototype.onPointer = function (e) {
        e.preventDefault();
        e.stopPropagation();
        this.view.domNode.focus();
        this.list.setFocus([e.index]);
        this.list.open([e.index]);
    };
    MouseController.prototype.dispose = function () {
        this.disposables = lifecycle_1.dispose(this.disposables);
    };
    return MouseController;
}());
var DefaultOptions = {
    keyboardSupport: true,
    mouseSupport: true
};
var List = (function () {
    function List(container, delegate, renderers, options) {
        if (options === void 0) { options = DefaultOptions; }
        var _this = this;
        this.idPrefix = "list_id_" + ++List.InstanceCount;
        this._onOpen = new event_1.Emitter();
        this._onDOMFocus = new event_1.Emitter();
        this._onDOMBlur = new event_1.Emitter();
        this._onDispose = new event_1.Emitter();
        this.focus = new FocusTrait(function (i) { return _this.getElementDomId(i); });
        this.selection = new Trait('selected');
        this.eventBufferer = new event_1.EventBufferer();
        renderers = renderers.map(function (r) {
            r = _this.focus.wrapRenderer(r);
            r = _this.selection.wrapRenderer(r);
            return r;
        });
        this.view = new listView_1.ListView(container, delegate, renderers, options);
        this.view.domNode.setAttribute('role', 'tree');
        this.view.domNode.tabIndex = 0;
        this.spliceable = new CombinedSpliceable([
            new TraitSpliceable(this.focus, this.view, options.identityProvider),
            new TraitSpliceable(this.selection, this.view, options.identityProvider),
            this.view
        ]);
        this.disposables = [this.focus, this.selection, this.view, this._onDispose];
        var tracker = DOM.trackFocus(this.view.domNode);
        this.disposables.push(tracker.addFocusListener(function () { return _this._onDOMFocus.fire(); }));
        this.disposables.push(tracker.addBlurListener(function () { return _this._onDOMBlur.fire(); }));
        if (typeof options.keyboardSupport !== 'boolean' || options.keyboardSupport) {
            this.disposables.push(new KeyboardController(this, this.view));
        }
        if (typeof options.mouseSupport !== 'boolean' || options.mouseSupport) {
            this.disposables.push(new MouseController(this, this.view));
        }
        this.onFocusChange(this._onFocusChange, this, this.disposables);
        if (options.ariaLabel) {
            this.view.domNode.setAttribute('aria-label', options.ariaLabel);
        }
    }
    Object.defineProperty(List.prototype, "onFocusChange", {
        get: function () {
            var _this = this;
            return event_1.mapEvent(this.eventBufferer.wrapEvent(this.focus.onChange), function (e) { return _this.toListEvent(e); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onSelectionChange", {
        get: function () {
            var _this = this;
            return event_1.mapEvent(this.eventBufferer.wrapEvent(this.selection.onChange), function (e) { return _this.toListEvent(e); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onContextMenu", {
        get: function () {
            var _this = this;
            return event_1.fromCallback(function (handler) { return _this.view.addListener('contextmenu', handler); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onOpen", {
        get: function () {
            var _this = this;
            return event_1.mapEvent(this._onOpen.event, function (indexes) { return _this.toListEvent({ indexes: indexes }); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onDOMFocus", {
        get: function () { return this._onDOMFocus.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onDOMBlur", {
        get: function () { return this._onDOMBlur.event; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "onDispose", {
        get: function () { return this._onDispose.event; },
        enumerable: true,
        configurable: true
    });
    List.prototype.splice = function (start, deleteCount, elements) {
        var _this = this;
        if (elements === void 0) { elements = []; }
        this.eventBufferer.bufferEvents(function () { return _this.spliceable.splice(start, deleteCount, elements); });
    };
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            return this.view.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "contentHeight", {
        get: function () {
            return this.view.getContentHeight();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "scrollTop", {
        get: function () {
            return this.view.getScrollTop();
        },
        set: function (scrollTop) {
            this.view.setScrollTop(scrollTop);
        },
        enumerable: true,
        configurable: true
    });
    List.prototype.layout = function (height) {
        this.view.layout(height);
    };
    List.prototype.setSelection = function (indexes) {
        var _this = this;
        this.eventBufferer.bufferEvents(function () {
            indexes = indexes.concat(_this.selection.set(indexes));
            indexes.forEach(function (i) { return _this.view.splice(i, 1, [_this.view.element(i)]); });
        });
    };
    List.prototype.selectNext = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var selection = this.selection.get();
        var index = selection.length > 0 ? selection[0] + n : 0;
        this.setSelection(loop ? [index % this.length] : [Math.min(index, this.length - 1)]);
    };
    List.prototype.selectPrevious = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var selection = this.selection.get();
        var index = selection.length > 0 ? selection[0] - n : 0;
        if (loop && index < 0) {
            index = this.length + (index % this.length);
        }
        this.setSelection([Math.max(index, 0)]);
    };
    List.prototype.getSelection = function () {
        return this.selection.get();
    };
    List.prototype.setFocus = function (indexes) {
        var _this = this;
        this.eventBufferer.bufferEvents(function () {
            indexes = indexes.concat(_this.focus.set(indexes));
            indexes.forEach(function (i) { return _this.view.splice(i, 1, [_this.view.element(i)]); });
        });
    };
    List.prototype.focusNext = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var focus = this.focus.get();
        var index = focus.length > 0 ? focus[0] + n : 0;
        this.setFocus(loop ? [index % this.length] : [Math.min(index, this.length - 1)]);
    };
    List.prototype.focusPrevious = function (n, loop) {
        if (n === void 0) { n = 1; }
        if (loop === void 0) { loop = false; }
        if (this.length === 0) {
            return;
        }
        var focus = this.focus.get();
        var index = focus.length > 0 ? focus[0] - n : 0;
        if (loop && index < 0) {
            index = (this.length + (index % this.length)) % this.length;
        }
        this.setFocus([Math.max(index, 0)]);
    };
    List.prototype.focusNextPage = function () {
        var _this = this;
        var lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
        lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
        var lastPageElement = this.view.element(lastPageIndex);
        var currentlyFocusedElement = this.getFocusedElements()[0];
        if (currentlyFocusedElement !== lastPageElement) {
            this.setFocus([lastPageIndex]);
        }
        else {
            var previousScrollTop = this.view.getScrollTop();
            this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));
            if (this.view.getScrollTop() !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () { return _this.focusNextPage(); }, 0);
            }
        }
    };
    List.prototype.focusPreviousPage = function () {
        var _this = this;
        var firstPageIndex;
        var scrollTop = this.view.getScrollTop();
        if (scrollTop === 0) {
            firstPageIndex = this.view.indexAt(scrollTop);
        }
        else {
            firstPageIndex = this.view.indexAfter(scrollTop - 1);
        }
        var firstPageElement = this.view.element(firstPageIndex);
        var currentlyFocusedElement = this.getFocusedElements()[0];
        if (currentlyFocusedElement !== firstPageElement) {
            this.setFocus([firstPageIndex]);
        }
        else {
            var previousScrollTop = scrollTop;
            this.view.setScrollTop(scrollTop - this.view.renderHeight);
            if (this.view.getScrollTop() !== previousScrollTop) {
                // Let the scroll event listener run
                setTimeout(function () { return _this.focusPreviousPage(); }, 0);
            }
        }
    };
    List.prototype.getFocus = function () {
        return this.focus.get();
    };
    List.prototype.getFocusedElements = function () {
        var _this = this;
        return this.getFocus().map(function (i) { return _this.view.element(i); });
    };
    List.prototype.reveal = function (index, relativeTop) {
        var scrollTop = this.view.getScrollTop();
        var elementTop = this.view.elementTop(index);
        var elementHeight = this.view.elementHeight(index);
        if (types_1.isNumber(relativeTop)) {
            relativeTop = relativeTop < 0 ? 0 : relativeTop;
            relativeTop = relativeTop > 1 ? 1 : relativeTop;
            // y = mx + b
            var m = elementHeight - this.view.renderHeight;
            this.view.setScrollTop(m * relativeTop + elementTop);
        }
        else {
            var viewItemBottom = elementTop + elementHeight;
            var wrapperBottom = scrollTop + this.view.renderHeight;
            if (elementTop < scrollTop) {
                this.view.setScrollTop(elementTop);
            }
            else if (viewItemBottom >= wrapperBottom) {
                this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
            }
        }
    };
    List.prototype.getElementDomId = function (index) {
        return this.idPrefix + "_" + index;
    };
    List.prototype.isDOMFocused = function () {
        return this.view.domNode === document.activeElement;
    };
    List.prototype.getHTMLElement = function () {
        return this.view.domNode;
    };
    List.prototype.open = function (indexes) {
        this.setSelection(indexes);
        this._onOpen.fire(indexes);
    };
    List.prototype.toListEvent = function (_a) {
        var _this = this;
        var indexes = _a.indexes;
        return { indexes: indexes, elements: indexes.map(function (i) { return _this.view.element(i); }) };
    };
    List.prototype._onFocusChange = function () {
        var focus = this.focus.get();
        if (focus.length > 0) {
            this.view.domNode.setAttribute('aria-activedescendant', this.getElementDomId(focus[0]));
        }
        else {
            this.view.domNode.removeAttribute('aria-activedescendant');
        }
        this.view.domNode.setAttribute('role', 'tree');
        DOM.toggleClass(this.view.domNode, 'element-focused', focus.length > 0);
    };
    List.prototype.dispose = function () {
        this._onDispose.fire();
        this.disposables = lifecycle_1.dispose(this.disposables);
    };
    return List;
}());
List.InstanceCount = 0;
__decorate([
    decorators_1.memoize
], List.prototype, "onFocusChange", null);
__decorate([
    decorators_1.memoize
], List.prototype, "onSelectionChange", null);
__decorate([
    decorators_1.memoize
], List.prototype, "onContextMenu", null);
__decorate([
    decorators_1.memoize
], List.prototype, "onOpen", null);
exports.List = List;
