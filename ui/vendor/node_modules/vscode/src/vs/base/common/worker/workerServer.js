/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var errors_1 = require('vs/base/common/errors');
var marshalling_1 = require('vs/base/common/marshalling');
var workerProtocol = require('vs/base/common/worker/workerProtocol');
var WorkerServer = (function () {
    function WorkerServer(postSerializedMessage) {
        this._postSerializedMessage = postSerializedMessage;
        this._workerId = 0;
        this._requestHandler = null;
        this._bindConsole();
    }
    WorkerServer.prototype._bindConsole = function () {
        self.console = {
            log: this._sendPrintMessage.bind(this, workerProtocol.PrintType.LOG),
            debug: this._sendPrintMessage.bind(this, workerProtocol.PrintType.DEBUG),
            info: this._sendPrintMessage.bind(this, workerProtocol.PrintType.INFO),
            warn: this._sendPrintMessage.bind(this, workerProtocol.PrintType.WARN),
            error: this._sendPrintMessage.bind(this, workerProtocol.PrintType.ERROR)
        };
        errors_1.setUnexpectedErrorHandler(function (e) {
            self.console.error(e);
        });
    };
    WorkerServer.prototype._sendPrintMessage = function (level) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        var transformedObjects = objects.map(function (obj) { return (obj instanceof Error) ? errors_1.transformErrorForSerialization(obj) : obj; });
        var msg = {
            monacoWorker: true,
            from: this._workerId,
            req: '0',
            type: workerProtocol.MessageType.PRINT,
            level: level,
            payload: (transformedObjects.length === 1 ? transformedObjects[0] : transformedObjects)
        };
        this._postMessage(msg);
    };
    WorkerServer.prototype._sendReply = function (msgId, action, payload) {
        var msg = {
            monacoWorker: true,
            from: this._workerId,
            req: '0',
            id: msgId,
            type: workerProtocol.MessageType.REPLY,
            action: action,
            payload: (payload instanceof Error) ? errors_1.transformErrorForSerialization(payload) : payload
        };
        this._postMessage(msg);
    };
    WorkerServer.prototype.loadModule = function (moduleId, callback, errorback) {
        // Use the global require to be sure to get the global config
        self.require([moduleId], function () {
            var result = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                result[_i - 0] = arguments[_i];
            }
            callback(result[0]);
        }, errorback);
    };
    WorkerServer.prototype.onmessage = function (msg) {
        this._onmessage(marshalling_1.parse(msg));
    };
    WorkerServer.prototype._postMessage = function (msg) {
        this._postSerializedMessage(marshalling_1.stringify(msg));
    };
    WorkerServer.prototype._onmessage = function (msg) {
        var _this = this;
        var c = this._sendReply.bind(this, msg.id, workerProtocol.ReplyType.COMPLETE);
        var e = this._sendReply.bind(this, msg.id, workerProtocol.ReplyType.ERROR);
        var p = this._sendReply.bind(this, msg.id, workerProtocol.ReplyType.PROGRESS);
        switch (msg.type) {
            case workerProtocol.MessageType.INITIALIZE:
                this._workerId = msg.payload.id;
                var loaderConfig = msg.payload.loaderConfiguration;
                // TODO@Alex: share this code with simpleWorker
                if (loaderConfig) {
                    // Remove 'baseUrl', handling it is beyond scope for now
                    if (typeof loaderConfig.baseUrl !== 'undefined') {
                        delete loaderConfig['baseUrl'];
                    }
                    if (typeof loaderConfig.paths !== 'undefined') {
                        if (typeof loaderConfig.paths.vs !== 'undefined') {
                            delete loaderConfig.paths['vs'];
                        }
                    }
                    var nlsConfig_1 = loaderConfig['vs/nls'];
                    // We need to have pseudo translation
                    if (nlsConfig_1 && nlsConfig_1.pseudo) {
                        require(['vs/nls'], function (nlsPlugin) {
                            nlsPlugin.setPseudoTranslation(nlsConfig_1.pseudo);
                        });
                    }
                    // Since this is in a web worker, enable catching errors
                    loaderConfig.catchError = true;
                    self.require.config(loaderConfig);
                }
                this.loadModule(msg.payload.moduleId, function (handlerModule) {
                    _this._requestHandler = handlerModule.value;
                    c();
                }, e);
                break;
            default:
                this._handleMessage(msg, c, e, p);
                break;
        }
    };
    WorkerServer.prototype._handleMessage = function (msg, c, e, p) {
        if (!this._requestHandler) {
            e('Request handler not loaded');
            return;
        }
        var handlerMethod = this._requestHandler[msg.type];
        if (typeof handlerMethod !== 'function') {
            e('Handler does not have method ' + msg.type);
            return;
        }
        try {
            handlerMethod.call(this._requestHandler, this, c, e, p, msg.payload);
        }
        catch (handlerError) {
            e(errors_1.transformErrorForSerialization(handlerError));
        }
    };
    return WorkerServer;
}());
exports.WorkerServer = WorkerServer;
function create(postMessage) {
    return new WorkerServer(postMessage);
}
exports.create = create;
