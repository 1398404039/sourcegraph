/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var platform = require("vs/base/common/platform");
var types = require("vs/base/common/types");
var paths_1 = require("vs/base/common/paths");
var strings_1 = require("vs/base/common/strings");
var PathLabelProvider = (function () {
    function PathLabelProvider(arg1) {
        this.root = arg1 && getPath(arg1);
    }
    PathLabelProvider.prototype.getLabel = function (arg1) {
        return getPathLabel(getPath(arg1), this.root);
    };
    return PathLabelProvider;
}());
exports.PathLabelProvider = PathLabelProvider;
function getPathLabel(resource, basePathProvider) {
    var absolutePath = getPath(resource);
    if (!absolutePath) {
        return null;
    }
    var basepath = basePathProvider && getPath(basePathProvider);
    if (basepath && paths_1.isEqualOrParent(absolutePath, basepath)) {
        if (basepath === absolutePath) {
            return ''; // no label if pathes are identical
        }
        return paths_1.normalize(strings_1.ltrim(absolutePath.substr(basepath.length), paths_1.nativeSep), true);
    }
    if (platform.isWindows && absolutePath && absolutePath[1] === ':') {
        return paths_1.normalize(absolutePath.charAt(0).toUpperCase() + absolutePath.slice(1), true); // convert c:\something => C:\something
    }
    return paths_1.normalize(absolutePath, true);
}
exports.getPathLabel = getPathLabel;
function getPath(arg1) {
    if (!arg1) {
        return null;
    }
    if (typeof arg1 === 'string') {
        return arg1;
    }
    if (types.isFunction(arg1.getWorkspace)) {
        var ws = arg1.getWorkspace();
        return ws ? ws.resource.fsPath : void 0;
    }
    return arg1.fsPath;
}
function tildify(path, userHome) {
    if (path && (platform.isMacintosh || platform.isLinux) && path.indexOf(userHome) === 0) {
        path = "~" + path.substr(userHome.length);
    }
    return path;
}
exports.tildify = tildify;
/**
 * Shortens the paths but keeps them easy to distinguish.
 * Replaces not important parts with ellipsis.
 * Every shorten path matches only one original path and vice versa.
 */
var ellipsis = '\u2026';
var unc = '\\\\';
function shorten(paths) {
    var shortenedPaths = new Array(paths.length);
    // for every path
    var match = false;
    for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
        var path = paths[pathIndex];
        if (path === '') {
            shortenedPaths[pathIndex] = '.';
            continue;
        }
        if (!path) {
            shortenedPaths[pathIndex] = path;
            continue;
        }
        match = true;
        // trim for now and concatenate unc path (e.g. \\network) or root path (/etc) later
        var prefix = '';
        if (path.indexOf(unc) === 0) {
            prefix = path.substr(0, path.indexOf(unc) + unc.length);
            path = path.substr(path.indexOf(unc) + unc.length);
        }
        else if (path.indexOf(paths_1.nativeSep) === 0) {
            prefix = path.substr(0, path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
            path = path.substr(path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
        }
        // pick the first shortest subpath found
        var segments = path.split(paths_1.nativeSep);
        for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
            for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                match = false;
                var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                // that is unique to any other path
                for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                    // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                    if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                        var isSubpathEnding = (start + subpathLength === segments.length);
                        var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpath);
                        match = !isSubpathEnding || isOtherPathEnding;
                    }
                }
                // found unique subpath
                if (!match) {
                    var result = '';
                    // preserve disk drive or root prefix
                    if (strings_1.endsWith(segments[0], ':') || prefix !== '') {
                        if (start === 1) {
                            // extend subpath to include disk drive prefix
                            start = 0;
                            subpathLength++;
                            subpath = segments[0] + paths_1.nativeSep + subpath;
                        }
                        if (start > 0) {
                            result = segments[0] + paths_1.nativeSep;
                        }
                        result = prefix + result;
                    }
                    // add ellipsis at the beginning if neeeded
                    if (start > 0) {
                        result = result + ellipsis + paths_1.nativeSep;
                    }
                    result = result + subpath;
                    // add ellipsis at the end if needed
                    if (start + subpathLength < segments.length) {
                        result = result + paths_1.nativeSep + ellipsis;
                    }
                    shortenedPaths[pathIndex] = result;
                }
            }
        }
        if (match) {
            shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
        }
    }
    return shortenedPaths;
}
exports.shorten = shorten;
var Type;
(function (Type) {
    Type[Type["TEXT"] = 0] = "TEXT";
    Type[Type["VARIABLE"] = 1] = "VARIABLE";
    Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
})(Type || (Type = {}));
/**
 * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
 * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
 * @param value string to which templating is applied
 * @param values the values of the templates to use
 */
function template(template, values) {
    if (values === void 0) { values = Object.create(null); }
    var segments = [];
    var inVariable = false;
    var char;
    var curVal = '';
    for (var i = 0; i < template.length; i++) {
        char = template[i];
        // Beginning of variable
        if (char === '$' || (inVariable && char === '{')) {
            if (curVal) {
                segments.push({ value: curVal, type: Type.TEXT });
            }
            curVal = '';
            inVariable = true;
        }
        else if (char === '}' && inVariable) {
            var resolved = values[curVal];
            // Variable
            if (typeof resolved === 'string') {
                if (resolved.length) {
                    segments.push({ value: resolved, type: Type.VARIABLE });
                }
            }
            else if (resolved) {
                var prevSegment = segments[segments.length - 1];
                if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                    segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                }
            }
            curVal = '';
            inVariable = false;
        }
        else {
            curVal += char;
        }
    }
    // Tail
    if (curVal && !inVariable) {
        segments.push({ value: curVal, type: Type.TEXT });
    }
    return segments.filter(function (segment, index) {
        // Only keep separator if we have values to the left and right
        if (segment.type === Type.SEPARATOR) {
            var left = segments[index - 1];
            var right = segments[index + 1];
            return [left, right].every(function (segment) { return segment && segment.type === Type.VARIABLE && segment.value.length > 0; });
        }
        // accept any TEXT and VARIABLE
        return true;
    }).map(function (segment) { return segment.value; }).join('');
}
exports.template = template;
