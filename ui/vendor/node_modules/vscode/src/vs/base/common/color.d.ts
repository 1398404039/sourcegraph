export declare class RGBA {
    _rgbaBrand: void;
    /**
     * Red: integer in [0-255]
     */
    readonly r: number;
    /**
     * Green: integer in [0-255]
     */
    readonly g: number;
    /**
     * Blue: integer in [0-255]
     */
    readonly b: number;
    /**
     * Alpha: integer in [0-255]
     */
    readonly a: number;
    constructor(r: number, g: number, b: number, a: number);
    static equals(a: RGBA, b: RGBA): boolean;
    private static _clampInt_0_255(c);
}
/**
 * http://en.wikipedia.org/wiki/HSL_color_space
 */
export declare class HSLA {
    _hslaBrand: void;
    /**
     * Hue: float in [0, 360]
     */
    readonly h: number;
    /**
     * Saturation: float in [0, 1]
     */
    readonly s: number;
    /**
     * Luminosity: float in [0, 1]
     */
    readonly l: number;
    /**
     * Alpha: float in [0, 1]
     */
    readonly a: number;
    constructor(h: number, s: number, l: number, a: number);
    private static _clampFloat_0_360(hue);
    private static _clampFloat_0_1(n);
}
export declare function isValidHexColor(hex: string): boolean;
export declare class Color {
    static fromRGBA(rgba: RGBA): Color;
    /**
     * Creates a color from a hex string (#RRGGBB or #RRGGBBAA).
     */
    static fromHex(hex: string): Color;
    static fromHSLA(hsla: HSLA): Color;
    private readonly rgba;
    private constructor(arg);
    equals(other: Color): boolean;
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getLuminosity(): number;
    private static _luminosityFor(color);
    /**
     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
     * Returns the contrast ration number in the set [1, 21].
     */
    getContrast(another: Color): number;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if darker color otherwise 'false'
     */
    isDarker(): boolean;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter(): boolean;
    isLighterThan(another: Color): boolean;
    isDarkerThan(another: Color): boolean;
    lighten(factor: number): Color;
    darken(factor: number): Color;
    transparent(factor: number): Color;
    opposite(): Color;
    toString(): string;
    /**
     * Prins the color as #RRGGBB
     */
    toRGBHex(): string;
    /**
     * Prins the color as #RRGGBBAA
     * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
     */
    toRGBAHex(compact?: boolean): string;
    private static _toTwoDigitHex(n);
    toHSLA(): HSLA;
    toRGBA(): RGBA;
    static getLighterColor(of: Color, relative: Color, factor?: number): Color;
    static getDarkerColor(of: Color, relative: Color, factor?: number): Color;
}
