/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var net_1 = require("net");
var winjs_base_1 = require("vs/base/common/winjs.base");
var event_1 = require("vs/base/common/event");
var event_2 = require("vs/base/node/event");
var ipc_1 = require("vs/base/parts/ipc/common/ipc");
function bufferIndexOf(buffer, value, start) {
    if (start === void 0) { start = 0; }
    while (start < buffer.length && buffer[start] !== value) {
        start++;
    }
    return start;
}
var Protocol = (function () {
    function Protocol(socket) {
        this.socket = socket;
        var buffer = null;
        var emitter = new event_1.Emitter();
        var onRawData = event_2.fromEventEmitter(socket, 'data', function (data) { return data; });
        onRawData(function (data) {
            var lastIndex = 0;
            var index = 0;
            while ((index = bufferIndexOf(data, 0, lastIndex)) < data.length) {
                var dataToParse = data.slice(lastIndex, index);
                if (buffer) {
                    emitter.fire(JSON.parse(Buffer.concat([buffer, dataToParse]).toString('utf8')));
                    buffer = null;
                }
                else {
                    emitter.fire(JSON.parse(dataToParse.toString('utf8')));
                }
                lastIndex = index + 1;
            }
            if (index - lastIndex > 0) {
                var dataToBuffer = data.slice(lastIndex, index);
                if (buffer) {
                    buffer = Buffer.concat([buffer, dataToBuffer]);
                }
                else {
                    buffer = dataToBuffer;
                }
            }
        });
        this._onMessage = emitter.event;
    }
    Object.defineProperty(Protocol.prototype, "onMessage", {
        get: function () { return this._onMessage; },
        enumerable: true,
        configurable: true
    });
    Protocol.prototype.send = function (message) {
        try {
            this.socket.write(JSON.stringify(message));
            this.socket.write(Protocol.Boundary);
        }
        catch (e) {
        }
    };
    return Protocol;
}());
Protocol.Boundary = new Buffer([0]);
var Server = (function (_super) {
    __extends(Server, _super);
    function Server(server) {
        var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;
        _this.server = server;
        return _this;
    }
    Server.toClientConnectionEvent = function (server) {
        var onConnection = event_2.fromEventEmitter(server, 'connection');
        return event_1.mapEvent(onConnection, function (socket) { return ({
            protocol: new Protocol(socket),
            onDidClientDisconnect: event_1.once(event_2.fromEventEmitter(socket, 'close'))
        }); });
    };
    Server.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.server.close();
        this.server = null;
    };
    return Server;
}(ipc_1.IPCServer));
exports.Server = Server;
var Client = (function (_super) {
    __extends(Client, _super);
    function Client(socket, id) {
        var _this = _super.call(this, new Protocol(socket), id) || this;
        _this.socket = socket;
        _this._onClose = new event_1.Emitter();
        socket.once('close', function () { return _this._onClose.fire(); });
        return _this;
    }
    Object.defineProperty(Client.prototype, "onClose", {
        get: function () { return this._onClose.event; },
        enumerable: true,
        configurable: true
    });
    Client.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.socket.end();
        this.socket = null;
    };
    return Client;
}(ipc_1.IPCClient));
exports.Client = Client;
function serve(hook) {
    return new winjs_base_1.TPromise(function (c, e) {
        var server = net_1.createServer();
        server.on('error', e);
        server.listen(hook, function () {
            server.removeListener('error', e);
            c(new Server(server));
        });
    });
}
exports.serve = serve;
function connect(hook, clientId) {
    return new winjs_base_1.TPromise(function (c, e) {
        var socket = net_1.createConnection(hook, function () {
            socket.removeListener('error', e);
            c(new Client(socket, clientId));
        });
        socket.once('error', e);
    });
}
exports.connect = connect;
