import * as autobind from "autobind-decorator";
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as platform from "vs/base/common/platform";

import { context } from "sourcegraph/app/context";
import { Router, RouterLocation } from "sourcegraph/app/router";
import { Annotation, Boom, Button, Heading } from "sourcegraph/components";
import { GitHubAuthButton } from "sourcegraph/components/GitHubAuthButton";
import { Close, Flag } from "sourcegraph/components/symbols/Primaries";
import { colors, typography, whitespace } from "sourcegraph/components/utils";
import { fontStack } from "sourcegraph/components/utils/typography";
import * as Dispatcher from "sourcegraph/Dispatcher";
import { getEditorInstance } from "sourcegraph/editor/Editor";
import * as OrgActions from "sourcegraph/org/OrgActions";
import * as AnalyticsConstants from "sourcegraph/util/constants/AnalyticsConstants";
import { EventLogger } from "sourcegraph/util/EventLogger";
import { privateGitHubOAuthScopes } from "sourcegraph/util/urlTo";

interface Props { location: RouterLocation; }

interface State {
	visibleMarks: number[];
	visibleAnnotation: number | null;
	viewedAnnotations: number[];
}

const _defCoachmarkIndex = 0;
const _refCoachmarkIndex = 1;
const _searchCoachmarkIndex = 2;

interface Coachmark {
	markIndex: number;
	markParentElementId: string;
	markId: string;
	markLineNumber: number;
	headingTitle: string;
	headingSubtitle: JSX.Element | null;
	actionTitle: string;
	actionCTA: JSX.Element | null;

}

const parentElementCssString = `display: inline-block; white-space: normal; cursor: auto; font-family: ${fontStack.sansSerif};`;

// Coachmark element by ID. By omitting the language and
// ending the classname with a space allows us to render
// coachmarks on any language.
const coachmarkLanguageIdentifier = "token identifier ";

const closeSx = {
	cursor: "pointer",
	float: "right",
	paddingRight: whitespace[3],
	paddingTop: whitespace[3],
};

const actionSx = Object.assign(
	{
		backgroundColor: colors.blue(),
		color: colors.white(),
		display: "inline-block",
		paddingLeft: whitespace[2],
		paddingBottom: whitespace[2],
		width: 240,
	},
	typography.size[6],
);

const headerSx = {
	backgroundColor: colors.white(),
	borderTopLeftRadius: 3,
	borderTopRightRadius: 3,
	paddingTop: whitespace[4],
	paddingLeft: whitespace[4],
	paddingRight: whitespace[4],
	paddingBottom: whitespace[2],
};

const p = Object.assign(
	{
		width: 270,
		color: colors.text(),
	},
	typography.size[6],
);

const flagSx = {
	marginTop: whitespace[1],
	verticalAlign: "top",
};

const searchSx = {
	backgroundColor: colors.blueGrayL3(0.8),
	borderRadius: 3,
	padding: whitespace[1],
	height: 21,
	width: 16,
};

@autobind
export class TourOverlay extends React.Component<Props, State>  {
	static contextTypes: React.ValidationMap<any> = {
		router: React.PropTypes.object.isRequired,
	};

	_coachmarks: Array<Coachmark>;
	_searchCoachmarkRef: any;

	context: { router: Router };

	constructor() {
		super();
		// During the tour it is possible to redirect the user to GitHub and back to Auth private code and it is possible to revisit the tour by clicking the back button.
		// Therefore we store the current session in the window sessionStore to ensure we do not display the same
		// tooltip twice. To set up the current visibleMarks we assume all are visible. Then we check if the current session
		// has any information about the tour we defer to using the sessionStorage. If the user is a private code user then we will not show the refCoachmarkIndex'd tooltip
		// because the CTA prompts for private code usage. Always null out state.visibleAnnotation in the constructor.
		let visibleMarks = [0, 1, 2];
		let tourStore: string | null = window.sessionStorage.getItem("tour");
		if (tourStore !== null) {
			visibleMarks = tourStore.length > 0 ? tourStore.split(",").map(Number) : [];
		}

		this.state = {
			visibleAnnotation: null,
			visibleMarks: visibleMarks,
			viewedAnnotations: [],
		};

		// Fetch orgs for analytics and GTM at start of onboarding flow.
		if (context.user && context.hasOrganizationGitHubToken()) {
			Dispatcher.Backends.dispatch(new OrgActions.WantOrgs(context.user.Login));
		}
	}

	componentDidMount(): void {
		this._tryForRenderedTokenIdentifier();
	}

	componentDidUpdate(prevProps: Props, prevState: State): void {
		this._coachmarksShouldUpdate();
	}

	componentWillReceiveProps(nextProps: Props): void {
		// Safety buffer for shortcircuting the url changes.
		if (nextProps.location !== this.props.location) {
			setTimeout(function (): void {
				// If the location has changed render the coachmarks in a new random location in the view.
				this._tryForRenderedTokenIdentifier();
			}.bind(this), 10);
		}
	}

	// Render the coachmarks at a random location upon the component mounting
	// OR a location change in the same file triggered by jump to def.
	_tryForRenderedTokenIdentifier(): void {
		// "token identifier go"" is subject to change based on the language. For now, since we are hardcoding the endpoint we can assume this will always be true.
		// however since we will move to make this onboarding more dynamic we will need this to be more robust by either exploring a VSCode widget or more generic DOM injection.
		let tokenElements = document.getElementsByClassName(coachmarkLanguageIdentifier);
		if (!tokenElements || tokenElements.length <= 0) {
			// Correctly time the rendering of the tokens with the response from the async file response.
			// This results in no delay and not prematurely trying to render on a token (which wouldn't exist)
			window.requestAnimationFrame(this._tryForRenderedTokenIdentifier);
			return;
		}
		const editor = getEditorInstance();
		if (!editor) {
			return;
		}
		let x = document.getElementsByClassName(coachmarkLanguageIdentifier);
		if (x.length > 2) {
			// Grab a random element that has been indexed and provides "code intelligence".
			// Divide the total number of visible intelligent elements in half and pick a random node from the first half.
			// Render the first tooltip in the top half. Then render the second tooltip based on the second half of visible nodes.
			const defrandom = Math.random() * ((x.length - x.length / 2) - 1) + x.length / 2;
			const refrandom = Math.random() * x.length / 2;
			const defRandom = x[Math.floor((defrandom) + 1)];
			const refRandom = x[Math.floor(refrandom + 1)];

			let defSubtitle;
			let refSubtitle;
			const ctrl = platform.isMacintosh ? "⌘" : "Control";
			// Build custom fields for coachmark.
			defSubtitle = <p style={p}>
				<strong>{ctrl} + Click</strong> any symbol to jump to the definition – even if it's defined in another repository.
			</p>;
			refSubtitle = <p style={p}>
				Click any symbol to view its <strong>references</strong> in this repository and in any public code.
			</p>;
			const defActionCTA = <Button onClick={this._installChromeExtensionClicked.bind(this)} style={{ marginLeft: whitespace[4] }} color="white" size="tiny">Install the Chrome extension</Button>;
			const refActionCTA = <div style={{ paddingLeft: whitespace[4] }}><GitHubAuthButton pageName="BlobViewOnboarding" img={false} color="blueGray" scopes={privateGitHubOAuthScopes} returnTo={this.props.location}>Authorize with GitHub</GitHubAuthButton></div>;

			this._coachmarks = [
				this._initCoachmarkAnnotation(
					defRandom,
					"def-coachmark",
					"def-mark",
					_defCoachmarkIndex,
					"Jump to definition",
					defSubtitle,
					"Jump to definition and hover documentation on GitHub",
					context.hasChromeExtensionInstalled() ? null : defActionCTA
				),
				this._initCoachmarkAnnotation(
					refRandom,
					"ref-coachmark",
					"ref-mark",
					_refCoachmarkIndex,
					"View references",
					refSubtitle,
					"Enable these features for your private code",
					context.hasPrivateGitHubToken() ? null : refActionCTA
				),
			];

			this._coachmarksShouldUpdate();

			// Setup listener for the editor modifying the DOM. When lines are scrolled past they are removed from the view and therefore we have to re-add the tooltip
			// when the user scrolls the line number back into the view.
			editor.onDidScrollChange(e => {
				this._coachmarksShouldUpdate();
			});
		}
	};

	// Inits the a coachmark and annotation by first finding a parent element given the current file structure.
	// Then finds the parent's parent and sets a reference to the line where the coachmark is rendered.
	// Lastly after a valid line number and element is found, creates the jump to def tooltip and annotation.
	_initCoachmarkAnnotation(element: Element, markId: string, markParentElementId: string, markIndex: number, headingTitle: string, headingSubtitle: JSX.Element | null, actionTitle: string, actionCTA: JSX.Element | null): Coachmark {
		let grandparentElement = this._getGrandparentForElement(element);
		return {
			markId: markId,
			markParentElementId: markParentElementId,
			markIndex: markIndex,
			markLineNumber: Number(grandparentElement.getAttribute("linenumber")),
			headingTitle: headingTitle,
			headingSubtitle: headingSubtitle,
			actionTitle: actionTitle,
			actionCTA: actionCTA,
		};
	}

	_getGrandparentForElement(element: Element): Element {
		let firstParent = element.parentNode || element;
		let topParent = firstParent && firstParent.parentNode ? firstParent.parentNode : firstParent;
		let topElement = topParent as Element;
		return topElement;
	}

	_playBoomAnimation(elementToRemove: HTMLElement): void {
		// Play animation
		const boomEl = document.createElement("div");
		const position = elementToRemove.getClientRects()[0];
		document.body.appendChild(boomEl);
		ReactDOM.render(<Boom style={{
			position: "absolute",
			left: position.left,
			top: position.top,
			zIndex: 200,
		}} />, boomEl);

		// Remove animation
		setTimeout(() => { boomEl.remove(); }, 2000);
	}

	_coachmarksShouldUpdate(): void {
		const editor = getEditorInstance();
		if (!editor) {
			return;
		}
		let { visibleMarks } = this.state;
		if (!this._coachmarks) {
			return;
		}
		this._coachmarks.map((coachmark, index) => {
			// Remove the element if the coachmark should not be displayed.
			if (visibleMarks.indexOf(coachmark.markIndex) === -1) {
				// Timeout to prevent errors that can happen when performing DOM manipulations during a redirect.
				setTimeout(() => {
					let elementToRemove = document.getElementById(coachmark.markId);
					if (elementToRemove !== null) {
						// Remove element
						elementToRemove.remove();
					}
				}, 10);
				return;
			}

			// Get currently visible lines.
			if (!editor["getCompletelyVisibleLinesRangeInViewport"]) {
				throw "Type Error: Expected editor instance to have concrete type CodeEditorWidget.";
			}
			let lineView = editor["getCompletelyVisibleLinesRangeInViewport"]();

			// Check that the desired element is within the currently visible range.
			if (coachmark.markLineNumber >= lineView.startLineNumber && coachmark.markLineNumber <= lineView.endLineNumber) {
				// Lines are removed from the dom and added back when the user scrolls therefore we we have to find the same element.
				// First grab all elements based on the same class. Then loop over each "token identifier" element and find it's parent's parent.
				// Compare the line number with the original line number and element. If they are the same check if the coachmark is currently rendered.
				// If the element has not been rendered yet create it and add it to the DOM. If it does exist overwrite the refParentElementId container so it is not lost during scroll.
				let tokenIdentifier = document.getElementsByClassName(coachmarkLanguageIdentifier);
				for (let i = 0; i < tokenIdentifier.length; i++) {
					let element = tokenIdentifier[i];
					let grandparentElement = this._getGrandparentForElement(element);
					let grandparentLineNumber = Number(grandparentElement.getAttribute("linenumber"));
					if (grandparentLineNumber === coachmark.markLineNumber) {
						if (!document.getElementById(coachmark.markId)) {
							let overwrite = document.createElement("div");
							overwrite.style.cssText = parentElementCssString;
							overwrite.id = coachmark.markParentElementId;
							element.appendChild(overwrite);
							this._renderCoachmarkAnnotationForContainer(coachmark, overwrite);
							return;
						} else {
							let node = document.getElementById(coachmark.markParentElementId);
							this._renderCoachmarkAnnotationForContainer(coachmark, node);
						}
					}
				}
			}
		});
	}

	_renderCoachmarkAnnotationForContainer(coachmark: Coachmark, containerNode: any): void {
		let { visibleAnnotation } = this.state;
		let refs = <div id={coachmark.markId} style={{ whitespace: "normal" }}>
			<Annotation
				color="purple"
				pulseColor="white"
				open={visibleAnnotation === coachmark.markIndex}
				active={!this.state.viewedAnnotations.includes(coachmark.markIndex)}
				markOnClick={() => this._handleCoachmarkClicked(coachmark.markIndex)}
				tooltipStyle={{ whitespace: "normal !important", zIndex: 102, backgroundColor: colors.blue() }}>

				<span style={closeSx} onClick={() => this.setState(Object.assign({}, this.state, { visibleAnnotation: null }))}>
					<Close width={18} color={colors.blueGrayD1(0.5)} />
				</span>
				<div style={headerSx}>
					<Heading color="blue" level={6} style={{ marginTop: 0 }}>{coachmark.headingTitle}</Heading>
					{coachmark.headingSubtitle}
				</div>
				{coachmark.actionCTA &&
					<div style={{ padding: whitespace[4] }}>
						<Flag width={22} style={flagSx} color={colors.blueD1(0.9)} />
						<strong style={actionSx}>{coachmark.actionTitle}</strong>
						{coachmark.actionCTA}
					</div>}
			</Annotation>
		</div>;

		ReactDOM.render(refs, containerNode);
	}

	_handleCoachmarkClicked(markIndex: number): void {
		// Only toggle whether or not the annotation is visible. This should not completely remove coachmarks.
		this.setState(Object.assign({}, this.state,
			{
				visibleAnnotation: this.state.visibleAnnotation === markIndex ? null : markIndex,
				viewedAnnotations:
				this.state.viewedAnnotations.includes(markIndex)
					? this.state.viewedAnnotations
					: this.state.viewedAnnotations.concat([markIndex]),
			}
		));

		switch (markIndex) {
			case _refCoachmarkIndex: {
				AnalyticsConstants.Events.OnboardingRefsCoachCTA_Clicked.logEvent({ page_name: "BlobViewOnboarding" });
			}
				break;
			case _defCoachmarkIndex: {
				AnalyticsConstants.Events.OnboardingJ2DCoachCTA_Clicked.logEvent({ page_name: "BlobViewOnboarding" });
			}
				break;
			case _searchCoachmarkIndex: {
				AnalyticsConstants.Events.OnboardingSearchCoachCTA_Clicked.logEvent({ page_name: "BlobViewOnboarding" });
			}
				break;
			default:
				return;
		}

	}

	// The search coachmark annotation is different because it does not live inside of the editor therefore we can render it like a standard react component.
	_renderSearchCoachmarkAnnotation(visibleAnnotation: number | null, markIndex: number): JSX.Element | null {
		return (
			<div
				ref={(c) => this._searchCoachmarkRef = c}
				style={{ position: "fixed", right: 160, top: 40 }}>
				<Annotation
					color="purple"
					pulseColor="white"
					annotationPosition="left"
					open={visibleAnnotation === markIndex}
					active={!this.state.viewedAnnotations.includes(markIndex)}
					markOnClick={() => this._handleCoachmarkClicked(markIndex)}>

					<span style={closeSx} onClick={
						() => this.setState(Object.assign({}, this.state, { visibleAnnotation: null }))
					}>
						<Close width={18} color={colors.blueGrayD1(0.5)} />
					</span>
					<div style={Object.assign({},
						headerSx,
						{ borderRadius: 3 },
					)}>
						<Heading color="blue" level={6}>Jump to symbols, files, and repositories</Heading>
						<p>Click Search or hit the <span style={searchSx}>/</span> key to open up search from anywhere.</p>
					</div>
				</Annotation>
			</div>
		);
	}

	_successHandler(): void {
		AnalyticsConstants.Events.ChromeExtension_Installed.logEvent({ page_name: "BlobViewOnboarding" });
		EventLogger.setUserProperty("installed_chrome_extension", "true");
		// Syncs the our site analytics tracking with the chrome extension tracker.
		EventLogger.updateTrackerWithIdentificationProps();
	}

	_failHandler(msg: String): void {
		AnalyticsConstants.Events.ChromeExtensionInstall_Failed.logEvent({ page_name: "BlobViewOnboarding" });
		EventLogger.setUserProperty("installed_chrome_extension", "false");
	}

	_installChromeExtensionClicked(): void {
		AnalyticsConstants.Events.ChromeExtensionCTA_Clicked.logEvent({ page_name: "BlobViewOnboarding" });

		if (!!global.chrome) {
			AnalyticsConstants.Events.ChromeExtensionInstall_Started.logEvent({ page_name: "BlobViewOnboarding" });
			global.chrome.webstore.install("https://chrome.google.com/webstore/detail/dgjhfomjieaadpoljlnidmbgkdffpack", this._successHandler.bind(this), this._failHandler.bind(this));
		} else {
			AnalyticsConstants.Events.ChromeExtensionStore_Redirected.logEvent({ page_name: "BlobViewOnboarding" });
			window.open("https://chrome.google.com/webstore/detail/dgjhfomjieaadpoljlnidmbgkdffpack", "_newtab");
		}
	}

	_renderDismissButton(): JSX.Element | null {
		return (
			<div style={{ position: "fixed", right: 42, bottom: 36 }}>
				<Button onClick={() => this._dismissTour()} size="small" color="white" outline={false}>Dismiss tour</Button>
			</div>
		);
	}

	_dismissTour(): void {
		AnalyticsConstants.Events.OnboardingTour_Dismissed.logEvent({ page_name: "BlobViewOnboarding" });
		this._endTour();
	}

	_endTour(): void {
		// Animate dismissal of all coachmarks
		this._playBoomAnimation(this._searchCoachmarkRef);
		if (this._coachmarks) {
			this._coachmarks.map((mark) => {
				if (mark) {
					const el = document.getElementById(mark.markId);
					if (el) { this._playBoomAnimation(el); }
				}
			});
		}

		window.sessionStorage.setItem("tour", "");
		delete this.props.location.query["tour"];
		const newLoc = Object.assign({}, this.props.location, { query: this.props.location.query });
		this.context.router.replace(newLoc);
		this.setState({
			visibleMarks: [],
			visibleAnnotation: null,
			viewedAnnotations: [],
		});
	}

	render(): JSX.Element | null {
		let { visibleMarks, visibleAnnotation } = this.state;
		return (<div style={{ zIndex: 101 }}>
			{visibleMarks.indexOf(_searchCoachmarkIndex) !== -1 && this._renderSearchCoachmarkAnnotation(visibleAnnotation, _searchCoachmarkIndex)}
			{visibleMarks.length > 0 && this._renderDismissButton()}
		</div>
		);
	}
}
