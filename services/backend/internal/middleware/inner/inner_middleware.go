// GENERATED CODE - DO NOT EDIT!
// @generated
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package inner

import (
	"time"

	"context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"sourcegraph.com/sourcegraph/sourcegraph/api/sourcegraph"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/errcode"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/inventory"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/vcs"
	"sourcegraph.com/sourcegraph/sourcegraph/services/backend"
	"sourcegraph.com/sourcegraph/sourcegraph/services/backend/internal/middleware/inner/trace"
	"sourcegraph.com/sourcegraph/sourcegraph/services/svc"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sqs/pbtypes"
)

// Services returns the local services wrapped with auth, etc.
func Services() svc.Services {
	return svc.Services{

		MultiRepoImporter: wrappedMultiRepoImporter{},

		Annotations: wrappedAnnotations{},

		Async: wrappedAsync{},

		Defs: wrappedDefs{},

		Meta: wrappedMeta{},

		MirrorRepos: wrappedMirrorRepos{},

		RepoStatuses: wrappedRepoStatuses{},

		RepoTree: wrappedRepoTree{},

		Repos: wrappedRepos{},

		Search: wrappedSearch{},
	}
}

type wrappedMultiRepoImporter struct{}

func (s wrappedMultiRepoImporter) Import(ctx context.Context, param *pb.ImportOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "MultiRepoImporter", "Import", param)
	defer func() {
		trace.After(ctx, "MultiRepoImporter", "Import", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.MultiRepoImporter.Import(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "MultiRepoImporter.Import returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "MultiRepoImporter.Import failed with internal error.")
		}
	}
	return
}

func (s wrappedMultiRepoImporter) CreateVersion(ctx context.Context, param *pb.CreateVersionOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "MultiRepoImporter", "CreateVersion", param)
	defer func() {
		trace.After(ctx, "MultiRepoImporter", "CreateVersion", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.MultiRepoImporter.CreateVersion(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "MultiRepoImporter.CreateVersion returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "MultiRepoImporter.CreateVersion failed with internal error.")
		}
	}
	return
}

func (s wrappedMultiRepoImporter) Index(ctx context.Context, param *pb.IndexOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "MultiRepoImporter", "Index", param)
	defer func() {
		trace.After(ctx, "MultiRepoImporter", "Index", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.MultiRepoImporter.Index(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "MultiRepoImporter.Index returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "MultiRepoImporter.Index failed with internal error.")
		}
	}
	return
}

type wrappedAnnotations struct{}

func (s wrappedAnnotations) List(ctx context.Context, param *sourcegraph.AnnotationsListOptions) (res *sourcegraph.AnnotationList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Annotations", "List", param)
	defer func() {
		trace.After(ctx, "Annotations", "List", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Annotations.List(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Annotations.List returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Annotations.List failed with internal error.")
		}
	}
	return
}

func (s wrappedAnnotations) GetDefAtPos(ctx context.Context, param *sourcegraph.AnnotationsGetDefAtPosOptions) (res *sourcegraph.DefSpec, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Annotations", "GetDefAtPos", param)
	defer func() {
		trace.After(ctx, "Annotations", "GetDefAtPos", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Annotations.GetDefAtPos(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Annotations.GetDefAtPos returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Annotations.GetDefAtPos failed with internal error.")
		}
	}
	return
}

type wrappedAsync struct{}

func (s wrappedAsync) RefreshIndexes(ctx context.Context, param *sourcegraph.AsyncRefreshIndexesOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Async", "RefreshIndexes", param)
	defer func() {
		trace.After(ctx, "Async", "RefreshIndexes", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Async.RefreshIndexes(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Async.RefreshIndexes returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Async.RefreshIndexes failed with internal error.")
		}
	}
	return
}

type wrappedDefs struct{}

func (s wrappedDefs) Get(ctx context.Context, param *sourcegraph.DefsGetOp) (res *sourcegraph.Def, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "Get", param)
	defer func() {
		trace.After(ctx, "Defs", "Get", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.Get(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.Get returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.Get failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) List(ctx context.Context, param *sourcegraph.DefListOptions) (res *sourcegraph.DefList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "List", param)
	defer func() {
		trace.After(ctx, "Defs", "List", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.List(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.List returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.List failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) ListRefs(ctx context.Context, param *sourcegraph.DefsListRefsOp) (res *sourcegraph.RefList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListRefs", param)
	defer func() {
		trace.After(ctx, "Defs", "ListRefs", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.ListRefs(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.ListRefs returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.ListRefs failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) ListRefLocations(ctx context.Context, param *sourcegraph.DefsListRefLocationsOp) (res *sourcegraph.RefLocationsList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListRefLocations", param)
	defer func() {
		trace.After(ctx, "Defs", "ListRefLocations", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.ListRefLocations(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.ListRefLocations returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.ListRefLocations failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) ListExamples(ctx context.Context, param *sourcegraph.DefsListExamplesOp) (res *sourcegraph.RefLocationsList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListExamples", param)
	defer func() {
		trace.After(ctx, "Defs", "ListExamples", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.ListExamples(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.ListExamples returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.ListExamples failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) ListAuthors(ctx context.Context, param *sourcegraph.DefsListAuthorsOp) (res *sourcegraph.DefAuthorList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListAuthors", param)
	defer func() {
		trace.After(ctx, "Defs", "ListAuthors", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.ListAuthors(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.ListAuthors returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.ListAuthors failed with internal error.")
		}
	}
	return
}

func (s wrappedDefs) RefreshIndex(ctx context.Context, param *sourcegraph.DefsRefreshIndexOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "RefreshIndex", param)
	defer func() {
		trace.After(ctx, "Defs", "RefreshIndex", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Defs.RefreshIndex(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Defs.RefreshIndex returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Defs.RefreshIndex failed with internal error.")
		}
	}
	return
}

type wrappedMeta struct{}

func (s wrappedMeta) Config(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.ServerConfig, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Meta", "Config", param)
	defer func() {
		trace.After(ctx, "Meta", "Config", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Meta.Config(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Meta.Config returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Meta.Config failed with internal error.")
		}
	}
	return
}

type wrappedMirrorRepos struct{}

func (s wrappedMirrorRepos) RefreshVCS(ctx context.Context, param *sourcegraph.MirrorReposRefreshVCSOp) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "MirrorRepos", "RefreshVCS", param)
	defer func() {
		trace.After(ctx, "MirrorRepos", "RefreshVCS", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.MirrorRepos.RefreshVCS(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "MirrorRepos.RefreshVCS returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "MirrorRepos.RefreshVCS failed with internal error.")
		}
	}
	return
}

type wrappedRepoStatuses struct{}

func (s wrappedRepoStatuses) GetCombined(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *sourcegraph.CombinedStatus, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoStatuses", "GetCombined", param)
	defer func() {
		trace.After(ctx, "RepoStatuses", "GetCombined", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoStatuses.GetCombined(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoStatuses.GetCombined returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoStatuses.GetCombined failed with internal error.")
		}
	}
	return
}

func (s wrappedRepoStatuses) GetCoverage(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.RepoStatusList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoStatuses", "GetCoverage", param)
	defer func() {
		trace.After(ctx, "RepoStatuses", "GetCoverage", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoStatuses.GetCoverage(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoStatuses.GetCoverage returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoStatuses.GetCoverage failed with internal error.")
		}
	}
	return
}

func (s wrappedRepoStatuses) Create(ctx context.Context, param *sourcegraph.RepoStatusesCreateOp) (res *sourcegraph.RepoStatus, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoStatuses", "Create", param)
	defer func() {
		trace.After(ctx, "RepoStatuses", "Create", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoStatuses.Create(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoStatuses.Create returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoStatuses.Create failed with internal error.")
		}
	}
	return
}

type wrappedRepoTree struct{}

func (s wrappedRepoTree) Get(ctx context.Context, param *sourcegraph.RepoTreeGetOp) (res *sourcegraph.TreeEntry, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "Get", param)
	defer func() {
		trace.After(ctx, "RepoTree", "Get", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoTree.Get(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoTree.Get returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoTree.Get failed with internal error.")
		}
	}
	return
}

func (s wrappedRepoTree) Search(ctx context.Context, param *sourcegraph.RepoTreeSearchOp) (res *sourcegraph.VCSSearchResultList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "Search", param)
	defer func() {
		trace.After(ctx, "RepoTree", "Search", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoTree.Search(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoTree.Search returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoTree.Search failed with internal error.")
		}
	}
	return
}

func (s wrappedRepoTree) List(ctx context.Context, param *sourcegraph.RepoTreeListOp) (res *sourcegraph.RepoTreeListResult, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "List", param)
	defer func() {
		trace.After(ctx, "RepoTree", "List", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.RepoTree.List(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "RepoTree.List returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "RepoTree.List failed with internal error.")
		}
	}
	return
}

type wrappedRepos struct{}

func (s wrappedRepos) Get(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.Repo, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Get", param)
	defer func() {
		trace.After(ctx, "Repos", "Get", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.Get(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.Get returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.Get failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) Resolve(ctx context.Context, param *sourcegraph.RepoResolveOp) (res *sourcegraph.RepoResolution, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Resolve", param)
	defer func() {
		trace.After(ctx, "Repos", "Resolve", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.Resolve(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.Resolve returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.Resolve failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) List(ctx context.Context, param *sourcegraph.RepoListOptions) (res *sourcegraph.RepoList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "List", param)
	defer func() {
		trace.After(ctx, "Repos", "List", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.List(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.List returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.List failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) Create(ctx context.Context, param *sourcegraph.ReposCreateOp) (res *sourcegraph.Repo, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Create", param)
	defer func() {
		trace.After(ctx, "Repos", "Create", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.Create(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.Create returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.Create failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) Update(ctx context.Context, param *sourcegraph.ReposUpdateOp) (res *sourcegraph.Repo, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Update", param)
	defer func() {
		trace.After(ctx, "Repos", "Update", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.Update(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.Update returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.Update failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) Delete(ctx context.Context, param *sourcegraph.RepoSpec) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Delete", param)
	defer func() {
		trace.After(ctx, "Repos", "Delete", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.Delete(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.Delete returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.Delete failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) GetConfig(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.RepoConfig, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetConfig", param)
	defer func() {
		trace.After(ctx, "Repos", "GetConfig", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.GetConfig(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.GetConfig returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.GetConfig failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) GetCommit(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *vcs.Commit, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetCommit", param)
	defer func() {
		trace.After(ctx, "Repos", "GetCommit", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.GetCommit(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.GetCommit returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.GetCommit failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ResolveRev(ctx context.Context, param *sourcegraph.ReposResolveRevOp) (res *sourcegraph.ResolvedRev, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ResolveRev", param)
	defer func() {
		trace.After(ctx, "Repos", "ResolveRev", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ResolveRev(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ResolveRev returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ResolveRev failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ListCommits(ctx context.Context, param *sourcegraph.ReposListCommitsOp) (res *sourcegraph.CommitList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListCommits", param)
	defer func() {
		trace.After(ctx, "Repos", "ListCommits", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ListCommits(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ListCommits returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ListCommits failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ListBranches(ctx context.Context, param *sourcegraph.ReposListBranchesOp) (res *sourcegraph.BranchList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListBranches", param)
	defer func() {
		trace.After(ctx, "Repos", "ListBranches", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ListBranches(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ListBranches returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ListBranches failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ListTags(ctx context.Context, param *sourcegraph.ReposListTagsOp) (res *sourcegraph.TagList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListTags", param)
	defer func() {
		trace.After(ctx, "Repos", "ListTags", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ListTags(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ListTags returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ListTags failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) EnableWebhook(ctx context.Context, param *sourcegraph.RepoWebhookOptions) (res *pbtypes.Void, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "EnableWebhook", param)
	defer func() {
		trace.After(ctx, "Repos", "EnableWebhook", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.EnableWebhook(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.EnableWebhook returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.EnableWebhook failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ListDeps(ctx context.Context, param *sourcegraph.URIList) (res *sourcegraph.URIList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListDeps", param)
	defer func() {
		trace.After(ctx, "Repos", "ListDeps", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ListDeps(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ListDeps returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ListDeps failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ListCommitters(ctx context.Context, param *sourcegraph.ReposListCommittersOp) (res *sourcegraph.CommitterList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListCommitters", param)
	defer func() {
		trace.After(ctx, "Repos", "ListCommitters", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ListCommitters(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ListCommitters returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ListCommitters failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) GetSrclibDataVersionForPath(ctx context.Context, param *sourcegraph.TreeEntrySpec) (res *sourcegraph.SrclibDataVersion, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetSrclibDataVersionForPath", param)
	defer func() {
		trace.After(ctx, "Repos", "GetSrclibDataVersionForPath", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.GetSrclibDataVersionForPath(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.GetSrclibDataVersionForPath returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.GetSrclibDataVersionForPath failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) GetInventory(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *inventory.Inventory, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetInventory", param)
	defer func() {
		trace.After(ctx, "Repos", "GetInventory", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.GetInventory(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.GetInventory returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.GetInventory failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) ReceivePack(ctx context.Context, param *sourcegraph.ReceivePackOp) (res *sourcegraph.Packet, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ReceivePack", param)
	defer func() {
		trace.After(ctx, "Repos", "ReceivePack", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.ReceivePack(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.ReceivePack returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.ReceivePack failed with internal error.")
		}
	}
	return
}

func (s wrappedRepos) UploadPack(ctx context.Context, param *sourcegraph.UploadPackOp) (res *sourcegraph.Packet, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "UploadPack", param)
	defer func() {
		trace.After(ctx, "Repos", "UploadPack", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Repos.UploadPack(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Repos.UploadPack returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Repos.UploadPack failed with internal error.")
		}
	}
	return
}

type wrappedSearch struct{}

func (s wrappedSearch) Search(ctx context.Context, param *sourcegraph.SearchOp) (res *sourcegraph.SearchResultsList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Search", "Search", param)
	defer func() {
		trace.After(ctx, "Search", "Search", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Search.Search(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Search.Search returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Search.Search failed with internal error.")
		}
	}
	return
}

func (s wrappedSearch) SearchRepos(ctx context.Context, param *sourcegraph.SearchReposOp) (res *sourcegraph.SearchReposResultList, err error) {
	var errActual error
	start := time.Now()
	ctx = trace.Before(ctx, "Search", "SearchRepos", param)
	defer func() {
		trace.After(ctx, "Search", "SearchRepos", param, errActual, time.Since(start))
	}()
	res, errActual = backend.Services.Search.SearchRepos(ctx, param)
	if res == nil && errActual == nil {
		errActual = grpc.Errorf(codes.Internal, "Search.SearchRepos returned nil, nil")
	}
	err = errActual
	if err != nil && !DebugMode(ctx) {
		if code := errcode.GRPC(err); code == codes.Unknown || code == codes.Internal {
			// Sanitize, because these errors should not be user visible.
			err = grpc.Errorf(code, "Search.SearchRepos failed with internal error.")
		}
	}
	return
}
