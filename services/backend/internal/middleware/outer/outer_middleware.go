// GENERATED CODE - DO NOT EDIT!
// @generated
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package outer

import (
	"context"
	"runtime"

	opentracing "github.com/opentracing/opentracing-go"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"

	"sourcegraph.com/sourcegraph/sourcegraph/api/sourcegraph"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/inventory"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/traceutil"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/vcs"
	"sourcegraph.com/sourcegraph/sourcegraph/services/svc"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sqs/pbtypes"
)

// Services returns a full set of services with an implementation of each service method that lets you customize the initial context.Context and map Go errors to gRPC error codes. It is similar to HTTP handler middleware, but for gRPC servers.
func Services(ctxFunc ContextFunc, services svc.Services) svc.Services {
	s := svc.Services{
		MultiRepoImporter: wrappedMultiRepoImporter{ctxFunc, services},
		Accounts:          wrappedAccounts{ctxFunc, services},
		Annotations:       wrappedAnnotations{ctxFunc, services},
		Async:             wrappedAsync{ctxFunc, services},
		Auth:              wrappedAuth{ctxFunc, services},
		Defs:              wrappedDefs{ctxFunc, services},
		Meta:              wrappedMeta{ctxFunc, services},
		MirrorRepos:       wrappedMirrorRepos{ctxFunc, services},
		RepoStatuses:      wrappedRepoStatuses{ctxFunc, services},
		RepoTree:          wrappedRepoTree{ctxFunc, services},
		Repos:             wrappedRepos{ctxFunc, services},
		Search:            wrappedSearch{ctxFunc, services},
		Users:             wrappedUsers{ctxFunc, services},
	}
	return s
}

type wrappedMultiRepoImporter struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMultiRepoImporter) Import(ctx context.Context, v1 *pb.ImportOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: MultiRepoImporter.Import", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Import: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Import(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMultiRepoImporter) CreateVersion(ctx context.Context, v1 *pb.CreateVersionOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: MultiRepoImporter.CreateVersion", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.CreateVersion: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.CreateVersion(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMultiRepoImporter) Index(ctx context.Context, v1 *pb.IndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: MultiRepoImporter.Index", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Index: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Index(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAccounts struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAccounts) Create(ctx context.Context, v1 *sourcegraph.NewAccount) (returnedResult *sourcegraph.CreatedAccount, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.Create", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) RequestPasswordReset(ctx context.Context, v1 *sourcegraph.RequestPasswordResetOp) (returnedResult *sourcegraph.PendingPasswordReset, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.RequestPasswordReset", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.RequestPasswordReset: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.RequestPasswordReset(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) ResetPassword(ctx context.Context, v1 *sourcegraph.NewPassword) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.ResetPassword", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.ResetPassword: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.ResetPassword(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Update(ctx context.Context, v1 *sourcegraph.User) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.Update", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) UpdateEmails(ctx context.Context, v1 *sourcegraph.UpdateEmailsOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.UpdateEmails", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.UpdateEmails: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.UpdateEmails(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Delete(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Accounts.Delete", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAnnotations struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAnnotations) List(ctx context.Context, v1 *sourcegraph.AnnotationsListOptions) (returnedResult *sourcegraph.AnnotationList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Annotations.List", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Annotations.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AnnotationsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Annotations")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAnnotations) GetDefAtPos(ctx context.Context, v1 *sourcegraph.AnnotationsGetDefAtPosOptions) (returnedResult *sourcegraph.DefSpec, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Annotations.GetDefAtPos", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Annotations.GetDefAtPos: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AnnotationsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Annotations")
	}

	rv, err := innerSvc.GetDefAtPos(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAsync struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAsync) RefreshIndexes(ctx context.Context, v1 *sourcegraph.AsyncRefreshIndexesOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Async.RefreshIndexes", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Async.RefreshIndexes: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AsyncOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Async")
	}

	rv, err := innerSvc.RefreshIndexes(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAuth struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAuth) GetAccessToken(ctx context.Context, v1 *sourcegraph.AccessTokenRequest) (returnedResult *sourcegraph.AccessTokenResponse, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Auth.GetAccessToken", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetAccessToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetAccessToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) Identify(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.AuthInfo, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Auth.Identify", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.Identify: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.Identify(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) GetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalTokenSpec) (returnedResult *sourcegraph.ExternalToken, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Auth.GetExternalToken", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) SetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalToken) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Auth.SetExternalToken", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.SetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.SetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) DeleteAndRevokeExternalToken(ctx context.Context, v1 *sourcegraph.ExternalTokenSpec) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Auth.DeleteAndRevokeExternalToken", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.DeleteAndRevokeExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.DeleteAndRevokeExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedDefs struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedDefs) Get(ctx context.Context, v1 *sourcegraph.DefsGetOp) (returnedResult *sourcegraph.Def, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.Get", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) List(ctx context.Context, v1 *sourcegraph.DefListOptions) (returnedResult *sourcegraph.DefList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.List", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListRefs(ctx context.Context, v1 *sourcegraph.DefsListRefsOp) (returnedResult *sourcegraph.RefList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.ListRefs", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListRefs: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListRefs(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListRefLocations(ctx context.Context, v1 *sourcegraph.DefsListRefLocationsOp) (returnedResult *sourcegraph.RefLocationsList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.ListRefLocations", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListRefLocations: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListRefLocations(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListExamples(ctx context.Context, v1 *sourcegraph.DefsListExamplesOp) (returnedResult *sourcegraph.RefLocationsList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.ListExamples", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListExamples: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListExamples(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListAuthors(ctx context.Context, v1 *sourcegraph.DefsListAuthorsOp) (returnedResult *sourcegraph.DefAuthorList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.ListAuthors", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListAuthors: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListAuthors(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) RefreshIndex(ctx context.Context, v1 *sourcegraph.DefsRefreshIndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Defs.RefreshIndex", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.RefreshIndex: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.RefreshIndex(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMeta struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMeta) Config(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.ServerConfig, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Meta.Config", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Meta.Config: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MetaOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Meta")
	}

	rv, err := innerSvc.Config(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMirrorRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMirrorRepos) RefreshVCS(ctx context.Context, v1 *sourcegraph.MirrorReposRefreshVCSOp) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: MirrorRepos.RefreshVCS", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MirrorRepos.RefreshVCS: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MirrorReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MirrorRepos")
	}

	rv, err := innerSvc.RefreshVCS(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoStatuses struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoStatuses) GetCombined(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *sourcegraph.CombinedStatus, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoStatuses.GetCombined", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.GetCombined: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.GetCombined(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoStatuses) GetCoverage(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.RepoStatusList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoStatuses.GetCoverage", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.GetCoverage: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.GetCoverage(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoStatuses) Create(ctx context.Context, v1 *sourcegraph.RepoStatusesCreateOp) (returnedResult *sourcegraph.RepoStatus, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoStatuses.Create", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoTree struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoTree) Get(ctx context.Context, v1 *sourcegraph.RepoTreeGetOp) (returnedResult *sourcegraph.TreeEntry, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoTree.Get", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) Search(ctx context.Context, v1 *sourcegraph.RepoTreeSearchOp) (returnedResult *sourcegraph.VCSSearchResultList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoTree.Search", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Search: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Search(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) List(ctx context.Context, v1 *sourcegraph.RepoTreeListOp) (returnedResult *sourcegraph.RepoTreeListResult, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: RepoTree.List", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepos) Get(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.Repo, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.Get", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Resolve(ctx context.Context, v1 *sourcegraph.RepoResolveOp) (returnedResult *sourcegraph.RepoResolution, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.Resolve", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Resolve: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Resolve(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) List(ctx context.Context, v1 *sourcegraph.RepoListOptions) (returnedResult *sourcegraph.RepoList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.List", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Create(ctx context.Context, v1 *sourcegraph.ReposCreateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.Create", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Update(ctx context.Context, v1 *sourcegraph.ReposUpdateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.Update", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Delete(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.Delete", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetConfig(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.RepoConfig, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.GetConfig", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetConfig: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetConfig(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetCommit(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *vcs.Commit, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.GetCommit", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetCommit: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetCommit(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ResolveRev(ctx context.Context, v1 *sourcegraph.ReposResolveRevOp) (returnedResult *sourcegraph.ResolvedRev, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ResolveRev", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ResolveRev: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ResolveRev(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommits(ctx context.Context, v1 *sourcegraph.ReposListCommitsOp) (returnedResult *sourcegraph.CommitList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ListCommits", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommits: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommits(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListBranches(ctx context.Context, v1 *sourcegraph.ReposListBranchesOp) (returnedResult *sourcegraph.BranchList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ListBranches", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListBranches: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListBranches(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListTags(ctx context.Context, v1 *sourcegraph.ReposListTagsOp) (returnedResult *sourcegraph.TagList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ListTags", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListTags: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListTags(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) EnableWebhook(ctx context.Context, v1 *sourcegraph.RepoWebhookOptions) (returnedResult *pbtypes.Void, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.EnableWebhook", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.EnableWebhook: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.EnableWebhook(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListDeps(ctx context.Context, v1 *sourcegraph.URIList) (returnedResult *sourcegraph.URIList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ListDeps", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListDeps: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListDeps(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommitters(ctx context.Context, v1 *sourcegraph.ReposListCommittersOp) (returnedResult *sourcegraph.CommitterList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ListCommitters", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommitters: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommitters(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetSrclibDataVersionForPath(ctx context.Context, v1 *sourcegraph.TreeEntrySpec) (returnedResult *sourcegraph.SrclibDataVersion, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.GetSrclibDataVersionForPath", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetSrclibDataVersionForPath: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetSrclibDataVersionForPath(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetInventory(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *inventory.Inventory, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.GetInventory", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetInventory: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetInventory(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ReceivePack(ctx context.Context, v1 *sourcegraph.ReceivePackOp) (returnedResult *sourcegraph.Packet, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.ReceivePack", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ReceivePack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ReceivePack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) UploadPack(ctx context.Context, v1 *sourcegraph.UploadPackOp) (returnedResult *sourcegraph.Packet, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Repos.UploadPack", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.UploadPack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.UploadPack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedSearch struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedSearch) Search(ctx context.Context, v1 *sourcegraph.SearchOp) (returnedResult *sourcegraph.SearchResultsList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Search.Search", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.Search: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.Search(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedSearch) SearchRepos(ctx context.Context, v1 *sourcegraph.SearchReposOp) (returnedResult *sourcegraph.SearchReposResultList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Search.SearchRepos", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.SearchRepos: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.SearchRepos(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedUsers struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedUsers) Get(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.User, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Users.Get", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) GetWithEmail(ctx context.Context, v1 *sourcegraph.EmailAddr) (returnedResult *sourcegraph.User, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Users.GetWithEmail", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.GetWithEmail: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.GetWithEmail(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) ListEmails(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.EmailAddrList, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Users.ListEmails", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.ListEmails: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.ListEmails(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) RegisterBeta(ctx context.Context, v1 *sourcegraph.BetaRegistration) (returnedResult *sourcegraph.BetaResponse, returnedError error) {
	parentSpanCtx := traceutil.ExtractGRPCMetadata(ctx)
	span := opentracing.StartSpan("GRPC call: Users.RegisterBeta", opentracing.ChildOf(parentSpanCtx))
	defer span.Finish()
	ctx = opentracing.ContextWithSpan(ctx, span)

	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.RegisterBeta: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.RegisterBeta(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}
