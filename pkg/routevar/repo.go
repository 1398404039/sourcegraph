package routevar

import (
	"bytes"
	"regexp"
	"strings"

	"sourcegraph.com/sourcegraph/sourcegraph/go-sourcegraph/sourcegraph"
)

var (
	Repo = `{Repo:` + NamedToNonCapturingGroups(RepoPattern) + `}`
	Rev  = `{Rev:` + NamedToNonCapturingGroups(RevPattern) + `}`

	RepoRevSuffix = `{Rev:` + NamedToNonCapturingGroups(`(?:@`+RevPattern+`)?`) + `}`
)

const (
	// RepoPattern is the regexp pattern that matches RepoSpec strings
	// ("repo" or "domain.com/repo" or "domain.com/path/to/repo").
	RepoPattern = `(?P<repo>(?:` + pathComponentNotDelim + `/)*` + pathComponentNotDelim + `)`

	RepoPathDelim         = "-"
	pathComponentNotDelim = `(?:[^@=/` + RepoPathDelim + `]|(?:[^=/@]{2,}))`

	// RevPattern is the regexp pattern that matches a VCS revision
	// and, optionally, a resolved commit ID. The format is "rev" or
	// "rev===commit".
	RevPattern = unresolvedRevPattern + `(?:` + resolvedRevSep + CommitPattern + `)?`

	// unresolvedRevPattern is the regexp pattern that matches a VCS
	// revision specifier (e.g., "master" or "my/branch~1") without
	// the "===" indicating the resolved commit ID. The revision may
	// not contain "=" or "@" to avoid ambiguity.
	unresolvedRevPattern = `(?P<rev>(?:` + pathComponentNotDelim + `/)*` + pathComponentNotDelim + `)`

	// CommitPattern is the regexp pattern that matches absolute
	// (40-character) hexidecimal commit IDs.
	CommitPattern = `(?P<commit>[[:xdigit:]]{40})`

	resolvedRevSep = `===`
)

var (
	repoPattern = regexp.MustCompile("^" + RepoPattern + "$")
	revPattern  = regexp.MustCompile("^" + RevPattern + "$")
)

// ParseRepo parses a RepoSpec string. If spec is invalid, an
// InvalidError is returned.
func ParseRepo(spec string) (repo string, err error) {
	if m := repoPattern.FindStringSubmatch(spec); len(m) > 0 {
		repo = m[0]
		return
	}
	return "", InvalidError{"RepoSpec", spec, nil}
}

// RepoString returns a RepoSpec string. It is the inverse of
// ParseRepo. It does not check the validity of the inputs.
func RepoString(repo string) string { return repo }

// ParseResolvedRev parses a ResolvedRevSpec string ("rev" or
// "rev===commit").
func ParseResolvedRev(spec string) (rev, commitID string) {
	if m := revPattern.FindStringSubmatch(spec); m != nil {
		rev = m[1]
		if len(m) >= 3 {
			commitID = m[2]
		}
		return
	}
	return spec, ""
}

// resolvedRevString returns a ResolvedRevSpec string. It is the
// inverse of ParseResolvedRev. It does not check the validity of the
// inputs.
func resolvedRevString(rev, commitID string) string {
	n := len(rev)
	if commitID != "" {
		n += len(resolvedRevSep) + len(commitID)
	}
	buf := bytes.NewBuffer(make([]byte, 0, n))
	buf.WriteString(rev)
	if commitID != "" {
		buf.Write([]byte(resolvedRevSep))
		buf.WriteString(commitID)
	}
	return buf.String()
}

// RepoRouteVars returns route variables for constructing repository
// routes.
func RepoRouteVars(s sourcegraph.RepoSpec) map[string]string {
	return map[string]string{"Repo": RepoSpecString(s)}
}

// ParseRepoSpec parses a string generated by (RepoSpec).SpecString()
// and returns the equivalent RepoSpec struct.
func ParseRepoSpec(s string) (sourcegraph.RepoSpec, error) {
	repo, err := ParseRepo(s)
	if err != nil {
		return sourcegraph.RepoSpec{}, err
	}
	return sourcegraph.RepoSpec{URI: repo}, nil
}

// ToRepoRevSpec marshals a map containing route variables
// generated by (RepoRevSpec).RouteVars() and returns the equivalent
// RepoRevSpec struct.
func ToRepoRevSpec(routeVars map[string]string) (sourcegraph.RepoRevSpec, error) {
	repo, err := ToRepoSpec(routeVars)
	if err != nil {
		return sourcegraph.RepoRevSpec{}, err
	}

	rrspec := sourcegraph.RepoRevSpec{RepoSpec: repo}
	if revStr := routeVars["Rev"]; revStr != "" {
		if !strings.HasPrefix(revStr, "@") {
			panic("Rev should have had '@' prefix from route")
		}
		revStr = strings.TrimPrefix(revStr, "@")
		rrspec.Rev, rrspec.CommitID = ParseResolvedRev(revStr)
	}
	if _, ok := routeVars["CommitID"]; ok {
		panic("unexpected CommitID route var; was removed in the simple-routes branch")
	}
	return rrspec, nil
}

// ToRepoSpec marshals a map containing route variables
// generated by (*RepoSpec).RouteVars() and returns the
// equivalent RepoSpec struct.
func ToRepoSpec(routeVars map[string]string) (sourcegraph.RepoSpec, error) {
	return ParseRepoSpec(routeVars["Repo"])
}

// RepoRevRouteVars returns route variables for constructing routes to a
// repository commit.
func RepoRevRouteVars(s sourcegraph.RepoRevSpec) map[string]string {
	m := RepoRouteVars(s.RepoSpec)

	rev := ResolvedRevString(s)
	if rev != "" {
		rev = "@" + rev
	}
	m["Rev"] = rev
	return m
}

// ResolvedRevString encodes the revision and commit ID. If CommitID
// is set, the return value is "Rev===CommitID"; otherwise, it is just
// "Rev". See the docstring for RepoRevSpec for an explanation why.
func ResolvedRevString(s sourcegraph.RepoRevSpec) string {
	return strings.TrimPrefix(resolvedRevString(s.Rev, s.CommitID), "@")
}

// RepoSpecString returns the string representation of the RepoSpec
// (which is just the URI). If the URI is empty, it panics.
func RepoSpecString(s sourcegraph.RepoSpec) string {
	if s.IsZero() {
		panic("empty RepoSpec")
	}
	return s.URI
}

func TreeEntryRouteVars(s sourcegraph.TreeEntrySpec) map[string]string {
	m := RepoRevRouteVars(s.RepoRev)
	m["Path"] = s.Path
	return m
}
