// Code generated by protoc-gen-gogo.
// source: vcs.proto
// DO NOT EDIT!

/*
	Package vcs is a generated protocol buffer package.

	It is generated from these files:
		vcs.proto

	It has these top-level messages:
		Commit
		Signature
		Branch
		BehindAhead
		BranchesOptions
		Tag
		SearchOptions
		SearchResult
		Committer
*/
package vcs

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import pbtypes "sourcegraph.com/sqs/pbtypes"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Commit struct {
	ID        CommitID   `protobuf:"bytes,1,opt,name=ID,proto3,customtype=CommitID" json:"ID,omitempty"`
	Author    Signature  `protobuf:"bytes,2,opt,name=Author" json:"Author"`
	Committer *Signature `protobuf:"bytes,3,opt,name=Committer" json:"Committer,omitempty"`
	Message   string     `protobuf:"bytes,4,opt,name=Message,proto3" json:"Message,omitempty"`
	// Parents are the commit IDs of this commit's parent commits.
	Parents []CommitID `protobuf:"bytes,5,rep,name=Parents,customtype=CommitID" json:"Parents,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{0} }

type Signature struct {
	Name  string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Email string            `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	Date  pbtypes.Timestamp `protobuf:"bytes,3,opt,name=Date" json:"Date"`
}

func (m *Signature) Reset()                    { *m = Signature{} }
func (m *Signature) String() string            { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()               {}
func (*Signature) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{1} }

// A Branch is a VCS branch.
type Branch struct {
	// Name is the name of this branch.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Head is the commit ID of this branch's head commit.
	Head CommitID `protobuf:"bytes,2,opt,name=Head,proto3,customtype=CommitID" json:"Head,omitempty"`
	// Commit optionally contains commit information for this branch's head commit.
	// It is populated if IncludeCommit option is set.
	Commit *Commit `protobuf:"bytes,4,opt,name=Commit" json:"Commit,omitempty"`
	// Counts optionally contains the commit counts relative to specified branch.
	Counts *BehindAhead `protobuf:"bytes,3,opt,name=Counts" json:"Counts,omitempty"`
}

func (m *Branch) Reset()                    { *m = Branch{} }
func (m *Branch) String() string            { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()               {}
func (*Branch) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{2} }

// BehindAhead is a set of behind/ahead counts.
type BehindAhead struct {
	Behind uint32 `protobuf:"varint,1,opt,name=Behind,proto3" json:"Behind,omitempty"`
	Ahead  uint32 `protobuf:"varint,2,opt,name=Ahead,proto3" json:"Ahead,omitempty"`
}

func (m *BehindAhead) Reset()                    { *m = BehindAhead{} }
func (m *BehindAhead) String() string            { return proto.CompactTextString(m) }
func (*BehindAhead) ProtoMessage()               {}
func (*BehindAhead) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{3} }

// BranchesOptions specifies options for the list of branches returned by
// (Repository).Branches.
type BranchesOptions struct {
	// MergedInto will cause the returned list to be restricted to only
	// branches that were merged into this branch name.
	MergedInto string `protobuf:"bytes,4,opt,name=MergedInto,proto3" json:"MergedInto,omitempty" url:",omitempty"`
	// IncludeCommit controls whether complete commit information is included.
	IncludeCommit bool `protobuf:"varint,2,opt,name=IncludeCommit,proto3" json:"IncludeCommit,omitempty" url:",omitempty"`
	// BehindAheadBranch specifies a branch name. If set to something other than blank
	// string, then each returned branch will include a behind/ahead commit counts
	// information against the specified base branch. If left blank, then branches will
	// not include that information and their Counts will be nil.
	BehindAheadBranch string `protobuf:"bytes,1,opt,name=BehindAheadBranch,proto3" json:"BehindAheadBranch,omitempty" url:",omitempty"`
	// ContainsCommit filters the list of branches to only those that
	// contain a specific commit ID (if set).
	ContainsCommit string `protobuf:"bytes,3,opt,name=ContainsCommit,proto3" json:"ContainsCommit,omitempty" url:",omitempty"`
}

func (m *BranchesOptions) Reset()                    { *m = BranchesOptions{} }
func (m *BranchesOptions) String() string            { return proto.CompactTextString(m) }
func (*BranchesOptions) ProtoMessage()               {}
func (*BranchesOptions) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{4} }

// A Tag is a VCS tag.
type Tag struct {
	Name     string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	CommitID CommitID `protobuf:"bytes,2,opt,name=CommitID,proto3,customtype=CommitID" json:"CommitID,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{5} }

// SearchOptions specifies options for a repository search.
type SearchOptions struct {
	// the query string
	Query string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	// currently only FixedQuery ("fixed") is supported
	QueryType string `protobuf:"bytes,2,opt,name=QueryType,proto3" json:"QueryType,omitempty"`
	// the number of lines before and after each hit to display
	ContextLines int32 `protobuf:"varint,3,opt,name=ContextLines,proto3" json:"ContextLines,omitempty"`
	// max number of matches to return
	N int32 `protobuf:"varint,4,opt,name=N,proto3" json:"N,omitempty"`
	// starting offset for matches (use with N for pagination)
	Offset int32 `protobuf:"varint,5,opt,name=Offset,proto3" json:"Offset,omitempty"`
}

func (m *SearchOptions) Reset()                    { *m = SearchOptions{} }
func (m *SearchOptions) String() string            { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()               {}
func (*SearchOptions) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{6} }

// A SearchResult is a match returned by a search.
type SearchResult struct {
	// File is the file that contains this match.
	File string `protobuf:"bytes,1,opt,name=File,proto3" json:"File,omitempty"`
	// The byte range [start,end) of the match.
	StartByte uint32 `protobuf:"varint,2,opt,name=StartByte,proto3" json:"StartByte,omitempty"`
	EndByte   uint32 `protobuf:"varint,3,opt,name=EndByte,proto3" json:"EndByte,omitempty"`
	// The line range [start,end] of the match.
	StartLine uint32 `protobuf:"varint,4,opt,name=StartLine,proto3" json:"StartLine,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=EndLine,proto3" json:"EndLine,omitempty"`
	// Match is the matching portion of the file from [StartByte,
	// EndByte).
	Match []byte `protobuf:"bytes,6,opt,name=Match,proto3" json:"Match,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{7} }

// A Committer is a contributor to a repository.
type Committer struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Email   string `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	Commits int32  `protobuf:"varint,3,opt,name=Commits,proto3" json:"Commits,omitempty"`
}

func (m *Committer) Reset()                    { *m = Committer{} }
func (m *Committer) String() string            { return proto.CompactTextString(m) }
func (*Committer) ProtoMessage()               {}
func (*Committer) Descriptor() ([]byte, []int) { return fileDescriptorVcs, []int{8} }

func init() {
	proto.RegisterType((*Commit)(nil), "vcs.Commit")
	proto.RegisterType((*Signature)(nil), "vcs.Signature")
	proto.RegisterType((*Branch)(nil), "vcs.Branch")
	proto.RegisterType((*BehindAhead)(nil), "vcs.BehindAhead")
	proto.RegisterType((*BranchesOptions)(nil), "vcs.BranchesOptions")
	proto.RegisterType((*Tag)(nil), "vcs.Tag")
	proto.RegisterType((*SearchOptions)(nil), "vcs.SearchOptions")
	proto.RegisterType((*SearchResult)(nil), "vcs.SearchResult")
	proto.RegisterType((*Committer)(nil), "vcs.Committer")
}
func (m *Commit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Commit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	data[i] = 0x12
	i++
	i = encodeVarintVcs(data, i, uint64(m.Author.Size()))
	n1, err := m.Author.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Committer != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintVcs(data, i, uint64(m.Committer.Size()))
		n2, err := m.Committer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Message) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if len(m.Parents) > 0 {
		for _, s := range m.Parents {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Signature) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Signature) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintVcs(data, i, uint64(m.Date.Size()))
	n3, err := m.Date.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *Branch) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Branch) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Head) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Head)))
		i += copy(data[i:], m.Head)
	}
	if m.Counts != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintVcs(data, i, uint64(m.Counts.Size()))
		n4, err := m.Counts.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Commit != nil {
		data[i] = 0x22
		i++
		i = encodeVarintVcs(data, i, uint64(m.Commit.Size()))
		n5, err := m.Commit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BehindAhead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BehindAhead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Behind != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintVcs(data, i, uint64(m.Behind))
	}
	if m.Ahead != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVcs(data, i, uint64(m.Ahead))
	}
	return i, nil
}

func (m *BranchesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BranchesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BehindAheadBranch) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.BehindAheadBranch)))
		i += copy(data[i:], m.BehindAheadBranch)
	}
	if m.IncludeCommit {
		data[i] = 0x10
		i++
		if m.IncludeCommit {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ContainsCommit) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.ContainsCommit)))
		i += copy(data[i:], m.ContainsCommit)
	}
	if len(m.MergedInto) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.MergedInto)))
		i += copy(data[i:], m.MergedInto)
	}
	return i, nil
}

func (m *Tag) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Tag) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *SearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.QueryType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.QueryType)))
		i += copy(data[i:], m.QueryType)
	}
	if m.ContextLines != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintVcs(data, i, uint64(m.ContextLines))
	}
	if m.N != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintVcs(data, i, uint64(m.N))
	}
	if m.Offset != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintVcs(data, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *SearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.File) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.File)))
		i += copy(data[i:], m.File)
	}
	if m.StartByte != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintVcs(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintVcs(data, i, uint64(m.EndByte))
	}
	if m.StartLine != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintVcs(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintVcs(data, i, uint64(m.EndLine))
	}
	if len(m.Match) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Match)))
		i += copy(data[i:], m.Match)
	}
	return i, nil
}

func (m *Committer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Committer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintVcs(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Commits != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintVcs(data, i, uint64(m.Commits))
	}
	return i, nil
}

func encodeFixed64Vcs(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Vcs(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVcs(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Commit) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = m.Author.Size()
	n += 1 + l + sovVcs(uint64(l))
	if m.Committer != nil {
		l = m.Committer.Size()
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if len(m.Parents) > 0 {
		for _, s := range m.Parents {
			l = len(s)
			n += 1 + l + sovVcs(uint64(l))
		}
	}
	return n
}

func (m *Signature) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = m.Date.Size()
	n += 1 + l + sovVcs(uint64(l))
	return n
}

func (m *Branch) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.Counts != nil {
		l = m.Counts.Size()
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovVcs(uint64(l))
	}
	return n
}

func (m *BehindAhead) Size() (n int) {
	var l int
	_ = l
	if m.Behind != 0 {
		n += 1 + sovVcs(uint64(m.Behind))
	}
	if m.Ahead != 0 {
		n += 1 + sovVcs(uint64(m.Ahead))
	}
	return n
}

func (m *BranchesOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.BehindAheadBranch)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.IncludeCommit {
		n += 2
	}
	l = len(m.ContainsCommit)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.MergedInto)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	return n
}

func (m *SearchOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.QueryType)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.ContextLines != 0 {
		n += 1 + sovVcs(uint64(m.ContextLines))
	}
	if m.N != 0 {
		n += 1 + sovVcs(uint64(m.N))
	}
	if m.Offset != 0 {
		n += 1 + sovVcs(uint64(m.Offset))
	}
	return n
}

func (m *SearchResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.StartByte != 0 {
		n += 1 + sovVcs(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovVcs(uint64(m.EndByte))
	}
	if m.StartLine != 0 {
		n += 1 + sovVcs(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovVcs(uint64(m.EndLine))
	}
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	return n
}

func (m *Committer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovVcs(uint64(l))
	}
	if m.Commits != 0 {
		n += 1 + sovVcs(uint64(m.Commits))
	}
	return n
}

func sovVcs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVcs(x uint64) (n int) {
	return sovVcs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Commit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = CommitID(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committer == nil {
				m.Committer = &Signature{}
			}
			if err := m.Committer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, CommitID(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Date.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Branch) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Branch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Branch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = CommitID(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counts == nil {
				m.Counts = &BehindAhead{}
			}
			if err := m.Counts.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BehindAhead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BehindAhead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BehindAhead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behind", wireType)
			}
			m.Behind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Behind |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahead", wireType)
			}
			m.Ahead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ahead |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BehindAheadBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BehindAheadBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCommit = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainsCommit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedInto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MergedInto = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = CommitID(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextLines", wireType)
			}
			m.ContextLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContextLines |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.N |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match[:0], data[iNdEx:postIndex]...)
			if m.Match == nil {
				m.Match = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Committer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Committer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Committer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVcs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			m.Commits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Commits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVcs(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVcs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVcs(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVcs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVcs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVcs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVcs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVcs(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVcs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVcs   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorVcs = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x6d, 0x9a, 0x9f, 0xd6, 0x37, 0x3f, 0x6d, 0x47, 0x5d, 0x44, 0xfd, 0xa4, 0x26, 0x9f, 0x05,
	0x55, 0xa5, 0x86, 0x04, 0x15, 0x09, 0x01, 0xbb, 0xba, 0x29, 0x22, 0x12, 0x69, 0x0b, 0xed, 0x0b,
	0x4c, 0x92, 0x5b, 0xdb, 0x52, 0xec, 0x31, 0x33, 0x63, 0x44, 0x9e, 0x80, 0x47, 0x23, 0x4b, 0xd6,
	0x2c, 0x22, 0x60, 0xc9, 0x92, 0x27, 0x60, 0x7e, 0x6c, 0x12, 0x55, 0xa1, 0x0b, 0x4b, 0x73, 0xe7,
	0x9e, 0x39, 0xf7, 0xdc, 0x73, 0x67, 0x0c, 0xce, 0xc7, 0xb1, 0xe8, 0x26, 0x9c, 0x49, 0x46, 0x8a,
	0x6a, 0x79, 0xf0, 0xc4, 0x0f, 0x65, 0x90, 0x8e, 0xba, 0x63, 0x16, 0xf5, 0x7c, 0xe6, 0xb3, 0x9e,
	0xc9, 0x8d, 0xd2, 0x3b, 0x13, 0x99, 0xc0, 0xac, 0xec, 0x99, 0x83, 0x13, 0xc1, 0x52, 0x3e, 0x46,
	0x9f, 0xd3, 0x24, 0x30, 0x67, 0xc4, 0x07, 0xd1, 0x4b, 0x46, 0x72, 0x96, 0xa0, 0xe8, 0xc9, 0x30,
	0x42, 0x21, 0x69, 0x94, 0x58, 0xb0, 0x3b, 0x2f, 0x40, 0xe5, 0x9c, 0x45, 0x51, 0x28, 0x49, 0x07,
	0x36, 0x07, 0xfd, 0x66, 0xa1, 0x5d, 0x38, 0x76, 0xbc, 0xf6, 0x7c, 0xd1, 0xda, 0xf8, 0xb6, 0x68,
	0x6d, 0xdb, 0xdc, 0xa0, 0xff, 0x6b, 0xd1, 0xaa, 0x0d, 0xfa, 0x1d, 0xa6, 0x02, 0x8c, 0x12, 0x39,
	0x23, 0x8f, 0xa0, 0x72, 0x96, 0xca, 0x80, 0xf1, 0xe6, 0xa6, 0x3a, 0x51, 0x3d, 0x6d, 0x74, 0xb5,
	0xea, 0x9b, 0xd0, 0x8f, 0xa9, 0x4c, 0x39, 0x7a, 0x25, 0xcd, 0x40, 0xfe, 0x07, 0xc7, 0x32, 0x48,
	0xe4, 0xcd, 0xe2, 0x3a, 0x20, 0xd9, 0x81, 0xad, 0x21, 0x0a, 0x41, 0x7d, 0x6c, 0x96, 0x74, 0x6d,
	0xf2, 0x1c, 0xb6, 0xae, 0x29, 0xc7, 0x58, 0x8a, 0x66, 0xb9, 0x5d, 0x54, 0x62, 0x1e, 0xaf, 0x11,
	0xb3, 0x97, 0x41, 0x96, 0x8a, 0xdc, 0x6b, 0x70, 0x96, 0xac, 0x35, 0x28, 0x5d, 0xd2, 0x08, 0x6d,
	0x3b, 0xa4, 0x0e, 0xe5, 0x8b, 0x88, 0x86, 0x53, 0xa3, 0xd5, 0x21, 0x47, 0x50, 0xea, 0x53, 0x89,
	0x99, 0x20, 0xd2, 0xcd, 0xcc, 0xe9, 0xde, 0xe6, 0xe6, 0x58, 0xf5, 0xee, 0x67, 0x65, 0x8e, 0xc7,
	0x69, 0x3c, 0x0e, 0xee, 0xf1, 0x3d, 0x85, 0xd2, 0x1b, 0xa4, 0x13, 0x4b, 0xe7, 0xb9, 0x6b, 0xf4,
	0x35, 0x74, 0x7e, 0xc5, 0xae, 0xb6, 0xb6, 0x39, 0xd5, 0x3d, 0xd9, 0xa2, 0xbb, 0xc6, 0x05, 0x0f,
	0x83, 0x30, 0x9e, 0x9c, 0x05, 0x0a, 0x4b, 0xfe, 0xcb, 0x07, 0x61, 0x6c, 0xa8, 0x9e, 0x56, 0x0d,
	0xc2, 0x6e, 0xb9, 0x1d, 0xa8, 0xae, 0x62, 0x1b, 0x4a, 0x97, 0x09, 0x8d, 0x9e, 0xba, 0xee, 0xcf,
	0x24, 0x8c, 0xa0, 0xba, 0xfb, 0xa5, 0x00, 0x3b, 0x56, 0x37, 0x8a, 0xab, 0x44, 0x86, 0x2c, 0x16,
	0xa4, 0x07, 0x7b, 0x2b, 0x0c, 0x36, 0x9b, 0x0d, 0x7b, 0xff, 0xf7, 0xa2, 0xb5, 0x9b, 0xf2, 0xe9,
	0x2b, 0x77, 0xc5, 0x4d, 0x72, 0x02, 0xf5, 0x41, 0x3c, 0x9e, 0xa6, 0x13, 0xcc, 0x64, 0x69, 0xee,
	0xed, 0x7f, 0x80, 0x3b, 0xd0, 0x38, 0x67, 0xb1, 0xa4, 0x61, 0x2c, 0x32, 0x74, 0xf1, 0x01, 0xea,
	0x63, 0x80, 0x21, 0x72, 0x1f, 0x27, 0x83, 0x58, 0x32, 0x3b, 0xf5, 0xf5, 0x48, 0x77, 0x08, 0xc5,
	0x5b, 0xea, 0xdf, 0x73, 0xff, 0x05, 0xfc, 0x75, 0x3a, 0x9b, 0xc0, 0xd1, 0x9a, 0x09, 0x90, 0x7c,
	0xbd, 0xc2, 0x37, 0x82, 0xfa, 0x0d, 0x52, 0x3e, 0x0e, 0x72, 0x57, 0x94, 0x71, 0xef, 0x52, 0xe4,
	0xb3, 0x8c, 0x79, 0x0f, 0x1c, 0x13, 0xde, 0xaa, 0xeb, 0x90, 0xdd, 0x95, 0x7d, 0xa8, 0xe9, 0xce,
	0xf0, 0x93, 0x7c, 0x1b, 0xc6, 0x68, 0xc7, 0x57, 0x26, 0x0e, 0x14, 0x2e, 0x8d, 0xf0, 0xb2, 0x9e,
	0xc5, 0xd5, 0xdd, 0x9d, 0x40, 0xa9, 0x6e, 0xab, 0x8a, 0x5d, 0x01, 0x35, 0x5b, 0xe3, 0x3d, 0x8a,
	0x74, 0x2a, 0xb5, 0xf6, 0xd7, 0xe1, 0x14, 0x97, 0x15, 0x6e, 0x24, 0xe5, 0xd2, 0x9b, 0x49, 0x5b,
	0xa1, 0xae, 0x1f, 0xc0, 0x45, 0x3c, 0x31, 0x1b, 0x45, 0xb3, 0x91, 0x63, 0x74, 0x41, 0x53, 0x24,
	0xc7, 0x98, 0x8d, 0x72, 0x3e, 0xf1, 0x21, 0x95, 0x6a, 0x84, 0x15, 0x15, 0xd6, 0xdc, 0x97, 0x2b,
	0xef, 0xec, 0xe1, 0xbb, 0xaf, 0x98, 0x2c, 0x32, 0x6b, 0xc5, 0xdb, 0x9d, 0xff, 0x38, 0xdc, 0x98,
	0xff, 0x3c, 0x2c, 0x7c, 0x55, 0xdf, 0x77, 0xf5, 0x8d, 0x2a, 0xe6, 0xd7, 0xf0, 0xec, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xd5, 0x0f, 0x0c, 0x2f, 0x88, 0x04, 0x00, 0x00,
}
